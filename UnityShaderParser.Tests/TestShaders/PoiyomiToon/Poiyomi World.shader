Shader ".poiyomi/Poiyomi 8.1/Poiyomi World"
{
	Properties
	{
		[HideInInspector] shader_master_label ("<color=#E75898ff>Poiyomi 8.1.167</color>", Float) = 0
		[HideInInspector] shader_is_using_thry_editor ("", Float) = 0
		[HideInInspector] shader_locale ("0db0b86376c3dca4b9a6828ef8615fe0", Float) = 0
		[HideInInspector] footer_youtube ("{texture:{name:icon-youtube,height:16},action:{type:URL,data:https://www.youtube.com/poiyomi},hover:YOUTUBE}", Float) = 0
		[HideInInspector] footer_twitter ("{texture:{name:icon-twitter,height:16},action:{type:URL,data:https://twitter.com/poiyomi},hover:TWITTER}", Float) = 0
		[HideInInspector] footer_patreon ("{texture:{name:icon-patreon,height:16},action:{type:URL,data:https://www.patreon.com/poiyomi},hover:PATREON}", Float) = 0
		[HideInInspector] footer_discord ("{texture:{name:icon-discord,height:16},action:{type:URL,data:https://discord.gg/Ays52PY},hover:DISCORD}", Float) = 0
		[HideInInspector] footer_github ("{texture:{name:icon-github,height:16},action:{type:URL,data:https://github.com/poiyomi/PoiyomiToonShader},hover:GITHUB}", Float) = 0
		
		// Warning that only shows up when ThryEditor hasn't loaded
		[Header(POIYOMI SHADER UI FAILED TO LOAD)]
		[Header(.    This is caused by scripts failing to compile. It can be fixed.)]
		[Header(.          The inspector will look broken and will not work properly until fixed.)]
		[Header(.    Please check your console for script errors.)]
		[Header(.          You can filter by errors in the console window.)]
		[Header(.          Often the topmost error points to the erroring script.)]
		[Space(30)][Header(Common Error Causes)]
		[Header(.    Installing multiple Poiyomi Shader packages)]
		[Header(.          Make sure to delete the Poiyomi shader folder before you update Poiyomi.)]
		[Header(.          If a package came with Poiyomi this is bad practice and can cause issues.)]
		[Header(.          Delete the package and import it without any Poiyomi components.)]
		[Header(.    Bad VRCSDK installation (e.g. Both VCC and Standalone))]
		[Header(.          Delete the VRCSDK Folder in Assets if you are using the VCC.)]
		[Header(.          Avoid using third party SDKs. They can cause incompatibility.)]
		[Header(.    Script Errors in other scripts)]
		[Header(.          Outdated tools or prefabs can cause this.)]
		[Header(.          Update things that are throwing errors or move them outside the project.)]
		[Space(30)][Header(Visit Our Discord to Ask For Help)]
		[Space(5)]_ShaderUIWarning0 (" → discord.gg/poiyomi ←    We can help you get it fixed!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         --{condition_showS:(0==1)}", Int) = -0
		[Space(1400)][Header(POIYOMI SHADER UI FAILED TO LOAD)]
		_ShaderUIWarning1 ("Please scroll up for more information!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     --{condition_showS:(0==1)}", Int) = -0
		
		// Keyword to remind users in the VRChat SDK that this material hasn't been locked.  Inelegant but it works.
		[HideInInspector] _ForgotToLockMaterial (";;YOU_FORGOT_TO_LOCK_THIS_MATERIAL;", Int) = 1
		[ThryShaderOptimizerLockButton] _ShaderOptimizerEnabled ("", Int) = 0
		[Helpbox(1)] _LockTooltip ("Animations don't work by default when locked in. Right click a property if you want to animate it. The shader will lock in automatically at upload time.", Int) = 0
		[HideInInspector] GeometryShader_Enabled("GEOMETRY SHADER ENABLED", Float) = 1
		[HideInInspector] Tessellation_Enabled("TESSELLATION ENABLED", Float) = 1
		[ThryWideEnum(Opaque, 0, Cutout, 1, TransClipping, 9, Fade, 2, Transparent, 3, Additive, 4, Soft Additive, 5, Multiplicative, 6, 2x Multiplicative, 7)]_Mode("Rendering Preset--{on_value_actions:[
		{value:0,actions:[{type:SET_PROPERTY,data:render_queue=2000}, {type:SET_PROPERTY,data:render_type=Opaque},            {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=1}, {type:SET_PROPERTY,data:_DstBlend=0},  {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=1}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=1}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=1}, {type:SET_PROPERTY,data:_OutlineDstBlend=0},  {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=0}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:1,actions:[{type:SET_PROPERTY,data:render_queue=2450}, {type:SET_PROPERTY,data:render_type=TransparentCutout}, {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=.5}, {type:SET_PROPERTY,data:_SrcBlend=1}, {type:SET_PROPERTY,data:_DstBlend=0},  {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=1}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=1}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=1}, {type:SET_PROPERTY,data:_OutlineDstBlend=0},  {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:9,actions:[{type:SET_PROPERTY,data:render_queue=2450}, {type:SET_PROPERTY,data:render_type=TransparentCutout}, {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=5}, {type:SET_PROPERTY,data:_DstBlend=10}, {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=5}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=1}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=5}, {type:SET_PROPERTY,data:_OutlineDstBlend=10}, {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:2,actions:[{type:SET_PROPERTY,data:render_queue=3000}, {type:SET_PROPERTY,data:render_type=Transparent},       {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=5}, {type:SET_PROPERTY,data:_DstBlend=10}, {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=5}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=0}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=5}, {type:SET_PROPERTY,data:_OutlineDstBlend=10}, {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:3,actions:[{type:SET_PROPERTY,data:render_queue=3000}, {type:SET_PROPERTY,data:render_type=Transparent},       {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=1}, {type:SET_PROPERTY,data:_DstBlend=10}, {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=1}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=0}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=1}, {type:SET_PROPERTY,data:_OutlineSrcBlend=1}, {type:SET_PROPERTY,data:_OutlineDstBlend=10}, {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:4,actions:[{type:SET_PROPERTY,data:render_queue=3000}, {type:SET_PROPERTY,data:render_type=Transparent},       {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=1}, {type:SET_PROPERTY,data:_DstBlend=1},  {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=1}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=0}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=1}, {type:SET_PROPERTY,data:_OutlineDstBlend=1},  {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:5,actions:[{type:SET_PROPERTY,data:render_queue=3000}, {type:SET_PROPERTY,data:render_type=Transparent},       {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=4}, {type:SET_PROPERTY,data:_DstBlend=1},  {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=4}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=0}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=4}, {type:SET_PROPERTY,data:_OutlineDstBlend=1},  {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:6,actions:[{type:SET_PROPERTY,data:render_queue=3000}, {type:SET_PROPERTY,data:render_type=Transparent},       {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=2}, {type:SET_PROPERTY,data:_DstBlend=0},  {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=2}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=0}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=2}, {type:SET_PROPERTY,data:_OutlineDstBlend=0},  {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]},
		{value:7,actions:[{type:SET_PROPERTY,data:render_queue=3000}, {type:SET_PROPERTY,data:render_type=Transparent},       {type:SET_PROPERTY,data:_BlendOp=0}, {type:SET_PROPERTY,data:_BlendOpAlpha=4}, {type:SET_PROPERTY,data:_Cutoff=0},  {type:SET_PROPERTY,data:_SrcBlend=2}, {type:SET_PROPERTY,data:_DstBlend=3},  {type:SET_PROPERTY,data:_SrcBlendAlpha=1}, {type:SET_PROPERTY,data:_DstBlendAlpha=1},  {type:SET_PROPERTY,data:_AddSrcBlend=2}, {type:SET_PROPERTY,data:_AddDstBlend=1}, {type:SET_PROPERTY,data:_AddSrcBlendAlpha=0}, {type:SET_PROPERTY,data:_AddDstBlendAlpha=1}, {type:SET_PROPERTY,data:_AlphaToCoverage=0},  {type:SET_PROPERTY,data:_ZWrite=0}, {type:SET_PROPERTY,data:_ZTest=4},   {type:SET_PROPERTY,data:_AlphaPremultiply=0}, {type:SET_PROPERTY,data:_OutlineSrcBlend=2}, {type:SET_PROPERTY,data:_OutlineDstBlend=3},  {type:SET_PROPERTY,data:_OutlineSrcBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineDstBlendAlpha=1}, {type:SET_PROPERTY,data:_OutlineBlendOp=0}, {type:SET_PROPERTY,data:_OutlineBlendOpAlpha=4}]}
		}]}]}", Int) = 0
		
		// Main
		[HideInInspector] m_mainCategory ("Color & Normals--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/main},hover:Documentation}}", Float) = 0
		//Main-main
		_Color ("Color & Alpha--{reference_property:_ColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_MainTex ("Texture--{reference_properties:[_MainTexPan, _MainTexUV, _MainPixelMode, _MainTexStochastic]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _MainTexUV ("UV", Int) = 0
		[HideInInspector][Vector2]_MainTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ToggleUI]_MainPixelMode ("Pixel Mode", Float) = 0
		[HideInInspector][ToggleUI]_MainTexStochastic ("Stochastic Sampling", Float) = 0
		[Normal]_BumpMap ("Normal Map--{reference_properties:[_BumpMapPan, _BumpMapUV, _BumpScale, _BumpMapStochastic]}", 2D) = "bump" { }
		[HideInInspector][Vector2]_BumpMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _BumpMapUV ("UV", Int) = 0
		[HideInInspector]_BumpScale ("Intensity", Range(0, 10)) = 1
		[HideInInspector][ToggleUI]_BumpMapStochastic ("Stochastic Sampling", Float) = 0
		[sRGBWarning]_ClippingMask ("Alpha Map--{reference_properties:[_ClippingMaskPan, _ClippingMaskUV, _Inverse_Clipping]}", 2D) = "white" { }
		[HideInInspector][Vector2]_ClippingMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _ClippingMaskUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_Inverse_Clipping ("Invert", Float) = 0
		_Cutoff ("Alpha Cutoff", Range(0, 1.001)) = 0.5
		
		//ifex _MainColorAdjustToggle==0
		[HideInInspector] m_start_MainHueShift ("Color Adjust--{reference_property:_MainColorAdjustToggle,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/color-adjust},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(COLOR_GRADING_HDR)] _MainColorAdjustToggle ("Adjust Colors", Float) = 0
		[sRGBWarning][ThryRGBAPacker(R Hue Mask, G Brightness Mask, B Saturation Mask)]_MainColorAdjustTexture ("Mask (Expand)--{reference_properties:[_MainColorAdjustTexturePan, _MainColorAdjustTextureUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_MainColorAdjustTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _MainColorAdjustTextureUV ("UV", Int) = 0
		_Saturation ("Saturation", Range(-1, 10)) = 0
		_MainBrightness ("Brightness", Range(-1, 1)) = 0
		[ThryToggleUI(true)] _MainHueShiftToggle ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		[ToggleUI]_MainHueShiftReplace ("Hue Replace?--{condition_showS:(_MainHueShiftToggle==1)}", Float) = 1
		_MainHueShift ("Hue Shift--{condition_showS:(_MainHueShiftToggle==1)}", Range(0, 1)) = 0
		_MainHueShiftSpeed ("Hue Shift Speed--{condition_showS:(_MainHueShiftToggle==1)}", Float) = 0
		
		[Space(4)]
		[ThryToggleUI(true)]_MainHueALCTEnabled ("<size=13><b>  Hue Shift Audio Link</b></size>--{condition_showS:(_MainHueShiftToggle==1 && _EnableAudioLink==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)]_MainALHueShiftBand ("Band--{condition_showS:(_MainHueShiftToggle==1 && _EnableAudioLink==1 && _MainHueALCTEnabled==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_MainALHueShiftCTIndex ("Motion Type--{condition_showS:(_MainHueShiftToggle==1 && _EnableAudioLink==1 && _MainHueALCTEnabled==1)}", Int) = 0
		_MainHueALMotionSpeed ("Motion Speed--{condition_showS:(_MainHueShiftToggle==1 && _EnableAudioLink==1 && _MainHueALCTEnabled==1)}", Float) = 1
		
		[HideInInspector] m_start_MainHueShiftGlobalMask ("Global Mask", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MainHueGlobalMask ("Hue--{reference_property:_MainHueGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _MainHueGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MainSaturationGlobalMask ("Saturation--{reference_property:_MainSaturationGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _MainSaturationGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MainBrightnessGlobalMask ("Brightness--{reference_property:_MainBrightnessGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _MainBrightnessGlobalMaskBlendType ("Blending", Int) = 2
		[HideInInspector] m_end_MainHueShiftGlobalMask ("Global Mask", Float) = 0
		
		[HideInInspector] m_end_MainHueShift ("Hue Shift", Float) = 0
		//endex
		
		[HideInInspector] m_start_Alpha ("Alpha Options--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/alpha-options},hover:Documentation}}", Float) = 0
		[ToggleUI]_AlphaForceOpaque ("Force Opaque", Float) = 0
		_AlphaMod ("Alpha Mod", Range(-1, 1)) = 0.0
		[ToggleUI]_AlphaPremultiply ("Alpha Premultiply", Float) = 0
		_AlphaBoostFA ("Boost Transparency in ForwardAdd--{condition_showS:(_AddBlendOp==4)}", Range(1, 100)) = 10
		
		//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
		[Space(4)]
		[ThryToggleUI(true)] _AlphaToCoverage ("<size=13><b>  Alpha To Coverage</b></size>", Float) = 0
		[ToggleUI]_AlphaSharpenedA2C ("Sharpened  A2C--{condition_showS:(_AlphaToCoverage==1)}", Float) = 0
		_AlphaMipScale ("Mip Level Alpha Scale--{condition_showS:(_AlphaToCoverage==1)}", Range(0, 1)) = 0.25
		//endex
		
		//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
		[Space(4)]
		[ThryToggleUI(true)] _AlphaDithering ("<size=13><b>  Dithering</b></size>", Float) = 0
		_AlphaDitherGradient ("Dither Gradient--{condition_showS:(_AlphaDithering==1)}", Range(0, 1)) = .1
		_AlphaDitherBias ("Dither Bias--{condition_showS:(_AlphaDithering==1)}", Range(0, 1)) = 0
		//endex
		
		//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
		[Space(4)]
		[ThryToggleUI(true)] _AlphaDistanceFade ("<size=13><b>  Distance Alpha</b></size>", Float) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _AlphaDistanceFadeType ("Pos To Use--{condition_showS:(_AlphaDistanceFade==1)}", Int) = 1
		_AlphaDistanceFadeMinAlpha ("Min Distance Alpha--{condition_showS:(_AlphaDistanceFade==1)}", Range(0, 1)) = 0
		_AlphaDistanceFadeMaxAlpha ("Max Distance Alpha--{condition_showS:(_AlphaDistanceFade==1)}", Range(0, 1)) = 1
		_AlphaDistanceFadeMin ("Min Distance--{condition_showS:(_AlphaDistanceFade==1)}", Float) = 0
		_AlphaDistanceFadeMax ("Max Distance--{condition_showS:(_AlphaDistanceFade==1)}", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _AlphaDistanceFadeGlobalMask ("Global Mask--{condition_showS:(_AlphaDistanceFade==1)}", Int) = 0
		//endex
		
		//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
		[Space(4)]
		[ThryToggleUI(true)] _AlphaFresnel ("<size=13><b>  Fresnel Alpha</b></size>", Float) = 0
		_AlphaFresnelAlpha ("Intensity--{condition_showS:(_AlphaFresnel==1)}", Range(0, 1)) = 0
		_AlphaFresnelSharpness ("Sharpness--{condition_showS:(_AlphaFresnel==1)}", Range(0, 1)) = .5
		_AlphaFresnelWidth ("Width--{condition_showS:(_AlphaFresnel==1)}", Range(0, 1)) = .5
		[ToggleUI]_AlphaFresnelInvert ("Invert--{condition_showS:(_AlphaFresnel==1)}", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _AlphaFresnelGlobalMask ("Global Mask--{condition_showS:(_AlphaFresnel==1)}", Int) = 0
		//endex
		
		//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
		[Space(4)]
		[ThryToggleUI(true)] _AlphaAngular ("<size=13><b>  Angular Alpha</b></size>", Float) = 0
		[Enum(Camera Face Model, 0, Model Face Camera, 1, Face Each Other, 2)] _AngleType ("Angle Type--{condition_showS:(_AlphaAngular==1)}", Int) = 0
		[Enum(Model, 0, Vertex, 1)] _AngleCompareTo ("Model or Vert Positon--{condition_showS:(_AlphaAngular==1)}", Int) = 0
		[Vector3]_AngleForwardDirection ("Forward Direction--{condition_showS:(_AlphaAngular==1)}", Vector) = (0, 0, 1)
		_CameraAngleMin ("Camera Angle Min--{condition_showS:(_AlphaAngular==1)}", Range(0, 180)) = 45
		_CameraAngleMax ("Camera Angle Max--{condition_showS:(_AlphaAngular==1)}", Range(0, 180)) = 90
		_ModelAngleMin ("Model Angle Min--{condition_showS:(_AlphaAngular==1)}", Range(0, 180)) = 45
		_ModelAngleMax ("Model Angle Max--{condition_showS:(_AlphaAngular==1)}", Range(0, 180)) = 90
		_AngleMinAlpha ("Min Alpha--{condition_showS:(_AlphaAngular==1)}", Range(0, 1)) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _AlphaAngularGlobalMask ("Global Mask--{condition_showS:(_AlphaAngular==1)}", Int) = 0
		//endex
		
		//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
		[Space(4)]
		[ThryToggleUI(true)]_AlphaAudioLinkEnabled ("<size=13><b>  Alpha Audio Link</b></size>--{condition_showS:(_EnableAudioLink==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AlphaAudioLinkAddBand ("Add Band--{ condition_showS:(_AlphaAudioLinkEnabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AlphaAudioLinkAddRange ("Add Range--{ condition_showS:(_AlphaAudioLinkEnabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0)
		//endex
		[HideInInspector] m_start_AlphaGlobalMask ("Global Mask", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _AlphaGlobalMask ("Alpha--{reference_property:_AlphaGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _AlphaGlobalMaskBlendType ("Blending", Int) = 2
		[HideInInspector] m_end_AlphaGlobalMask ("Global Mask", Float) = 0
		
		[HideInInspector] m_end_Alpha ("Alpha Options", Float) = 0
		
		//ifex _DetailEnabled==0
		[HideInInspector] m_start_DetailOptions ("Details--{reference_property:_DetailEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/details},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(FINALPASS)]_DetailEnabled ("Enable", Float) = 0
		[sRGBWarning][ThryRGBAPacker(R Texture Mask, G Normal Mask, B Nothing, A Nothing)]_DetailMask ("Detail Mask (Expand)--{reference_properties:[_DetailMaskPan, _DetailMaskUV, _DetailMaskStochastic]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DetailMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DetailMaskUV ("UV", Int) = 0
		_DetailTint ("Detail Texture Tint--{reference_property:_DetailTintThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DetailTintThemeIndex ("", Int) = 0
		[HideInInspector][ToggleUI]_DetailMaskStochastic ("Stochastic Sampling", Float) = 0
		
		[sRGBWarning(true)]_DetailTex ("Detail Texture--{reference_properties:[_DetailTexPan, _DetailTexUV, _DetailTexStochastic]}", 2D) = "gray" { }
		[HideInInspector][Vector2]_DetailTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DetailTexUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_DetailTexStochastic ("Stochastic Sampling", Float) = 0
		_DetailTexIntensity ("Detail Tex Intensity", Range(0, 10)) = 1
		_DetailBrightness ("Detail Brightness:", Range(0, 2)) = 1
		
		[Normal]_DetailNormalMap ("Detail Normal--{reference_properties:[_DetailNormalMapPan, _DetailNormalMapUV, _DetailNormalMapScale, _DetailNormalMapStochastic]}", 2D) = "bump" { }
		[HideInInspector]_DetailNormalMapScale ("Detail Normal Intensity", Range(0, 10)) = 1
		[HideInInspector][Vector2]_DetailNormalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DetailNormalMapUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_DetailNormalMapStochastic ("Stochastic Sampling", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _DetailTexGlobalMask ("Detail Texture Global Mask--{reference_property:_DetailTexGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_DetailTexGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _DetailNormalGlobalMask ("Detail Normal Global Mask--{reference_property:_DetailNormalGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_DetailNormalGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		[HideInInspector] m_end_DetailOptions ("Details", Float) = 0
		//endex
		
		//ifex _VertexManipulationsEnabled==0
		[HideInInspector] m_start_vertexManipulation ("Vertex Options--{reference_property:_VertexManipulationsEnabled, button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/vertex-options},hover:YouTube}}", Float) = 0
		[HideInInspector][ThryToggle(AUTO_EXPOSURE)]_VertexManipulationsEnabled ("Enabled", Float) = 0
		[Vector3]_VertexManipulationLocalTranslation ("Local Translation", Vector) = (0, 0, 0, 1)
		[Vector3]_VertexManipulationLocalRotation ("Local Rotation", Vector) = (0, 0, 0, 1)
		[Vector3]_VertexManipulationLocalRotationSpeed ("Local Rotation Speed", Vector) = (0, 0, 0, 1)
		_VertexManipulationLocalScale ("Local Scale", Vector) = (1, 1, 1, 1)
		[Vector3]_VertexManipulationWorldTranslation ("World Translation", Vector) = (0, 0, 0, 1)
		_VertexManipulationHeight ("Vertex Height", Float) = 0
		[sRGBWarning]_VertexManipulationHeightMask ("Height Map--{reference_properties:[_VertexManipulationHeightMaskPan, _VertexManipulationHeightMaskUV, _VertexManipulationHeightMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_VertexManipulationHeightMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][Enum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)] _VertexManipulationHeightMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_VertexManipulationHeightMaskChannel ("Channel", Float) = 0
		_VertexManipulationHeightBias ("Mask Bias", Range(0, 1)) = 0
		[ToggleUI]_VertexRoundingEnabled ("Rounding Enabled", Float) = 0
		[Enum(World, 0, Local, 1)]_VertexRoundingSpace ("Rounding Space", Int) = 0
		_VertexRoundingDivision ("Rounding Interval", Float) = 0.02
		[ThryToggleUI(true)]_VertexBarrelMode ("<size=13><b>  Barrel Mode</b></size>", Float) = 0
		_VertexBarrelWidth ("Barrel Width--{condition_showS:(_VertexBarrelMode==1)}", Float) = 0.2
		_VertexBarrelAlpha ("Barrel Alpha--{condition_showS:(_VertexBarrelMode==1)}", Range(0, 1)) = 0
		_VertexBarrelHeight ("Barrel Height--{condition_showS:(_VertexBarrelMode==1)}", Range(0, 1)) = 0
		
		[ThryToggleUI(true)]_VertexSphereMode ("<size=13><b>  Sphere Mode</b></size>", Float) = 0
		_VertexSphereRadius ("Sphere Radius--{condition_showS:(_VertexSphereMode==1)}", Range(0, 1)) = 1
		_VertexSphereHeight ("Sphere Height--{condition_showS:(_VertexSphereMode==1)}", Range(0, 1)) = 1
		_VertexSphereAlpha ("Sphere Alpha--{condition_showS:(_VertexSphereMode==1)}", Range(0, 1)) = 0
		[Vector3]_VertexSphereCenter ("Sphere Center--{condition_showS:(_VertexSphereMode==1)}", Vector) = (0, 0, 0, 1)
		[Space(10)]
		[ThryToggleUI(true)]_VertexAudioLinkEnabled ("<size=13><b>  Audio Link</b></size>--{condition_showS:(_EnableAudioLink==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalTranslationALBand ("Local Translate Band--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Vector3]_VertexLocalTranslationALMin ("Local Translate Min--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Vector3]_VertexLocalTranslationALMax ("Local Translate Max--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Space(10)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalRotationALBandX ("Rotation Band X--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalRotationALBandY ("Rotation Band Y--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalRotationALBandZ ("Rotation Band Z--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Vector3]_VertexLocalRotationAL ("Rotation--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Space(10)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalRotationCTALBandX ("Band X--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_VertexLocalRotationCTALTypeX ("Motion Type X--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalRotationCTALBandY ("Band Y--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_VertexLocalRotationCTALTypeY ("Motion Type Y--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalRotationCTALBandZ ("Band Z--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_VertexLocalRotationCTALTypeZ ("Motion Type Z--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Vector3]_VertexLocalRotationCTALSpeed ("Rotation Speed--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Space(10)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexLocalScaleALBand ("Scale Band--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		_VertexLocalScaleALMin ("Scale Min--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0, 0)
		_VertexLocalScaleALMax ("Scale Max--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0, 0)
		[Space(10)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexWorldTranslationALBand ("World Translation Band--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[Vector3]_VertexWorldTranslationALMin ("World Translation Min--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Vector3]_VertexWorldTranslationALMax ("World Translation Max--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Space(10)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexManipulationHeightBand ("Vertex Height Band--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[VectorLabel(Min, Max)]_VertexManipulationHeightAL ("Vertex Height--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[Space(10)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _VertexRoundingRangeBand ("Rounding Band--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Int) = 0
		[VectorLabel(Min, Max)]_VertexRoundingRangeAL ("Rounding Range--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Vector) = (0, 0, 0)
		[ThryToggleUI(true)]_VertexSpectrumMotion ("<size=13><b>Spectrum Motion</b></size>--{condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1)}", Float) = 0
		[Enum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)] _VertexSpectrumUV ("UV--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1 && _VertexSpectrumMotion == 1)}", Int) = 0
		[Enum(X, 0, Y, 1)] _VertexSpectrumUVDirection ("UV Direction--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1 && _VertexSpectrumMotion == 1)}", Int) = 0
		_VertexSpectrumOffsetMin ("Offset Min--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1 && _VertexSpectrumMotion == 1)}", Vector) = (0, 0, 0)
		_VertexSpectrumOffsetMax ("Offset Max--{ condition_showS:(_EnableAudioLink==1 && _VertexAudioLinkEnabled==1 && _VertexSpectrumMotion == 1)}", Vector) = (0, .1, 0)
		[HideInInspector] m_end_vertexManipulation ("Vertex Offset", Float) = 0
		//endex
		
		//ifex _VertexGlitchingEnabled==0
		[HideInInspector] m_start_vertexGlitching ("Vertex Glitching--{reference_property:_VertexGlitchingEnabled}", Float) = 0
		[HideInInspector][ThryToggle(POI_VERTEX_GLITCHING)]_VertexGlitchingEnabled ("Enabled", Float) = 0
		// _VertexGlitchMap ("Glitch Map", 2D) = "white" { }
		[ThryToggle(POI_VERTEX_GLITCHING_TEXTURE, true)]_VertexGlitchingUseTexture ("<size=13><b>  Use Texture</b></size>", Float) = 0
		// [ThryToggleUI(true)]_VertexGlitchingUseTexture ("Use Texture", Float) = 0
		[sRGBWarning][ThryRGBAPacker(R Both, G Right, B Left, A unused)]_VertexGlitchMap ("Glitch Map [Expand]--{condition_showS:(_VertexGlitchingUseTexture==1)}", 2D) = "white" { }
		_VertexGlitchDensity ("Glitch Density--{condition_showS:(_VertexGlitchingUseTexture==1)}", Range(0, 50)) = 10
		_VertexGlitchMapPanSpeed ("Glitch Map Pan Speed--{condition_showS:(_VertexGlitchingUseTexture==1)}", Range(0, 100)) = 10
		[Space(10)]
		_VertexGlitchFrequency ("Glitch Interval", Float) = 1
		_VertexGlitchThreshold ("Glitch Threshold", Range(0, 1)) = 1
		_VertexGlitchStrength ("Glitch Strength", Range(0, 10)) = 1
		[Space(10)]
		[ThryToggleUI(true)]_VertexGlitchMirrorEnable ("<size=13><b>Mirror</b></size>", Float) = 0
		[ThryWideEnum(Show In Both, 0, Show Only In Mirror, 1, Dont Show In Mirror, 2)] _VertexGlitchMirror ("Show in mirror--{condition_showS:(_VertexGlitchMirrorEnable==1)}", Int) = 0
		
		[ThryToggleUI(true)]_VertexGlitchingAudioLinkEnabled ("<size=13><b>  Audio Link</b></size>--{condition_showS:(_EnableAudioLink==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3, VU Intensity, 4)] _VertexGlitchingAudioLinkBand ("Glitch Band--{condition_showS:(_EnableAudioLink==1)}", Int) = 0
		[ThryToggleUI(true)]_VertexGlitchingAudiolinkOverride ("Override Glitch Intensity with Audiolink--{condition_showS:(_EnableAudioLink==1)}", Float) = 1
		
		[HideInInspector] m_end_vertexGlitching ("Vertex Glitching", Float) = 0
		//endex
		
		//ifex _MainVertexColoringEnabled==0
		[HideInInspector] m_start_MainVertexColors ("Vertex Colors--{reference_property:_MainVertexColoringEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/vertex-colors},hover:Documentation}}", Float) = 0
		[HideInInspector][ToggleUI]_MainVertexColoringEnabled ("Enable", Float) = 0
		[ToggleUI]_MainVertexColoringLinearSpace ("Linear Colors", Float) = 1
		_MainVertexColoring ("Use Vertex Color", Range(0, 1)) = 0
		_MainUseVertexColorAlpha ("Use Vertex Color Alpha", Range(0, 1)) = 0
		[HideInInspector] m_end_MainVertexColors ("Vertex Colors", Float) = 0
		//endex
		
		//ifex _BackFaceEnabled!=1
		// Back Face Textures and Emission
		[HideInInspector] m_start_backFace ("Back Face--{reference_property:_BackFaceEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/back-face},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_BACKFACE)]_BackFaceEnabled ("Backface Enabled", Float) = 0
		_BackFaceColor ("Color--{reference_property:_BackFaceColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _BackFaceColorThemeIndex ("", Int) = 0
		_BackFaceEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[sRGBWarning(true)]_BackFaceTexture ("Texture--{reference_properties:[_BackFaceTexturePan, _BackFaceTextureUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_BackFaceTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_BackFaceTextureUV ("UV#", Int) = 0
		[sRGBWarning]_BackFaceMask ("Mask--{reference_properties:[_BackFaceMaskPan, _BackFaceMaskUV, _BackFaceMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_BackFaceMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_BackFaceMaskUV ("UV#", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_BackFaceMaskChannel ("Channel", Float) = 0
		_BackFaceDetailIntensity ("Detail Intensity", Range(0, 5)) = 1
		[ToggleUI]_BackFaceReplaceAlpha ("Replace Alpha", Float) = 0
		_BackFaceEmissionLimiter ("Emission Limiter", Range(0, 1)) = 1
		[Space(10)]
		[ThryToggleUI(true)]_BackFaceHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_BackFaceHueShift ("Hue Shift--{condition_showS:(_BackFaceHueShiftEnabled==1)}", Range(0, 1)) = 0
		_BackFaceHueShiftSpeed ("Hue Shift Speed--{condition_showS:(_BackFaceHueShiftEnabled==1)}", Float) = 0
		[HideInInspector] m_end_backFace ("Back Face", Float) = 0
		//endex
		
		//ifex _RGBMaskEnabled==0
		[HideInInspector] m_start_RGBMask ("RGBA Color Masking--{reference_property:_RGBMaskEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/rgba-color-masking},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(VIGNETTE)]_RGBMaskEnabled ("RGB Mask Enabled", Float) = 0
		[ToggleUI]_RGBUseVertexColors ("Use Vertex Colors", Float) = 0
		[ToggleUI]_RGBBlendMultiplicative ("Multiplicative", Float) = 0
		[sRGBWarning][ThryRGBAPacker(R Mask,G Mask,B Mask,A Mask)]_RGBMask ("Mask--{reference_properties:[_RGBMaskPan, _RGBMaskUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_RGBMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RGBMaskUV ("UV", int) = 0
		
		[HideInInspector] m_start_RGBAColors ("Colors", Float) = 0
		
		_RedColor ("R Color--{reference_property:_RedColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _RedColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_RedTexture ("R Texture--{reference_properties:[_RedTexturePan, _RedTextureUV, _RedTextureStochastic, _RedAlphaAdd, _RgbRedMaskChannel, _RgbRedGlobalMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_RedTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RedTextureUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_RedTextureStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector]_RedAlphaAdd ("R Alpha Add", Range(-1,1)) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbRedMaskChannel ("Mask Channel", Int) = 0
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbRedGlobalMaskChannel ("Global Mask--{reference_property:_RgbRedGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbRedGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		
		_GreenColor ("G Color--{reference_property:_GreenColorThemeIndex}", Color) = (1, 1, 1, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _GreenColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_GreenTexture ("G Texture--{reference_properties:[_GreenTexturePan, _GreenTextureUV, _GreenTextureStochastic, _GreenAlphaAdd, _RgbGreenMaskChannel, _RgbGreenGlobalMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GreenTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_GreenTextureUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_GreenTextureStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector]_GreenAlphaAdd ("G Alpha Add", Range(-1,1)) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbGreenMaskChannel ("Mask Channel", Int) = 1
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbGreenGlobalMaskChannel ("Global Mask--{reference_property:_RgbGreenGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbGreenGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		
		_BlueColor ("B Color--{reference_property:_BlueColorThemeIndex}", Color) = (1, 1, 1, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _BlueColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_BlueTexture ("B Texture--{reference_properties:[_BlueTexturePan, _BlueTextureUV, _BlueTextureStochastic, _BlueAlphaAdd, _RgbBlueMaskChannel, _RgbBlueGlobalMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_BlueTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_BlueTextureUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_BlueTextureStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector]_BlueAlphaAdd ("B Alpha Add", Range(-1,1)) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbBlueMaskChannel ("Mask Channel", Int) = 2
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbBlueGlobalMaskChannel ("Global Mask--{reference_property:_RgbBlueGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbBlueGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		
		_AlphaColor ("A Color--{reference_property:_AlphaColorThemeIndex}", Color) = (1, 1, 1, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _AlphaColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_AlphaTexture ("A Texture--{reference_properties:[_AlphaTexturePan, _AlphaTextureUV, _AlphaTextureStochastic, _AlphaAlphaAdd, _RgbAlphaMaskChannel, _RgbAlphaGlobalMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_AlphaTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_AlphaTextureUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_AlphaTextureStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector]_AlphaAlphaAdd ("A Alpha Add", Range(-1,1)) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbAlphaMaskChannel ("Mask Channel", Int) = 3
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbAlphaGlobalMaskChannel ("Global Mask--{reference_property:_RgbAlphaGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbAlphaGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		[HideInInspector] m_end_RGBAColors ("Colors", Float) = 0
		
		//ifex _RgbNormalsEnabled == 0
		// RGB MASKED NORMALS
		[HideInInspector] m_start_rgbanormals ("Normals--{reference_property:_RgbNormalsEnabled}", Float) = 0
		[HideInInspector][ThryToggle(GEOM_TYPE_MESH)]_RgbNormalsEnabled ("Enable Normals", Float) = 0
		[ToggleUI]_RGBNormalBlend ("Blend with Base", Float) = 0
		[Normal]_RgbNormalR ("R Normal--{reference_properties:[_RgbNormalRPan, _RgbNormalRUV, _RgbNormalRStochastic, _RgbNormalRMaskChannel, _RgbNormalRGlobalMaskChannel]}", 2D) = "bump" { }
		[HideInInspector][Vector2]_RgbNormalRPan ("Pan", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RgbNormalRUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_RgbNormalRStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbNormalRMaskChannel ("Mask Channel", Int) = 0
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbNormalRGlobalMaskChannel ("Global Mask--{reference_property:_RgbNormalRGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbNormalRGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_RgbNormalRScale ("Intensity", Range(0, 10)) = 0
		[Space(10)]
		[Normal]_RgbNormalG ("G Normal--{reference_properties:[_RgbNormalGPan, _RgbNormalGUV, _RgbNormalGStochastic, _RgbNormalGMaskChannel, _RgbNormalGGlobalMaskChannel]}", 2D) = "bump" { }
		[HideInInspector][Vector2]_RgbNormalGPan ("Pan", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RgbNormalGUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_RgbNormalGStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbNormalGMaskChannel ("Mask Channel", Int) = 1
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbNormalGGlobalMaskChannel ("Global Mask--{reference_property:_RgbNormalGGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbNormalGGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_RgbNormalGScale ("Intensity", Range(0, 10)) = 0
		[Space(10)]
		[Normal]_RgbNormalB ("B Normal--{reference_properties:[_RgbNormalBPan, _RgbNormalBUV, _RgbNormalBStochastic, _RgbNormalBMaskChannel, _RgbNormalBGlobalMaskChannel]}", 2D) = "bump" { }
		[HideInInspector][Vector2]_RgbNormalBPan ("Pan", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RgbNormalBUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_RgbNormalBStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbNormalBMaskChannel ("Mask Channel", Int) = 2
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbNormalBGlobalMaskChannel ("Global Mask--{reference_property:_RgbNormalBGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbNormalBGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_RgbNormalBScale ("Intensity", Range(0, 10)) = 0
		[Space(10)]
		[Normal]_RgbNormalA ("A Normal--{reference_properties:[_RgbNormalAPan, _RgbNormalAUV, _RgbNormalAStochastic, _RgbNormalAMaskChannel, _RgbNormalAGlobalMaskChannel]}", 2D) = "bump" { }
		[HideInInspector][Vector2]_RgbNormalAPan ("Pan", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RgbNormalAUV ("UV", int) = 0
		[HideInInspector][ToggleUI]_RgbNormalAStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RgbNormalAMaskChannel ("Mask Channel", Int) = 3
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RgbNormalAGlobalMaskChannel ("Global Mask--{reference_property:_RgbNormalAGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RgbNormalAGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_RgbNormalAScale ("Intensity", Range(0, 10)) = 0
		[HideInInspector] m_end_rgbanormals ("RGBA Normals", Float) = 0
		//endex
		[HideInInspector] m_end_RGBMask ("RGB Color Masking", Float) = 0
		//endex
		
		// Decal Texture
		[HideInInspector] m_start_DecalSection ("Decals--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/decals},hover:YouTube}}", Float) = 0
		[sRGBWarning][ThryRGBAPacker(Decal 0 Mask, Decal 1 Mask, Decal 2 Mask, Decal 3 Mask)]_DecalMask ("Decal RGBA Mask--{reference_properties:[_DecalMaskPan, _DecalMaskUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DecalMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DecalMaskUV ("UV", Int) = 0
		
		[HideInInspector] g_start_DecalTPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _DecalTPSDepthMaskEnabled ("<size=13><b>  TPS Depth Enabled</b></size>", Float) = 0
		_Decal0TPSMaskStrength ("Mask r Strength--{condition_showS:(_DecalTPSDepthMaskEnabled==1)}", Range(0, 1)) = 1
		_Decal1TPSMaskStrength ("Mask g Strength--{condition_showS:(_DecalTPSDepthMaskEnabled==1)}", Range(0, 1)) = 1
		_Decal2TPSMaskStrength ("Mask b Strength--{condition_showS:(_DecalTPSDepthMaskEnabled==1)}", Range(0, 1)) = 1
		_Decal3TPSMaskStrength ("Mask a Strength--{condition_showS:(_DecalTPSDepthMaskEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_DecalTPSMaskGroup ("", Float) = 0
		//ifex _DecalEnabled==0
		// Decal 0
		[HideInInspector] m_start_Decal0 ("Decal 0--{reference_property:_DecalEnabled}", Float) = 0
		[HideInInspector][ThryToggle(GEOM_TYPE_BRANCH)]_DecalEnabled ("Enable", Float) = 0
		[HideInInspector] g_start_decal_position ("Positioning--{draw_border:true}", Float) = 0
		[ThryDecalPositioning(_DecalTexture, _DecalTextureUV, _DecalPosition, _DecalRotation, _DecalScale, _DecalSideOffset)]
		[Vector2]_DecalPosition ("Position", Vector) = (.5, .5, 0, 0)
		_DecalRotation ("Rotation", Range(0, 360)) = 0
		_DecalRotationSpeed ("Rotation Speed", Float) = 0
		[Vector2]_DecalScale ("Scale", Vector) = (1, 1, 0, 0)
		[VectorLabel(L, R, D, U)]_DecalSideOffset ("Side Offset", Vector) = (0, 0, 0, 0)
		[HideInInspector] g_end_decal_position ("Positioning--{draw_border:true}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)] _Decal0MaskChannel ("Mask Channel", Int) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal0GlobalMask ("Global Mask--{reference_property:_Decal0GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Decal0GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_DecalColor ("Color--{reference_property:_DecalColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DecalColorThemeIndex ("", Int) = 0
		_DecalEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[sRGBWarning(true)]_DecalTexture ("Decal--{reference_properties:[_DecalTexturePan, _DecalTextureUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DecalTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DecalTextureUV ("UV", Int) = 0
		[ToggleUI]_DecalTiled ("Tiled", Float) = 0
		_Decal0Depth ("Depth", Float) = 0
		[ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_DecalBlendType ("Blending", Range(0, 1)) = 0
		_DecalBlendAlpha ("Alpha", Range(0, 1)) = 1
		[ToggleUI]_DecalOverrideAlpha ("Override Alpha", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal0ApplyGlobalMaskIndex ("Apply to Global Mask--{reference_property:_Decal0ApplyGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _Decal0ApplyGlobalMaskBlendType ("Blending", Int) = 0
		[ThryToggleUI(true)]_DecalHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_DecalHueShiftSpeed ("Shift Speed--{condition_showS:(_DecalHueShiftEnabled==1)}", Float) = 0
		_DecalHueShift ("Hue Shift--{condition_showS:(_DecalHueShiftEnabled==1)}", Range(0, 1)) = 0
		_Decal0HueAngleStrength ("Hue Angle Power--{condition_showS:(_DecalHueShiftEnabled==1)}", Float) = 0
		[NoAnimate][ThryToggle(true)]_Decal0ChannelSeparationEnable ("<size=13><b>  Channel Separation</b></size>", Float) = 0
		[HideInInspector] g_start_Decal0ChannelSeparation ("--{condition_showS:_Decal0ChannelSeparationEnable==1}", Int) = 0
		_Decal0ChannelSeparation ("Intensity", Float) = 0
		_Decal0ChannelSeparationAngleStrength ("Surface Angle Intensity", Float) = 0
		_Decal0ChannelSeparationHue ("Hue", Range(-1, 1)) = 0
		_Decal0ChannelSeparationVertical ("Direction", Range(-3.142, 3.142)) = 0
		[ToggleUI]_Decal0ChannelSeparationPremultiply ("Premultiply Alpha--{tooltip:''Fixes channel separation issues on some decal textures''}", Float) = 0
		[HideInInspector] g_end_Decal0ChannelSeparation ("", Int) = 0
		// Decal 0 Audio Link
		[HideInInspector] m_start_Decal0AudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal0ScaleBand ("Scale Band", Int) = 0
		[VectorLabel(Xmin, Ymin, Xmax, Ymax)]_AudioLinkDecal0Scale ("Scale Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal0SideBand ("Side Band", Int) = 0
		[VectorLabel(L, R, D, U)]_AudioLinkDecal0SideMin ("Side Mod Min", Vector) = (0, 0, 0, 0)
		[VectorLabel(L, R, D, U)]_AudioLinkDecal0SideMax ("Side Mod Max", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal0RotationBand ("Rotation Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal0Rotation ("Rotation Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal0AlphaBand ("Alpha Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal0Alpha ("Alpha Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal0EmissionBand ("Emission Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal0Emission ("Emission Mod", Vector) = (0, 0, 0, 0)
		[ToggleUI]_AudioLinkDecalCC0 ("CC Strip", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _DecalRotationCTALBand0 ("Chrono Rotation Band", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_DecalRotationCTALType0 ("Chrono Motion Type", Int) = 0
		_DecalRotationCTALSpeed0 ("Chrono Rotation Speed", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal0ChannelSeparationBand ("Channel Separation Band--{condition_showS:(_Decal0ChannelSeparationEnable==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal0ChannelSeparation ("Channel Separation--{condition_showS:(_Decal0ChannelSeparationEnable==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_Decal0AudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_Decal0 ("Decal 0", Float) = 0
		//endex
		//ifex _DecalEnabled1==0
		// Decal 1
		[HideInInspector] m_start_Decal1 ("Decal 1--{reference_property:_DecalEnabled1}", Float) = 0
		[HideInInspector][ThryToggle(GEOM_TYPE_BRANCH_DETAIL)]_DecalEnabled1 ("Enable", Float) = 0
		[HideInInspector] g_start_decal1_position ("Positioning--{draw_border:true}", Float) = 0
		[ThryDecalPositioning(_DecalTexture1, _DecalTexture1UV, _DecalPosition1, _DecalRotation1, _DecalScale1, _DecalSideOffset1)]
		[Vector2]_DecalPosition1 ("Position", Vector) = (.5, .5, 0, 0)
		_DecalRotation1 ("Rotation", Range(0, 360)) = 0
		_DecalRotationSpeed1 ("Rotation Speed", Float) = 0
		[Vector2]_DecalScale1 ("Scale", Vector) = (1, 1, 0, 0)
		[VectorLabel(L, R, D, U)]_DecalSideOffset1 ("Side Offset", Vector) = (0, 0, 0, 0)
		[HideInInspector] g_end_decal1_position ("Positioning--{draw_border:true}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)] _Decal1MaskChannel ("Mask Channel", Int) = 1
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal1GlobalMask ("Global Mask--{reference_property:_Decal1GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Decal1GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_DecalColor1 ("Color--{reference_property:_DecalColor1ThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DecalColor1ThemeIndex ("", Int) = 0
		_DecalEmissionStrength1 ("Emission Strength", Range(0, 20)) = 0
		[sRGBWarning(true)]_DecalTexture1 ("Decal--{reference_properties:[_DecalTexture1Pan, _DecalTexture1UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DecalTexture1Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DecalTexture1UV ("UV", Int) = 0
		[ToggleUI]_DecalTiled1 ("Tiled", Float) = 0
		_Decal1Depth ("Depth", Float) = 0
		[ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_DecalBlendType1 ("Blending", Range(0, 1)) = 0
		_DecalBlendAlpha1 ("Alpha", Range(0, 1)) = 1
		[ToggleUI]_DecalOverrideAlpha1 ("Override Alpha", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal1ApplyGlobalMaskIndex ("Apply to Global Mask--{reference_property:_Decal1ApplyGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _Decal1ApplyGlobalMaskBlendType ("Blending", Int) = 0
		[ThryToggleUI(true)]_DecalHueShiftEnabled1 ("<size=13><b>Hue Shift</b></size>", Float) = 0
		_DecalHueShiftSpeed1 ("Shift Speed--{condition_showS:(_DecalHueShiftEnabled1==1)}", Float) = 0
		_DecalHueShift1 ("Hue Shift--{condition_showS:(_DecalHueShiftEnabled1==1)}", Range(0, 1)) = 0
		_Decal1HueAngleStrength ("Hue Angle Power--{condition_showS:(_DecalHueShiftEnabled1==1)}", Float) = 0
		[NoAnimate][ThryToggle(true)]_Decal1ChannelSeparationEnable ("<size=13><b>  Channel Separation</b></size>", Float) = 0
		[HideInInspector] g_start_Decal1ChannelSeparation ("--{condition_showS:_Decal1ChannelSeparationEnable==1}", Int) = 0
		_Decal1ChannelSeparation ("Intensity", Float) = 0
		_Decal1ChannelSeparationAngleStrength ("Surface Angle Intensity", Float) = 0
		_Decal1ChannelSeparationHue ("Hue", Range(-1, 1)) = 0
		_Decal1ChannelSeparationVertical ("Direction", Range(-3.142, 3.142)) = 0
		[ToggleUI]_Decal1ChannelSeparationPremultiply ("Premultiply Alpha--{tooltip:''Fixes channel separation issues on some decal textures''}", Float) = 0
		[HideInInspector] g_end_Decal1ChannelSeparation ("", Int) = 0
		// Decal 1 Audio Link
		[HideInInspector] m_start_Decal1AudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal1ScaleBand ("Scale Band", Int) = 0
		[VectorLabel(Xmin, Ymin, Xmax, Ymax)]_AudioLinkDecal1Scale ("Scale Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal1SideBand ("Side Band", Int) = 0
		[VectorLabel(L, R, D, U)]_AudioLinkDecal1SideMin ("Side Mod Min", Vector) = (0, 0, 0, 0)
		[VectorLabel(L, R, D, U)]_AudioLinkDecal1SideMax ("Side Mod Max", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal1RotationBand ("Rotation Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal1Rotation ("Rotation Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal1AlphaBand ("Alpha Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal1Alpha ("Alpha Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal1EmissionBand ("Emission Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal1Emission ("Emission Mod", Vector) = (0, 0, 0, 0)
		[ToggleUI]_AudioLinkDecalCC1 ("CC Strip", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _DecalRotationCTALBand1 ("Chrono Rotation Band", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_DecalRotationCTALType1 ("Chrono Motion Type", Int) = 0
		_DecalRotationCTALSpeed1 ("Chrono Rotation Speed", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal1ChannelSeparationBand ("Channel Separation Band--{condition_showS:(_Decal1ChannelSeparationEnable==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal1ChannelSeparation ("Channel Separation--{condition_showS:(_Decal1ChannelSeparationEnable==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_Decal1AudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_Decal1 ("Decal 0", Float) = 0
		//endex
		//ifex _DecalEnabled2==0
		// Decal 2
		[HideInInspector] m_start_Decal2 ("Decal 2--{reference_property:_DecalEnabled2}", Float) = 0
		[HideInInspector][ThryToggle(GEOM_TYPE_FROND)]_DecalEnabled2 ("Enable", Float) = 0
		[HideInInspector] g_start_decal2_position ("Positioning--{draw_border:true}", Float) = 0
		[ThryDecalPositioning(_DecalTexture2, _DecalTexture2UV, _DecalPosition2, _DecalRotation2, _DecalScale2, _DecalSideOffset2)]
		[Vector2]_DecalPosition2 ("Position", Vector) = (.5, .5, 0, 0)
		_DecalRotation2 ("Rotation", Range(0, 360)) = 0
		_DecalRotationSpeed2 ("Rotation Speed", Float) = 0
		[Vector2]_DecalScale2 ("Scale", Vector) = (1, 1, 0, 0)
		[VectorLabel(L, R, D, U)]_DecalSideOffset2 ("Side Offset", Vector) = (0, 0, 0, 0)
		[HideInInspector] g_end_decal2_position ("Positioning--{draw_border:true}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)] _Decal2MaskChannel ("Mask Channel", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal2GlobalMask ("Global Mask--{reference_property:_Decal2GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Decal2GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_DecalColor2 ("Color--{reference_property:_DecalColor2ThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DecalColor2ThemeIndex ("", Int) = 0
		_DecalEmissionStrength2 ("Emission Strength", Range(0, 20)) = 0
		[sRGBWarning(true)]_DecalTexture2 ("Decal--{reference_properties:[_DecalTexture2Pan, _DecalTexture2UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DecalTexture2Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DecalTexture2UV ("UV", Int) = 0
		[ToggleUI]_DecalTiled2 ("Tiled", Float) = 0
		_Decal2Depth ("Depth", Float) = 0
		[ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_DecalBlendType2 ("Blending", Range(0, 1)) = 0
		_DecalBlendAlpha2 ("Alpha", Range(0, 1)) = 1
		[ToggleUI]_DecalOverrideAlpha2 ("Override Alpha", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal2ApplyGlobalMaskIndex ("Apply to Global Mask--{reference_property:_Decal2ApplyGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _Decal2ApplyGlobalMaskBlendType ("Blending", Int) = 0
		[ThryToggleUI(true)]_DecalHueShiftEnabled2 ("<size=13><b>Hue Shift</b></size>", Float) = 0
		_DecalHueShiftSpeed2 ("Shift Speed--{condition_showS:(_DecalHueShiftEnabled2==1)}", Float) = 0
		_DecalHueShift2 ("Hue Shift--{condition_showS:(_DecalHueShiftEnabled2==1)}", Range(0, 1)) = 0
		_Decal2HueAngleStrength ("Hue Angle Power--{condition_showS:(_DecalHueShiftEnabled2==1)}", Float) = 0
		[NoAnimate][ThryToggle(true)]_Decal2ChannelSeparationEnable ("<size=13><b>  Channel Separation</b></size>", Float) = 0
		[HideInInspector] g_start_Decal2ChannelSeparation ("--{condition_showS:_Decal2ChannelSeparationEnable==1}", Int) = 0
		_Decal2ChannelSeparation ("Intensity", Float) = 0
		_Decal2ChannelSeparationAngleStrength ("Surface Angle Intensity", Float) = 0
		_Decal2ChannelSeparationHue ("Hue", Range(-1, 1)) = 0
		_Decal2ChannelSeparationVertical ("Direction", Range(-3.142, 3.142)) = 0
		[ToggleUI]_Decal2ChannelSeparationPremultiply ("Premultiply Alpha--{tooltip:''Fixes channel separation issues on some decal textures''}", Float) = 0
		[HideInInspector] g_end_Decal2ChannelSeparation ("", Int) = 0
		// Decal 2 Audio Link
		[HideInInspector] m_start_Decal2AudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal2ScaleBand ("Scale Band", Int) = 0
		[VectorLabel(Xmin, Ymin, Xmax, Ymax)]_AudioLinkDecal2Scale ("Scale Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal2SideBand ("Side Band", Int) = 0
		[VectorLabel(L, R, U, D)]_AudioLinkDecal2SideMin ("Side Mod Min", Vector) = (0, 0, 0, 0)
		[VectorLabel(L, R, U, D)]_AudioLinkDecal2SideMax ("Side Mod Max", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal2RotationBand ("Rotation Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal2Rotation ("Rotation Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal2AlphaBand ("Alpha Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal2Alpha ("Alpha Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal2EmissionBand ("Emission Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal2Emission ("Emission Mod", Vector) = (0, 0, 0, 0)
		[ToggleUI]_AudioLinkDecalCC2 ("CC Strip", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _DecalRotationCTALBand2 ("Chrono Rotation Band", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_DecalRotationCTALType2 ("Chrono Motion Type", Int) = 0
		_DecalRotationCTALSpeed2 ("Chrono Rotation Speed", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal2ChannelSeparationBand ("Channel Separation Band--{condition_showS:(_Decal2ChannelSeparationEnable==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal2ChannelSeparation ("Channel Separation--{condition_showS:(_Decal2ChannelSeparationEnable==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_Decal2AudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_Decal2 ("Decal 0", Float) = 0
		//endex
		//ifex _DecalEnabled3==0
		// Decal 3
		[HideInInspector] m_start_Decal3 ("Decal 3--{reference_property:_DecalEnabled3}", Float) = 0
		[HideInInspector][ThryToggle(DEPTH_OF_FIELD_COC_VIEW)]_DecalEnabled3 ("Enable", Float) = 0
		[HideInInspector] g_start_decal3_position ("Positioning--{draw_border:true}", Float) = 0
		[ThryDecalPositioning(_DecalTexture3, _DecalTexture3UV, _DecalPosition3, _DecalRotation3, _DecalScale3, _DecalSideOffset3)]
		[Vector3]_DecalPosition3 ("Position", Vector) = (.5, .5, 0, 0)
		_DecalRotation3 ("Rotation", Range(0, 360)) = 0
		_DecalRotationSpeed3 ("Rotation Speed", Float) = 0
		[Vector3]_DecalScale3 ("Scale", Vector) = (1, 1, 0, 0)
		[VectorLabel(L, R, D, U)]_DecalSideOffset3 ("Side Offset", Vector) = (0, 0, 0, 0)
		[HideInInspector] g_end_decal3_position ("Positioning--{draw_border:true}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)] _Decal3MaskChannel ("Mask Channel", Int) = 3
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal3GlobalMask ("Global Mask--{reference_property:_Decal3GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Decal3GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_DecalColor3 ("Color--{reference_property:_DecalColor3ThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DecalColor3ThemeIndex ("", Int) = 0
		_DecalEmissionStrength3 ("Emission Strength", Range(0, 20)) = 0
		[sRGBWarning(true)]_DecalTexture3 ("Decal--{reference_properties:[_DecalTexture3Pan, _DecalTexture3UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DecalTexture3Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DecalTexture3UV ("UV", Int) = 0
		[ToggleUI]_DecalTiled3 ("Tiled", Float) = 0
		_Decal3Depth ("Depth", Float) = 0
		[ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_DecalBlendType3 ("Blending", Range(0, 1)) = 0
		_DecalBlendAlpha3 ("Alpha", Range(0, 1)) = 1
		[ToggleUI]_DecalOverrideAlpha3 ("Override Alpha", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Decal3ApplyGlobalMaskIndex ("Apply to Global Mask--{reference_property:_Decal3ApplyGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _Decal3ApplyGlobalMaskBlendType ("Blending", Int) = 0
		[ThryToggleUI(true)]_DecalHueShiftEnabled3 ("<size=13><b>Hue Shift</b></size>", Float) = 0
		_DecalHueShiftSpeed3 ("Shift Speed--{condition_showS:(_DecalHueShiftEnabled3==1)}", Float) = 0
		_DecalHueShift3 ("Hue Shift--{condition_showS:(_DecalHueShiftEnabled3==1)}", Range(0, 1)) = 0
		_Decal3HueAngleStrength ("Hue Angle Power--{condition_showS:(_DecalHueShiftEnabled3==1)}", Float) = 0
		[NoAnimate][ThryToggle(true)]_Decal3ChannelSeparationEnable ("<size=13><b>  Channel Separation</b></size>", Float) = 0
		[HideInInspector] g_start_Decal3ChannelSeparation ("--{condition_showS:_Decal3ChannelSeparationEnable==1}", Int) = 0
		_Decal3ChannelSeparation ("Intensity", Float) = 0
		_Decal3ChannelSeparationAngleStrength ("Surface Angle Intensity", Float) = 0
		_Decal3ChannelSeparationHue ("Hue", Range(-1, 1)) = 0
		_Decal3ChannelSeparationVertical ("Direction", Range(-3.142, 3.142)) = 0
		[ToggleUI]_Decal3ChannelSeparationPremultiply ("Premultiply Alpha--{tooltip:''Fixes channel separation issues on some decal textures''}", Float) = 0
		[HideInInspector] g_end_Decal3ChannelSeparation ("", Int) = 0
		// Decal 3 Audio Link
		[HideInInspector] m_start_Decal3AudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal3ScaleBand ("Scale Band", Int) = 0
		[VectorLabel(Xmin, Ymin, Xmax, Ymax)]_AudioLinkDecal3Scale ("Scale Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal3SideBand ("Side Band", Int) = 0
		[VectorLabel(L, R, U, D)]_AudioLinkDecal3SideMin ("Side Mod Min", Vector) = (0, 0, 0, 0)
		[VectorLabel(L, R, U, D)]_AudioLinkDecal3SideMax ("Side Mod Max", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal3RotationBand ("Rotation Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal3Rotation ("Rotation Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal3AlphaBand ("Alpha Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal3Alpha ("Alpha Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal3EmissionBand ("Emission Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal3Emission ("Emission Mod", Vector) = (0, 0, 0, 0)
		[ToggleUI]_AudioLinkDecalCC3 ("CC Strip", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _DecalRotationCTALBand3 ("Chrono Rotation Band", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_DecalRotationCTALType3 ("Chrono Motion Type", Int) = 0
		_DecalRotationCTALSpeed3 ("Chrono Rotation Speed", Float) = 0
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDecal3ChannelSeparationBand ("Channel Separation Band--{condition_showS:(_Decal3ChannelSeparationEnable==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDecal3ChannelSeparation ("Channel Separation--{condition_showS:(_Decal3ChannelSeparationEnable==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_Decal3AudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_Decal3 ("Decal 0", Float) = 0
		//endex
		[HideInInspector] m_end_DecalSection ("Decal", Float) = 0
		
		[HideInInspector] m_start_GlobalThemes ("Global Themes--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/color-and-normals/global-themes},hover:Documentation}}", Float) = 0
		[HideInInspector] m_start_GlobalThemeColor0 ("Theme Color 0", Float) = 0
		[HDR]_GlobalThemeColor0 ("Theme Color 0",       Color       ) = (1, 1, 1, 1)
		_GlobalThemeHue0        ("Hue Adjust",          Range( 0, 1)) = 0
		_GlobalThemeHueSpeed0   ("Hue Adjust Speed",    Float       ) = 0
		_GlobalThemeSaturation0 ("Saturation Adjust",   Range(-1, 1)) = 0
		_GlobalThemeValue0      ("Value Adjust",        Range(-1, 1)) = 0
		[HideInInspector] m_end_GlobalThemeColor0   ("Theme Color 0", Float) = 0
		[HideInInspector] m_start_GlobalThemeColor1 ("Theme Color 1", Float) = 0
		[HDR]_GlobalThemeColor1 ("Theme Color 1",       Color       ) = (1, 1, 1, 1)
		_GlobalThemeHue1        ("Hue Adjust",          Range( 0, 1)) = 0
		_GlobalThemeHueSpeed1   ("Hue Adjust Speed",    Float       ) = 0
		_GlobalThemeSaturation1 ("Saturation Adjust",   Range(-1, 1)) = 0
		_GlobalThemeValue1      ("Value Adjust",        Range(-1, 1)) = 0
		[HideInInspector] m_end_GlobalThemeColor1   ("Theme Color 1", Float) = 0
		[HideInInspector] m_start_GlobalThemeColor2 ("Theme Color 2", Float) = 0
		[HDR]_GlobalThemeColor2 ("Theme Color 2",       Color       ) = (1, 1, 1, 1)
		_GlobalThemeHue2        ("Hue Adjust",          Range( 0, 1)) = 0
		_GlobalThemeHueSpeed2   ("Hue Adjust Speed",    Float       ) = 0
		_GlobalThemeSaturation2 ("Saturation Adjust",   Range(-1, 1)) = 0
		_GlobalThemeValue2      ("Value Adjust",        Range(-1, 1)) = 0
		[HideInInspector] m_end_GlobalThemeColor2   ("Theme Color 2", Float) = 0
		[HideInInspector] m_start_GlobalThemeColor3 ("Theme Color 3", Float) = 0
		[HDR]_GlobalThemeColor3 ("Theme Color 3",       Color       ) = (1, 1, 1, 1)
		_GlobalThemeHue3        ("Hue Adjust",          Range( 0, 1)) = 0
		_GlobalThemeHueSpeed3   ("Hue Adjust Speed",    Float       ) = 0
		_GlobalThemeSaturation3 ("Saturation Adjust",   Range(-1, 1)) = 0
		_GlobalThemeValue3      ("Value Adjust",        Range(-1, 1)) = 0
		[HideInInspector] m_end_GlobalThemeColor3   ("Theme Color 3", Float) = 0
		[HideInInspector] m_end_GlobalThemes ("Global Themes", Float ) = 0
		
		[HideInInspector] m_start_GlobalMask ("Global Mask", Float) = 0
		
		//ifex _GlobalMaskTexturesEnable==0
		[HideInInspector] m_start_GlobalMaskTextures ("Textures--{reference_property:_GlobalMaskTexturesEnable}", Float) = 0
		[HideInInspector][ThryToggle(POI_GLOBALMASK_TEXTURES)] _GlobalMaskTexturesEnable ("Global Mask Textures Enable", Float) = 0
		
		[sRGBWarning][ThryRGBAPacker(R, G, B, A, 0)]_GlobalMaskTexture0 ("Global Mask Texture 1--{reference_properties:[_GlobalMaskTexture0Pan, _GlobalMaskTexture0SplitTilingOffset_G, _GlobalMaskTexture0SplitPan_G, _GlobalMaskTexture0SplitTilingOffset_B, _GlobalMaskTexture0SplitPan_B, _GlobalMaskTexture0SplitTilingOffset_A, _GlobalMaskTexture0SplitPan_A, _GlobalMaskTexture0Split, _GlobalMaskTexture0UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlobalMaskTexture0Pan ("Panning", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(G Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture0SplitTilingOffset_G ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture0Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture0SplitPan_G ("Panning--{condition_showS:(_GlobalMaskTexture0Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(B Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture0SplitTilingOffset_B ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture0Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture0SplitPan_B ("Panning--{condition_showS:(_GlobalMaskTexture0Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(A Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture0SplitTilingOffset_A ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture0Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture0SplitPan_A ("Panning--{condition_showS:(_GlobalMaskTexture0Split==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector][ToggleUI] _GlobalMaskTexture0Split ("Split Sampling", Int) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_GlobalMaskTexture0UV ("UV", Int) = 0
		
		[sRGBWarning][ThryRGBAPacker(R, G, B, A, 0)]_GlobalMaskTexture1 ("Global Mask Texture 2--{reference_properties:[_GlobalMaskTexture1Pan, _GlobalMaskTexture1SplitTilingOffset_G, _GlobalMaskTexture1SplitPan_G, _GlobalMaskTexture1SplitTilingOffset_B, _GlobalMaskTexture1SplitPan_B, _GlobalMaskTexture1SplitTilingOffset_A, _GlobalMaskTexture1SplitPan_A, _GlobalMaskTexture1Split, _GlobalMaskTexture1UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlobalMaskTexture1Pan ("Panning", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(G Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture1SplitTilingOffset_G ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture1Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture1SplitPan_G ("Panning--{condition_showS:(_GlobalMaskTexture1Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(B Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture1SplitTilingOffset_B ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture1Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture1SplitPan_B ("Panning--{condition_showS:(_GlobalMaskTexture1Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(A Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture1SplitTilingOffset_A ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture1Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture1SplitPan_A ("Panning--{condition_showS:(_GlobalMaskTexture1Split==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector][ToggleUI] _GlobalMaskTexture1Split ("Split Sampling", Int) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_GlobalMaskTexture1UV ("UV", Int) = 0
		
		[sRGBWarning][ThryRGBAPacker(R, G, B, A, 0)]_GlobalMaskTexture2 ("Global Mask Texture 3--{reference_properties:[_GlobalMaskTexture2Pan, _GlobalMaskTexture2SplitTilingOffset_G, _GlobalMaskTexture2SplitPan_G, _GlobalMaskTexture2SplitTilingOffset_B, _GlobalMaskTexture2SplitPan_B, _GlobalMaskTexture2SplitTilingOffset_A, _GlobalMaskTexture2SplitPan_A, _GlobalMaskTexture2Split, _GlobalMaskTexture2UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlobalMaskTexture2Pan ("Panning", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(G Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture2SplitTilingOffset_G ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture2Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture2SplitPan_G ("Panning--{condition_showS:(_GlobalMaskTexture2Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(B Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture2SplitTilingOffset_B ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture2Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture2SplitPan_B ("Panning--{condition_showS:(_GlobalMaskTexture2Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(A Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture2SplitTilingOffset_A ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture2Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture2SplitPan_A ("Panning--{condition_showS:(_GlobalMaskTexture2Split==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector][ToggleUI] _GlobalMaskTexture2Split ("Split Sampling", Int) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_GlobalMaskTexture2UV ("UV", Int) = 0
		
		[sRGBWarning][ThryRGBAPacker(R, G, B, A, 0)]_GlobalMaskTexture3 ("Global Mask Texture 4--{reference_properties:[_GlobalMaskTexture3Pan, _GlobalMaskTexture3SplitTilingOffset_G, _GlobalMaskTexture3SplitPan_G, _GlobalMaskTexture3SplitTilingOffset_B, _GlobalMaskTexture3SplitPan_B, _GlobalMaskTexture3SplitTilingOffset_A, _GlobalMaskTexture3SplitPan_A, _GlobalMaskTexture3Split, _GlobalMaskTexture3UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlobalMaskTexture3Pan ("Panning", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(G Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture3SplitTilingOffset_G ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture3Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture3SplitPan_G ("Panning--{condition_showS:(_GlobalMaskTexture3Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(B Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture3SplitTilingOffset_B ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture3Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture3SplitPan_B ("Panning--{condition_showS:(_GlobalMaskTexture3Split==1)}", Vector) = (0, 0, 0, 0)
		[ThryHeaderLabel(A Channel)]
		[HideInInspector][VectorLabel(tX, tY, oX, oY)]_GlobalMaskTexture3SplitTilingOffset_A ("Tiling/Offset--{condition_showS:(_GlobalMaskTexture3Split==1)}", Vector) = (1, 1, 0, 0)
		[HideInInspector][Vector2]_GlobalMaskTexture3SplitPan_A ("Panning--{condition_showS:(_GlobalMaskTexture3Split==1)}", Vector) = (0, 0, 0, 0)
		[HideInInspector][ToggleUI] _GlobalMaskTexture3Split ("Split Sampling", Int) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_GlobalMaskTexture3UV ("UV", Int) = 0
		
		[HideInInspector] m_end_GlobalMaskTextures ("Global Mask Textures", Float) = 0
		//endex
		
		[HideInInspector] m_start_GlobalMaskModifiers ("Modifiers", Float) = 0
		
		//ifex _GlobalMaskModifiersBackfaceEnable==0
		[HideInInspector] m_start_GlobalMaskModifiersBackface ("Backface Masking--{reference_property:_GlobalMaskModifiersBackfaceEnable}", Float) = 0
		[HideInInspector][NoAnimate][ThryToggleUI(true)] _GlobalMaskModifiersBackfaceEnable ("Global Mask Backface Enable", Float) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_0  ("1R", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_1  ("1G", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_2  ("1B", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_3  ("1A", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_4  ("2R", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_5  ("2G", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_6  ("2B", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_7  ("2A", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_8  ("3R", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_9  ("3G", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_10 ("3B", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_11 ("3A", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_12 ("4R", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_13 ("4G", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_14 ("4B", Int) = 0
		[Enum(Both, 0, Back Only, 1, Front Only, 2)] _GlobalMaskBackface_15 ("4A", Int) = 0
		[HideInInspector] m_end_GlobalMaskModifiersBackface ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskModifiersMirrorEnable==0
		[HideInInspector] m_start_GlobalMaskModifiersMirror ("Mirror Masking--{reference_property:_GlobalMaskModifiersMirrorEnable}", Float) = 0
		[HideInInspector][NoAnimate][ThryToggleUI(true)] _GlobalMaskModifiersMirrorEnable ("Global Mask Mirror Enable", Float) = 0
		[Enum(Generic, 0, VRC, 1)] _GlobalMaskMirrorVisibilityMode ("Mirror Detection Mode", Int) = 1
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_0  ("1R", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_1  ("1G", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_2  ("1B", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_3  ("1A", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_4  ("2R", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_5  ("2G", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_6  ("2B", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_7  ("2A", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_8  ("3R", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_9  ("3G", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_10 ("3B", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_11 ("3A", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_12 ("4R", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_13 ("4G", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_14 ("4B", Int) = 0
		[Enum(Both, 0, Only Outside Mirror, 1, Only In Mirror, 2)] _GlobalMaskMirror_15 ("4A", Int) = 0
		[HideInInspector] m_end_GlobalMaskModifiersMirror ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskModifiersCameraEnable==0
		[HideInInspector] m_start_GlobalMaskModifiersCamera ("Camera Masking--{reference_property:_GlobalMaskModifiersCameraEnable}", Float) = 0
		[HideInInspector][NoAnimate][ThryToggleUI(true)] _GlobalMaskModifiersCameraEnable ("Global Mask Camera Enable", Float) = 0
		[Helpbox(1)] _GlobalMaskModifiersCameraInfo ("Camera Masking only works in VRChat.", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_0  ("1R", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_1  ("1G", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_2  ("1B", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_3  ("1A", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_4  ("2R", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_5  ("2G", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_6  ("2B", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_7  ("2A", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_8  ("3R", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_9  ("3G", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_10 ("3B", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_11 ("3A", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_12 ("4R", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_13 ("4G", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_14 ("4B", Int) = 0
		[Enum(Both, 0, Only Outside Camera, 1, Only In Camera, 2)] _GlobalMaskCamera_15 ("4A", Int) = 0
		[HideInInspector] m_end_GlobalMaskModifiersCamera ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskModifiersDistanceEnable==0
		[HideInInspector] m_start_GlobalMaskModifiersDistance ("Distance Masking--{reference_property:_GlobalMaskModifiersDistanceEnable}", Float) = 0
		[HideInInspector][NoAnimate][ThryToggleUI(true)] _GlobalMaskModifiersDistanceEnable ("Global Mask Camera Enable", Float) = 0
		
		//ifex _GlobalMaskDistanceEnable_0==0// [Vector2] _GlobalMaskDistance_0 ("1R", Vector) = (1,2,0,0)
		[HideInInspector] m_start_GlobalMaskDistanceM_0 ("1R--{reference_property:_GlobalMaskDistanceEnable_0}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_0 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_0 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_0 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_0 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_0 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_0 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_0 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_0 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_1==0
		[HideInInspector] m_start_GlobalMaskDistanceM_1 ("1G--{reference_property:_GlobalMaskDistanceEnable_1}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_1 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_1 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_1 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_1 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_1 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_1 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_1 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_1 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_2==0
		[HideInInspector] m_start_GlobalMaskDistanceM_2 ("1B--{reference_property:_GlobalMaskDistanceEnable_2}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_2 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_2 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_2 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_2 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_2 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_2 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_2 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_2 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_3==0
		[HideInInspector] m_start_GlobalMaskDistanceM_3 ("1A--{reference_property:_GlobalMaskDistanceEnable_3}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_3 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_3 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_3 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_3 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_3 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_3 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_3 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_3 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_4==0
		[HideInInspector] m_start_GlobalMaskDistanceM_4 ("2R--{reference_property:_GlobalMaskDistanceEnable_4}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_4 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_4 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_4 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_4 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_4 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_4 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_4 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_4 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_5==0
		[HideInInspector] m_start_GlobalMaskDistanceM_5 ("2G--{reference_property:_GlobalMaskDistanceEnable_5}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_5 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_5 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_5 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_5 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_5 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_5 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_5 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_5 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_6==0
		[HideInInspector] m_start_GlobalMaskDistanceM_6 ("2B--{reference_property:_GlobalMaskDistanceEnable_6}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_6 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_6 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_6 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_6 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_6 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_6 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_6 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_6 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_7==0
		[HideInInspector] m_start_GlobalMaskDistanceM_7 ("2A--{reference_property:_GlobalMaskDistanceEnable_7}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_7 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_7 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_7 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_7 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_7 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_7 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_7 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_7 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_8==0
		[HideInInspector] m_start_GlobalMaskDistanceM_8 ("3R--{reference_property:_GlobalMaskDistanceEnable_8}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_8 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_8 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_8 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_8 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_8 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_8 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_8 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_8 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_9==0
		[HideInInspector] m_start_GlobalMaskDistanceM_9 ("3G--{reference_property:_GlobalMaskDistanceEnable_9}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_9 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_9 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_9 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_9 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_9 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_9 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_9 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_9 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_10==0
		[HideInInspector] m_start_GlobalMaskDistanceM_10 ("3B--{reference_property:_GlobalMaskDistanceEnable_10}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_10 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_10 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_10 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_10 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_10 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_10 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_10 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_10 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_11==0
		[HideInInspector] m_start_GlobalMaskDistanceM_11 ("3A--{reference_property:_GlobalMaskDistanceEnable_11}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_11 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_11 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_11 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_11 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_11 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_11 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_11 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_11 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_12==0
		[HideInInspector] m_start_GlobalMaskDistanceM_12 ("4R--{reference_property:_GlobalMaskDistanceEnable_12}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_12 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_12 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_12 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_12 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_12 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_12 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_12 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_12 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_13==0
		[HideInInspector] m_start_GlobalMaskDistanceM_13 ("4G--{reference_property:_GlobalMaskDistanceEnable_13}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_13 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_13 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_13 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_13 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_13 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_13 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_13 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_13 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_14==0
		[HideInInspector] m_start_GlobalMaskDistanceM_14 ("4B--{reference_property:_GlobalMaskDistanceEnable_14}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_14 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_14 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_14 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_14 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_14 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_14 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_14 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_14 ("", Float) = 0
		//endex
		
		//ifex _GlobalMaskDistanceEnable_15==0
		[HideInInspector] m_start_GlobalMaskDistanceM_15 ("4A--{reference_property:_GlobalMaskDistanceEnable_15}", Float) = 0
		[HideInInspector][ThryToggleUI(true)] _GlobalMaskDistanceEnable_15 ("", Int) = 0
		[Enum(Object Position, 0, Pixel Position, 1)] _GlobalMaskDistanceType_15 ("Pos To Use", Int) = 1
		_GlobalMaskDistanceMin_15 ("Min Distance", Float) = 1
		_GlobalMaskDistanceMax_15 ("Max Distance", Float) = 2
		_GlobalMaskDistanceMinAlpha_15 ("Min Distance Alpha", Range(0, 1)) = 0
		_GlobalMaskDistanceMaxAlpha_15 ("Max Distance Alpha", Range(0, 1)) = 1
		[ThryWideEnum(Replace, 0, Multiply, 2)] _GlobalMaskDistanceBlendType_15 ("Blending", Int) = 0
		[HideInInspector] m_end_GlobalMaskDistanceM_15 ("", Float) = 0
		//endex
		
		[HideInInspector] m_end_GlobalMaskModifiersDistance ("", Float) = 0
		//endex
		
		[HideInInspector] m_end_GlobalMaskModifiers ("", Float) = 0
		
		//ifex _GlobalMaskOptionsEnable==0
		[HideInInspector] m_start_GlobalMaskOptions ("Options--{reference_property:_GlobalMaskOptionsEnable}", Float) = 0
		[HideInInspector][NoAnimate][ThryToggleUI(true)] _GlobalMaskOptionsEnable ("Global Mask Options Enable", Float) = 0
		[Enum(Sliders, 0, Min Max Sliders, 1, Force Toggles, 2)] _GlobalMaskOptionsType ("Type", Int) = 0
		
		//ifex _GlobalMaskOptionsType!=0
		[HideInInspector] g_start_GlobalMaskOptionsSliders ("--{condition_showS:_GlobalMaskOptionsType==0}", Int) = 0
		_GlobalMaskSlider_0  ("1R", Range(-1, 1)) = 0
		_GlobalMaskSlider_1  ("1G", Range(-1, 1)) = 0
		_GlobalMaskSlider_2  ("1B", Range(-1, 1)) = 0
		_GlobalMaskSlider_3  ("1A", Range(-1, 1)) = 0
		_GlobalMaskSlider_4  ("2R", Range(-1, 1)) = 0
		_GlobalMaskSlider_5  ("2G", Range(-1, 1)) = 0
		_GlobalMaskSlider_6  ("2B", Range(-1, 1)) = 0
		_GlobalMaskSlider_7  ("2A", Range(-1, 1)) = 0
		_GlobalMaskSlider_8  ("3R", Range(-1, 1)) = 0
		_GlobalMaskSlider_9  ("3G", Range(-1, 1)) = 0
		_GlobalMaskSlider_10 ("3B", Range(-1, 1)) = 0
		_GlobalMaskSlider_11 ("3A", Range(-1, 1)) = 0
		_GlobalMaskSlider_12 ("4R", Range(-1, 1)) = 0
		_GlobalMaskSlider_13 ("4G", Range(-1, 1)) = 0
		_GlobalMaskSlider_14 ("4B", Range(-1, 1)) = 0
		_GlobalMaskSlider_15 ("4A", Range(-1, 1)) = 0
		[HideInInspector] g_end_GlobalMaskOptionsSliders ("", Int) = 0
		//endex
		
		//ifex _GlobalMaskOptionsType!=1
		[HideInInspector] g_start_GlobalMaskOptionsMinMaxSliders ("--{condition_showS:_GlobalMaskOptionsType==1}", Int) = 0
		[MultiSlider] _GlobalMaskMinMaxSlider_0  ("1R", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_1  ("1G", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_2  ("1B", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_3  ("1A", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_4  ("2R", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_5  ("2G", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_6  ("2B", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_7  ("2A", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_8  ("3R", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_9  ("3G", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_10 ("3B", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_11 ("3A", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_12 ("4R", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_13 ("4G", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_14 ("4B", Vector) = (0, 1, 0, 1)
		[MultiSlider] _GlobalMaskMinMaxSlider_15 ("4A", Vector) = (0, 1, 0, 1)
		[HideInInspector] g_end_GlobalMaskOptionsMinMaxSliders ("", Int) = 0
		//endex
		
		//ifex _GlobalMaskOptionsType!=2
		[HideInInspector] g_start_GlobalMaskOptionsForceToggles ("--{condition_showS:_GlobalMaskOptionsType==2}", Int) = 0
		[ThryHeaderLabel(Force On)]
		[ToggleUI] _GlobalMaskToggleOn_0   ("1R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_1   ("1G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_2   ("1B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_3   ("1A", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_4   ("2R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_5   ("2G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_6   ("2B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_7   ("2A", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_8   ("3R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_9   ("3G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_10  ("3B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_11  ("3A", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_12  ("4R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_13  ("4G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_14  ("4B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOn_15  ("4A", Int) = 0
		[Space(8)]
		[ThryHeaderLabel(Force Off)]
		[ToggleUI] _GlobalMaskToggleOff_0  ("1R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_1  ("1G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_2  ("1B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_3  ("1A", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_4  ("2R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_5  ("2G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_6  ("2B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_7  ("2A", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_8  ("3R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_9  ("3G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_10 ("3B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_11 ("3A", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_12 ("4R", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_13 ("4G", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_14 ("4B", Int) = 0
		[ToggleUI] _GlobalMaskToggleOff_15 ("4A", Int) = 0
		[HideInInspector] g_end_GlobalMaskOptionsForceToggles ("", Int) = 0
		//endex
		
		[HideInInspector] m_end_GlobalMaskOptions ("Global Mask Options", Float) = 0
		//endex
		
		[HideInInspector] m_end_GlobalMask ("Global Mask", Float) = 0
		
		// Lighting
		[HideInInspector] m_lightingCategory ("Shading", Float) = 0
		
		[HideInInspector] m_start_PoiLightData ("Light Data--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/light-data},hover:Documentation}}", Float) = 0
		// Lighting Data
		[sRGBWarning]_LightingAOMaps ("AO Maps (expand)--{reference_properties:[_LightingAOMapsPan, _LightingAOMapsUV,_LightDataAOStrengthR,_LightDataAOStrengthG,_LightDataAOStrengthB,_LightDataAOStrengthA, _LightDataAOGlobalMaskR]}", 2D) = "white" { }
		[HideInInspector][Vector2]_LightingAOMapsPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _LightingAOMapsUV ("UV", Int) = 0
		[HideInInspector]_LightDataAOStrengthR ("R Strength", Range(0, 1)) = 1
		[HideInInspector]_LightDataAOStrengthG ("G Strength", Range(0, 1)) = 0
		[HideInInspector]_LightDataAOStrengthB ("B Strength", Range(0, 1)) = 0
		[HideInInspector]_LightDataAOStrengthA ("A Strength", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _LightDataAOGlobalMaskR ("Global Mask--{reference_property:_LightDataAOGlobalMaskBlendTypeR}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _LightDataAOGlobalMaskBlendTypeR ("Blending", Range(0, 1)) = 2
		[sRGBWarning]_LightingDetailShadowMaps ("Detail Shadows (expand)--{reference_properties:[_LightingDetailShadowMapsPan, _LightingDetailShadowMapsUV,_LightingDetailShadowStrengthR,_LightingDetailShadowStrengthG,_LightingDetailShadowStrengthB,_LightingDetailShadowStrengthA,_LightingAddDetailShadowStrengthR,_LightingAddDetailShadowStrengthG,_LightingAddDetailShadowStrengthB,_LightingAddDetailShadowStrengthA, _LightDataDetailShadowGlobalMaskR]}", 2D) = "white" { }
		[HideInInspector][Vector2]_LightingDetailShadowMapsPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _LightingDetailShadowMapsUV ("UV", Int) = 0
		[HideInInspector]_LightingDetailShadowStrengthR ("R Strength", Range(0, 1)) = 1
		[HideInInspector]_LightingDetailShadowStrengthG ("G Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingDetailShadowStrengthB ("B Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingDetailShadowStrengthA ("A Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingAddDetailShadowStrengthR ("Additive R Strength", Range(0, 1)) = 1
		[HideInInspector]_LightingAddDetailShadowStrengthG ("Additive G Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingAddDetailShadowStrengthB ("Additive B Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingAddDetailShadowStrengthA ("Additive A Strength", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _LightDataDetailShadowGlobalMaskR ("Global Mask--{reference_property:_LightDataDetailShadowGlobalMaskBlendTypeR}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _LightDataDetailShadowGlobalMaskBlendTypeR ("Blending", Range(0, 1)) = 2
		[sRGBWarning]_LightingShadowMasks ("Shadow Masks (expand)--{reference_properties:[_LightingShadowMasksPan, _LightingShadowMasksUV,_LightingShadowMaskStrengthR,_LightingShadowMaskStrengthG,_LightingShadowMaskStrengthB,_LightingShadowMaskStrengthA, _LightDataShadowMaskGlobalMaskR]}", 2D) = "white" { }
		[HideInInspector][Vector2]_LightingShadowMasksPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _LightingShadowMasksUV ("UV", Int) = 0
		[HideInInspector]_LightingShadowMaskStrengthR ("R Strength", Range(0, 1)) = 1
		[HideInInspector]_LightingShadowMaskStrengthG ("G Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingShadowMaskStrengthB ("B Strength", Range(0, 1)) = 0
		[HideInInspector]_LightingShadowMaskStrengthA ("A Strength", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _LightDataShadowMaskGlobalMaskR ("Global Mask--{reference_property:_LightDataShadowMaskGlobalMaskBlendTypeR}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _LightDataShadowMaskGlobalMaskBlendTypeR ("Blending", Range(0, 1)) = 2
		// Base Pass
		[Space(15)]
		[ThryHeaderLabel(Base Pass Lighting, 13)]
		[Space(4)]
		[Enum(Poi Custom, 0, Standard, 1, UTS2, 2, OpenLit(lil toon), 3)] _LightingColorMode ("Light Color Mode", Int) = 0
		[Enum(Poi Custom, 0, Normalized NDotL, 1, Saturated NDotL, 2)] _LightingMapMode ("Light Map Mode", Int) = 0
		[Enum(Poi Custom, 0, Forced Local Direction, 1, Forced World Direction, 2, UTS2, 3, OpenLit(lil toon), 4)] _LightingDirectionMode ("Light Direction Mode", Int) = 0
		[Vector3]_LightngForcedDirection ("Forced Direction--{condition_showS:(_LightingDirectionMode==1 || _LightingDirectionMode==2)}", Vector) = (0, 0, 0)
		[ToggleUI]_LightingForceColorEnabled ("Force Light Color", Float) = 0
		_LightingForcedColor ("Forced Color--{condition_showS:(_LightingForceColorEnabled==1), reference_property:_LightingForcedColorThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _LightingForcedColorThemeIndex ("", Int) = 0
		_Unlit_Intensity ("Unlit_Intensity--{condition_showS:(_LightingColorMode==2)}", Range(0.001, 4)) = 1
		[ToggleUI]_LightingCapEnabled ("Limit Brightness", Float) = 1
		_LightingCap ("Max Brightness--{condition_showS:(_LightingCapEnabled==1)}", Range(0, 10)) = 1
		_LightingMinLightBrightness ("Min Brightness", Range(0, 1)) = 0
		_LightingIndirectUsesNormals ("Indirect Uses Normals--{condition_showS:(_LightingColorMode==0)}", Range(0, 1)) = 0
		_LightingCastedShadows ("Receive Casted Shadows", Range(0, 1)) = 0
		_LightingMonochromatic ("Grayscale Lighting", Range(0, 1)) = 0
		// Lighting Additive
		[Space(15)]
		[ThryHeaderLabel(Add Pass Lighting(Realtime), 13)]
		[Space(4)]
		[ToggleUI]_LightingVertexLightingEnabled ("Vertex lights (Non-Important)", Float) = 1
		[ToggleUI]_LightingAdditiveEnable ("Pixel lights (Important)", Float) = 1
		[ToggleUI]_DisableDirectionalInAdd ("Ignore Directional--{condition_showS:(_LightingAdditiveEnable==1)}", Float) = 1
		[ToggleUI]_LightingAdditiveLimited ("Limit Brightness", Float) = 0
		_LightingAdditiveLimit ("Max Brightness--{condition_showS:(_LightingAdditiveLimited==1)}", Range(0, 10)) = 1
		_LightingAdditiveCastedShadows ("Receive Casted Shadows", Range(0, 1)) = 1
		_LightingAdditiveMonochromatic ("Grayscale Lighting", Range(0, 1)) = 0
		_LightingAdditivePassthrough ("Point Light Passthrough--{condition_showS:(_LightingAdditiveEnable==1)}", Range(0, 1)) = .5
		// Lighting Data Debug
		[Space(15)]
		[ThryHeaderLabel(Debug Visualization, 13)]
		[Space(4)]
		[NoAnimate][ThryToggleUI(false)]_LightDataDebugEnabled ("Debug", Float) = 0
		[ThryWideEnum(Direct Color, 0, Indirect Color, 1, Light Map, 2, Attenuation, 3, N Dot L, 4, Half Dir, 5, Direction, 6, Add Color, 7, Add Attenuation, 8, Add Shadow, 9, Add N Dot L, 10)] _LightingDebugVisualize ("Visualize--{condition_showS:(_LightDataDebugEnabled==1)}", Int) = 0
		
		[HideInInspector] m_end_PoiLightData ("Light Data", Float) = 0
		
		[HideInInspector] m_start_bakedLighting ("Baked Lighting", Float) = 0
		//_SpecularLMOcclusion ("Specular Occlusion", Range(0, 1)) = 0
		//_SpecLMOcclusionAdjust ("Spec Occlusion Sensitiviy", Range(0, 1)) = 0.2
		_GIEmissionMultiplier ("GI Emission Multiplier", Float) = 1
		[HideInInspector] DSGI ("DSGI", Float) = 0 //add this property for double sided illumination settings to be shown
		[HideInInspector] LightmapFlags ("Lightmap Flags", Float) = 0 //add this property for lightmap flags settings to be shown
		[HideInInspector] m_end_bakedLighting ("Baked Lighting", Float) = 0
		
		//ifex _ShadingEnabled==0
		[HideInInspector] m_start_PoiShading (" Shading--{reference_property:_ShadingEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/main},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(VIGNETTE_MASKED)]_ShadingEnabled ("Enable Shading", Float) = 1
		[ThryHeaderLabel(Base Pass Shading, 13)]
		[Space(4)]
		[KeywordEnum(TextureRamp, Multilayer Math, Wrapped, Skin, ShadeMap, Flat, Realistic, Cloth, SDF)] _LightingMode ("Lighting Type", Float) = 5
		
		_LightingShadowColor ("Shadow Tint--{condition_showS:(_LightingMode!=4 && _LightingMode!=1 && _LightingMode!=5)}", Color) = (1, 1, 1)
		
		//ifex _LightingMode!=0
		// Texture Ramp
		[sRGBWarning(true)][Gradient]_ToonRamp ("Lighting Ramp--{texture:{width:512,height:4,filterMode:Bilinear,wrapMode:Clamp},force_texture_options:true,condition_showS:(_LightingMode==0)}", 2D) = "white" { }
		_ShadowOffset ("Ramp Offset--{condition_showS:(_LightingMode==0)}", Range(-1, 1)) = 0
		//endex
		
		//ifex _LightingMode!=1
		// Multilayer Math
		[ToggleUI]_LightingMulitlayerNonLinear ("Non Linear Edge--{condition_showS:(_LightingMode==1)}", Float) = 1
		
		[sRGBWarning]_MultilayerMathBlurMap ("Blur Map--{reference_properties:[_MultilayerMathBlurMapPan, _MultilayerMathBlurMapUV], condition_showS:(_LightingMode==1)}", 2D) = "white" { }
		
		[HideInInspector] g_start_MultilayerMath1stLayer ("Layer 1--{draw_border:true, condition_showS:(_LightingMode==1)}", Float) = 0
		[sRGBWarning(true)]_ShadowColorTex ("Color Tex--{reference_properties:[_ShadowColorTexPan, _ShadowColorTexUV], condition_showS:(_LightingMode==1)}", 2D) = "black" { }
		[HideInInspector][Vector2]_ShadowColorTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _ShadowColorTexUV ("UV", Int) = 0
		_ShadowColor ("Color--{condition_showS:(_LightingMode==1)}", Color) = (0.7, 0.75, 0.85, 1.0)
		[HideInInspector][Vector2]_MultilayerMathBlurMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _MultilayerMathBlurMapUV ("UV", Int) = 0
		_ShadowBorder ("Border--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0.5
		_ShadowBlur ("Blur--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0.1
		_ShadowReceive ("Receive Shadow--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0
		[HideInInspector] g_end_MultilayerMath1stLayer ("Layer 1--{draw_border:true}", Float) = 0
		
		[HideInInspector] g_start_MultilayerMath2ndLayer ("Layer 2--{draw_border:true, condition_showS:(_LightingMode==1)}", Float) = 0
		[sRGBWarning(true)]_Shadow2ndColorTex ("Color Tex--{reference_properties:[_Shadow2ndColorTexPan, _Shadow2ndColorTexUV], condition_showS:(_LightingMode==1)}", 2D) = "black" { }
		[HideInInspector][Vector2]_Shadow2ndColorTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Shadow2ndColorTexUV ("UV", Int) = 0
		_Shadow2ndColor ("Color--{condition_showS:(_LightingMode==1)}", Color) = (0, 0, 0, 0)
		_Shadow2ndBorder ("Border--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0.5
		_Shadow2ndBlur ("Blur--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0.3
		_Shadow2ndReceive ("Receive Shadow--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0
		[HideInInspector] g_end_MultilayerMath2ndLayer ("Layer 2--{draw_border:true}", Float) = 0
		
		[HideInInspector] g_start_MultilayerMath3rdLayer ("Layer 3--{draw_border:true, condition_showS:(_LightingMode==1)}", Float) = 0
		[sRGBWarning(true)]_Shadow3rdColorTex ("Color Tex--{reference_properties:[_Shadow3rdColorTexPan, _Shadow3rdColorTexUV], condition_showS:(_LightingMode==1)}", 2D) = "black" { }
		[HideInInspector][Vector2]_Shadow3rdColorTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Shadow3rdColorTexUV ("UV", Int) = 0
		_Shadow3rdColor ("Color--{condition_showS:(_LightingMode==1)}", Color) = (0, 0, 0, 0)
		_Shadow3rdBorder ("Border--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0.25
		_Shadow3rdBlur ("Blur--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0.1
		_Shadow3rdReceive ("Receive Shadow--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0
		[HideInInspector] g_end_MultilayerMath3rdLayer ("Layer 3--{draw_border:true}", Float) = 0
		
		[HideInInspector] g_start_MultilayerMathBorder ("Border--{draw_border:true, condition_showS:(_LightingMode==1)}", Float) = 0
		_ShadowBorderColor ("Color--{condition_showS:(_LightingMode==1)}", Color) = (1, 0, 0, 1)
		_ShadowBorderRange ("Border Range--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0
		[HideInInspector] g_end_MultilayerMath1stBorder ("Border--{draw_border:true}", Float) = 0
		
		_ShadowMainStrength ("Contrast--{condition_showS:(_LightingMode==1)}", Range(0, 1)) = 0
		//endex
		
		//ifex _LightingMode!=2
		// Wrapped
		_LightingWrappedWrap ("Wrap--{condition_showS:(_LightingMode==2)}", Range(0, 2)) = 0
		_LightingWrappedNormalization ("Normalization--{condition_showS:(_LightingMode==2)}", Range(0, 1)) = 0
		_LightingGradientStart ("Gradient Start--{condition_showS:(_LightingMode==2)}", Range(0, 1)) = 0
		_LightingGradientEnd ("Gradient End--{condition_showS:(_LightingMode==2)}", Range(0, 1)) = .5
		//endex
		
		// Shade Maps
		//ifex _LightingMode!=4
		_1st_ShadeColor ("1st ShadeColor--{condition_showS:(_LightingMode==4)}", Color) = (1, 1, 1)
		[sRGBWarning(true)]_1st_ShadeMap ("1st ShadeMap--{reference_properties:[_1st_ShadeMapPan, _1st_ShadeMapUV, _Use_1stShadeMapAlpha_As_ShadowMask, _1stShadeMapMask_Inverse],condition_showS:(_LightingMode==4)}", 2D) = "white" { }
		[HideInInspector][Vector2]_1st_ShadeMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _1st_ShadeMapUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_Use_1stShadeMapAlpha_As_ShadowMask ("1st ShadeMap.a As ShadowMask", Float) = 0
		[HideInInspector][ToggleUI]_1stShadeMapMask_Inverse ("1st ShadeMapMask Inverse", Float) = 0
		[ToggleUI] _Use_BaseAs1st ("Use BaseMap as 1st ShadeMap--{condition_showS:(_LightingMode==4)}", Float) = 0
		_2nd_ShadeColor ("2nd ShadeColor--{condition_showS:(_LightingMode==4)}", Color) = (1, 1, 1, 1)
		[sRGBWarning(true)]_2nd_ShadeMap ("2nd ShadeMap--{reference_properties:[_2nd_ShadeMapPan, _2nd_ShadeMapUV, _Use_2ndShadeMapAlpha_As_ShadowMask, _2ndShadeMapMask_Inverse],condition_showS:(_LightingMode==4)}", 2D) = "white" { }
		[HideInInspector][Vector2]_2nd_ShadeMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _2nd_ShadeMapUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_Use_2ndShadeMapAlpha_As_ShadowMask ("2nd ShadeMap.a As ShadowMask", Float) = 0
		[HideInInspector][ToggleUI]_2ndShadeMapMask_Inverse ("2nd ShadeMapMask Inverse", Float) = 0
		[ToggleUI] _Use_1stAs2nd ("Use 1st ShadeMap as 2nd_ShadeMap--{condition_showS:(_LightingMode==4)}", Float) = 0
		_BaseColor_Step ("BaseColor_Step--{condition_showS:(_LightingMode==4)}", Range(0.01, 1)) = 0.5
		_BaseShade_Feather ("Base/Shade_Feather--{condition_showS:(_LightingMode==4)}", Range(0.0001, 1)) = 0.0001
		_ShadeColor_Step ("ShadeColor_Step--{condition_showS:(_LightingMode==4)}", Range(0, 1)) = 0
		_1st2nd_Shades_Feather ("1st/2nd_Shades_Feather--{condition_showS:(_LightingMode==4)}", Range(0.0001, 1)) = 0.0001
		[Enum(Replace, 0, Multiply, 1)]_ShadingShadeMapBlendType ("Blend Mode--{condition_showS:(_LightingMode==4)}", Int) = 0
		//endex
		
		// Skin Shading
		//ifex _LightingMode!=3
		[sRGBWarning]_SkinLUT ("LUT--{condition_showS:(_LightingMode==3)}", 2D) = "white" { }
		_SssScale ("Scale--{condition_showS:(_LightingMode==3)}", Range(0, 1)) = 1
		_SkinThicknessMap ("Thickness Map--{reference_properties:[_SkinThicknessMapPan, _SkinThicknessMapUV, _SkinThicknessMapInvert],condition_showS:(_LightingMode==3)}", 2D) = "black" { }
		[HideInInspector][Vector2]_SkinThicknessMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _SkinThicknessMapUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_SkinThicknessMapInvert ("Invert", Float) = 0
		_SkinThicknessPower ("Thickness Power--{condition_showS:(_LightingMode==3)}", Range(0, 3)) = 1
		_SssBumpBlur ("Bump Blur--{condition_showS:(_LightingMode==3)}", Range(0, 1)) = 0.7
		[HideInInspector][Vector3]_SssTransmissionAbsorption ("Absorption--{condition_showS:(_LightingMode==3)}", Vector) = (-8, -40, -64, 0)
		[HideInInspector][Vector3]_SssColorBleedAoWeights ("AO Color Bleed--{condition_showS:(_LightingMode==3)}", Vector) = (0.4, 0.15, 0.13, 0)
		//endex
		
		//ifex _LightingMode!=7
		// Cloth
		[NonModifiableTextureData] [NoScaleOffset] _ClothDFG ("MultiScatter Cloth DFG--{condition_showS:(_LightingMode==7)}", 2D) = "black" { }
		[sRGBWarning][ThryRGBAPacker(Metallic Map, Cloth Mask, Reflectance, Smoothness)]_ClothMetallicSmoothnessMap ("Maps (Expand)--{reference_properties:[_ClothMetallicSmoothnessMapPan, _ClothMetallicSmoothnessMapUV, _ClothMetallicSmoothnessMapInvert],condition_showS:(_LightingMode==7)}", 2D) = "white" { }
		[HideInInspector][Vector2] _ClothMetallicSmoothnessMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ToggleUI] _ClothMetallicSmoothnessMapInvert ("Invert Smoothness", Float) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _ClothMetallicSmoothnessMapUV ("UV", Int) = 0
		[NoAnimate][ThryToggleUI(false)] _ClothLerp ("Clothmask Lerp--{condition_showS:(_LightingMode==7)}", Float) = 0
		//[Gamma] _ClothMetallic ("Metallic--{condition_showS:(_LightingMode==7)}", Range(0, 1)) = 0
		_ClothReflectance ("Reflectance--{condition_showS:(_LightingMode==7)}", Range(0.35, 1)) = 0.5
		_ClothSmoothness ("Smoothness--{condition_showS:(_LightingMode==7)}", Range(0, 1)) = 0.5
		//endex
		
		//ifex _LightingMode!=8
		// SDF
		[sRGBWarning]_SDFShadingTexture ("SDF--{reference_properties:[_SDFShadingTexturePan, _SDFShadingTextureUV],condition_showS:(_LightingMode==8)}", 2D) = "white" { }
		[HideInInspector][Vector2]_SDFShadingTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _SDFShadingTextureUV ("UV", Int) = 0
		_SDFBlur ("Blur--{condition_showS:(_LightingMode==8)}", Range(0, 1)) = 0.1
		[Vector3]_SDFForward ("Forward Direction--{condition_showS:(_LightingMode==8)}", Vector) = (0, 0, 1, 0)
		[Vector3]_SDFLeft ("Left Direction--{condition_showS:(_LightingMode==8)}", Vector) = (-1, 0, 0, 0)
		//endex
		
		// Generic
		_ShadowStrength ("Shadow Strength--{condition_showS:(_LightingMode<=4 || _LightingMode==8)}", Range(0, 1)) = 1
		_LightingIgnoreAmbientColor ("Ignore Indirect Shadow Color--{condition_showS:(_LightingMode<=3 || _LightingMode==8)}", Range(0, 1)) = 1
		
		// Additive
		[Space(15)]
		[ThryHeaderLabel(Add Pass Shading, 13)]
		[Space(4)]
		[Enum(Realistic, 0, Toon, 1, Same as Base Pass, 3)] _LightingAdditiveType ("Lighting Type", Int) = 1
		_LightingAdditiveGradientStart ("Gradient Start--{condition_showS:(_LightingAdditiveType==1)}", Range(0, 1)) = 0
		_LightingAdditiveGradientEnd ("Gradient End--{condition_showS:(_LightingAdditiveType==1)}", Range(0, 1)) = .5
		//_LightingAdditiveDetailStrength ("Detail Shadow Strength", Range(0, 1)) = 1 //TODO-implement this
		
		[HideInInspector] m_end_PoiShading ("Shading", Float) = 0
		//endex
		
		//ifex _EnableAniso==0
		
		[HideInInspector] m_start_Aniso (" Anisotropics--{reference_property:_EnableAniso}", Float) = 0
		[HideInInspector][ThryToggle(POI_ANISOTROPICS)]_EnableAniso ("Enable Aniso", Float) = 0
		[sRGBWarning(true)][ThryRGBAPacker(1, RGB Color, A Offset, 1)]_AnisoColorMap ("Color & Offset--{reference_properties:[_AnisoColorMapPan, _AnisoColorMapUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_AnisoColorMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _AnisoColorMapUV ("UV", Int) = 0
		/*
		[sRGBWarning]_AnisoNoiseMap ("Noise Map--{reference_properties:[_AnisoNoiseMapPan, _AnisoNoiseMapUV]}", 2D) = "black" { }
		[HideInInspector][Vector2]_AnisoNoiseMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _AnisoNoiseMapUV ("UV", Int) = 0
		*/
		_AnisoUseLightColor ("Mix Light Color", Range(0, 1)) = 1
		_AnisoUseBaseColor ("Mix Base Color", Range(0, 1)) = 0
		_AnisoReplace ("Replace Blending", Range(0, 1)) = 0
		_AnisoAdd ("Add Blending", Range(0, 1)) = 1
		_AnisoHideInShadow ("Hide In Shadow", Range(0, 1)) = 1
		
		[Space(10)]
		[ThryHeaderLabel(Top Layer, 13)]
		_Aniso0Power ("Power", Range(0, 1)) = 0
		_Aniso0Strength ("Strength", Range(0, 1)) = 1
		_Aniso0Offset ("Offset", Range(-10, 10)) = 0
		_Aniso0OffsetMapStrength ("Map Offset Strength", Range(0, 1)) = 0
		_Aniso0Tint ("Tint--{reference_property:_Aniso0TintIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Aniso0TintIndex ("", Int) = 0
		[ToggleUI]_Aniso0SwitchDirection ("Switch Direction", Int) = 0
		[ThryToggleUI(true)] _Aniso0ToonMode ("Toon Mode", Float) = 0
		_Aniso0Edge ("Edge--{condition_showS:(_Aniso0ToonMode==1)}", Range(0, 1)) = .5
		_Aniso0Blur ("Blur--{condition_showS:(_Aniso0ToonMode==1)}", Range(0, 1)) = 0
		
		[Space(10)]
		[ThryHeaderLabel(Bottom Layer, 13)]
		_Aniso1Power ("Power", Range(0, 1)) = .1
		_Aniso1Strength ("Strength", Range(0, 1)) = 1
		_Aniso1Offset ("Offset", Range(-1, 1)) = 0
		_Aniso1OffsetMapStrength ("Map Offset Strength", Range(0, 1)) = 0
		_Aniso1Tint ("Tint--{reference_property:_Aniso1TintIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Aniso1TintIndex ("", Int) = 0
		[ToggleUI]_Aniso1SwitchDirection ("Switch Direction", Int) = 0
		[ThryToggleUI(true)] _Aniso1ToonMode ("Toon Mode", Float) = 0
		_Aniso1Edge ("Edge--{condition_showS:(_Aniso1ToonMode==1)}", Range(0, 1)) = .5
		_Aniso1Blur ("Blur--{condition_showS:(_Aniso1ToonMode==1)}", Range(0, 1)) = 0
		
		[Space(4)]
		[NoAnimate][ThryToggleUI(true)]_AnisoDebugToggle ("Debug", Float) = 0
		[ThryWideEnum(Off, 0, Overall Specular, 1, Specular 0, 2, Specular 1, 3)] _AnisoDebugMode ("Visualize--{condition_showS:(_AnisoDebugToggle==1)}", Int) = 0
		
		[HideInInspector] m_end_Ansio ("Anisotropics", Float) = 0
		//endex
		
		// First Matcap
		//ifex _MatcapEnable==0
		[HideInInspector] m_start_matcap ("Matcap 0--{reference_property:_MatcapEnable,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/matcap},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_MATCAP0)]_MatcapEnable ("Enable Matcap", Float) = 0
		[ThryWideEnum(UTS Style, 0, Top Pinch, 1, Double Sided, 2)] _MatcapUVMode ("UV Mode", Int) = 1
		_MatcapColor ("Color--{reference_property:_MatcapColorThemeIndex}", Color) = (1, 1, 1, 1)
		_MatcapBaseColorMix ("Base Color Mix", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _MatcapColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_Matcap ("Matcap--{reference_properties:[_MatcapUVToBlend, _MatCapBlendUV1]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _MatcapUVToBlend ("UV To Blend", Int) = 1
		[HideInInspector][VectorToSliders(Blend UV X, 0.0, 1.0, Blend UV Y, 0.0, 1.0)]_MatCapBlendUV1 ("UV Blend", Vector) = (0, 0, 0, 0)
		_MatcapBorder ("Border", Range(0, 5)) = 0.43
		_MatcapRotation ("Rotation", Range(-1, 1)) = 0
		[sRGBWarning][ThryRGBAPacker(R Mask, G Nothing, B Nothing, A Smoothness)]_MatcapMask ("Mask--{reference_properties:[_MatcapMaskPan, _MatcapMaskUV, _MatcapMaskChannel, _MatcapMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_MatcapMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _MatcapMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_MatcapMaskChannel ("Channel", Float) = 0
		[HideInInspector][ToggleUI]_MatcapMaskInvert ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MatcapMaskGlobalMask ("Global Mask--{reference_property:_MatcapMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_MatcapMaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_MatcapEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		_MatcapIntensity ("Intensity", Range(0, 5)) = 1
		_MatcapLightMask ("Hide in Shadow", Range(0, 1)) = 0
		_MatcapReplace ("Replace Blend", Range(0, 1)) = 1
		_MatcapMultiply ("Multiply Blend", Range(0, 1)) = 0
		_MatcapAdd ("Add Blend", Range(0, 1)) = 0
		_MatcapMixed ("Mixed Blend", Range(0, 1)) = 0
		_MatcapScreen ("Screen Blend", Range(0, 1)) = 0
		_MatcapAddToLight ("Add To Light", Range(0, 1)) = 0
		_MatcapAlphaOverride ("Override Alpha", Range(0, 1)) = 0
		[Enum(Vertex, 0, Pixel, 1)] _MatcapNormal ("Normal to use", Int) = 1
		[ThryToggle(POI_MATCAP0_CUSTOM_NORMAL, true)] _Matcap0CustomNormal ("<size=13><b>  Custom Normal</b></size>", Float) = 0
		[Normal]_Matcap0NormalMap ("Normal Map--{reference_properties:[_Matcap0NormalMapPan, _Matcap0NormalMapUV, _Matcap0NormalMapScale], condition_showS:(_Matcap0CustomNormal==1)}", 2D) = "bump" { }
		[HideInInspector][Vector2]_Matcap0NormalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap0NormalMapUV ("UV", Int) = 0
		[HideInInspector]_Matcap0NormalMapScale ("Intensity", Range(0, 10)) = 1
		[ThryToggleUI(true)] _MatcapHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_MatcapHueShiftSpeed ("Shift Speed--{condition_showS:(_MatcapHueShiftEnabled==1)}", Float) = 0
		_MatcapHueShift ("Hue Shift--{condition_showS:(_MatcapHueShiftEnabled==1)}", Range(0, 1)) = 0
		[ThryToggleUI(true)] _MatcapSmoothnessEnabled ("<size=13><b>  Blur</b></size>", Float) = 0
		_MatcapSmoothness ("Smoothness--{condition_showS:(_MatcapSmoothnessEnabled==1)}", Range(0, 1)) = 1
		[ToggleUI]_MatcapMaskSmoothnessApply ("Apply Mask for Smoothness--{condition_showS:(_MatcapSmoothnessEnabled==1)}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)]_MatcapMaskSmoothnessChannel ("Mask Channel for Smoothness--{condition_showS:(_MatcapSmoothnessEnabled==1)}", Int) = 3
		[HideInInspector] g_start_MatcapTPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _MatcapTPSDepthEnabled ("<size=13><b>  TPS Depth Mask Enabled</b></size>", Float) = 0
		_MatcapTPSMaskStrength ("TPS Mask Strength--{condition_showS:(_MatcapTPSDepthEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_MatcapTPSMaskGroup ("", Float) = 0
		[HideInInspector] m_end_matcap ("Matcap--{condition_showS:(_MatcapHueShiftEnabled==1)}", Float) = 0
		//endex
		
		// Second Matcap
		//ifex _Matcap2Enable==0
		[HideInInspector] m_start_Matcap2 ("Matcap 1--{reference_property:_Matcap2Enable,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/matcap},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(COLOR_GRADING_HDR_3D)]_Matcap2Enable ("Enable Matcap 2", Float) = 0
		[ThryWideEnum(UTS Style, 0, Top Pinch, 1, Double Sided, 2)] _Matcap2UVMode ("UV Mode", Int) = 1
		_Matcap2Color ("Color--{reference_property:_Matcap2ColorThemeIndex}", Color) = (1, 1, 1, 1)
		_Matcap2BaseColorMix ("Base Color Mix", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Matcap2ColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_Matcap2 ("Matcap--{reference_properties:[_Matcap2UVToBlend,_MatCap2ndBlendUV1]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap2UVToBlend ("UV To Blend", Int) = 1
		[HideInInspector][VectorToSliders(Blend UV X, 0.0, 1.0, Blend UV Y, 0.0, 1.0)]_MatCap2ndBlendUV1 ("UV Blend", Vector) = (0, 0, 0, 0)
		_Matcap2Border ("Border", Range(0, 5)) = 0.43
		_Matcap2Rotation ("Rotation", Range(-1, 1)) = 0
		[sRGBWarning][ThryRGBAPacker(R Mask, G Nothing, B Nothing, A Smoothness)]_Matcap2Mask ("Mask--{reference_properties:[_Matcap2MaskPan, _Matcap2MaskUV, _Matcap2MaskChannel, _Matcap2MaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_Matcap2MaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap2MaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Matcap2MaskChannel ("Channel", Float) = 0
		[HideInInspector][ToggleUI]_Matcap2MaskInvert ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Matcap2MaskGlobalMask ("Global Mask--{reference_property:_Matcap2MaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Matcap2MaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_Matcap2EmissionStrength ("Emission Strength", Range(0, 20)) = 0
		_Matcap2Intensity ("Intensity", Range(0, 5)) = 1
		_Matcap2LightMask ("Hide in Shadow", Range(0, 1)) = 0
		_Matcap2Replace ("Replace Blend", Range(0, 1)) = 0
		_Matcap2Multiply ("Multiply Blend", Range(0, 1)) = 0
		_Matcap2Add ("Add Blend", Range(0, 1)) = 0
		_Matcap2Mixed ("Mixed Blend", Range(0, 1)) = 0
		_Matcap2Screen ("Screen Blend", Range(0, 1)) = 0
		_Matcap2AddToLight ("Add To Light", Range(0, 1)) = 0
		_Matcap2AlphaOverride ("Override Alpha", Range(0, 1)) = 0
		[Enum(Vertex, 0, Pixel, 1)] _Matcap2Normal ("Normal to use", Int) = 1
		[ThryToggle(POI_MATCAP1_CUSTOM_NORMAL, true)] _Matcap1CustomNormal ("<size=13><b>  Custom Normal</b></size>", Float) = 0
		[Normal]_Matcap1NormalMap ("Normal Map--{reference_properties:[_Matcap1NormalMapPan, _Matcap1NormalMapUV, _Matcap1NormalMapScale], condition_showS:(_Matcap1CustomNormal==1)}", 2D) = "bump" { }
		[HideInInspector][Vector2]_Matcap1NormalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap1NormalMapUV ("UV", Int) = 0
		[HideInInspector]_Matcap1NormalMapScale ("Intensity", Range(0, 10)) = 1
		[ThryToggleUI(true)] _Matcap2HueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_Matcap2HueShiftSpeed ("Shift Speed--{condition_showS:(_Matcap2HueShiftEnabled==1)}", Float) = 0
		_Matcap2HueShift ("Hue Shift--{condition_showS:(_Matcap2HueShiftEnabled==1)}", Range(0, 1)) = 0
		[ThryToggleUI(true)] _Matcap2SmoothnessEnabled ("<size=13><b>  Blur</b></size>", Float) = 0
		_Matcap2Smoothness ("Smoothness--{condition_showS:(_Matcap2SmoothnessEnabled==1)}", Range(0, 1)) = 1
		[ToggleUI]_Matcap2MaskSmoothnessApply ("Apply Mask for Smoothness--{condition_showS:(_Matcap2SmoothnessEnabled==1)}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)]_Matcap2MaskSmoothnessChannel ("Mask Channel for Smoothness--{condition_showS:(_Matcap2SmoothnessEnabled==1)}", Int) = 3
		[HideInInspector] g_start_Matcap2TPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _Matcap2TPSDepthEnabled ("<size=13><b>  TPS Depth Mask Enabled</b></size>", Float) = 0
		_Matcap2TPSMaskStrength ("TPS Mask Strength--{condition_showS:(_Matcap2TPSDepthEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_Matcap2TPSMaskGroup ("", Float) = 0
		[HideInInspector] m_end_Matcap2 ("Matcap 1--{condition_showS:(_Matcap2HueShiftEnabled==1)}", Float) = 0
		//endex
		
		// Third Matcap
		//ifex _Matcap3Enable==0
		[HideInInspector] m_start_Matcap3 ("Matcap 2--{reference_property:_Matcap3Enable,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/matcap},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_MATCAP2)]_Matcap3Enable ("Enable Matcap 2", Float) = 0
		[ThryWideEnum(UTS Style, 0, Top Pinch, 1, Double Sided, 2)] _Matcap3UVMode ("UV Mode", Int) = 1
		_Matcap3Color ("Color--{reference_property:_Matcap3ColorThemeIndex}", Color) = (1, 1, 1, 1)
		_Matcap3BaseColorMix ("Base Color Mix", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Matcap3ColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_Matcap3 ("Matcap--{reference_properties:[_Matcap3UVToBlend, _MatCap3rdBlendUV1]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap3UVToBlend ("UV To Blend", Int) = 1
		[HideInInspector][VectorToSliders(Blend UV X, 0.0, 1.0, Blend UV Y, 0.0, 1.0)]_MatCap3rdBlendUV1 ("UV Blend", Vector) = (0, 0, 0, 0)
		_Matcap3Border ("Border", Range(0, 5)) = 0.43
		_Matcap3Rotation ("Rotation", Range(-1, 1)) = 0
		[sRGBWarning][ThryRGBAPacker(R Mask, G Nothing, B Nothing, A Smoothness)]_Matcap3Mask ("Mask--{reference_properties:[_Matcap3MaskPan, _Matcap3MaskUV, _Matcap3MaskChannel, _Matcap3MaskInvert]}", 2D) = "white" { }
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Matcap3MaskChannel ("Channel", Float) = 0
		[HideInInspector][Vector2]_Matcap3MaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap3MaskUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_Matcap3MaskInvert ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Matcap3MaskGlobalMask ("Global Mask--{reference_property:_Matcap3MaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Matcap3MaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_Matcap3EmissionStrength ("Emission Strength", Range(0, 20)) = 0
		_Matcap3Intensity ("Intensity", Range(0, 5)) = 1
		_Matcap3LightMask ("Hide in Shadow", Range(0, 1)) = 0
		_Matcap3Replace ("Replace Blend", Range(0, 1)) = 0
		_Matcap3Multiply ("Multiply Blend", Range(0, 1)) = 0
		_Matcap3Add ("Add Blend", Range(0, 1)) = 0
		_Matcap3Mixed ("Mixed Blend", Range(0, 1)) = 0
		_Matcap3Screen ("Screen Blend", Range(0, 1)) = 0
		_Matcap3AddToLight ("Add To Light", Range(0, 1)) = 0
		_Matcap3AlphaOverride ("Override Alpha", Range(0, 1)) = 0
		[Enum(Vertex, 0, Pixel, 1)] _Matcap3Normal ("Normal to use", Int) = 1
		[ThryToggle(POI_MATCAP2_CUSTOM_NORMAL, true)] _Matcap2CustomNormal ("<size=13><b>  Custom Normal</b></size>", Float) = 0
		[Normal]_Matcap2NormalMap ("Normal Map--{reference_properties:[_Matcap2NormalMapPan, _Matcap2NormalMapUV, _Matcap2NormalMapScale], condition_showS:(_Matcap2CustomNormal==1)}", 2D) = "bump" { }
		[HideInInspector][Vector2]_Matcap2NormalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap2NormalMapUV ("UV", Int) = 0
		[HideInInspector]_Matcap2NormalMapScale ("Intensity", Range(0, 10)) = 1
		[ThryToggleUI(true)] _Matcap3HueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_Matcap3HueShiftSpeed ("Shift Speed--{condition_showS:(_Matcap3HueShiftEnabled==1)}", Float) = 0
		_Matcap3HueShift ("Hue Shift--{condition_showS:(_Matcap3HueShiftEnabled==1)}", Range(0, 1)) = 0
		[ThryToggleUI(true)] _Matcap3SmoothnessEnabled ("<size=13><b>  Blur</b></size>", Float) = 0
		_Matcap3Smoothness ("Smoothness--{condition_showS:(_Matcap3SmoothnessEnabled==1)}", Range(0, 1)) = 1
		[ToggleUI]_Matcap3MaskSmoothnessApply ("Apply Mask for Smoothness--{condition_showS:(_Matcap3SmoothnessEnabled==1)}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)]_Matcap3MaskSmoothnessChannel ("Mask Channel for Smoothness--{condition_showS:(_Matcap3SmoothnessEnabled==1)}", Int) = 3
		[HideInInspector] g_start_Matcap3TPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _Matcap3TPSDepthEnabled ("<size=13><b>  TPS Depth Mask Enabled</b></size>", Float) = 0
		_Matcap3TPSMaskStrength ("TPS Mask Strength--{condition_showS:(_Matcap3TPSDepthEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_Matcap3TPSMaskGroup ("", Float) = 0
		[HideInInspector] m_end_Matcap3 ("Matcap 2--{condition_showS:(_Matcap3HueShiftEnabled==1)}", Float) = 0
		//endex
		
		// Fourth Matcap
		//ifex _Matcap4Enable==0
		[HideInInspector] m_start_Matcap4 ("Matcap 3--{reference_property:_Matcap4Enable,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/matcap},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_MATCAP3)]_Matcap4Enable ("Enable Matcap 3", Float) = 0
		[ThryWideEnum(UTS Style, 0, Top Pinch, 1, Double Sided, 2)] _Matcap4UVMode ("UV Mode", Int) = 1
		_Matcap4Color ("Color--{reference_property:_Matcap4ColorThemeIndex}", Color) = (1, 1, 1, 1)
		_Matcap4BaseColorMix ("Base Color Mix", Range(0, 1)) = 0
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Matcap4ColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_Matcap4 ("Matcap--{reference_properties:[_Matcap4UVToBlend,_MatCap4thBlendUV1]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap4UVToBlend ("UV To Blend", Int) = 1
		[HideInInspector][VectorToSliders(Blend UV X, 0.0, 1.0, Blend UV Y, 0.0, 1.0)]_MatCap4thBlendUV1 ("UV Blend", Vector) = (0, 0, 0, 0)
		_Matcap4Border ("Border", Range(0, .5)) = 0.43
		_Matcap4Rotation ("Rotation", Range(-1, 1)) = 0
		[sRGBWarning][ThryRGBAPacker(R Mask, G Nothing, B Nothing, A Smoothness)]_Matcap4Mask ("Mask--{reference_properties:[_Matcap4MaskPan, _Matcap4MaskUV, _Matcap4MaskChannel, _Matcap4MaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_Matcap4MaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap4MaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Matcap4MaskChannel ("Channel", Float) = 0
		[HideInInspector][ToggleUI]_Matcap4MaskInvert ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Matcap4MaskGlobalMask ("Global Mask--{reference_property:_Matcap4MaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_Matcap4MaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_Matcap4EmissionStrength ("Emission Strength", Range(0, 20)) = 0
		_Matcap4Intensity ("Intensity", Range(0, 5)) = 1
		_Matcap4LightMask ("Hide in Shadow", Range(0, 1)) = 0
		_Matcap4Replace ("Replace Blend", Range(0, 1)) = 0
		_Matcap4Multiply ("Multiply Blend", Range(0, 1)) = 0
		_Matcap4Add ("Add Blend", Range(0, 1)) = 0
		_Matcap4Mixed ("Mixed Blend", Range(0, 1)) = 0
		_Matcap4Screen ("Screen Blend", Range(0, 1)) = 0
		_Matcap4AddToLight ("Add To Light", Range(0, 1)) = 0
		_Matcap4AlphaOverride ("Override Alpha", Range(0, 1)) = 0
		[Enum(Vertex, 0, Pixel, 1)] _Matcap4Normal ("Normal to use", Int) = 1
		[ThryToggle(POI_MATCAP3_CUSTOM_NORMAL, true)] _Matcap3CustomNormal ("<size=13><b>  Custom Normal</b></size>", Float) = 0
		[Normal]_Matcap3NormalMap ("Normal Map--{reference_properties:[_Matcap3NormalMapPan, _Matcap3NormalMapUV, _Matcap3NormalMapScale], condition_showS:(_Matcap3CustomNormal==1)}", 2D) = "bump" { }
		[HideInInspector][Vector2]_Matcap3NormalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Matcap3NormalMapUV ("UV", Int) = 0
		[HideInInspector]_Matcap3NormalMapScale ("Intensity", Range(0, 10)) = 1
		[ThryToggleUI(true)] _Matcap4HueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_Matcap4HueShiftSpeed ("Shift Speed--{condition_showS:(_Matcap4HueShiftEnabled==1)}", Float) = 0
		_Matcap4HueShift ("Hue Shift--{condition_showS:(_Matcap4HueShiftEnabled==1)}", Range(0, 1)) = 0
		[ThryToggleUI(true)] _Matcap4SmoothnessEnabled ("<size=13><b>  Blur</b></size>", Float) = 0
		_Matcap4Smoothness ("Smoothness--{condition_showS:(_Matcap4SmoothnessEnabled==1)}", Range(0, 1)) = 1
		[ToggleUI]_Matcap4MaskSmoothnessApply ("Apply Mask for Smoothness--{condition_showS:(_Matcap4SmoothnessEnabled==1)}", Float) = 0
		[Enum(R, 0, G, 1, B, 2, A, 3)]_Matcap4MaskSmoothnessChannel ("Mask Channel for Smoothness--{condition_showS:(_Matcap4SmoothnessEnabled==1)}", Int) = 3
		[HideInInspector] g_start_Matcap4TPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _Matcap4TPSDepthEnabled ("<size=13><b>  TPS Depth Mask Enabled</b></size>", Float) = 0
		_Matcap4TPSMaskStrength ("TPS Mask Strength--{condition_showS:(_Matcap4TPSDepthEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_Matcap4TPSMaskGroup ("", Float) = 0
		[HideInInspector] m_end_Matcap4 ("Matcap 3--{condition_showS:(_Matcap4HueShiftEnabled==1)}", Float) = 0
		//endex
		
		//ifex _CubeMapEnabled==0
		[HideInInspector] m_start_CubeMap ("CubeMap--{reference_property:_CubeMapEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/cubemap},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(_CUBEMAP)]_CubeMapEnabled ("Enable CubeMap", Float) = 0
		[ThryWideEnum(Skybox, 0, Reflection, 1, World Normal Direction, 2, Local Normal Direction, 3)] _CubeMapUVMode ("UV Mode", Int) = 1
		_CubeMapWorldNormalsStrength ("Normals Strength--{condition_showS:(_CubeMapUVMode==2)}", Range(0,1)) = 1
		_CubeMapColor ("Color--{reference_property:_CubeMapColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _CubeMapColorThemeIndex ("", Int) = 0
		[NoScaleOffset]_CubeMap ("CubeMap--{reference_properties:[_CubeMapRotation, _CubeMapRotationPan]}", Cube) = "" { }
		[HideInInspector][Vector3]_CubeMapRotation ("Rotation in Degrees", Vector) = (0, 0, 0, 0)
		[HideInInspector][Vector3]_CubeMapRotationPan ("Panning in Degrees", Vector) = (0, 0, 0, 0)
		[sRGBWarning]_CubeMapMask ("Mask--{reference_properties:[_CubeMapMaskPan, _CubeMapMaskUV, _CubeMapMaskChannel, _CubeMapMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_CubeMapMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _CubeMapMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_CubeMapMaskChannel ("Channel", Float) = 0
		[HideInInspector][ToggleUI]_CubeMapMaskInvert ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _CubeMapMaskGlobalMask ("Global Mask--{reference_property:_CubeMapMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_CubeMapMaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_CubeMapEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		_CubeMapIntensity ("Color Strength", Range(0, 5)) = 1
		_CubeMapLightMask ("Hide in Shadow", Range(0, 1)) = 0
		_CubeMapReplace ("Replace With CubeMap", Range(0, 1)) = 1
		_CubeMapMultiply ("Multiply CubeMap", Range(0, 1)) = 0
		_CubeMapAdd ("Add CubeMap", Range(0, 1)) = 0
		[Enum(Vertex, 0, Pixel, 1)] _CubeMapNormal ("Normal to use", Int) = 1
		
		[Space(10)]
		[ThryHeaderLabel(Hue Shift, 13)]
		[Space(4)]
		[ToggleUI]_CubeMapHueShiftEnabled ("Enabled", Float) = 0
		_CubeMapHueShiftSpeed ("Shift Speed--{condition_showS:(_CubeMapHueShiftEnabled==1)}", Float) = 0
		_CubeMapHueShift ("Hue Shift--{condition_showS:(_CubeMapHueShiftEnabled==1)}", Range(0, 1)) = 0
		[HideInInspector] m_end_CubeMap ("CubeMap", Float) = 0
		//endex
		
		//ifex _EnableRimLighting==0
		[HideInInspector] m_start_rimLight1Options ("Rim Lighting 1--{reference_property:_EnableRimLighting,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/rim-lighting},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(_GLOSSYREFLECTIONS_OFF)]_EnableRimLighting ("Enable Rim Lighting", Float) = 0
		[KeywordEnum(Poiyomi, UTS2, LilToon)] _RimStyle ("Style", Float) = 0
		[sRGBWarning(true)]_RimTex ("Rim Texture--{reference_properties:[_RimTexPan, _RimTexUV], condition_showS:_RimStyle==0}", 2D) = "white" { }
		[HideInInspector][Vector2]_RimTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _RimTexUV ("UV", Int) = 0
		
		[sRGBWarning][ThryRGBAPacker(1, Mask, Bias, 1)]_RimMask ("Mask & Bias--{reference_properties:[_RimMaskPan, _RimMaskUV, _RimMaskChannel, _RimMaskInvert, _RimBiasIntensity], condition_showS:_RimStyle==0}", 2D) = "white" { }
		[HideInInspector][Vector2]_RimMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _RimMaskUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_RimMaskInvert("Invert Mask", Float) = 0
		[HideInInspector]_RimBiasIntensity("Bias Intensity", Range(0,1)) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RimMaskChannel ("Channel", Float) = 0
		
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RimGlobalMask ("Global Mask--{reference_property:_RimGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _RimGlobalMaskBlendType ("Blending", Int) = 2
		
		_Is_NormalMapToRimLight ("Normal Strength", Range(0, 1)) = 1
		[ToggleUI]_RimLightingInvert ("Invert Rim Lighting--{ condition_showS:_RimStyle==0}", Float) = 0
		_RimLightColor ("Rim Color--{condition_showS:_RimStyle==0||_RimStyle==1,reference_property:_RimLightColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _RimLightColorThemeIndex ("", Int) = 0
		_RimWidth ("Rim Width--{ condition_showS:_RimStyle==0}", Range(0, 1)) = 0.8
		_RimSharpness ("Rim Sharpness--{ condition_showS:_RimStyle==0}", Range(0, 1)) = .25
		_RimPower ("Rim Power--{ condition_showS:_RimStyle==0}", Range(0, 10)) = 1
		_RimStrength ("Rim Emission--{ condition_showS:_RimStyle==0}", Range(0, 20)) = 0
		_RimBaseColorMix ("Mix Base Color--{ condition_showS:_RimStyle==0}", Range(0, 1)) = 0
		[ThryWideEnum(Add, 0, Replace, 1, Multiply, 2, Mixed, 3)] _RimBlendMode ("Blend Mode--{ condition_showS:_RimStyle==0}", Int) = 0
		_RimBrightness ("Brightness--{ condition_showS:_RimStyle==0}", Range(0, 10)) = 1
		_RimBlendStrength ("Blend Strength--{ condition_showS:_RimStyle==0}", Range(0, 1)) = 1
		[ThryToggle(false)] _RimClamp ("Clamp Intensity", Float) = 0
		
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _RimApplyGlobalMaskIndex ("Apply to Global Mask--{reference_property:_RimApplyGlobalMaskBlendType,condition_showS:_RimStyle==0}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _RimApplyGlobalMaskBlendType ("Blending", Int) = 2
		
		// UTS2
		[sRGBWarning]_Set_RimLightMask ("Set_RimLightMask--{reference_properties:[_Set_RimLightMaskPan, _Set_RimLightMaskUV, _Set_RimLightMaskChannel], condition_showS:_RimStyle==1}", 2D) = "white" { }
		[HideInInspector][Vector2]_Set_RimLightMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Set_RimLightMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Set_RimLightMaskChannel ("Channel", Float) = 1
		_Tweak_RimLightMaskLevel ("Tweak_RimLightMaskLevel--{ condition_showS:_RimStyle==1}", Range(-1, 1)) = 0
		_Is_LightColor_RimLight ("Mix Light Color--{ condition_showS:_RimStyle==1}", Range(0, 1)) = 1
		_RimLight_Power ("Rim Power--{ condition_showS:_RimStyle==1}", Range(0, 1)) = 0.1
		_RimLight_InsideMask ("Inside Mask--{ condition_showS:_RimStyle==1}", Range(0.0001, 1)) = 0.0001
		[Toggle(_)] _RimLight_FeatherOff ("Feather Off--{ condition_showS:_RimStyle==1}", Float) = 0
		[ThryToggleUI(true)] _LightDirection_MaskOn ("<size=13><b>  Light Direction Mask</b></size>--{ condition_showS:_RimStyle==1}", Float) = 0
		_Tweak_LightDirection_MaskLevel ("Light Dir Mask Level--{ condition_showS:_LightDirection_MaskOn==1&&_RimStyle==1}", Range(0, 0.5)) = 0
		[ThryToggleUI(true)] _Add_Antipodean_RimLight ("<size=13><b>  Antipodean(Ap) Rim</b></size>--{ condition_showS:_LightDirection_MaskOn==1&&_RimStyle==1}", Float) = 0
		_Is_LightColor_Ap_RimLight ("Ap Light Color Mix--{ condition_showS:_LightDirection_MaskOn==1&&_Add_Antipodean_RimLight==1&&_RimStyle==1}", Range(0, 1)) = 1
		_Ap_RimLightColor ("Ap Color--{reference_property:_RimApColorThemeIndex, condition_showS:_LightDirection_MaskOn==1&&_Add_Antipodean_RimLight==1&&_RimStyle==1}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _RimApColorThemeIndex ("", Int) = 0
		_Ap_RimLight_Power ("Ap Power--{ condition_showS:_LightDirection_MaskOn==1&&_Add_Antipodean_RimLight==1&&_RimStyle==1}", Range(0, 1)) = 0.1
		[Toggle(_)] _Ap_RimLight_FeatherOff ("Ap Feather Off--{ condition_showS:_LightDirection_MaskOn==1&&_Add_Antipodean_RimLight==1&&_RimStyle==1}", Float) = 0
		
		// Liltoon
		[HDR][Gamma]_RimColor ("Rim Color--{condition_showS:_RimStyle==2,reference_property:_RimLightColorThemeIndex}", Color) = (0.66,0.5,0.48,1)
		
		[sRGBWarning(true)] _RimColorTex ("Texture--{condition_showS:_RimStyle==2,reference_properties:[_RimColorTexPan, _RimColorTexUV]}", 2D) = "white" {}
		[HideInInspector][Vector2] _RimColorTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _RimColorTexUV ("UV", Int) = 0
		
		_RimMainStrength ("Main Color Blend--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0
		_RimNormalStrength ("Normal Strength--{condition_showS:_RimStyle==2}", Range(0, 1)) = 1.0
		_RimBorder ("Border--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0.5
		_RimBlur ("Blur--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0.65
		[PowerSlider(3.0)]_RimFresnelPower ("Fresnel Power--{condition_showS:_RimStyle==2}", Range(0.01, 50)) = 3.5
		_RimEnableLighting ("Enable Lighting--{condition_showS:_RimStyle==2}", Range(0, 1)) = 1
		_RimShadowMask ("Shadow Mask--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0.5
		[ToggleUI]_RimBackfaceMask ("Backface Mask--{condition_showS:_RimStyle==2}", Int) = 1
		_RimVRParallaxStrength ("VR Parallax Strength--{condition_showS:_RimStyle==2}", Range(0, 1)) = 1
		// [ToggleUI]_RimApplyTransparency ("Apply Transparency--{condition_showS:_RimStyle==2}", Int) = 1
		_RimDirStrength ("Light direction strength--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0
		_RimDirRange ("Direction Light Width--{condition_showS:_RimStyle==2}", Range(-1, 1)) = 0
		_RimIndirRange ("Indirection Light Width--{condition_showS:_RimStyle==2}", Range(-1, 1)) = 0
		[HDR][Gamma]_RimIndirColor ("Indirection Color--{condition_showS:_RimStyle==2}", Color) = (1,1,1,1)
		_RimIndirBorder ("Indirection Border--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0.5
		_RimIndirBlur ("Indirection Blur--{condition_showS:_RimStyle==2}", Range(0, 1)) = 0.1
		
		[ThryToggleUI(true)] _RimShadowToggle ("<size=13><b>  Light Direction Mask</b></size>--{ condition_showS:_RimStyle==0}", Float) = 0
		[Enum(Shadow Map, 0, Custom, 1)]_RimShadowMaskRampType ("Light Falloff Type--{ condition_showS:_RimStyle==0&&_RimShadowToggle==1}", Int) = 0
		[ToggleUI]_RimShadowMaskInvert ("Invert Shadow Mask--{ condition_showS:_RimStyle==0&&_RimShadowToggle==1}", Float) = 0
		_RimShadowMaskStrength ("Shadow Mask Strength--{ condition_showS:_RimStyle==0&&_RimShadowToggle==1}", Range(0, 1)) = 1
		[MultiSlider]_RimShadowAlpha ("Hide In Shadow--{ condition_showS:_RimStyle==0&&_RimShadowToggle==1&&_RimShadowMaskRampType==1}", Vector) = (0.0, 0.0, 0, 1)
		_RimShadowWidth ("Shrink In Shadow--{ condition_showS:_RimStyle==0&&_RimShadowToggle==1}", Range(0, 1)) = 0
		
		[ThryToggleUI(true)] _RimHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_RimHueShiftSpeed ("Shift Speed--{condition_showS:(_RimHueShiftEnabled==1)}", Float) = 0
		_RimHueShift ("Hue Shift--{condition_showS:(_RimHueShiftEnabled==1)}", Range(0, 1)) = 0
		
		[HideInInspector] m_start_RimAudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1&&_RimStyle==0}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkRimWidthBand ("Width Add Band", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkRimWidthAdd ("Width Add", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkRimEmissionBand ("Emission Add Band", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkRimEmissionAdd ("Emission Add", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkRimBrightnessBand ("Brightness Band", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkRimBrightnessAdd ("Brightness Add", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_RimAudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_rim1LightOptions ("Rim Lighting", Float) = 0
		//endex
		
		// Second Rim Lighting
		//ifex _EnableRim2Lighting==0
		[HideInInspector] m_start_rim2LightOptions ("Rim Lighting 2--{reference_property:_EnableRim2Lighting,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/rim-lighting},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_RIM2)]_EnableRim2Lighting ("Enable Rim2 Lighting", Float) = 0
		[KeywordEnum(Poiyomi, UTS2, LilToon)] _Rim2Style ("Style", Float) = 0
		[sRGBWarning(true)]_Rim2Tex ("Rim Texture--{reference_properties:[_Rim2TexPan, _Rim2TexUV], condition_showS:_Rim2Style==0}", 2D) = "white" { }
		[HideInInspector][Vector2]_Rim2TexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Rim2TexUV ("UV", Int) = 0
		[sRGBWarning][ThryRGBAPacker(1, Mask, Bias, 1)]_Rim2Mask ("Mask & Bias--{reference_properties:[_Rim2MaskPan, _Rim2MaskUV, _Rim2MaskChannel, _Rim2MaskInvert, _Rim2BiasIntensity], condition_showS:_Rim2Style==0}", 2D) = "white" { }
		[HideInInspector][Vector2]_Rim2MaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Rim2MaskUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_Rim2MaskInvert("Invert Mask", Float) = 0
		[HideInInspector]_Rim2BiasIntensity("Bias Intensity", Range(0,1)) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Rim2MaskChannel ("Channel", Float) = 0
		
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Rim2GlobalMask ("Global Mask--{reference_property:_Rim2GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _Rim2GlobalMaskBlendType ("Blending", Int) = 2
		
		_Is_NormalMapToRim2Light ("Normal Strength", Range(0, 1)) = 1
		[ToggleUI]_Rim2LightingInvert ("Invert Rim Lighting--{ condition_showS:_Rim2Style==0}", Float) = 0
		_Rim2LightColor ("Rim Color--{condition_showS:_Rim2Style==0||_Rim2Style==1,reference_property:_Rim2LightColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Rim2LightColorThemeIndex ("", Int) = 0
		_Rim2Width ("Rim Width--{ condition_showS:_Rim2Style==0}", Range(0, 1)) = 0.8
		_Rim2Sharpness ("Rim Sharpness--{ condition_showS:_Rim2Style==0}", Range(0, 1)) = .25
		_Rim2Power ("Rim Power--{ condition_showS:_Rim2Style==0}", Range(0, 10)) = 1
		_Rim2Strength ("Rim Emission--{ condition_showS:_Rim2Style==0}", Range(0, 20)) = 0
		_Rim2BaseColorMix ("Mix Base Color--{ condition_showS:_Rim2Style==0}", Range(0, 1)) = 0
		[ThryWideEnum(Add, 0, Replace, 1, Multiply, 2, Mixed, 3)] _Rim2BlendMode ("Blend Mode--{ condition_showS:_Rim2Style==0}", Int) = 0
		_Rim2Brightness ("Brightness--{ condition_showS:_Rim2Style==0}", Range(0, 10)) = 1
		_Rim2BlendStrength ("Blend Strength--{ condition_showS:_Rim2Style==0}", Range(0, 1)) = 1
		[ThryToggle(false)] _Rim2Clamp ("Clamp Intensity", Float) = 0
		
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _Rim2ApplyGlobalMaskIndex ("Apply to Global Mask--{reference_property:_Rim2ApplyGlobalMaskBlendType,condition_showS:_Rim2Style==0}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)] _Rim2ApplyGlobalMaskBlendType ("Blending", Int) = 2
		
		// UTS2
		[sRGBWarning]_Set_Rim2LightMask ("Set_RimLightMask--{reference_properties:[_Set_Rim2LightMaskPan, _Set_Rim2LightMaskUV, _Set_Rim2LightMaskChannel], condition_showS:_RimStyle==1}", 2D) = "white" { }
		[HideInInspector][Vector2]_Set_Rim2LightMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Set_Rim2LightMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Set_Rim2LightMaskChannel ("Channel", Float) = 1
		_Tweak_Rim2LightMaskLevel ("Tweak_RimLightMaskLevel--{ condition_showS:_Rim2Style==1}", Range(-1, 1)) = 0
		_Is_LightColor_Rim2Light ("Mix Light Color--{ condition_showS:_Rim2Style==1}", Range(0, 1)) = 1
		_Rim2Light_Power ("Rim Power--{ condition_showS:_Rim2Style==1}", Range(0, 1)) = 0.1
		_Rim2Light_InsideMask ("Inside Mask--{ condition_showS:_Rim2Style==1}", Range(0.0001, 1)) = 0.0001
		[Toggle(_)] _Rim2Light_FeatherOff ("Feather Off--{ condition_showS:_Rim2Style==1}", Float) = 0
		[ThryToggleUI(true)] _LightDirection_MaskOn2 ("<size=13><b>  Light Direction Mask</b></size>--{ condition_showS:_Rim2Style==1}", Float) = 0
		_Tweak_LightDirection_MaskLevel2 ("Light Dir Mask Level--{ condition_showS:_LightDirection_MaskOn2==1&&_Rim2Style==1}", Range(0, 0.5)) = 0
		[ThryToggleUI(true)] _Add_Antipodean_Rim2Light ("<size=13><b>  Antipodean(Ap) Rim</b></size>--{ condition_showS:_LightDirection_MaskOn2==1&&_Rim2Style==1}", Float) = 0
		_Is_LightColor_Ap_Rim2Light ("Ap Light Color Mix--{ condition_showS:_LightDirection_MaskOn2==1&&_Add_Antipodean_Rim2Light==1&&_Rim2Style==1}", Range(0, 1)) = 1
		_Ap_Rim2LightColor ("Ap Color--{reference_property:_Rim2ApColorThemeIndex, condition_showS:_LightDirection_MaskOn2==1&&_Add_Antipodean_Rim2Light==1&&_Rim2Style==1}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _Rim2ApColorThemeIndex ("", Int) = 0
		_Ap_Rim2Light_Power ("Ap Power--{ condition_showS:_LightDirection_MaskOn2==1&&_Add_Antipodean_Rim2Light==1&&_Rim2Style==1}", Range(0, 1)) = 0.1
		[Toggle(_)] _Ap_Rim2Light_FeatherOff ("Ap Feather Off--{ condition_showS:_LightDirection_MaskOn2==1&&_Add_Antipodean_Rim2Light==1&&_Rim2Style==1}", Float) = 0
		
		// Liltoon
		[HDR][Gamma]_Rim2Color ("Rim Color--{condition_showS:_Rim2Style==2,reference_property:_Rim2LightColorThemeIndex}", Color) = (0.66,0.5,0.48,1)
		
		[sRGBWarning(true)] _Rim2ColorTex ("Texture--{condition_showS:_Rim2Style==2,reference_properties:[_Rim2ColorTexPan, _Rim2ColorTexUV]}", 2D) = "white" {}
		[HideInInspector][Vector2] _Rim2ColorTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _Rim2ColorTexUV ("UV", Int) = 0
		
		_Rim2MainStrength ("Main Color Blend--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0
		_Rim2NormalStrength ("Normal Strength--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 1.0
		_Rim2Border ("Border--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0.5
		_Rim2Blur ("Blur--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0.65
		[PowerSlider(3.0)]_Rim2FresnelPower ("Fresnel Power--{condition_showS:_Rim2Style==2}", Range(0.01, 50)) = 3.5
		_Rim2EnableLighting ("Enable Lighting--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 1
		_Rim2ShadowMask ("Shadow Mask--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0.5
		[ToggleUI]_Rim2BackfaceMask ("Backface Mask--{condition_showS:_Rim2Style==2}", Int) = 1
		_Rim2VRParallaxStrength ("VR Parallax Strength--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 1
		// [ToggleUI]_Rim2ApplyTransparency ("Apply Transparency--{condition_showS:_Rim2Style==2}", Int) = 1
		_Rim2DirStrength ("Light direction strength--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0
		_Rim2DirRange ("Direction Light Width--{condition_showS:_Rim2Style==2}", Range(-1, 1)) = 0
		_Rim2IndirRange ("Indirection Light Width--{condition_showS:_Rim2Style==2}", Range(-1, 1)) = 0
		[HDR][Gamma]_Rim2IndirColor ("Indirection Color--{condition_showS:_Rim2Style==2}", Color) = (1,1,1,1)
		_Rim2IndirBorder ("Indirection Border--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0.5
		_Rim2IndirBlur ("Indirection Blur--{condition_showS:_Rim2Style==2}", Range(0, 1)) = 0.1
		
		[ThryToggleUI(true)] _Rim2ShadowToggle ("<size=13><b>  Light Direction Mask</b></size>--{ condition_showS:_Rim2Style==0}", Float) = 0
		[Enum(Shadow Map, 0, Custom, 1)]_Rim2ShadowMaskRampType ("Light Falloff Type--{ condition_showS:_Rim2Style==0&&_Rim2ShadowToggle==1}", Int) = 0
		[ToggleUI]_Rim2ShadowMaskInvert ("Invert Shadow Mask--{ condition_showS:_Rim2Style==0&&_Rim2ShadowToggle==1}", Float) = 0
		_Rim2ShadowMaskStrength ("Shadow Mask Strength--{ condition_showS:_Rim2Style==0&&_Rim2ShadowToggle==1}", Range(0, 1)) = 1
		[MultiSlider]_Rim2ShadowAlpha ("Hide In Shadow--{ condition_showS:_Rim2Style==0&&_Rim2ShadowToggle==1&&_Rim2ShadowMaskRampType==1}", Vector) = (0.0, 0.0, 0, 1)
		_Rim2ShadowWidth ("Shrink In Shadow--{ condition_showS:_Rim2Style==0&&_Rim2ShadowToggle==1}", Range(0, 1)) = 0
		
		[ThryToggleUI(true)] _Rim2HueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_Rim2HueShiftSpeed ("Shift Speed--{condition_showS:(_Rim2HueShiftEnabled==1)}", Float) = 0
		_Rim2HueShift ("Hue Shift--{condition_showS:(_Rim2HueShiftEnabled==1)}", Range(0, 1)) = 0
		
		[HideInInspector] m_start_Rim2AudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1&&_Rim2Style==0}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkRim2WidthBand ("Width Add Band", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkRim2WidthAdd ("Width Add", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkRim2EmissionBand ("Emission Add Band", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkRim2EmissionAdd ("Emission Add", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkRim2BrightnessBand ("Brightness Band", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkRim2BrightnessAdd ("Brightness Add", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_Rim2AudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_rim2LightOptions ("Rim2 Lighting", Float) = 0
		//endex
		
		//ifex _EnableDepthRimLighting==0
		[HideInInspector] m_start_depthRimLightOptions ("Depth Rim Lighting--{reference_property:_EnableDepthRimLighting,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/depth-rim-lighting},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(_POI_DEPTH_RIMLIGHT)]_EnableDepthRimLighting ("", Float) = 0
		[Enum(vertex, 0, pixel, 1)] _DepthRimNormalToUse ("Normal To Use", Int) = 1
		[ThryWideEnum(Two Samples, 0, Ten Samples, 1)] _DepthRimType ("Rim Type", Int) = 0
		_DepthRimWidth ("Width", Range(0, 1)) = .2
		_DepthRimSharpness ("Depth", Range(0, 1)) = .2
		[ToggleUI]_DepthRimHideInShadow ("Hide In Shadow", Float) = 0
		
		[Space][ThryHeaderLabel(Color and Blending, 13)]
		_DepthRimMixBaseColor ("Use Base Color", Range(0, 1)) = 0
		_DepthRimMixLightColor ("Light Color Mix", Range(0, 1)) = 0
		_DepthRimColor ("Rim Color--{reference_property:_DepthRimColorThemeIndex}", Color) = (1, 1, 1, 1)
		_DepthRimBrightness ("Color Brightness", Range(0, 10)) = 1
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DepthRimColorThemeIndex ("", Int) = 0
		_DepthRimEmission ("Emission", Range(0, 20)) = 0
		_DepthRimReplace ("Replace", Range(0, 1)) = 0
		_DepthRimAdd ("Add", Range(0, 1)) = 0
		_DepthRimMultiply ("Multiply", Range(0, 1)) = 0
		_DepthRimAdditiveLighting ("Add to Light", Range(0, 1)) = 0
		[HideInInspector] m_end_depthRimLightOptions ("Rim Lighting", Float) = 0
		//endex
		
		//ifex _SubsurfaceScattering==0
		[HideInInspector] m_start_subsurfaceScattering ("Subsurface Scattering--{reference_property:_SubsurfaceScattering}}", Float) = 0
		[HideInInspector][ThryToggle(POI_SUBSURFACESCATTERING)]_SubsurfaceScattering ("Enable", Float) = 0
		
		_SSSColor ("Subsurface Color", Color) = (1, 0, 0, 1)
		[sRGBWarning]_SSSThicknessMap ("Thickness Map--{reference_properties:[_SSSThicknessMapPan, _SSSThicknessMapUV, _SSSThicknessMapChannel]}", 2D) = "black" { }
		[HideInInspector][Vector2]_SSSThicknessMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][Enum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, DistortedUV1, 4)] _SSSThicknessMapUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)] _SSSThicknessMapChannel ("Channel", Int) = 0
		_SSSThicknessMod ("Thickness mod", Range(-1, 1)) = 0
		_SSSStrength ("Light Strength", Range(0, 1)) = 0.25
		_SSSSpread ("Light Spread", Range(1, 100)) = 5
		_SSSDistortion ("Light Distortion", Range(0, 1)) = 1
		
		[HideInInspector] m_end_subsurfaceScattering ("", Float) = 0
		//endex
		
		//ifex _MochieBRDF==0
		[HideInInspector] m_start_brdf ("Reflections & Specular--{reference_property:_MochieBRDF,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/reflections-and-specular},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(MOCHIE_PBR)]_MochieBRDF ("Enable", Float) = 0
		_MochieReflectionStrength ("Reflection Strength", Range(0, 1)) = 1
		_MochieSpecularStrength ("Specular Strength", Range(0, 1)) = 1
		_MochieMetallicMultiplier ("Metallic", Range(0, 1)) = 0
		_MochieRoughnessMultiplier ("Smoothness", Range(0, 1)) = 1
		_MochieReflectionTint ("Reflection Tint--{reference_property:_MochieReflectionTintThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _MochieReflectionTintThemeIndex ("", Int) = 0
		_MochieSpecularTint ("Specular Tint--{reference_property:_MochieSpecularTintThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _MochieSpecularTintThemeIndex ("", Int) = 0
		[Space(8)]
		[sRGBWarning][ThryRGBAPacker(R Metallic Map, G Smoothness Map, B Reflection Mask, A Specular Mask)]_MochieMetallicMaps ("Packed Maps [Expand]--{reference_properties:[_MochieMetallicMapsPan, _MochieMetallicMapsUV, _MochieMetallicMapsStochastic, _MochieMetallicMapsMetallicChannel, _MochieMetallicMapsRoughnessChannel, _MochieMetallicMapsReflectionMaskChannel, _MochieMetallicMapsSpecularMaskChannel, _MochieMetallicMapInvert, _MochieRoughnessMapInvert, _MochieReflectionMaskInvert, _MochieSpecularMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_MochieMetallicMapsPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_MochieMetallicMapsUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_MochieMetallicMapsStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_MochieMetallicMapsMetallicChannel ("Metallic Channel", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_MochieMetallicMapsRoughnessChannel ("Smoothness Channel", Float) = 1
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_MochieMetallicMapsReflectionMaskChannel ("Reflection Mask Channel", Float) = 2
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_MochieMetallicMapsSpecularMaskChannel ("Specular Mask Channel", Float) = 3
		[HideInInspector][ToggleUI]_MochieMetallicMapInvert ("Invert Metallic", Float) = 0
		[HideInInspector][ToggleUI]_MochieRoughnessMapInvert ("Invert Smoothness", Float) = 0
		[HideInInspector][ToggleUI]_MochieReflectionMaskInvert ("Invert Reflection Mask", Float) = 0
		[HideInInspector][ToggleUI]_MochieSpecularMaskInvert ("Invert Specular Mask", Float) = 0
		[ThryToggleUI(true)]_PBRSplitMaskSample ("<size=13><b>  Split Mask Sampling</b></size>", Float) = 0
		[VectorLabel(tX, tY, oX, oY)]_PBRMaskScaleTiling ("Tiling/Offset--{condition_showS:(_PBRSplitMaskSample==1)}", Vector) = (1, 1, 0, 0)
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_MochieMetallicMasksUV ("UV--{condition_showS:(_PBRSplitMaskSample==1)}", Int) = 0
		[ToggleUI]_PBRSplitMaskStochastic ("Stochastic Sampling--{condition_showS:(_PBRSplitMaskSample==1)}", Float) = 0
		[Vector2]_MochieMetallicMasksPan ("Panning--{condition_showS:(_PBRSplitMaskSample==1)}", Vector) = (0, 0, 0, 0)
		[ThryToggleUI(true)]_Specular2ndLayer ("<size=13><b>  2nd Specular</b></size>", Float) = 0
		_MochieSpecularStrength2 ("Strength--{condition_showS:(_Specular2ndLayer==1)}", Range(0, 1)) = 1
		_MochieRoughnessMultiplier2 ("Smoothness--{condition_showS:(_Specular2ndLayer==1)}", Range(0, 1)) = 1
		[Space(4)]
		[ThryTexture][NoScaleOffset]_MochieReflCube ("Fallback Cubemap", Cube) = "" { }
		[ToggleUI]_MochieForceFallback ("Force Fallback", Int) = 0
		
		[HideInInspector] m_start_brdfadvanced ("Advanced", Float) = 0
		[ToggleUI]_MochieLitFallback ("Lit Fallback", Float) = 1
		[ToggleUI]_IgnoreCastedShadows ("Ignore Casted Shadows", Float) = 0
		_PBRNormalSelect ("Pixel Normal Mix", Range(0, 1)) = 1
		[PowerSlider(.2)]_RefSpecFresnel ("Fresnel Reflection", Range(0, 1)) = 1
		[ThryToggleUI(true)]_MochieGSAAEnabled ("<size=13><b>  GSAA</b></size>", Float) = 1
		_PoiGSAAVariance ("GSAA Variance", Range(0, 1)) = 0.15
		_PoiGSAAThreshold ("GSAA Threshold", Range(0, 1)) = 0.1
		[HideInInspector] g_start_BRDFTPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _BRDFTPSDepthEnabled ("<size=13><b>  TPS Depth Enabled</b></size>", Float) = 0
		_BRDFTPSReflectionMaskStrength ("Reflection Mask Strength--{condition_showS:(_BRDFTPSDepthEnabled==1)}", Range(0, 1)) = 1
		_BRDFTPSSpecularMaskStrength ("Specular Mask Strength--{condition_showS:(_BRDFTPSDepthEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_BRDFTPSMaskGroup ("", Float) = 0
		[HideInInspector] m_end_brdfadvanced ("", Float) = 0
		
		[HideInInspector] m_start_brdfglobalmask ("Global Mask", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MochieMetallicGlobalMask ("Metallic--{reference_property:_MochieMetallicGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _MochieMetallicGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MochieSmoothnessGlobalMask ("Smoothness--{reference_property:_MochieSmoothnessGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _MochieSmoothnessGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MochieReflectionStrengthGlobalMask ("Reflection Strength--{reference_property:_MochieReflectionStrengthGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _MochieReflectionStrengthGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _MochieSpecularStrengthGlobalMask ("Specular Strength--{reference_property:_MochieSpecularStrengthGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _MochieSpecularStrengthGlobalMaskBlendType ("Blending", Int) = 2
		[HideInInspector] m_end_brdfglobalmask ("", Float) = 0
		
		[HideInInspector] m_end_brdf ("", Float) = 0
		//endex
		
		//ifex _ClearCoatBRDF==0
		[HideInInspector] m_start_clearCoat ("Clear Coat--{reference_property:_ClearCoatBRDF,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/clear-coat},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_CLEARCOAT)]_ClearCoatBRDF ("Enable", Float) = 0
		_ClearCoatStrength ("ClearCoat Strength", Range(0, 1)) = 1
		_ClearCoatSmoothness ("Smoothness", Range(0, 1)) = 1
		_ClearCoatReflectionStrength ("Reflections Strength", Range(0, 1)) = 1
		_ClearCoatSpecularStrength ("Specular Strength", Range(0, 1)) = 1
		_ClearCoatReflectionTint ("Reflection Tint--{reference_property:_ClearCoatReflectionTintThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ClearCoatReflectionTintThemeIndex ("", Int) = 0
		_ClearCoatSpecularTint ("Specular Tint--{reference_property:_ClearCoatSpecularTintThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ClearCoatSpecularTintThemeIndex ("", Int) = 0
		[Space(8)]
		[sRGBWarning][ThryRGBAPacker(ClearCoat Mask, Smoothness Map, Reflection Mask, Specular Mask)]_ClearCoatMaps ("Packed Maps [Expand]--{reference_properties:[_ClearCoatMapsPan, _ClearCoatMapsUV, _ClearCoatMapsStochastic, _ClearCoatMapsClearCoatMaskChannel, _ClearCoatMapsRoughnessChannel, _ClearCoatMapsReflectionMaskChannel, _ClearCoatMapsSpecularMaskChannel, _ClearCoatMaskInvert, _ClearCoatSmoothnessMapInvert, _ClearCoatReflectionMaskInvert, _ClearCoatSpecularMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_ClearCoatMapsPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_ClearCoatMapsUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_ClearCoatMapsStochastic ("Stochastic Sampling", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_ClearCoatMapsClearCoatMaskChannel ("ClearCoat Mask Channel", Float) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_ClearCoatMapsRoughnessChannel ("Smoothness Channel", Float) = 1
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_ClearCoatMapsReflectionMaskChannel ("Reflection Mask Channel", Float) = 2
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3, White, 4)]_ClearCoatMapsSpecularMaskChannel ("Specular Mask Channel", Float) = 3
		[HideInInspector][ToggleUI]_ClearCoatMaskInvert ("Invert ClearCoat Mask", Float) = 0
		[HideInInspector][ToggleUI]_ClearCoatSmoothnessMapInvert ("Invert Smoothness", Float) = 0
		[HideInInspector][ToggleUI]_ClearCoatReflectionMaskInvert ("Invert Reflection Mask", Float) = 0
		[HideInInspector][ToggleUI]_ClearCoatSpecularMaskInvert ("Invert Specular Mask", Float) = 0
		[Space(4)]
		[ThryTexture][NoScaleOffset]_ClearCoatFallback ("Fallback Cubemap", Cube) = "" { }
		[ToggleUI]_ClearCoatForceFallback ("Force Fallback", Int) = 0
		
		[HideInInspector] m_start_clearcoatadvanced ("Advanced", Float) = 0
		[ToggleUI]_ClearCoatLitFallback ("Lit Fallback", Float) = 1
		[ToggleUI]_CCIgnoreCastedShadows ("Ignore Casted Shadows", Float) = 0
		_ClearCoatNormalSelect ("Pixel Normal Mix", Range(0, 1)) = 0
		[PowerSlider(.2)]_ClearcoatFresnel ("Fresnel Reflection", Range(0, 1)) = 1
		[ThryToggleUI(true)]_ClearCoatGSAAEnabled ("<size=13><b>  GSAA</b></size>", Float) = 1
		_ClearCoatGSAAVariance ("GSAA Variance", Range(0, 1)) = 0.15
		_ClearCoatGSAAThreshold ("GSAA Threshold", Range(0, 1)) = 0.1
		[HideInInspector] g_start_ClearCoatTPSMaskGroup ("--{condition_showS:(_TPSPenetratorEnabled==1)}", Float) = 0
		[ThryToggleUI(true)] _ClearCoatTPSDepthMaskEnabled ("<size=13><b>  TPS Depth Enabled</b></size>", Float) = 0
		_ClearCoatTPSMaskStrength ("Mask Strength--{condition_showS:(_ClearCoatTPSDepthMaskEnabled==1)}", Range(0, 1)) = 1
		[HideInInspector] g_end_ClearCoatTPSMaskGroup ("", Float) = 0
		[HideInInspector] m_end_clearcoatadvanced ("", Float) = 0
		
		[HideInInspector] m_start_clearcoatglobalmask ("Global Mask", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _ClearCoatGlobalMask ("ClearCoat--{reference_property:_ClearCoatGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _ClearCoatGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _ClearCoatSmoothnessGlobalMask ("Smoothness--{reference_property:_ClearCoatSmoothnessGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _ClearCoatSmoothnessGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _ClearCoatReflectionStrengthGlobalMask ("Reflection Strength--{reference_property:_ClearCoatReflectionStrengthGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _ClearCoatReflectionStrengthGlobalMaskBlendType ("Blending", Int) = 2
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _ClearCoatSpecularStrengthGlobalMask ("Specular Strength--{reference_property:_ClearCoatSpecularStrengthGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)] _ClearCoatSpecularStrengthGlobalMaskBlendType ("Blending", Int) = 2
		[HideInInspector] m_end_clearcoatglobalmask ("", Float) = 0
		
		[HideInInspector] m_end_clearCoat ("", Float) = 0
		//endex
		
		//ifex _EnableEnvironmentalRim==0
		[HideInInspector] m_start_reflectionRim ("Environmental Rim--{reference_property:_EnableEnvironmentalRim,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/environmental-rim},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_ENVIRORIM)]_EnableEnvironmentalRim ("Enable", Float) = 0
		[sRGBWarning]_RimEnviroMask ("Mask--{reference_properties:[_RimEnviroMaskPan, _RimEnviroMaskUV, _RimEnviroChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_RimEnviroMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_RimEnviroMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_RimEnviroChannel ("Channel", Float) = 0
		_RimEnviroBlur ("Blur", Range(0, 1)) = 0.7
		_RimEnviroWidth ("Rim Width", Range(0, 1)) = 0.45
		_RimEnviroSharpness ("Rim Sharpness", Range(0, 1)) = 0
		_RimEnviroMinBrightness ("Min Brightness Threshold", Range(0, 2)) = 0
		_RimEnviroIntensity ("Intensity", Range(0, 1)) = 1
		[HideInInspector] m_end_reflectionRim ("", Float) = 0
		//endex
		
		//ifex _StylizedSpecular==0
		[HideInInspector] m_start_stylizedSpec (" Stylized Specular--{reference_property:_StylizedSpecular,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/shading/stylized-specular},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_STYLIZED_StylizedSpecular)]_StylizedSpecular ("Enable", Float) = 0
		
		[sRGBWarning(true)][ThryTexture]_HighColor_Tex ("Specular Map--{reference_properties:[_HighColor_TexPan, _HighColor_TexUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_HighColor_TexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_HighColor_TexUV ("UV", Int) = 0
		_HighColor ("Tint--{reference_property:_HighColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _HighColorThemeIndex ("", Int) = 0
		[sRGBWarning]_Set_HighColorMask ("Mask--{reference_properties:[_Set_HighColorMaskPan, _Set_HighColorMaskUV, _Set_HighColorMaskChannel, _Tweak_HighColorMaskLevel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_Set_HighColorMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_Set_HighColorMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_Set_HighColorMaskChannel ("Channel", Float) = 1
		[HideInInspector]_Tweak_HighColorMaskLevel ("Mask Level", Range(-1, 1)) = 0
		[ThryWideEnum(Toon, 0, Realistic, 1)]_Is_SpecularToHighColor ("Specular Mode", Float) = 0
		[ThryWideEnum(Replace, 0, Add, 1)]_Is_BlendAddToHiColor ("Color Blend Mode", Int) = 0
		[ToggleUI] _StylizedSpecularIgnoreNormal ("Ignore Normal", Float) = 0
		[ToggleUI] _StylizedSpecularIgnoreShadow ("Ignore Shadow", Float) = 0
		
		_StylizedSpecularStrength ("Strength", Float) = 1
		[ToggleUI] _UseLightColor ("Use Light Color", Float) = 1
		[ToggleUI]_SSIgnoreCastedShadows ("Ignore Casted Shadows", Float) = 0
		[Space(8)]
		
		[ThryHeaderLabel(Layer 1, 13)]
		_HighColor_Power ("Size", Range(0, 1)) = 0.2
		_StylizedSpecularFeather ("Feather--{condition_showS:(_Is_SpecularToHighColor==0)}", Range(0, 1)) = 0
		_Layer1Strength ("Strength", Range(0, 1)) = 1
		[Space(8)]
		
		[ThryHeaderLabel(Layer 2, 13)]
		_Layer2Size ("Size", Range(0, 1)) = 0
		_StylizedSpecular2Feather ("Feather--{condition_showS:(_Is_SpecularToHighColor==0)}", Range(0, 1)) = 0
		_Layer2Strength ("Strength", Range(0, 1)) = 0
		[HideInInspector] m_end_stylizedSpec ("", Float) = 0
		//endex
		
		//ifex _BacklightEnabled!=1
		[HideInInspector] m_start_backlight ("Backlight--{reference_property:_BacklightEnabled}", Float) = 0
		[HideInInspector][ThryToggle(POI_BACKLIGHT)]_BacklightEnabled ("Backlight Enabled", Float) = 0
		[HDR][Gamma] _BacklightColor ("Color", Color) = (0.85,0.8,0.7,1.0)
		[sRGBWarning(true)] _BacklightColorTex ("Texture--{reference_properties:[_BacklightColorTexPan, _BacklightColorTexUV]}", 2D) = "white" {}
		[HideInInspector][Vector2] _BacklightColorTexPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _BacklightColorTexUV ("UV", Int) = 0
		_BacklightMainStrength ("Main Color Blend", Range(0, 1)) = 0
		_BacklightNormalStrength ("Normal Strength", Range(0, 1)) = 1.0
		_BacklightBorder ("Border", Range(0, 1)) = 0.35
		_BacklightBlur ("Blur", Range(0, 1)) = 0.05
		_BacklightDirectivity ("Directivity", Float) = 5.0
		_BacklightViewStrength ("View direction strength", Range(0, 1)) = 1
		[ToggleUI] _BacklightReceiveShadow ("Receive Shadow", Int) = 1
		[ToggleUI] _BacklightBackfaceMask ("Backface Mask", Int) = 1
		[HideInInspector] m_end_backlight ("Backlight", Float) = 0
		//endex
		
		// Rendering Options
		[HideInInspector] m_specialFXCategory ("Special FX", Float) = 0
		//ifex _EnableUDIMDiscardOptions==0
		// SPECIALFX_PROPERTIES
		// UDIM Discard
		[HideInInspector] m_start_udimdiscardOptions ("UV Tile Discard--{reference_property:_EnableUDIMDiscardOptions,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/udim-discard},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_UDIMDISCARD)]_EnableUDIMDiscardOptions ("Enable UDIM Discard Options", Float) = 0
		[Helpbox(1)]_UDIMDiscardHelpbox ("UV Tile Discard requires special model setup. Place object UVs on different UV Tiles.", Int) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)]_UDIMDiscardUV ("Discard UV", Int) = 0
		[Enum(Vertex (Faster), 0, Pixel (Slower), 1)] _UDIMDiscardMode ("Discard Mode", Int) = 0
		
		[ThryMultiFloats(true, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3)] _UDIMDiscardRow3_0("v = 3", Float) = 0
		[HideInInspector] _UDIMDiscardRow3_1("", Float) = 0
		[HideInInspector] _UDIMDiscardRow3_2("", Float) = 0
		[HideInInspector] _UDIMDiscardRow3_3("", Float) = 0
		
		[ThryMultiFloats(true, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3)] _UDIMDiscardRow2_0("v = 2", Float) = 0
		[HideInInspector] _UDIMDiscardRow2_1("", Float) = 0
		[HideInInspector] _UDIMDiscardRow2_2("", Float) = 0
		[HideInInspector] _UDIMDiscardRow2_3("", Float) = 0
		
		[ThryMultiFloats(true, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3)] _UDIMDiscardRow1_0("v = 1", Float) = 0
		[HideInInspector] _UDIMDiscardRow1_1("", Float) = 0
		[HideInInspector] _UDIMDiscardRow1_2("", Float) = 0
		[HideInInspector] _UDIMDiscardRow1_3("", Float) = 0
		
		[ThryMultiFloats(true, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3)] _UDIMDiscardRow0_0("v = 0", Float) = 0
		[HideInInspector] _UDIMDiscardRow0_1("", Float) = 0
		[HideInInspector] _UDIMDiscardRow0_2("", Float) = 0
		[HideInInspector] _UDIMDiscardRow0_3("", Float) = 0
		
		[HideInInspector] m_end_udimdiscardOptions ("UV Tile Discard", Float) = 0
		//endex
		
		//ifex _EnableDepthBulge==0
		[HideInInspector] m_start_DepthBulge ("Depth Bulge--{reference_property:_EnableDepthBulge}", Float) = 0
		[HideInInspector][ThryToggle(POI_DEPTHBULGE)] _EnableDepthBulge ("Bulge", Float) = 0
		[Helpbox(1)]_DepthBulgeWarning ("Depth Bulge doesn't write to depth, which can break certain transparent effects like custom fog and raymarching", Int) = 0
		_DepthBulgeMask ("Bulge Mask--{reference_properties:[_DepthBulgeMaskUV, _DepthBulgeMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Enum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)] _DepthBulgeMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)] _DepthBulgeMaskChannel ("Channel", Float) = 0
		_DepthBulgeFadeLength ("Touch Distance", Range(0, 1.0)) = 0.02
		_DepthBulgeHeight ("Bulge Height", Range(-0.2, 0.2)) = 0.02
		[HideInInspector] m_end_DepthBulge ("Depth Bulge", Float) = 0
		//endex
		
		//ifex _EnableDissolve==0
		[HideInInspector] m_start_dissolve ("Dissolve--{reference_property:_EnableDissolve,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/dissolve},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(DISTORT)]_EnableDissolve ("Enable Dissolve", Float) = 0
		[Enum(Basic, 1, Point2Point, 2, Spherical, 3, CenterOut, 4)] _DissolveType ("Dissolve Type", Int) = 1
		_DissolveEdgeWidth ("Edge Width--{condition_show:_DissolveType!=2}", Range(0, .5)) = 0.025
		_DissolveEdgeHardness ("Edge Hardness", Range(0, 1)) = 0.5
		_DissolveEdgeColor ("Edge Color--{reference_property:_DissolveEdgeColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DissolveEdgeColorThemeIndex ("", Int) = 0
		[sRGBWarning][Gradient]_DissolveEdgeGradient ("Edge Gradient", 2D) = "white" { }
		_DissolveEdgeEmission ("Edge Emission", Range(0, 20)) = 0
		_DissolveTextureColor ("Dissolved Color--{reference_property:_DissolveTextureColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DissolveTextureColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_DissolveToTexture ("Dissolved Texture--{reference_properties:[_DissolveToTexturePan, _DissolveToTextureUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DissolveToTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DissolveToTextureUV ("UV", Int) = 0
		_DissolveToEmissionStrength ("Dissolved Emission Strength", Range(0, 20)) = 0
		[sRGBWarning]_DissolveNoiseTexture ("Dissolve Gradient--{condition_show:_DissolveType==1,reference_properties:[_DissolveNoiseTexturePan, _DissolveNoiseTextureUV, _DissolveInvertNoise]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DissolveNoiseTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DissolveNoiseTextureUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_DissolveInvertNoise ("Invert", Float) = 0
		[sRGBWarning]_DissolveDetailNoise ("Dissolve Noise--{reference_properties:[_DissolveDetailNoisePan, _DissolveDetailNoiseUV, _DissolveInvertDetailNoise]}", 2D) = "black" { }
		[HideInInspector][Vector2]_DissolveDetailNoisePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DissolveDetailNoiseUV ("UV", Int) = 0
		[HideInInspector][ToggleUI]_DissolveInvertDetailNoise ("Invert", Float) = 0
		_DissolveDetailEdgeSmoothing ("Detail Noise Smoothing", Range(0, 1)) = 0
		_DissolveDetailStrength ("Dissolve Detail Strength", Range(0, 1)) = 0.1
		_DissolveAlpha ("Dissolve Alpha", Range(0, 1)) = 0
		[sRGBWarning]_DissolveMask ("Dissolve Mask--{reference_properties:[_DissolveMaskPan, _DissolveMaskUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DissolveMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DissolveMaskUV ("UV", Int) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _DissolveMaskGlobalMask ("Global Mask--{reference_property:_DissolveMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_DissolveMaskGlobalMaskBlendType ("Blending", Int) = 2
		[Enum(Off, 0, Red, 1, Green, 2, Blue, 3, Alpha, 4)]_DissolveUseVertexColors ("VertexColor Mask", Int) = 0
		[HideInInspector][ToggleUI]_DissolveMaskInvert ("Invert", Float) = 0
		_ContinuousDissolve ("Continuous Dissolve Speed", Float) = 0
		
		[Space(10)]
		[ThryToggleUI(true)] _EnableDissolveAudioLink ("<size=13><b>  Audio Link</b></size>--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDissolveAlphaBand ("Dissolve Alpha Band--{ condition_showS:(_EnableDissolveAudioLink==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDissolveAlpha ("Dissolve Alpha Mod--{ condition_showS:(_EnableDissolveAudioLink==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkDissolveDetailBand ("Dissolve Detail Band--{ condition_showS:(_EnableDissolveAudioLink==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkDissolveDetail ("Dissolve Detail Mod--{ condition_showS:(_EnableDissolveAudioLink==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		
		// Spherical Dissolve
		[HideInInspector] m_start_SphericalDissolve ("Spherical--{condition_showS:(_DissolveType==3)}", Float) = 0
		[Vector3] 	_SphericalDissolveCenter ("Center Point",  	Vector) = (0, 0, 0)
		_SphericalDissolveRadius ("Radius", 		Float) 	= 1.5
		[ToggleUI] 	_SphericalDissolveInvert ("Invert", 		Float) 	= 0
		[ToggleUI] 	_SphericalDissolveClamp  ("Clamp Dissolve", Float) 	= 0
		[HideInInspector] m_end_SphericalDissolve ("Spherical", Float) = 0
		
		// Point to Point Dissolve
		[HideInInspector] m_start_pointToPoint ("Point to Point--{condition_showS:(_DissolveType==2)}", Float) = 0
		[Enum(Local, 0, World, 1, Vertex Colors, 2)] _DissolveP2PWorldLocal ("World/Local", Int) = 0
		_DissolveP2PEdgeLength ("Edge Length", Float) = 0.1
		[Vector3]_DissolveStartPoint ("Start Point", Vector) = (0, -1, 0, 0)
		[Vector3]_DissolveEndPoint ("End Point", Vector) = (0, 1, 0, 0)
		[ToggleUI]_DissolveP2PClamp ("Clamp Dissolve", Float) = 0
		[HideInInspector] m_end_pointToPoint ("Point To Point", Float) = 0
		
		// CenterOut Dissolve
		[HideInInspector] m_start_CenterOutDissolve ("CenterOut--{condition_showS:(_DissolveType==4)}", Float) = 0
		[Enum(View Direction, 1, Custom Direction, 2, Light Direction, 3)] 	_CenterOutDissolveMode 		("CenterOut Mode", Int) = 1
		[Vector3] 	_CenterOutDissolveDirection ("Custom Direction--{condition_showS:(_CenterOutDissolveMode==2)}",	Vector) = (0,0,1,0)
		[ToggleUI] 	_CenterOutDissolveInvert 	("Invert", 				Float) 	= 0
		_CenterOutDissolveNormals  	("Use Pixel Normals",Range(0,1)) = 0
		_CenterOutDissolvePower		("Power", Range(.1, 5)) = 1
		[HideInInspector] m_end_CenterOutDissolve ("CenterOut", 	Float) = 0
		
		[HideInInspector] m_start_dissolveHueShift ("Hue Shift--{reference_property:_DissolveHueShiftEnabled}", Float) = 0
		[HideInInspector][ToggleUI]_DissolveHueShiftEnabled ("Dissolved Enabled", Float) = 0
		_DissolveHueShiftSpeed ("Dissolved Speed", Float) = 0
		_DissolveHueShift ("Dissolved Shift", Range(0, 1)) = 0
		[ToggleUI]_DissolveEdgeHueShiftEnabled ("Edge Enabled", Float) = 0
		_DissolveEdgeHueShiftSpeed ("Edge Speed", Float) = 0
		_DissolveEdgeHueShift ("Edge Shift", Range(0, 1)) = 0
		[HideInInspector] m_end_dissolveHueShift ("Hue Shift", Float) = 0
		
		[HideInInspector] m_start_UVTileDissolve ("UV Tile Dissolve--{reference_property:_UVTileDissolveEnabled}", Float) = 0
		[HideInInspector][ToggleUI]_UVTileDissolveEnabled ("Enabled", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)]_UVTileDissolveUV ("UV Tile UV", Int) = 0
		[ToggleUI]_UVTileDissolveDiscardAtMax ("Discard Tiles at Max", Float) = 1
		[HideInInspector] m_start_UVTileDissolveRow3 ("Row 3 Alpha", Float) = 0
		_UVTileDissolveAlpha_Row3_0 ("Row 3 Column 0", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row3_1 ("Row 3 Column 1", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row3_2 ("Row 3 Column 2", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row3_3 ("Row 3 Column 3", Range(-1, 1)) = 0
		[HideInInspector] m_end_UVTileDissolveRow3 ("Row 3", Float) = 0
		
		[HideInInspector] m_start_UVTileDissolveRow2 ("Row 2 Alpha", Float) = 0
		_UVTileDissolveAlpha_Row2_0 ("Row 2 Column 0", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row2_1 ("Row 2 Column 1", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row2_2 ("Row 2 Column 2", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row2_3 ("Row 2 Column 3", Range(-1, 1)) = 0
		[HideInInspector] m_end_UVTileDissolveRow2 ("Row 2", Float) = 0
		
		[HideInInspector] m_start_UVTileDissolveRow1 ("Row 1 Alpha", Float) = 0
		_UVTileDissolveAlpha_Row1_0 ("Row 1 Column 0", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row1_1 ("Row 1 Column 1", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row1_2 ("Row 1 Column 2", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row1_3 ("Row 1 Column 3", Range(-1, 1)) = 0
		[HideInInspector] m_end_UVTileDissolveRow1 ("Row 1", Float) = 0
		
		[HideInInspector] m_start_UVTileDissolveRow0 ("Row 0 Alpha", Float) = 0
		_UVTileDissolveAlpha_Row0_0 ("Row 0 Column 0", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row0_1 ("Row 0 Column 1", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row0_2 ("Row 0 Column 2", Range(-1, 1)) = 0
		_UVTileDissolveAlpha_Row0_3 ("Row 0 Column 3", Range(-1, 1)) = 0
		[HideInInspector] m_end_UVTileDissolveRow0 ("Row 0", Float) = 0
		[HideInInspector] m_end_UVTileDissolve ("UV Tile Dissolve", Float) = 0
		
		// Locked in anim sldiers
		[HideInInspector] m_start_BonusSliders ("Locked In Anim Sliders", Float) = 0
		_DissolveAlpha0 ("Dissolve Alpha 0", Range(-1, 1)) = 0
		_DissolveAlpha1 ("Dissolve Alpha 1", Range(-1, 1)) = 0
		_DissolveAlpha2 ("Dissolve Alpha 2", Range(-1, 1)) = 0
		_DissolveAlpha3 ("Dissolve Alpha 3", Range(-1, 1)) = 0
		_DissolveAlpha4 ("Dissolve Alpha 4", Range(-1, 1)) = 0
		_DissolveAlpha5 ("Dissolve Alpha 5", Range(-1, 1)) = 0
		_DissolveAlpha6 ("Dissolve Alpha 6", Range(-1, 1)) = 0
		_DissolveAlpha7 ("Dissolve Alpha 7", Range(-1, 1)) = 0
		_DissolveAlpha8 ("Dissolve Alpha 8", Range(-1, 1)) = 0
		_DissolveAlpha9 ("Dissolve Alpha 9", Range(-1, 1)) = 0
		[HideInInspector] m_end_BonusSliders ("Locked In Sliders", Float) = 0
		[HideInInspector] m_end_dissolve ("Dissolve", Float) = 0
		//endex
		
		//ifex _EnableFlipbook==0
		[HideInInspector] m_start_flipBook ("Flipbook--{reference_property:_EnableFlipbook,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/flipbook},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(_SUNDISK_HIGH_QUALITY)]_EnableFlipbook ("Enable Flipbook", Float) = 0
		[ToggleUI]_FlipbookAlphaControlsFinalAlpha ("Flipbook Controls Alpha", Float) = 0
		[ToggleUI]_FlipbookIntensityControlsAlpha ("Intensity Controls Alpha", Float) = 0
		[ToggleUI]_FlipbookColorReplaces ("Color Replaces Flipbook", Float) = 0
		[TextureArray]_FlipbookTexArray ("Texture Array--{reference_properties:[_FlipbookTexArrayPan, _FlipbookTexArrayUV]}", 2DArray) = "" { }
		[HideInInspector][Vector2]_FlipbookTexArrayPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _FlipbookTexArrayUV ("UV", Int) = 0
		[sRGBWarning]_FlipbookMask ("Mask--{reference_properties:[_FlipbookMaskPan, _FlipbookMaskUV, _FlipbookMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_FlipbookMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _FlipbookMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_FlipbookMaskChannel ("Channel", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _FlipbookMaskGlobalMask ("Global Mask--{reference_property:_FlipbookMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_FlipbookMaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_FlipbookColor ("Color & alpha--{reference_property:_FlipbookColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _FlipbookColorThemeIndex ("", Int) = 0
		// _FlipbookTotalFrames ("Total Frames", Float) = 1
		_FlipbookFPS ("FPS", Float) = 30.0
		_FlipbookFrameOffset("+Frame", Float) = 0
		[VectorLabel(sX, sY, oX, oY)]_FlipbookScaleOffset ("Scale | Offset", Vector) = (1, 1, 0, 0)
		[VectorLabel(L, R, D, U)]_FlipbookSideOffset ("Side Offset", Vector) = (0, 0, 0, 0)
		[ToggleUI]_FlipbookTiled ("Tiled", Float) = 0
		_FlipbookEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		_FlipbookRotation ("Rotation", Range(0, 360)) = 0
		_FlipbookRotationSpeed ("Rotation Speed", Float) = 0
		_FlipbookReplace ("Replace", Range(0, 1)) = 1
		_FlipbookMultiply ("Multiply", Range(0, 1)) = 0
		_FlipbookAdd ("Add", Range(0, 1)) = 0
		// Flipbook Manual Control
		[ThryToggleUI(true)]_FlipbookManualFrameControl ("<size=13><b>  Manual Frame Control</b></size>", Float) = 0
		_FlipbookCurrentFrame ("Current Frame--{ condition_showS:_FlipbookManualFrameControl==1}", Float) = 0
		[ThryToggleUI(true)]_FlipbookStartAndEnd ("<size=13><b>  Start and End Frames</b></size>", Float) = 0
		_FlipbookStartFrame ("Start Frame--{ condition_showS:_FlipbookStartAndEnd==1}", Float) = 0
		_FlipbookEndFrame ("End Frame--{ condition_showS:_FlipbookStartAndEnd==1}", Float) = 0
		[ThryToggleUI(true)]_FlipbookCrossfadeEnabled ("<size=13><b>  Crossfade</b></size>", Float) = 0
		[MultiSlider]_FlipbookCrossfadeRange ("Fade Range--{ condition_showS:_FlipbookCrossfadeEnabled==1}", Vector) = (0.75, 1, 0, 1)
		[ThryToggleUI(true)]_FlipbookHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_FlipbookHueShiftSpeed ("Shift Speed--{ condition_showS:_FlipbookHueShiftEnabled==1}", Float) = 0
		_FlipbookHueShift ("Hue Shift--{ condition_showS:_FlipbookHueShiftEnabled==1}", Range(0, 1)) = 0
		
		//Flipbook audio link
		[HideInInspector] m_start_FlipbookAudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkFlipbookScaleBand ("Scale Band", Int) = 0
		_AudioLinkFlipbookScale ("Scale Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkFlipbookAlphaBand ("Alpha Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkFlipbookAlpha ("Alpha Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkFlipbookEmissionBand ("Emission Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkFlipbookEmission ("Emission Mod", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkFlipbookFrameBand ("Frame Band", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkFlipbookFrame ("Frame control", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[ToggleUI]_FlipbookChronotensityEnabled ("Chronotensity", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _FlipbookChronotensityBand ("Chrono Band--{ condition_showS:_FlipbookChronotensityEnabled==1}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_FlipbookChronoType ("Chrono Type--{ condition_showS:_FlipbookChronotensityEnabled==1}", Int) = 0
		_FlipbookChronotensitySpeed ("Chrono Speed--{ condition_showS:_FlipbookChronotensityEnabled==1}", Float) = 0
		[HideInInspector] m_end_FlipbookAudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_flipBook ("Flipbook", Float) = 0
		//endex
		
		//ifex _EnableEmission==0
		//Emission 1
		[HideInInspector] m_start_emissionOptions ("Emission 0--{reference_property:_EnableEmission,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/emission},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(_EMISSION)]_EnableEmission ("Enable Emission", Float) = 0
		[ToggleUI]_EmissionReplace0 ("Replace Base Color", Float) = 0
		[HDR]_EmissionColor ("Emission Color--{reference_property:_EmissionColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _EmissionColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)][Gradient]_EmissionMap ("Emission Map--{reference_properties:[_EmissionMapPan, _EmissionMapUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMapUV ("UV", Int) = 0
		[ToggleUI]_EmissionBaseColorAsMap ("Base Color as Map", Float) = 0
		[sRGBWarning]_EmissionMask ("Emission Mask--{reference_properties:[_EmissionMaskPan, _EmissionMaskUV, _EmissionMaskChannel, _EmissionMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_EmissionMaskChannel ("Channel", Float) = 0
		[ToggleUI]_EmissionMaskInvert ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _EmissionMask0GlobalMask ("Global Mask--{reference_property:_EmissionMask0GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_EmissionMask0GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_EmissionStrength ("Emission Strength", Range(0, 20)) = 0
		
		[Space(4)]
		[ThryToggleUI(true)]_EmissionHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_EmissionHueShift ("Hue Shift--{condition_showS:(_EmissionHueShiftEnabled==1)}", Range(0, 1)) = 0
		_EmissionHueShiftSpeed ("Hue Shift Speed--{condition_showS:(_EmissionHueShiftEnabled==1)}", Float) = 0
		
		// Center out emission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionCenterOutEnabled ("<size=13><b>  Center Out</b></size>", Float) = 0
		_EmissionCenterOutSpeed ("Flow Speed--{condition_showS:(_EmissionCenterOutEnabled==1)}", Float) = 5
		
		// Glow in the dark Emission
		[Space(4)]
		[ThryToggleUI(true)]_EnableGITDEmission ("<size=13><b>  Light Based</b></size>", Float) = 0
		[Enum(World, 0, Mesh, 1)] _GITDEWorldOrMesh ("Lighting Type--{condition_showS:(_EnableGITDEmission==1)}", Int) = 0
		_GITDEMinEmissionMultiplier ("Min Emission Multiplier--{condition_showS:(_EnableGITDEmission==1)}", Range(0, 1)) = 1
		_GITDEMaxEmissionMultiplier ("Max Emission Multiplier--{condition_showS:(_EnableGITDEmission==1)}", Range(0, 1)) = 0
		_GITDEMinLight ("Min Lighting--{condition_showS:(_EnableGITDEmission==1)}", Range(0, 1)) = 0
		_GITDEMaxLight ("Max Lighting--{condition_showS:(_EnableGITDEmission==1)}", Range(0, 1)) = 1
		
		// Blinking Emission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionBlinkingEnabled ("<size=13><b>  Blinking</b></size>", Float) = 0
		_EmissiveBlink_Min ("Emissive Blink Min--{condition_showS:(_EmissionBlinkingEnabled==1)}", Float) = 0
		_EmissiveBlink_Max ("Emissive Blink Max--{condition_showS:(_EmissionBlinkingEnabled==1)}", Float) = 1
		_EmissiveBlink_Velocity ("Emissive Blink Velocity--{condition_showS:(_EmissionBlinkingEnabled==1)}", Float) = 4
		_EmissionBlinkingOffset ("Offset--{condition_showS:(_EmissionBlinkingEnabled==1)}", Float) = 0
		
		// Scrolling Emission
		[Space(4)]
		[ThryToggleUI(true)] _ScrollingEmission ("<size=13><b>  Scrolling</b></size>", Float) = 0
		[ToggleUI]_EmissionScrollingUseCurve ("Use Curve--{condition_showS:(_ScrollingEmission==1)}", float) = 0
		[Curve]_EmissionScrollingCurve ("Curve--{condition_showS:(_ScrollingEmission==1&&_EmissionScrollingUseCurve==1)}", 2D) = "white" { }
		[ToggleUI]_EmissionScrollingVertexColor ("VColor as position--{condition_showS:(_ScrollingEmission==1)}", float) = 0
		_EmissiveScroll_Direction ("Direction--{condition_showS:(_ScrollingEmission==1)}", Vector) = (0, -10, 0, 0)
		_EmissiveScroll_Width ("Width--{condition_showS:(_ScrollingEmission==1)}", Float) = 10
		_EmissiveScroll_Velocity ("Velocity--{condition_showS:(_ScrollingEmission==1)}", Float) = 10
		_EmissiveScroll_Interval ("Interval--{condition_showS:(_ScrollingEmission==1)}", Float) = 20
		_EmissionScrollingOffset ("Offset--{condition_showS:(_ScrollingEmission==1)}", Float) = 0
		
		[Space(4)]
		[ThryToggleUI(true)] _EmissionAL0Enabled ("<size=13><b>  Audio Link</b></size>--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL0MultipliersBand ("Emission Multiplier Band--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL0Multipliers ("Emission Multiplier--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Vector) = (1, 1, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL0StrengthBand ("Emission Strength Add Band--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL0StrengthMod ("Emission Strength Add--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkEmission0CenterOutBand ("Center Out Band--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkEmission0CenterOut ("Center Out--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		_AudioLinkEmission0CenterOutSize ("Intensity Threshold--{ condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Range(0, 1)) = 0
		_AudioLinkEmission0CenterOutDuration ("Duration--{tooltip:''How much AL history is used. Negative values reverse direction'', condition_showS:(_EmissionAL0Enabled==1 && _EnableAudioLink==1)}", Range(-1, 1)) = 1
		[HideInInspector] m_end_emissionOptions ("", Float) = 0
		//endex
		//ifex _EnableEmission1==0
		// Second Emission
		[HideInInspector] m_start_emission1Options ("Emission 1--{reference_property:_EnableEmission1,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/emission},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_EMISSION_1)]_EnableEmission1 ("Enable Emission 2", Float) = 0
		[ToggleUI]_EmissionReplace1 ("Replace Base Color", Float) = 0
		[HDR]_EmissionColor1 ("Emission Color--{reference_property:_EmissionColor1ThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _EmissionColor1ThemeIndex ("", Int) = 0
		[sRGBWarning(true)][Gradient]_EmissionMap1 ("Emission Map--{reference_properties:[_EmissionMap1Pan, _EmissionMap1UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMap1Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMap1UV ("UV", Int) = 0
		[ToggleUI]_EmissionBaseColorAsMap1 ("Base Color as Map", Float) = 0
		[sRGBWarning]_EmissionMask1 ("Emission Mask--{reference_properties:[_EmissionMask1Pan, _EmissionMask1UV, _EmissionMask1Channel, _EmissionMaskInvert1]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMask1Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMask1UV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_EmissionMask1Channel ("Channel", Float) = 0
		[ToggleUI]_EmissionMaskInvert1 ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _EmissionMask1GlobalMask ("Global Mask--{reference_property:_EmissionMask1GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_EmissionMask1GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_EmissionStrength1 ("Emission Strength", Range(0, 20)) = 0
		
		[Space(4)]
		[ThryToggleUI(true)]_EmissionHueShiftEnabled1 ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_EmissionHueShift1 ("Hue Shift--{condition_showS:(_EmissionHueShiftEnabled1==1)}", Range(0, 1)) = 0
		_EmissionHueShiftSpeed1 ("Hue Shift Speed--{condition_showS:(_EmissionHueShiftEnabled1==1)}", Float) = 0
		
		// Second Center Out Enission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionCenterOutEnabled1 ("<size=13><b>  Center Out</b></size>", Float) = 0
		_EmissionCenterOutSpeed1 ("Flow Speed--{condition_showS:(_EmissionCenterOutEnabled1==1)}", Float) = 5
		
		// Second Glow In The Dark Emission
		[Space(4)]
		[ThryToggleUI(true)]_EnableGITDEmission1 ("<size=13><b>  Light Based</b></size>", Float) = 0
		[Enum(World, 0, Mesh, 1)] _GITDEWorldOrMesh1 ("Lighting Type--{condition_showS:(_EnableGITDEmission1==1)}", Int) = 0
		_GITDEMinEmissionMultiplier1 ("Min Emission Multiplier--{condition_showS:(_EnableGITDEmission1==1)}", Range(0, 1)) = 1
		_GITDEMaxEmissionMultiplier1 ("Max Emission Multiplier--{condition_showS:(_EnableGITDEmission1==1)}", Range(0, 1)) = 0
		_GITDEMinLight1 ("Min Lighting--{condition_showS:(_EnableGITDEmission1==1)}", Range(0, 1)) = 0
		_GITDEMaxLight1 ("Max Lighting--{condition_showS:(_EnableGITDEmission1==1)}", Range(0, 1)) = 1
		
		// Second Blinking Emission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionBlinkingEnabled1 ("<size=13><b>  Blinking</b></size>", Float) = 0
		_EmissiveBlink_Min1 ("Emissive Blink Min--{condition_showS:(_EmissionBlinkingEnabled1==1)}", Float) = 0
		_EmissiveBlink_Max1 ("Emissive Blink Max--{condition_showS:(_EmissionBlinkingEnabled1==1)}", Float) = 1
		_EmissiveBlink_Velocity1 ("Emissive Blink Velocity--{condition_showS:(_EmissionBlinkingEnabled1==1)}", Float) = 4
		_EmissionBlinkingOffset1 ("Offset--{condition_showS:(_EmissionBlinkingEnabled1==1)}", Float) = 0
		
		// Second Scrolling Emission
		[Space(4)]
		[ThryToggleUI(true)] _ScrollingEmission1 ("<size=13><b>  Scrolling</b></size>", Float) = 0
		[ToggleUI]_EmissionScrollingUseCurve1 ("Use Curve--{condition_showS:(_ScrollingEmission1==1)}", float) = 0
		[Curve]_EmissionScrollingCurve1 ("Curve--{condition_showS:(_ScrollingEmission1==1&&_EmissionScrollingUseCurve1==1)}", 2D) = "white" { }
		[ToggleUI]_EmissionScrollingVertexColor1 ("VColor as position--{condition_showS:(_ScrollingEmission1==1)}", float) = 0
		_EmissiveScroll_Direction1 ("Direction--{condition_showS:(_ScrollingEmission1==1)}", Vector) = (0, -10, 0, 0)
		_EmissiveScroll_Width1 ("Width--{condition_showS:(_ScrollingEmission1==1)}", Float) = 10
		_EmissiveScroll_Velocity1 ("Velocity--{condition_showS:(_ScrollingEmission1==1)}", Float) = 10
		_EmissiveScroll_Interval1 ("Interval--{condition_showS:(_ScrollingEmission1==1)}", Float) = 20
		_EmissionScrollingOffset1 ("Offset--{condition_showS:(_ScrollingEmission1==1)}", Float) = 0
		
		[Space(4)]
		[ThryToggleUI(true)] _EmissionAL1Enabled ("<size=13><b>  Audio Link</b></size>--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL1MultipliersBand ("Emission Multiplier Band--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL1Multipliers ("Emission Multiplier--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Vector) = (1, 1, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL1StrengthBand ("Emission Strength Add Band--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL1StrengthMod ("Emission Strength Add--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkEmission1CenterOutBand ("Center Out Band--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkEmission1CenterOut ("Center Out--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		_AudioLinkEmission1CenterOutSize ("Intensity Threshold--{ condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Range(0, 1)) = 0
		_AudioLinkEmission1CenterOutDuration ("Duration--{tooltip:''How much AL history is used. Negative values reverse direction'', condition_showS:(_EmissionAL1Enabled==1 && _EnableAudioLink==1)}", Range(-1, 1)) = 1
		[HideInInspector] m_end_emission1Options ("", Float) = 0
		//endex
		//ifex _EnableEmission2==0
		// Third Emission
		[HideInInspector] m_start_emission2Options ("Emission 2--{reference_property:_EnableEmission2,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/emission},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_EMISSION_2)]_EnableEmission2 ("Enable Emission 2", Float) = 0
		[ToggleUI]_EmissionReplace2 ("Replace Base Color", Float) = 0
		[HDR]_EmissionColor2 ("Emission Color--{reference_property:_EmissionColor2ThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _EmissionColor2ThemeIndex ("", Int) = 0
		[Gradient]_EmissionMap2 ("Emission Map--{reference_properties:[_EmissionMap2Pan, _EmissionMap2UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMap2Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMap2UV ("UV", Int) = 0
		[ToggleUI]_EmissionBaseColorAsMap2 ("Base Color as Map", Float) = 0
		[sRGBWarning]_EmissionMask2 ("Emission Mask--{reference_properties:[_EmissionMask2Pan, _EmissionMask2UV, _EmissionMask2Channel, _EmissionMaskInvert2]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMask2Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMask2UV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_EmissionMask2Channel ("Channel", Float) = 0
		[ToggleUI]_EmissionMaskInvert2 ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _EmissionMask2GlobalMask ("Global Mask--{reference_property:_EmissionMask2GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_EmissionMask2GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_EmissionStrength2 ("Emission Strength", Range(0, 20)) = 0
		
		[Space(4)]
		[ThryToggleUI(true)]_EmissionHueShiftEnabled2 ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_EmissionHueShift2 ("Hue Shift--{condition_showS:(_EmissionHueShiftEnabled2==1)}", Range(0, 1)) = 0
		_EmissionHueShiftSpeed2 ("Hue Shift Speed--{condition_showS:(_EmissionHueShiftEnabled2==1)}", Float) = 0
		
		// Third Center Out Enission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionCenterOutEnabled2 ("<size=13><b>  Center Out</b></size>", Float) = 0
		_EmissionCenterOutSpeed2 ("Flow Speed--{condition_showS:(_EmissionCenterOutEnabled2==1)}", Float) = 5
		
		// Third Glow In The Dark Emission
		[Space(4)]
		[ThryToggleUI(true)]_EnableGITDEmission2 ("<size=13><b>  Light Based</b></size>", Float) = 0
		[Enum(World, 0, Mesh, 1)] _GITDEWorldOrMesh2 ("Lighting Type--{condition_showS:(_EnableGITDEmission2==1)}", Int) = 0
		_GITDEMinEmissionMultiplier2 ("Min Emission Multiplier--{condition_showS:(_EnableGITDEmission2==1)}", Range(0, 1)) = 1
		_GITDEMaxEmissionMultiplier2 ("Max Emission Multiplier--{condition_showS:(_EnableGITDEmission2==1)}", Range(0, 1)) = 0
		_GITDEMinLight2 ("Min Lighting--{condition_showS:(_EnableGITDEmission2==1)}", Range(0, 1)) = 0
		_GITDEMaxLight2 ("Max Lighting--{condition_showS:(_EnableGITDEmission2==1)}", Range(0, 1)) = 1
		
		// Third Blinking Emission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionBlinkingEnabled2 ("<size=13><b>  Blinking</b></size>", Float) = 0
		_EmissiveBlink_Min2 ("Emissive Blink Min--{condition_showS:(_EmissionBlinkingEnabled2==1)}", Float) = 0
		_EmissiveBlink_Max2 ("Emissive Blink Max--{condition_showS:(_EmissionBlinkingEnabled2==1)}", Float) = 1
		_EmissiveBlink_Velocity2 ("Emissive Blink Velocity--{condition_showS:(_EmissionBlinkingEnabled2==1)}", Float) = 4
		_EmissionBlinkingOffset2 ("Offset--{condition_showS:(_EmissionBlinkingEnabled2==1)}", Float) = 0
		
		// Third Scrolling Emission
		[Space(4)]
		[ThryToggleUI(true)] _ScrollingEmission2 ("<size=13><b>  Scrolling</b></size>", Float) = 0
		[ToggleUI]_EmissionScrollingUseCurve2 ("Use Curve--{condition_showS:(_ScrollingEmission2==1)}", float) = 0
		[Curve]_EmissionScrollingCurve2 ("Curve--{condition_showS:(_ScrollingEmission1==1&&_EmissionScrollingUseCurve2==1)}", 2D) = "white" { }
		[ToggleUI]_EmissionScrollingVertexColor2 ("VColor as position--{condition_showS:(_ScrollingEmission2==1)}", float) = 0
		_EmissiveScroll_Direction2 ("Direction--{condition_showS:(_ScrollingEmission2==1)}", Vector) = (0, -10, 0, 0)
		_EmissiveScroll_Width2 ("Width--{condition_showS:(_ScrollingEmission2==1)}", Float) = 10
		_EmissiveScroll_Velocity2 ("Velocity--{condition_showS:(_ScrollingEmission2==1)}", Float) = 10
		_EmissiveScroll_Interval2 ("Interval--{condition_showS:(_ScrollingEmission2==1)}", Float) = 20
		_EmissionScrollingOffset2 ("Offset--{condition_showS:(_ScrollingEmission2==1)}", Float) = 0
		
		[Space(4)]
		[ThryToggleUI(true)] _EmissionAL2Enabled ("<size=13><b>  Audio Link</b></size>--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL2MultipliersBand ("Emission Multiplier Band--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL2Multipliers ("Emission Multiplier--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Vector) = (1, 1, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL2StrengthBand ("Emission Strength Add Band--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL2StrengthMod ("Emission Strength Add--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkEmission2CenterOutBand ("Center Out Band--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Int) = 0[VectorLabel(Min, Max)] _AudioLinkEmission2CenterOut ("Center Out--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		_AudioLinkEmission2CenterOutSize ("Intensity Threshold--{ condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Range(0, 1)) = 0
		_AudioLinkEmission2CenterOutDuration ("Duration--{tooltip:''How much AL history is used. Negative values reverse direction'', condition_showS:(_EmissionAL2Enabled==1 && _EnableAudioLink==1)}", Range(-1, 1)) = 1
		[HideInInspector] m_end_emission2Options ("", Float) = 0
		//endex
		
		//ifex _EnableEmission3==0
		// Fourth Emission
		[HideInInspector] m_start_emission3Options ("Emission 3--{reference_property:_EnableEmission3,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/emission},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_EMISSION_3)]_EnableEmission3 ("Enable Emission 3", Float) = 0
		[ToggleUI]_EmissionReplace3 ("Replace Base Color", Float) = 0
		[HDR]_EmissionColor3 ("Emission Color--{reference_property:_EmissionColor3ThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _EmissionColor3ThemeIndex ("", Int) = 0
		[sRGBWarning(true)][Gradient]_EmissionMap3 ("Emission Map--{reference_properties:[_EmissionMap3Pan, _EmissionMap3UV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMap3Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMap3UV ("UV", Int) = 0
		[ToggleUI]_EmissionBaseColorAsMap3 ("Base Color as Map", Float) = 0
		[sRGBWarning]_EmissionMask3 ("Emission Mask--{reference_properties:[_EmissionMask3Pan, _EmissionMask3UV, _EmissionMask3Channel, _EmissionMaskInvert3]}", 2D) = "white" { }
		[HideInInspector][Vector2]_EmissionMask3Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _EmissionMask3UV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_EmissionMask3Channel ("Channel", Float) = 0
		[ToggleUI]_EmissionMaskInvert3 ("Invert", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _EmissionMask3GlobalMask ("Global Mask--{reference_property:_EmissionMask3GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_EmissionMask3GlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_EmissionStrength3 ("Emission Strength", Range(0, 20)) = 0
		
		[Space(4)]
		[ThryToggleUI(true)]_EmissionHueShiftEnabled3 ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_EmissionHueShift3 ("Hue Shift--{condition_showS:(_EmissionHueShiftEnabled3==1)}", Range(0, 1)) = 0
		_EmissionHueShiftSpeed3 ("Hue Shift Speed--{condition_showS:(_EmissionHueShiftEnabled3==1)}", Float) = 0
		
		// Fourth Center Out Enission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionCenterOutEnabled3 ("<size=13><b>  Center Out</b></size>", Float) = 0
		_EmissionCenterOutSpeed3 ("Flow Speed--{condition_showS:(_EmissionCenterOutEnabled3==1)}", Float) = 5
		
		// Fourth Glow In The Dark Emission
		[Space(4)]
		[ThryToggleUI(true)]_EnableGITDEmission3 ("<size=13><b>  Light Based</b></size>", Float) = 0
		[Enum(World, 0, Mesh, 1)] _GITDEWorldOrMesh3 ("Lighting Type--{condition_showS:(_EnableGITDEmission3==1)}", Int) = 0
		_GITDEMinEmissionMultiplier3 ("Min Emission Multiplier--{condition_showS:(_EnableGITDEmission3==1)}", Range(0, 1)) = 1
		_GITDEMaxEmissionMultiplier3 ("Max Emission Multiplier--{condition_showS:(_EnableGITDEmission3==1)}", Range(0, 1)) = 0
		_GITDEMinLight3 ("Min Lighting--{condition_showS:(_EnableGITDEmission3==1)}", Range(0, 1)) = 0
		_GITDEMaxLight3 ("Max Lighting--{condition_showS:(_EnableGITDEmission3==1)}", Range(0, 1)) = 1
		
		// Fourth Blinking Emission
		[Space(4)]
		[ThryToggleUI(true)]_EmissionBlinkingEnabled3 ("<size=13><b>  Blinking</b></size>", Float) = 0
		_EmissiveBlink_Min3 ("Emissive Blink Min--{condition_showS:(_EmissionBlinkingEnabled3==1)}", Float) = 0
		_EmissiveBlink_Max3 ("Emissive Blink Max--{condition_showS:(_EmissionBlinkingEnabled3==1)}", Float) = 1
		_EmissiveBlink_Velocity3 ("Emissive Blink Velocity--{condition_showS:(_EmissionBlinkingEnabled3==1)}", Float) = 4
		_EmissionBlinkingOffset3 ("Offset--{condition_showS:(_EmissionBlinkingEnabled3==1)}", Float) = 0
		
		// Fourth Scrolling Emission
		[Space(4)]
		[ThryToggleUI(true)] _ScrollingEmission3 ("<size=13><b>  Scrolling</b></size>", Float) = 0
		[ToggleUI]_EmissionScrollingUseCurve3 ("Use Curve--{condition_showS:(_ScrollingEmission3==1)}", float) = 0
		[Curve]_EmissionScrollingCurve3 ("Curve--{condition_showS:(_ScrollingEmission1==1&&_EmissionScrollingUseCurve3==1)}", 2D) = "white" { }
		[ToggleUI]_EmissionScrollingVertexColor3 ("VColor as position--{condition_showS:(_ScrollingEmission3==1)}", float) = 0
		_EmissiveScroll_Direction3 ("Direction--{condition_showS:(_ScrollingEmission3==1)}", Vector) = (0, -10, 0, 0)
		_EmissiveScroll_Width3 ("Width--{condition_showS:(_ScrollingEmission3==1)}", Float) = 10
		_EmissiveScroll_Velocity3 ("Velocity--{condition_showS:(_ScrollingEmission3==1)}", Float) = 10
		_EmissiveScroll_Interval3 ("Interval--{condition_showS:(_ScrollingEmission3==1)}", Float) = 20
		_EmissionScrollingOffset3 ("Offset--{condition_showS:(_ScrollingEmission3==1)}", Float) = 0
		
		[Space(4)]
		[ThryToggleUI(true)] _EmissionAL3Enabled ("<size=13><b>  Audio Link</b></size>--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL3MultipliersBand ("Emission Multiplier Band--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL3Multipliers ("Emission Multiplier--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Vector) = (1, 1, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _EmissionAL3StrengthBand ("Emission Strength Add Band--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)]_EmissionAL3StrengthMod ("Emission Strength Add--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkEmission3CenterOutBand ("Center Out Band--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Int) = 0
		[VectorLabel(Min, Max)] _AudioLinkEmission3CenterOut ("Center Out--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Vector) = (0, 0, 0, 0)
		_AudioLinkEmission3CenterOutSize ("Intensity Threshold--{ condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Range(0, 1)) = 0
		_AudioLinkEmission3CenterOutDuration ("Duration--{tooltip:''How much AL history is used. Negative values reverse direction'', condition_showS:(_EmissionAL3Enabled==1 && _EnableAudioLink==1)}", Range(-1, 1)) = 1
		[HideInInspector] m_end_emission3Options ("", Float) = 0
		//endex
		
		// Glitter
		//ifex _GlitterEnable==0
		[HideInInspector] m_start_glitter ("Glitter / Sparkle--{reference_property:_GlitterEnable,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/glitter},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(_SUNDISK_SIMPLE)]_GlitterEnable ("Enable Glitter", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _GlitterUV ("UV", Int) = 0
		[Enum(Angle, 0, Linear Emission, 1, Light Reflections, 2)]_GlitterMode ("Mode", Int) = 0
		[Enum(Circle, 0, Square, 1)]_GlitterShape ("Shape", Int) = 0
		[Enum(Add, 0, Replace, 1)] _GlitterBlendType ("Blend Mode", Int) = 0
		_GlitterUseNormals ("Use Normals", Range(0, 1)) = 0
		[HDR]_GlitterColor ("Color--{reference_property:_GlitterColorThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _GlitterColorThemeIndex ("", Int) = 0
		_GlitterUseSurfaceColor ("Use Surface Color", Range(0, 1)) = 0
		[sRGBWarning(true)]_GlitterColorMap ("Glitter Color Map--{reference_properties:[_GlitterColorMapPan, _GlitterColorMapUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlitterColorMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _GlitterColorMapUV ("UV", Int) = 0
		[HideInInspector][Vector2]_GlitterPan ("Panning", Vector) = (0, 0, 0, 0)
		[sRGBWarning]_GlitterMask ("Glitter Mask--{reference_properties:[_GlitterMaskPan, _GlitterMaskUV, _GlitterMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlitterMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _GlitterMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_GlitterMaskChannel ("Channel", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _GlitterMaskGlobalMask ("Global Mask--{reference_property:_GlitterMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_GlitterMaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		_GlitterTexture ("Glitter Texture--{reference_properties:[_GlitterTexturePan]}", 2D) = "white" { }
		[HideInInspector][Vector2]_GlitterTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[Vector2]_GlitterUVPanning ("Panning Speed", Vector) = (0, 0, 0, 0)
		_GlitterTextureRotation ("Rotation Speed", Float) = 0
		_GlitterFrequency ("Glitter Density", Float) = 300.0
		_GlitterJitter ("Glitter Jitter", Range(0, 1)) = 1.0
		_GlitterSpeed ("Glitter Speed", Float) = 10.0
		_GlitterSize ("Glitter Size", Range(0, 1)) = .3
		_GlitterContrast ("Glitter Contrast--{condition_showS:(_GlitterMode==0||_GlitterMode==2)}", Range(1, 1000)) = 300
		_GlitterAngleRange ("Glitter Angle Range--{condition_showS:(_GlitterMode==0||_GlitterMode==2)}", Range(0, 90)) = 90
		_GlitterMinBrightness ("Glitter Min Brightness", Range(0, 1)) = 0
		_GlitterBrightness ("Glitter Max Brightness", Range(0, 40)) = 3
		_GlitterBias ("Glitter Bias--{condition_show:(_GlitterMode==0)}", Range(0, 1)) = .8
		_GlitterHideInShadow ("Hide in shadow", Range(0, 1)) = 0
		_GlitterCenterSize ("dim light--{condition_show:{type:AND,condition1:{type:PROPERTY_BOOL,data:_GlitterMode==1},condition2:{type:PROPERTY_BOOL,data:_GlitterShape==1}}}", Range(0, 1)) = .08
		_glitterFrequencyLinearEmissive ("Frequency--{condition_show:{type:PROPERTY_BOOL,data:_GlitterMode==1}}", Range(0, 100)) = 20
		_GlitterJaggyFix ("Jaggy Fix--{condition_show:{type:PROPERTY_BOOL,data:_GlitterShape==1}}", Range(0, .1)) = .0
		
		[Space(10)]
		[ThryToggleUI(true)]_GlitterHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_GlitterHueShiftSpeed ("Shift Speed--{condition_showS:(_GlitterHueShiftEnabled==1)}", Float) = 0
		_GlitterHueShift ("Hue Shift--{condition_showS:(_GlitterHueShiftEnabled==1)}", Range(0, 1)) = 0
		
		[HideInInspector] m_start_GlitterRandomStuff ("Random Stuff", Float) = 0
		
		[ToggleUI]_GlitterRandomColors ("Random Colors", Float) = 0
		[MultiSlider]_GlitterMinMaxSaturation ("Saturation Range", Vector) = (0.8, 1, 0, 1)
		[MultiSlider]_GlitterMinMaxBrightness ("Brightness Range", Vector) = (0.8, 1, 0, 1)
		[ToggleUI]_GlitterRandomSize ("Random Size", Float) = 0
		[MultiSlider]_GlitterMinMaxSize ("Size Range", Vector) = (0.1, 0.5, 0, 1)
		[ToggleUI]_GlitterRandomRotation ("Random Tex Rotation", Float) = 0
		
		[HideInInspector] m_end_GlitterRandomStuff ("Random Stuff", Float) = 0
		
		[HideInInspector] m_end_glitter ("Glitter / Sparkle", Float) = 0
		//endex
		
		//ifex _EnablePathing==0
		[HideInInspector] m_start_pathing ("Pathing--{reference_property: _EnablePathing,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/pathing},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_PATHING)] _EnablePathing ("Enable Pathing", Float) = 0
		[Enum(Split Channels, 0, Merged Channels, 1)]_PathGradientType ("Gradient Type", Float) = 0
		[ToggleUI]_PathingOverrideAlpha ("Override alpha", Float) = 0
		//[ThryExternalTextureToolDrawer(Flood Tool, DreadScripts.GradientFlood)]
		[sRGBWarning][ThryRGBAPacker(R Path, G Path, B Path, A Path)]_PathingMap ("RGBA Path Map--{reference_properties:[_PathingMapPan, _PathingMapUV]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_PathingMapUV ("UV", Int) = 0
		[HideInInspector][Vector2]_PathingMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[sRGBWarning(true)][ThryRGBAPacker(1, RGB Color, A Mask, 1)]_PathingColorMap ("Color & Mask (Expand)--{reference_properties:[_PathingColorMapPan, _PathingColorMapUV]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_PathingColorMapUV ("UV", Int) = 0
		[HideInInspector][Vector2]_PathingColorMapPan ("Panning", Vector) = (0, 0, 0, 0)
		
		[Enum(Fill, 0, Path, 1, Loop, 2)]_PathTypeR ("R Path Type", Float) = 0
		[Enum(Fill, 0, Path, 1, Loop, 2)]_PathTypeG ("G Path Type", Float) = 0
		[Enum(Fill, 0, Path, 1, Loop, 2)]_PathTypeB ("B Path Type", Float) = 0
		[Enum(Fill, 0, Path, 1, Loop, 2)]_PathTypeA ("A Path Type", Float) = 0
		
		[HDR]_PathColorR ("R Color--{reference_property:_PathColorRThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _PathColorRThemeIndex ("", Int) = 0
		[HDR]_PathColorG ("G Color--{reference_property:_PathColorGThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _PathColorGThemeIndex ("", Int) = 0
		[HDR]_PathColorB ("B Color--{reference_property:_PathColorBThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _PathColorBThemeIndex ("", Int) = 0
		[HDR]_PathColorA ("A Color--{reference_property:_PathColorAThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _PathColorAThemeIndex ("", Int) = 0
		
		[VectorLabel(R,G,B,A)]_PathEmissionStrength ("Emission Strength", Vector) = (0.0, 0.0, 0.0, 0.0)
		[VectorLabel(R,G,B,A)]_PathSoftness ("Softness", Vector) = (1, 1, 1, 1)
		[VectorLabel(R,G,B,A)]_PathSpeed ("Speed", Vector) = (1.0, 1.0, 1.0, 1.0)
		[VectorLabel(R,G,B,A)]_PathWidth ("Length", Vector) = (0.03, 0.03, 0.03, 0.03)
		
		[Header(Timing Options)]
		[VectorLabel(R,G,B,A)]_PathTime ("Manual Timing", Vector) = (-999.0, -999.0, -999.0, -999.0)
		[VectorLabel(R,G,B,A)]_PathOffset ("Timing Offset", Vector) = (0.0, 0.0, 0.0, 0.0)
		[VectorLabel(R,G,B,A)]_PathSegments ("Path Segments", Vector) = (0.0, 0.0, 0.0, 0.0)
		
		[HideInInspector] m_start_PathAudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		// Time Offsets
		[ThryToggleUI(true)]_PathALTimeOffset ("<size=13><b>  Time Offset</b></size>", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathTimeOffsetBandR ("Band	R--{condition_showS:(_PathALTimeOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathTimeOffsetR ("Offset	R--{condition_showS:(_PathALTimeOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathTimeOffsetBandG ("Band	G--{condition_showS:(_PathALTimeOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathTimeOffsetG ("Offset	G--{condition_showS:(_PathALTimeOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathTimeOffsetBandB ("Band	B--{condition_showS:(_PathALTimeOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathTimeOffsetB ("Offset	B--{condition_showS:(_PathALTimeOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathTimeOffsetBandA ("Band	A--{condition_showS:(_PathALTimeOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathTimeOffsetA ("Offset	A--{condition_showS:(_PathALTimeOffset==1)}", Vector) = (0, 0, 0)
		[Space(4)]
		[ThryToggleUI(true)]_PathALEmissionOffset ("<size=13><b>  Emission Offset</b></size>", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathEmissionAddBandR ("Band	R--{condition_showS:(_PathALEmissionOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathEmissionAddR ("Offset	R--{condition_showS:(_PathALEmissionOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathEmissionAddBandG ("Band	G--{condition_showS:(_PathALEmissionOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathEmissionAddG ("Offset	G--{condition_showS:(_PathALEmissionOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathEmissionAddBandB ("Band	B--{condition_showS:(_PathALEmissionOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathEmissionAddB ("Offset	B--{condition_showS:(_PathALEmissionOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathEmissionAddBandA ("Band	A--{condition_showS:(_PathALEmissionOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathEmissionAddA ("Offset	A--{condition_showS:(_PathALEmissionOffset==1)}", Vector) = (0, 0, 0)
		[Space(4)]
		[ThryToggleUI(true)]_PathALWidthOffset ("<size=13><b>  Width Offset</b></size>", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathWidthOffsetBandR ("Band	R--{condition_showS:(_PathALWidthOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathWidthOffsetR ("Offset	R--{condition_showS:(_PathALWidthOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathWidthOffsetBandG ("Band	G--{condition_showS:(_PathALWidthOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathWidthOffsetG ("Offset	G--{condition_showS:(_PathALWidthOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathWidthOffsetBandB ("Band	B--{condition_showS:(_PathALWidthOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathWidthOffsetB ("Offset	B--{condition_showS:(_PathALWidthOffset==1)}", Vector) = (0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _AudioLinkPathWidthOffsetBandA ("Band	A--{condition_showS:(_PathALWidthOffset==1)}", Int) = 0
		[VectorLabel(Min, Max)]_AudioLinkPathWidthOffsetA ("Offset	A--{condition_showS:(_PathALWidthOffset==1)}", Vector) = (0, 0, 0)
		[Space(4)]
		[ThryToggleUI(true)]_PathALHistory ("<size=13><b>  History</b></size>", Float) = 0
		[Enum(Mask, 0, Override, 1)] _PathALHistoryMode ("History Mode--{condition_showS:(_PathALHistory==1)}", Float) = 0
		
		[ToggleUI]_PathALHistoryR ("R History--{condition_showS:(_PathALHistory==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathALHistoryBandR ("R Band--{condition_showS:(_PathALHistory==1 && _PathALHistoryR==1)}", Int) = 0
		[MultiSlider]_PathALHistoryRangeR ("R Range--{condition_showS:(_PathALHistory==1 && _PathALHistoryR==1)}", Vector) = (0, 1, 0, 1)
		
		[ToggleUI]_PathALHistoryG ("G History--{condition_showS:(_PathALHistory==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathALHistoryBandG ("G Band--{condition_showS:(_PathALHistory==1 && _PathALHistoryG==1)}", Int) = 0
		[MultiSlider]_PathALHistoryRangeG ("G Range--{condition_showS:(_PathALHistory==1 && _PathALHistoryG==1)}", Vector) = (0, 1, 0, 1)
		
		[ToggleUI]_PathALHistoryB ("B History--{condition_showS:(_PathALHistory==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathALHistoryBandB ("B Band--{condition_showS:(_PathALHistory==1 && _PathALHistoryB==1)}", Int) = 0
		[MultiSlider]_PathALHistoryRangeB ("B Range--{condition_showS:(_PathALHistory==1 && _PathALHistoryB==1)}", Vector) = (0, 1, 0, 1)
		
		[ToggleUI]_PathALHistoryA ("A History--{condition_showS:(_PathALHistory==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathALHistoryBandA ("A Band--{condition_showS:(_PathALHistory==1 && _PathALHistoryA==1)}", Int) = 0
		[MultiSlider]_PathALHistoryRangeA ("A Range--{condition_showS:(_PathALHistory==1 && _PathALHistoryA==1)}", Vector) = (0, 1, 0, 1)
		[Space(4)]
		[ThryToggleUI(true)]_PathALChrono ("<size=13><b>  Chrono Time</b></size>", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathChronoBandR ("R Band--{condition_showS:(_PathALChrono==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_PathChronoTypeR ("R Motion Type--{condition_showS:(_PathALChrono==1)}", Int) = 0
		_PathChronoSpeedR ("R Speed--{condition_showS:(_PathALChrono==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathChronoBandG ("G Band--{condition_showS:(_PathALChrono==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_PathChronoTypeG ("G Motion Type--{condition_showS:(_PathALChrono==1)}", Int) = 0
		_PathChronoSpeedG ("G Speed--{condition_showS:(_PathALChrono==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathChronoBandB ("B Band--{condition_showS:(_PathALChrono==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_PathChronoTypeB ("B Motion Type--{condition_showS:(_PathALChrono==1)}", Int) = 0
		_PathChronoSpeedB ("B Speed--{condition_showS:(_PathALChrono==1)}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _PathChronoBandA ("A Band--{condition_showS:(_PathALChrono==1)}", Int) = 0
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_PathChronoTypeA ("A Motion Type--{condition_showS:(_PathALChrono==1)}", Int) = 0
		_PathChronoSpeedA ("A Speed--{condition_showS:(_PathALChrono==1)}", Float) = 0
		[Space(4)]
		[ThryToggleUI(true)]_PathALAutoCorrelator ("<size=13><b>  Auto Correlator</b></size>", Float) = 0
		[Enum(Mask, 0, Override, 1)] _PathALAutoCorrelatorMode ("Autocorrelator Mode--{condition_showS:(_PathALAutoCorrelator==1)}", Float) = 0
		[Enum(Off, 0, On, 1, Mirrored, 2)]_PathALAutoCorrelatorR ("R Type--{condition_showS:(_PathALAutoCorrelator==1)}", Int) = 0
		[MultiSlider]_PathALAutoCorrelatorRangeR ("R Range--{condition_showS:(_PathALAutoCorrelator==1 && _PathALAutoCorrelatorR > 0)}", Vector) = (0.1, .9, 0, 1)
		[Enum(Off, 0, On, 1, Mirrored, 2)]_PathALAutoCorrelatorG ("G Type--{condition_showS:(_PathALAutoCorrelator==1)}", Int) = 0
		[MultiSlider]_PathALAutoCorrelatorRangeG ("G Range--{condition_showS:(_PathALAutoCorrelator==1 && _PathALAutoCorrelatorG > 0)}", Vector) = (0.1, .9, 0, 1)
		[Enum(Off, 0, On, 1, Mirrored, 2)]_PathALAutoCorrelatorB ("B Type--{condition_showS:(_PathALAutoCorrelator==1)}", Int) = 0
		[MultiSlider]_PathALAutoCorrelatorRangeB ("B Range--{condition_showS:(_PathALAutoCorrelator==1 && _PathALAutoCorrelatorB > 0)}", Vector) = (0.1, 0.9, 0, 1)
		[Enum(Off, 0, On, 1, Mirrored, 2)]_PathALAutoCorrelatorA ("A Type--{condition_showS:(_PathALAutoCorrelator==1)}", Int) = 0
		[MultiSlider]_PathALAutoCorrelatorRangeA ("A Range--{condition_showS:(_PathALAutoCorrelator==1 && _PathALAutoCorrelatorA > 0)}", Vector) = (0.1, 0.9, 0, 1)
		[Space(4)]
		[ThryToggleUI(true)]_PathALColorChord ("<size=13><b>  Color Chord</b></size>", Float) = 0
		[ToggleUI]_PathALCCR ("R Color Chord Strip--{condition_showS:(_PathALColorChord==1)}", Float) = 0
		[ToggleUI]_PathALCCG ("G Color Chord Strip--{condition_showS:(_PathALColorChord==1)}", Float) = 0
		[ToggleUI]_PathALCCB ("B Color Chord Strip--{condition_showS:(_PathALColorChord==1)}", Float) = 0
		[ToggleUI]_PathALCCA ("A Color Chord Strip--{condition_showS:(_PathALColorChord==1)}", Float) = 0
		[HideInInspector] m_end_PathAudioLink ("", Float) = 0
		[HideInInspector] m_end_pathing ("", Float) = 0
		//endex
		
		//ifex _EnableMirrorOptions==0
		[HideInInspector] m_start_mirrorOptions ("Mirror/Camera Visibility--{reference_property:_EnableMirrorOptions,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/mirror},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_MIRROR)]_EnableMirrorOptions ("Enable Mirror Options", Float) = 0
		[ThryWideEnum(Generic, 0, VRC, 1)] _VisibilityMode ("Mode", Int) = 1
		[ThryWideEnum(Show In Both, 0, Show Only In Mirror, 1, Dont Show In Mirror, 2)] _Mirror ("Mirror Visibility--{condition_showS:(_VisibilityMode==0)}", Int) = 0
		[ThryToggleUI(True)]_VisibilityVRCRegular 			("Normal (Outside Mirror/Camera)--{condition_showS:(_VisibilityMode==1)}", Int) = 1
		[ThryToggleUI(True)]_VisibilityVRCMirrorVR 			("Mirror (VR)--{condition_showS:(_VisibilityMode==1)}", Int) = 1
		[ThryToggleUI(True)]_VisibilityVRCMirrorDesktop 	("Mirror (Desktop)--{condition_showS:(_VisibilityMode==1)}", Int) = 1
		[ThryToggleUI(True)]_VisibilityVRCCameraVR 			("Camera (VR)--{condition_showS:(_VisibilityMode==1)}", Int) = 1
		[ThryToggleUI(True)]_VisibilityVRCCameraDesktop 	("Camera (Desktop)--{condition_showS:(_VisibilityMode==1)}", Int) = 1
		[ThryToggleUI(True)]_VisibilityVRCCameraScreenshot 	("Screenshot--{condition_showS:(_VisibilityMode==1)}", Int) = 1
		_MirrorColor ("Mirror Tint Color--{reference_property:_MirrorColorThemeIndex}", Color) = (1, 1, 1, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _MirrorColorThemeIndex ("", Int) = 0
		[sRGBWarning(true)]_MirrorTexture ("Mirror Texture--{reference_properties:[_MirrorTexturePan, _MirrorTextureUV, _MirrorTextureBlendType]}", 2D) = "white" { }
		[HideInInspector][Vector2]_MirrorTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _MirrorTextureUV("UV", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_MirrorTextureBlendType ("Blending", Range(0, 1)) = 0
		[HideInInspector] m_end_mirrorOptions ("Mirror", Float) = 0
		//endex
		
		//ifex _EnableTouchGlow==0
		[HideInInspector] m_start_depthFX ("Depth FX--{reference_property:_EnableTouchGlow}", Float) = 0
		[HideInInspector][ThryToggle(GRAIN)]_EnableTouchGlow ("Enable Depth FX", Float) = 0
		[Helpbox(1)]_DepthFXWarning ("Depth FX doesn't write to depth, which can break certain transparent effects like custom fog and raymarching", Int) = 0
		[sRGBWarning]_DepthMask ("Mask--{reference_properties:[_DepthMaskPan, _DepthMaskUV, _DepthMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DepthMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _DepthMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_DepthMaskChannel ("Channel", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _DepthMaskGlobalMask ("Global Mask--{reference_property:_DepthMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_DepthMaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		
		[Space(10)]
		[ThryToggleUI(true)]_DepthColorToggle ("<size=13><b>  Color & Emission</b></size>", Float) = 0
		[ThryWideEnum(Replace, 0, Multiply, 1, Add, 2)] _DepthColorBlendMode ("Blend Type--{condition_showS:(_DepthColorToggle==1)}", Int) = 0
		[sRGBWarning(true)]_DepthTexture ("Depth Texture--{reference_properties:[_DepthTexturePan, _DepthTextureUV], condition_showS:(_DepthColorToggle==1)}", 2D) = "white" { }
		[HideInInspector][Vector2]_DepthTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7, Depth Gradient, 8)] _DepthTextureUV ("UV", Int) = 0
		_DepthColor ("Color--{condition_showS:(_DepthColorToggle==1), reference_property:_DepthColorThemeIndex}", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _DepthColorThemeIndex ("", Int) = 0
		_DepthEmissionStrength ("Emission Strength--{condition_showS:(_DepthColorToggle==1)}", Range(0, 20)) = 0
		_DepthColorMinDepth ("Min Depth--{condition_showS:(_DepthColorToggle==1)}", Float) = 0
		_DepthColorMaxDepth ("Max Depth--{condition_showS:(_DepthColorToggle==1)}", Float) = 1
		_DepthColorMinValue ("Min Color Blend--{condition_showS:(_DepthColorToggle==1)}", Range(0, 1)) = 0
		_DepthColorMaxValue ("Max Color Blend--{condition_showS:(_DepthColorToggle==1)}", Range(0, 1)) = 1
		
		[Space(10)]
		[ThryToggleUI(true)]_DepthAlphaToggle ("<size=13><b>  Alpha</b></size>", Float) = 0
		_DepthAlphaMinDepth ("Min Depth--{condition_showS:(_DepthAlphaToggle==1)}", Float) = 0
		_DepthAlphaMaxDepth ("Max Depth--{condition_showS:(_DepthAlphaToggle==1)}", Float) = 1
		_DepthAlphaMinValue ("Min Alpha--{condition_showS:(_DepthAlphaToggle==1)}", Range(0, 1)) = 1
		_DepthAlphaMaxValue ("Max Alpha--{condition_showS:(_DepthAlphaToggle==1)}", Range(0, 1)) = 0
		[HideInInspector] m_end_depthFX ("Depth FX", Float) = 0
		//endex
		
		//ifex _EnableIridescence==0
		[HideInInspector] m_start_Iridescence ("Iridescence--{reference_property:_EnableIridescence,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/iridescence},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POI_IRIDESCENCE)]_EnableIridescence ("Enable Iridescence", Float) = 0
		[sRGBWarning(true)][Gradient]_IridescenceRamp ("Ramp--{reference_properties:[_IridescenceRampPan]}", 2D) = "white" { }
		[HideInInspector][Vector2]_IridescenceRampPan ("Panning", Vector) = (0, 0, 0, 0)
		
		[sRGBWarning]_IridescenceMask ("Mask--{reference_properties:[_IridescenceMaskPan, _IridescenceMaskUV, _IridescenceMaskChannel, _IridescenceMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_IridescenceMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_IridescenceMaskUV ("Mask UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_IridescenceMaskChannel ("Channel", Float) = 0
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _IridescenceMaskGlobalMask ("Global Mask--{reference_property:_IridescenceMaskGlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Add, 7, Subtract, 1, Multiply, 2, Divide, 3, Min, 4, Max, 5, Average, 6 , Replace, 0)]_IridescenceMaskGlobalMaskBlendType ("Blending", Range(0, 1)) = 2
		[ToggleUI]_IridescenceMaskInvert ("Invert", Float) = 0
		[ToggleUI]_IridescenceNormalToggle ("Custom Normals", Float) = 0
		[Normal]_IridescenceNormalMap ("Normal Map--{reference_properties:[_IridescenceNormalIntensity, _IridescenceNormalMapPan, _IridescenceNormalMapUV]}", 2D) = "bump" { }
		[HideInInspector]_IridescenceNormalIntensity ("Normal Intensity", Range(0, 10)) = 1
		[HideInInspector][Vector2]_IridescenceNormalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_IridescenceNormalMapUV ("Normal UV", Int) = 0
		[Enum(Vertex, 0, Pixel, 1)] _IridescenceNormalSelection ("Normal Select", Int) = 1
		_IridescenceIntensity ("Intensity", Range(0, 10)) = 1
		_IridescenceAddBlend ("Blend Add", Range(0, 1)) = 0
		_IridescenceReplaceBlend ("Blend Replace", Range(0, 1)) = 0
		_IridescenceMultiplyBlend ("Blend Multiply", Range(0, 1)) = 0
		_IridescenceEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[ThryToggleUI(true)]_IridescenceHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_IridescenceHueShiftSpeed ("Speed--{condition_showS:(_IridescenceHueShiftEnabled==1)}", Float) = 0
		_IridescenceHueShift ("Shift--{condition_showS:(_IridescenceHueShiftEnabled==1)}", Range(0, 1)) = 0
		
		// Iridescence Audio Link
		[HideInInspector] m_start_IridescenceAudioLink ("Audio Link ♫--{ condition_showS:_EnableAudioLink==1}", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _IridescenceAudioLinkEmissionAddBand ("Emission Band", Int) = 0
		[VectorLabel(Min, Max)]_IridescenceAudioLinkEmissionAdd ("Emission Mod", Vector) = (0, 0, 0, 0)
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _IridescenceAudioLinkIntensityAddBand ("Intensity Band", Int) = 0
		[VectorLabel(Min, Max)]_IridescenceAudioLinkIntensityAdd ("Intensity Mod", Vector) = (0, 0, 0, 0)
		[ThryWideEnum(Motion increases as intensity of band increases, 0, Above but Smooth, 1, Motion moves back and forth as a function of intensity, 2, Above but Smoooth, 3, Fixed speed increase when the band is dark Stationary when light, 4, Above but Smooooth, 5, Fixed speed increase when the band is dark Fixed speed decrease when light, 6, Above but Smoooooth, 7)]_IridescenceAudioLinkChronoPanType ("Chrono Pan Type", Int) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _IridescenceAudioLinkChronoPanBand ("Intensity Band", Int) = 0
		_IridescenceAudioLinkChronoPanSpeed ("Speed", Float) = 0
		[HideInInspector] m_end_IridescenceAudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_Iridescence ("Iridescence", Float) = 0
		//endex
		
		//ifex _TextEnabled==0
		// MSDF OVERLAY
		[HideInInspector] m_start_Text ("Stats Overlay--{reference_property:_TextEnabled,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/stats-overlay},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(EFFECT_BUMP)]_TextEnabled ("Text", Float) = 0
		[sRGBWarning]_TextGlyphs ("Font Array", 2D) = "black" { }
		_TextPixelRange ("Pixel Range", Float) = 4.0
		
		// FPS
		[HideInInspector] m_start_TextFPS ("FPS--{reference_property:_TextFPSEnabled}", Float) = 0
		[HideInInspector][ToggleUI]_TextFPSEnabled ("FPS Text", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _TextFPSUV ("FPS UV", Int) = 0
		_TextFPSColor ("Color--{reference_property:_TextFPSColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _TextFPSColorThemeIndex ("", Int) = 0
		_TextFPSEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[Vector2]_TextFPSOffset ("Offset", Vector) = (0, 0, 0, 0)
		_TextFPSRotation ("Rotation", Range(0, 360)) = 0
		[Vector2]_TextFPSScale ("Scale", Vector) = (1, 1, 1, 1)
		[VectorLabel(L, D, R, U)]_TextFPSPadding ("Padding Reduction", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_TextFPS ("FPS", Float) = 0
		
		// POSITION
		[HideInInspector] m_start_TextPosition ("Position--{reference_property:_TextPositionEnabled}", Float) = 0
		[HideInInspector][ToggleUI]_TextPositionEnabled ("Position Text", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _TextPositionUV ("Position UV", Int) = 0
		//[ToggleUI]_TextPositionVertical ("Vertical", Float) = 0
		_TextPositionColor ("Color--{reference_property:_TextPositionColorThemeIndex}", Color) = (1, 0, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _TextPositionColorThemeIndex ("", Int) = 0
		_TextPositionEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[Vector2]_TextPositionOffset ("Offset", Vector) = (0, 0, 0, 0)
		_TextPositionRotation ("Rotation", Range(0, 360)) = 0
		[Vector2]_TextPositionScale ("Scale", Vector) = (1, 1, 1, 1)
		[VectorLabel(L, D, R, U)]_TextPositionPadding ("Padding Reduction", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_TextPosition ("Position", Float) = 0
		
		// INSTANCE TIME
		[HideInInspector] m_start_TextInstanceTime ("Instance Time--{reference_property:_TextTimeEnabled}", Float) = 0
		[HideInInspector][ToggleUI]_TextTimeEnabled ("Time Text", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _TextTimeUV ("Time UV", Int) = 0
		_TextTimeColor ("Color--{reference_property:_TextTimeColorThemeIndex}", Color) = (1, 0, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _TextTimeColorThemeIndex ("", Int) = 0
		_TextTimeEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[Vector2]_TextTimeOffset ("Offset", Vector) = (0, 0, 0, 0)
		_TextTimeRotation ("Rotation", Range(0, 360)) = 0
		[Vector2]_TextTimeScale ("Scale", Vector) = (1, 1, 1, 1)
		[VectorLabel(L, D, R, U)]_TextTimePadding ("Padding Reduction", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_TextInstanceTime ("Instance Time", Float) = 0
		
		// NUMERIC OVERLAY
		[HideInInspector] m_start_TextNumeric ("Numeric (WIP)--{reference_property:_TextNumericEnabled}", Float) = 0
		[HideInInspector][ToggleUI]_TextNumericEnabled ("Numeric Text", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _TextNumericUV ("Numeric UV", Int) = 0
		_TextNumericColor ("Color--{reference_property:_TextNumericColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _TextNumericColorThemeIndex ("", Int) = 0
		_TextNumericValue ("Display Value", Float) = 0
		[IntRange]_TextNumericWholeDigits ("Whole Digits", Range(0, 4)) = 4
		[IntRange]_TextNumericDecimalDigits ("Decimal Digits", Range(0, 4)) = 0
		[ToggleUI]_TextNumericTrimZeroes ("Trim Leading Zeroes", Float) = 0
		_TextNumericEmissionStrength ("Emission Strength", Range(0, 20)) = 0
		[Vector2]_TextNumericOffset ("Offset", Vector) = (0, 0, 0, 0)
		_TextNumericRotation ("Rotation", Range(0, 360)) = 0
		[Vector2]_TextNumericScale ("Scale", Vector) = (1, 1, 1, 1)
		[VectorLabel(L, D, R, U)]_TextNumericPadding ("Padding Reduction", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_TextNumeric ("Numeric", Float) = 0
		
		[HideInInspector] m_end_Text ("MSDF Text Overlay", Float) = 0
		//endex
		
		//ifex _FXProximityColor==0
		[HideInInspector] m_start_FXProximityColor ("Proximity Color--{reference_property:_FXProximityColor,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/special-fx/proximity-color},hover:Documentation}}", Float) = 0
		[HideInInspector][ToggleUI]_FXProximityColor ("Enable", Float) = 0
		[Enum(Object Position, 0, Pixel Position, 1)]_FXProximityColorType ("Pos To Use", Int) = 1
		_FXProximityColorMinColor ("Min Distance Alpha", Color) = (0, 0, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _FXProximityColorMinColorThemeIndex ("", Int) = 0
		_FXProximityColorMaxColor ("Max Distance Alpha", Color) = (1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _FXProximityColorMaxColorThemeIndex ("", Int) = 0
		_FXProximityColorMinDistance ("Min Distance", Float) = 0
		_FXProximityColorMaxDistance ("Max Distance", Float) = 1
		[ToggleUI]_FXProximityColorBackFace ("Force BackFace Color", Float) = 0
		[HideInInspector] m_end_FXProximityColor ("", Float) = 0
		//endex
		
		//ifex _PoiInternalParallax==0
		[HideInInspector] m_start_internalparallax (" Internal Parallax--{reference_property:_PoiInternalParallax}", Float) = 0
		[HideInInspector][ThryToggle(POI_INTERNALPARALLAX)]_PoiInternalParallax ("Enable", Float) = 0
		
		[Enum(Basic, 0, HeightMap, 1)] _ParallaxInternalHeightmapMode ("Parallax Mode", Int) = 0
		[ToggleUI]_ParallaxInternalHeightFromAlpha ("HeightFromAlpha", Float) = 0
		
		[sRGBWarning(true)][ThryTexture]_ParallaxInternalMap ("Internal Map--{reference_properties:[_ParallaxInternalMapPan]}", 2D) = "black" { }
		[HideInInspector][Vector2]_ParallaxInternalMapPan ("Panning", Vector) = (0, 0, 0, 0)
		
		[sRGBWarning][ThryTexture]_ParallaxInternalMapMask ("Mask--{reference_properties:[_ParallaxInternalMapMaskPan, _ParallaxInternalMapMaskUV, _ParallaxInternalMapMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_ParallaxInternalMapMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][Enum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, distorteduv0, 4)] _ParallaxInternalMapMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_ParallaxInternalMapMaskChannel ("Channel", Float) = 0
		[IntRange]_ParallaxInternalIterations ("Parallax Internal Iterations", Range(1, 50)) = 4
		_ParallaxInternalMinDepth ("Min Depth", Float) = 0
		_ParallaxInternalMaxDepth ("Max Depth", Float) = 0.1
		_ParallaxInternalMinFade ("Min Depth Brightness", Range(0, 5)) = 1.0
		_ParallaxInternalMaxFade ("Max Depth Brightness", Range(0, 5)) = 0.1
		_ParallaxInternalMinColor ("Min Depth Color--{reference_property:_ParallaxInternalMinColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ParallaxInternalMinColorThemeIndex ("", Int) = 0
		_ParallaxInternalMaxColor ("Max Depth Color--{reference_property:_ParallaxInternalMaxColorThemeIndex}", Color) = (1, 1, 1, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ParallaxInternalMaxColorThemeIndex ("", Int) = 0
		// [Vector2]_ParallaxInternalPanSpeed ("Pan Speed", Vector) = (0, 0, 0, 0)
		[Vector2]_ParallaxInternalPanDepthSpeed ("Per Level Speed Multiplier", Vector) = (0, 0, 0, 0)
		
		[Space(4)]
		[ThryToggleUI(true)]_ParallaxInternalHueShiftEnabled ("<size=13><b>  Hue Shift</b></size>", Float) = 0
		_ParallaxInternalHueShift ("Hue Shift--{condition_showS:(_ParallaxInternalHueShiftEnabled==1)}", Range(0, 1)) = 0
		_ParallaxInternalHueShiftSpeed ("Hue Shift Speed--{condition_showS:(_ParallaxInternalHueShiftEnabled==1)}", Float) = 0
		_ParallaxInternalHueShiftPerLevel ("Hue Shift Per Level--{condition_showS:(_ParallaxInternalHueShiftEnabled==1)}", Float) = 0
		// _ParallaxInternalHueShiftPerLevelSpeed ("Hue Shift Per Level Speed--{condition_showS:(_ParallaxInternalHueShiftEnabled==1)}", Float) = 0
		
		[HideInInspector] m_end_internalparallax ("Internal Parallax", Float) = 0
		//endex
		
		//ifex _VideoEffectsEnable==0
		[HideInInspector] m_start_videoEffects ("Video Effects--{reference_property:_VideoEffectsEnable}", Float) = 0
		[HideInInspector][ThryToggle]_VideoEffectsEnable ("Enable VideoEffects", Float) = 0
		[Enum(LCD, 0, TN, 1, CRT, 2, OLED, 3, Gameboy, 4, Projector, 5)] _VideoType ("Screen Type", Int) = 3
		_VideoBacklight ("Brightness", Range(0, 100)) = 1
		[ToggleUI]_VideoEmissionEnabled ("Emission Enabled", Float) = 1
		_VideoPixelTexture ("Pixel Texture--{reference_properties:[_VideoPixelTextureUV]}", 2D) = "white" { }
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)]_VideoPixelTextureUV ("UV", Int) = 0
		[sRGBWarning]_VideoMaskTexture ("Mask--{reference_properties:[_VideoMaskTexturePan, _VideoMaskTextureUV, _VideoMaskTextureChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_VideoMaskTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_VideoMaskTextureUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_VideoMaskTextureChannel ("Channel", Float) = 0
		[HideInInspector] m_start_VideoSettings ("Video Texture Settings", Float) = 0
		[Vector2]_VideoResolution ("Resolution", Vector) = (1280, 720, 0, 0)
		[ToggleUI]_VideoPixelateToResolution ("Pixelate To Resolution", Float) = 0
		// [ToggleUI]_VideoRepeatVideoTexture ("Clamp To UV", Float) = 0
		_VideoSaturation ("Saturation", Range(-1, 3)) = 0
		_VideoContrast ("Contrast boost", Range(0, 3)) = 0
		
		[HideInInspector] m_end_VideoSettings ("Video Texture Settings", Float) = 0
		
		[HideInInspector] m_start_CRT ("CRT Options--{condition_showS:(_VideoType==2)}", Float) = 0
		_VideoCRTRefreshRate ("Refresh Rate", Float) = 24
		_VideoCRTPixelEnergizedTime ("Pixel Fade Time", Float) = 1.9
		[HideInInspector] m_end_CRT ("CRT Options", Float) = 0
		
		[HideInInspector] m_start_Gameboy ("Gameboy Options--{condition_showS:(_VideoType==4)}", Float) = 0
		[sRGBWarning(true)][Gradient]_VideoGameboyRamp ("Color Ramp", 2D) = "white" { }
		[HideInInspector] m_end_Gameboy ("Gameboy Options", Float) = 0
		
		[HideInInspector] m_end_videoEffects ("Video Effects", Float) = 0
		//endex
		
		// Poi Extras
		//ifex _EnableAudioLink==0
		[HideInInspector] m_AudioLinkCategory (" Audio Link--{reference_property:_EnableAudioLink}", Float) = 0
		[HideInInspector] m_start_audioLink ("Audio Link", Float) = 0
		[HideInInspector][ThryToggle(POI_AUDIOLINK)] _EnableAudioLink ("Enabled", Float) = 0
		[Helpbox(1)] _AudioLinkHelp ("This section houses the global controls for audio link. Controls for individual features are in their respective sections. (Emission, Dissolve, etc...)", Int) = 0
		[ToggleUI] _AudioLinkAnimToggle ("Anim Toggle", Float) = 1
		/*
		_AudioLinkDelay ("Delay", Range(0, 1)) = 0
		[ToggleUI]_AudioLinkCCStripY("CC Strip Y UV", Float) = 0
		*/
		[ThryHeaderLabel(Smoothing)]
		_AudioLinkSmoothingBass ("Bass", Range(0, 1)) = 0
		_AudioLinkSmoothingLowMid ("Low Mid", Range(0, 1)) = 0
		_AudioLinkSmoothingHighMid ("High Mid", Range(0, 1)) = 0
		_AudioLinkSmoothingTreble ("Treble", Range(0, 1)) = 0
		[HideInInspector] m_end_audioLink ("Audio Link", Float) = 0
		//endex
		//ifex _EnableALDecal==0
		[HideInInspector] m_start_ALDecalSpectrum ("AL ♫ Spectrum--{  reference_property:_EnableALDecal}", Float) = 0
		[HideInInspector][ThryToggle(POI_AL_DECAL)]_EnableALDecal ("Enable AL Decal", Float) = 0
		[HideInInspector][ThryWideEnum(lil Spectrum, 0)] _ALDecalType ("AL Type--{ condition_showS:_EnableAudioLink==1}", Int) = 0
		
		[ThryHeaderLabel(Transform, 13)]
		[Space(4)]
		[Enum(Normal, 0, Circle, 1)] _ALDecalUVMode ("UV Mode", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _ALDecalUV ("UV", Int) = 0
		[Vector2]_ALUVPosition ("Position", Vector) = (.5, .5, 1)
		_ALUVScale ("Scale", Vector) = (1, 1, 1, 1)
		_ALUVRotation ("Rotation", Range(0, 360)) = 0
		_ALUVRotationSpeed ("Rotation Speed", Float) = 0
		_ALDecalLineWidth ("Line Width", Range(0, 1)) = 1.0
		_ALDecaldCircleDimensions ("Cirlce Dimensions--{ condition_showS:_ALDecalUVMode==1}", Vector) = (0, 1, 0, 1)
		
		[Space][ThryHeaderLabel(Volume, 13)]
		[Space(4)]
		_ALDecalVolumeStep ("Volume Step Num (0 = Off)", Float) = 0.0
		_ALDecalVolumeClipMin ("Volume Clip Min", Range(0, 1)) = 0.0
		_ALDecalVolumeClipMax ("Volume Clip Max", Range(0, 1)) = 1.0
		
		[Space][ThryHeaderLabel(Band, 13)]
		[Space(4)]
		_ALDecalBandStep ("Band Step Num (0 = Off)", Float) = 0.0
		_ALDecalBandClipMin ("Band Clip Min", Range(0, 1)) = 0.0
		_ALDecalBandClipMax ("Band Clip Max", Range(0, 1)) = 1.0
		
		[Space][ThryToggleUI(true)]_ALDecalShapeClip ("<size=13><b>  Shape Clip</b></size>", Float) = 0
		_ALDecalShapeClipVolumeWidth ("Volume Width--{ condition_showS:_ALDecalShapeClip==1}", Range(0, 1)) = 0.5
		_ALDecalShapeClipBandWidth ("Band Width--{ condition_showS:_ALDecalShapeClip==1}", Range(0, 1)) = 0.5
		
		[Space][ThryHeaderLabel(Audio Mods, 13)]
		[Space(4)]
		_ALDecalVolume ("Volume", Int) = 0.5
		_ALDecalBaseBoost ("Bass Boost", Float) = 5.0
		_ALDecalTrebleBoost ("Treble Boost", Float) = 1.0
		
		[Space][ThryHeaderLabel(Colors and Blending, 13)]
		[Space(4)]
		[sRGBWarning(true)][ThryRGBAPacker(1, RGB Color, A Mask, 1)]_ALDecalColorMask ("Color & Mask--{reference_properties:[_ALDecalColorMaskPan, _ALDecalColorMaskUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_ALDecalColorMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)] _ALDecalColorMaskUV ("UV", Int) = 0
		[Enum(UVX, 0, UVY, 1, Volume, 2)] _ALDecalVolumeColorSource ("Source", Int) = 1
		_ALDecalVolumeColorLow ("Volume Color Low--{reference_property:_ALDecalVolumeColorLowThemeIndex}", Color) = (0, 0, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ALDecalVolumeColorLowThemeIndex ("", Int) = 0
		_ALDecalLowEmission ("Low Emission", Range(0, 20)) = 0
		_ALDecalVolumeColorMid ("Volume Color Mid--{reference_property:_ALDecalVolumeColorMidThemeIndex}", Color) = (0, 1, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ALDecalVolumeColorMidThemeIndex ("", Int) = 0
		_ALDecalMidEmission ("Mid Emission", Range(0, 20)) = 0
		_ALDecalVolumeColorHigh ("Volume Color High--{reference_property:_ALDecalVolumeColorHighThemeIndex}", Color) = (1, 0, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ALDecalVolumeColorHighThemeIndex ("", Int) = 0
		_ALDecalHighEmission ("High Emission", Range(0, 20)) = 0
		[ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_ALDecalBlendType ("Blend Type", Range(0, 1)) = 0
		_ALDecalBlendAlpha ("Alpha", Range(0, 1)) = 1
		_ALDecalControlsAlpha ("Override Alpha", Range(0, 1)) = 0
		[HideInInspector] m_end_ALDecalSpectrum ("AL ♫ Spectrum", Float) = 0
		//endex
		
		//ifex _EnableVolumeColor==0
		[HideInInspector] m_start_ALVolumeColor ("AL ♫ Volume Color--{  reference_property:_EnableVolumeColor}", Float) = 0
		[HideInInspector][ThryToggle(POI_AL_VOLUMECOLOR)]_EnableVolumeColor ("Enable AL Volume Color", Float) = 0
		[Enum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)] _ALVolumeColorUV ("UV", Int) = 0
		[Enum(X, 0, Y, 1)] _ALVolumeColorDirection ("UV Direction", Int) = 0
		[ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_ALVolumeColorBlendType ("Blend Type", Range(0, 1)) = 0
		
		_ALVolumeColorBlendAlpha ("Alpha", Range(0,1)) = 1
		_ALVolumeColorLow ("Volume Color Low--{reference_property:_ALVolumeColorLowThemeIndex}", Color) = (0, 0, 1)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ALVolumeColorLowThemeIndex ("", Int) = 0
		_ALLowEmission ("Low Emission", Range(0, 20)) = 0
		_ALVolumeColorMid ("Volume Color Mid--{reference_property:_ALVolumeColorMidThemeIndex}", Color) = (0, 1, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ALVolumeColorMidThemeIndex ("", Int) = 0
		_ALMidEmission ("Mid Emission", Range(0, 20)) = 0
		_ALVolumeColorHigh ("Volume Color High--{reference_property:_ALVolumeColorHighThemeIndex}", Color) = (1, 0, 0)
		[HideInInspector][ThryWideEnum(Off, 0, Theme Color 0, 1, Theme Color 1, 2, Theme Color 2, 3, Theme Color 3, 4, ColorChord 0, 5, ColorChord 1, 6, ColorChord 2, 7, ColorChord 3, 8, AL Theme 0, 9, AL Theme 1, 10, AL Theme 2, 11, AL Theme 3, 12)] _ALVolumeColorHighThemeIndex ("", Int) = 0
		_ALHighEmission ("High Emission", Range(0, 20)) = 0
		
		[HideInInspector] m_end_ALVolumeColor ("AL ♫ Volume Color", Float) = 0
		//endex
		
		// Rendering Options
		[HideInInspector] m_modifierCategory ("Modifiers", Float) = 0
		[HideInInspector] m_start_Stochastic ("Stochastic Sampling", Float) = 0
		[KeywordEnum(Deliot Heitz, Hextile, None)] _StochasticMode ("Sampling Mode", Float) = 0
		[HideInInspector] g_start_deliot ("Deliot Heitz--{condition_show:{type:PROPERTY_BOOL,data:_StochasticMode==0}}", Float) = 0
		_StochasticDeliotHeitzDensity ("Detiling Density", Range(0.1, 10)) = 1
		[HideInInspector] g_end_deliot ("Deliot Heitz", Float) = 0
		[HideInInspector] g_start_hextile ("Hextile--{condition_show:{type:PROPERTY_BOOL,data:_StochasticMode==1}}", Float) = 0
		_StochasticHexGridDensity ("Hex Grid Density", Range(0.1, 10)) = 1
		_StochasticHexRotationStrength ("Rotation Strength", Range(0, 2)) = 0
		_StochasticHexFallOffContrast("Falloff Contrast", Range(0.01, 0.99)) = 0.6
		_StochasticHexFallOffPower("Falloff Power", Range(0, 20)) = 7
		[HideInInspector] g_end_hextile ("Hextile", Float) = 0
		[HideInInspector] m_end_Stochastic ("Stochastic Sampling", Float) = 0
		
		//ifex _EnableDistortion==0
		[HideInInspector] m_start_uvDistortion (" Distortion UV--{reference_property:_EnableDistortion}", Float) = 0
		[HideInInspector][ThryToggle(USER_LUT)] _EnableDistortion ("Enabled", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Local Pos, 8, Polar UV, 6)] _DistortionUvToDistort ("Distorted UV", Int) = 0
		[sRGBWarning]_DistortionMask ("Mask--{reference_properties:[_DistortionMaskPan, _DistortionMaskUV, _DistortionMaskChannel]}", 2D) = "white" { }
		[HideInInspector][Vector2]_DistortionMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Local Pos, 8, Polar UV, 6)] _DistortionMaskUV ("UV", Int) = 0
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_DistortionMaskChannel ("Channel", Float) = 0
		[sRGBWarning]_DistortionFlowTexture ("Distortion Texture 1--{reference_properties:[_DistortionFlowTexturePan, _DistortionFlowTextureUV]}", 2D) = "black" { }
		[HideInInspector][Vector2]_DistortionFlowTexturePan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Local Pos, 8, Polar UV, 6)] _DistortionFlowTextureUV ("UV", Int) = 0
		[sRGBWarning]_DistortionFlowTexture1 ("Distortion Texture 2--{reference_properties:[_DistortionFlowTexture1Pan, _DistortionFlowTexture1UV]}", 2D) = "black" { }
		[HideInInspector][Vector2]_DistortionFlowTexture1Pan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Local Pos, 8, Polar UV, 6)] _DistortionFlowTexture1UV ("UV", Int) = 0
		_DistortionStrength ("Strength1", Float) = 0.03
		_DistortionStrength1 ("Strength2", Float) = 0.01
		[HideInInspector] m_start_DistortionAudioLink ("Audio Link ♫--{reference_property:_EnableDistortionAudioLink, condition_showS:_EnableAudioLink==1}", Float) = 0
		[HideInInspector][ToggleUI] _EnableDistortionAudioLink ("Enabled", Float) = 0
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _DistortionStrengthAudioLinkBand ("Strength 1 Band", Int) = 0
		[VectorLabel(Min, Max)]_DistortionStrengthAudioLink ("Strength 1 Offset Range", Vector) = (0, 0, 0, 0)
		[Space(7)]
		[Enum(Bass, 0, Low Mid, 1, High Mid, 2, Treble, 3)] _DistortionStrength1AudioLinkBand ("Strength 2 Band", Int) = 0
		[VectorLabel(Min, Max)]_DistortionStrength1AudioLink ("Strength 2 Offset Range", Vector) = (0, 0, 0, 0)
		[HideInInspector] m_end_DistortionAudioLink ("Audio Link", Float) = 0
		[HideInInspector] m_end_uvDistortion ("Distortion UV", Float) = 0
		//endex
		
		[HideInInspector] m_start_uvLocalWorld ("Local World UV", Float) = 0
		[ThryWideEnum(X, 0, Y, 1, Z, 2, Zero, 3, VColor R, 4, VColor G, 5, VColor B, 6, VColor A, 7)] _UVModLocalPos0 ("Local X", Int) = 0
		[ThryWideEnum(X, 0, Y, 1, Z, 2, Zero, 3, VColor R, 4, VColor G, 5, VColor B, 6, VColor A, 7)] _UVModLocalPos1 ("Local Y", Int) = 1
		[Space(10)]
		[ThryWideEnum(X, 0, Y, 1, Z, 2, Zero, 3)] _UVModWorldPos0 ("World X", Int) = 0
		[ThryWideEnum(X, 0, Y, 1, Z, 2, Zero, 3)] _UVModWorldPos1 ("World Y", Int) = 2
		[HideInInspector] m_end_uvLocalWorld ("Local World UV", Float) = 0
		
		[HideInInspector] m_start_uvPanosphere ("Panosphere UV", Float) = 0
		[ToggleUI] _StereoEnabled ("Stereo Enabled", Float) = 0
		[ToggleUI] _PanoUseBothEyes ("Perspective Correct (VR)", Float) = 1
		[HideInInspector] m_end_uvPanosphere ("Panosphere UV", Float) = 0
		
		[HideInInspector] m_start_uvPolar ("Polar UV", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8)] _PolarUV ("UV", Int) = 0
		[Vector2]_PolarCenter ("Center Coordinate", Vector) = (.5, .5, 0, 0)
		_PolarRadialScale ("Radial Scale", Float) = 1
		_PolarLengthScale ("Length Scale", Float) = 1
		_PolarSpiralPower ("Spiral Power", Float) = 0
		[HideInInspector] m_end_uvPolar ("Polar UV", Float) = 0
		
		//ifex _PoiParallax==0
		[HideInInspector] m_start_parallax (" Parallax Heightmapping--{reference_property:_PoiParallax}", Float) = 0
		[HideInInspector][ThryToggle(POI_PARALLAX)]_PoiParallax ("Enable", Float) = 0
		[ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_ParallaxUV ("Applies To: ", Int) = 0
		
		[sRGBWarning][ThryTexture]_HeightMap ("Heightmap--{reference_properties:[_HeightMapPan, _HeightMapUV]}", 2D) = "white" { }
		[HideInInspector][Vector2]_HeightMapPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_HeightMapUV ("UV", Int) = 0
		
		[sRGBWarning][ThryTexture]_Heightmask ("Mask--{reference_properties:[_HeightmaskPan, _HeightmaskUV, _HeightmaskChannel, _HeightmaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_HeightmaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_HeightmaskChannel ("Channel", Float) = 0
		[HideInInspector][ToggleUI]_HeightmaskInvert ("Invert", Float) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_HeightmaskUV ("UV", Int) = 0
		_HeightStrength ("Strength", Range(0, 1)) = 0.4247461
		//_HeightOffset ("Offset", Range(-1, 1)) = 0
		_CurvatureU ("Curvature U", Range(0, 100)) = 0
		_CurvatureV ("Curvature V", Range(0, 30)) = 0
		[IntRange]_HeightStepsMin ("Steps Min", Range(0, 128)) = 10
		[IntRange]_HeightStepsMax ("Steps Max", Range(0, 128)) = 128
		_CurvFix ("Curvature Bias", Range(0, 1)) = 1
		// [ThryToggle]_ParallaxUV0 ("UV0", Float) = 0
		// [ThryToggle]_ParallaxUV1 ("UV1", Float) = 0
		// [ThryToggle]_ParallaxUV2 ("UV2", Float) = 0
		// [ThryToggle]_ParallaxUV3 ("UV3", Float) = 0
		// [ThryToggle]_ParallaxPano ("Panosphere", Float) = 0
		// [ThryToggle]_ParallaxWorldPos ("World Pos", Float) = 0
		// [ThryToggle]_ParallaxPolar ("Polar", Float) = 0
		// [ThryToggle]_ParallaxDist ("Distorted UV", Float) = 0
		
		[HideInInspector] m_end_parallax ("Parallax Heightmapping", Float) = 0
		//endex
		
		//ifex _BlackLightMaskingEnabled==0
		[HideInInspector] m_start_BlackLightMasking ("BlackLight Masking--{reference_property:_BlackLightMaskingEnabled}", Float) = 0
		[HideInInspector][ThryToggle(POI_BLACKLIGHTMASKING)] _BlackLightMaskingEnabled ("BlackLight Masking Enabled", Float) = 0
		
		[ThryHeaderLabel(One, 13)]
		_BlackLightMasking0Key ("Key", Float) = 1
		[Vector2] _BlackLightMasking0Range ("Range", Vector) = (0.1, 0.5, 0, 0)
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _BlackLightMasking0GlobalMaskIndex ("Apply to Global Mask--{reference_property:_BlackLightMasking0GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_BlackLightMasking0GlobalMaskBlendType ("Blending", Range(0, 1)) = 0
		[Space(4)]
		[ThryHeaderLabel(Two, 13)]
		_BlackLightMasking1Key ("Key", Float) = 2
		[Vector2] _BlackLightMasking1Range ("Range", Vector) = (0.1, 0.5, 0, 0)
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _BlackLightMasking1GlobalMaskIndex ("Apply to Global Mask--{reference_property:_BlackLightMasking1GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_BlackLightMasking1GlobalMaskBlendType ("Blending", Range(0, 1)) = 0
		[Space(4)]
		[ThryHeaderLabel(Three, 13)]
		_BlackLightMasking2Key ("Key", Float) = 3
		[Vector2] _BlackLightMasking2Range ("Range", Vector) = (0.1, 0.5, 0, 0)
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _BlackLightMasking2GlobalMaskIndex ("Apply to Global Mask--{reference_property:_BlackLightMasking2GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_BlackLightMasking2GlobalMaskBlendType ("Blending", Range(0, 1)) = 0
		[Space(4)]
		[ThryHeaderLabel(Four, 13)]
		_BlackLightMasking3Key ("Key", Float) = 4
		[Vector2] _BlackLightMasking3Range ("Range", Vector) = (0.1, 0.5, 0, 0)
		[ThryWideEnum(Off, 0, 1R, 1, 1G, 2, 1B, 3, 1A, 4, 2R, 5, 2G, 6, 2B, 7, 2A, 8, 3R, 9, 3G, 10, 3B, 11, 3A, 12, 4R, 13, 4G, 14, 4B, 15, 4A, 16)] _BlackLightMasking3GlobalMaskIndex ("Apply to Global Mask--{reference_property:_BlackLightMasking3GlobalMaskBlendType}", Int) = 0
		[HideInInspector][ThryWideEnum(Replace, 0, Multiply, 2, Screen, 6, Linear Dodge(Add), 8, Overlay, 9, Mixed, 20)]_BlackLightMasking3GlobalMaskBlendType ("Blending", Range(0, 1)) = 0
		
		[HideInInspector] m_end_BlackLightMasking ("BlackLight Masking", Float) = 0
		//endex
		
		//ifex _NormalCorrect==0
		[HideInInspector] m_start_normalCorrect (" Normal Correct--{reference_property:_NormalCorrect}}", Float) = 0
		[HideInInspector][ThryToggle(POI_NORMALCORRECT)]_NormalCorrect ("Enable", Float) = 0
		_NormalCorrectAmount ("Normal Correct Amount", Range(0,1)) = 0.9
		[Vector3]_NormalCorrectOrigin ("Origin", Vector) = (0,0.4,-0.025)
		[HideInInspector] m_end_normalCorrect ("", Float) = 0
		//endex
		
		//Third party
		[HideInInspector] m_thirdpartyCategory ("Third Party", Float) = 0
		
		// Rendering Options
		[HideInInspector] m_postprocessing ("Post Processing", Float) = 0
		[HideInInspector] m_start_PoiLightData ("PP Animations--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/post-processing/pp-animations},hover:Documentation}}", Float) = 0
		[Helpbox(1)] _PPHelp ("This section meant for real time adjustments through animations and not to be changed in unity", Int) = 0
		_PPLightingMultiplier ("Lighting Mulitplier", Float) = 1
		_PPLightingAddition ("Lighting Add", Float) = 0
		_PPEmissionMultiplier ("Emission Multiplier", Float) = 1
		_PPFinalColorMultiplier ("Final Color Multiplier", Float) = 1
		[HideInInspector] m_end_PoiLightData ("PP Animations ", Float) = 0
		
		//ifex _PostProcess==0
		[HideInInspector] m_start_postprocess ("Post Processing--{reference_property:_PostProcess,button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/post-processing/main},hover:Documentation}}", Float) = 0
		[HideInInspector][ThryToggle(POSTPROCESS)]_PostProcess ("Enable", Float) = 0
		[sRGBWarning][ThryTexture] _PPMask ("Mask--{reference_properties:[_PPMaskPan, _PPMaskUV, _PPMaskChannel, _PPMaskInvert]}", 2D) = "white" { }
		[HideInInspector][Vector2]_PPMaskPan ("Panning", Vector) = (0, 0, 0, 0)
		[HideInInspector][Enum(R, 0, G, 1, B, 2, A, 3)]_PPMaskChannel ("Channel", Float) = 0
		[HideInInspector][ToggleUI]_PPMaskInvert ("Invert", Float) = 0
		[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos, 5, Local Pos, 8, Polar UV, 6, Distorted UV, 7)]_PPMaskUV ("UV", Int) = 0
		
		_PPHue ("Hue", Range(0, 1)) = 0
		[HDR]_PPTint ("Tint", Color) = (1, 1, 1, 1)
		[VectorLabel(R,G,B)]_PPRGB ("RGB", Vector) = (1, 1, 1, 1)
		_PPContrast ("Contrast", Float) = 1
		_PPSaturation ("Saturation", Float) = 1
		_PPBrightness ("Brightness", Float) = 1
		_PPLightness ("Lightness", Float) = 0
		_PPHDR ("HDR", Float) = 0
		
		[ThryToggleUI(true)]_PPPosterization ("<size=13><b>  Posterization</b></size>", Float) = 0
		_PPPosterizationAmount ("Steps--{condition_showS:(_PPPosterization==1)}", Range(1, 30)) = 4
		
		[HideInInspector] m_end_postprocess ("", Float) = 0
		//endex
		
		// Rendering Options
		[HideInInspector] m_renderingCategory ("Rendering--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/rendering/main},hover:Documentation}}", Float) = 0
		[Enum(UnityEngine.Rendering.CullMode)] _Cull ("Cull", Float) = 2
		[Enum(UnityEngine.Rendering.CompareFunction)] _ZTest ("ZTest", Float) = 4
		[Enum(Off, 0, On, 1)] _ZWrite ("ZWrite", Int) = 1
		[Enum(Thry.ColorMask)] _ColorMask ("Color Mask", Int) = 15
		_OffsetFactor ("Offset Factor", Float) = 0.0
		_OffsetUnits ("Offset Units", Float) = 0.0
		[ToggleUI]_RenderingReduceClipDistance ("Reduce Clip Distance", Float) = 0
		[ToggleUI]_IgnoreFog ("Ignore Fog", Float) = 0
		[HideInInspector] Instancing ("Instancing", Float) = 0 //add this property for instancing variants settings to be shown
		
		// Blending Options
		[HideInInspector] m_start_blending ("Blending--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/rendering/blending},hover:Documentation}}", Float) = 0
		[Enum(Thry.BlendOp)]_BlendOp ("RGB Blend Op", Int) = 0
		[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend ("RGB Source Blend", Int) = 1
		[Enum(UnityEngine.Rendering.BlendMode)] _DstBlend ("RGB Destination Blend", Int) = 0
		[Space][ThryHeaderLabel(Additive Blending, 13)]
		[Enum(Thry.BlendOp)]_AddBlendOp ("RGB Blend Op", Int) = 0
		[Enum(UnityEngine.Rendering.BlendMode)] _AddSrcBlend ("RGB Source Blend", Int) = 1
		[Enum(UnityEngine.Rendering.BlendMode)] _AddDstBlend ("RGB Destination Blend", Int) = 1
		
		[HideInInspector] m_start_alphaBlending ("Advanced Alpha Blending", Float) = 0
		[Enum(Thry.BlendOp)]_BlendOpAlpha ("Alpha Blend Op", Int) = 4
		[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlendAlpha ("Alpha Source Blend", Int) = 1
		[Enum(UnityEngine.Rendering.BlendMode)] _DstBlendAlpha ("Alpha Destination Blend", Int) = 1
		[Space][ThryHeaderLabel(Additive Blending, 13)]
		[Enum(Thry.BlendOp)]_AddBlendOpAlpha ("Alpha Blend Op", Int) = 0
		[Enum(UnityEngine.Rendering.BlendMode)] _AddSrcBlendAlpha ("Alpha Source Blend", Int) = 1
		[Enum(UnityEngine.Rendering.BlendMode)] _AddDstBlendAlpha ("Alpha Destination Blend", Int) = 1
		[HideInInspector] m_end_alphaBlending ("Advanced Alpha Blending", Float) = 0
		
		[HideInInspector] m_end_blending ("Blending", Float) = 0
		
		// Stencils
		[HideInInspector] m_start_StencilPassOptions ("Stencil--{button_help:{text:Tutorial,action:{type:URL,data:https://www.poiyomi.com/rendering/stencil},hover:Documentation}}", Float) = 0
		[ThryWideEnum(Simple, 0, Front Face vs Back Face, 1)] _StencilType ("Stencil Type", Float) = 0
		[IntRange] _StencilRef ("Stencil Reference Value", Range(0, 255)) = 0
		[IntRange] _StencilReadMask ("Stencil ReadMask Value", Range(0, 255)) = 255
		[IntRange] _StencilWriteMask ("Stencil WriteMask Value", Range(0, 255)) = 255
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilPassOp ("Stencil Pass Op--{condition_showS:(_StencilType==0)}", Float) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilFailOp ("Stencil Fail Op--{condition_showS:(_StencilType==0)}", Float) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilZFailOp ("Stencil ZFail Op--{condition_showS:(_StencilType==0)}", Float) = 0
		[Enum(UnityEngine.Rendering.CompareFunction)] _StencilCompareFunction ("Stencil Compare Function--{condition_showS:(_StencilType==0)}", Float) = 8
		
		[HideInInspector] m_start_StencilPassBackOptions("Back--{condition_showS:(_StencilType==1)}", Float) = 0
		[Helpbox(1)] _FFBFStencilHelp0 ("Front Face and Back Face Stencils only work when locked in due to Unity's Stencil managment", Int) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilBackPassOp ("Back Pass Op", Float) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilBackFailOp ("Back Fail Op", Float) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilBackZFailOp ("Back ZFail Op", Float) = 0
		[Enum(UnityEngine.Rendering.CompareFunction)] _StencilBackCompareFunction ("Back Compare Function", Float) = 8
		[HideInInspector] m_end_StencilPassBackOptions("Back", Float) = 0
		
		[HideInInspector] m_start_StencilPassFrontOptions("Front--{condition_showS:(_StencilType==1)}", Float) = 0
		[Helpbox(1)] _FFBFStencilHelp1 ("Front Face and Back Face Stencils only work when locked in due to Unity's Stencil managment", Int) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilFrontPassOp ("Front Pass Op", Float) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilFrontFailOp ("Front Fail Op", Float) = 0
		[Enum(UnityEngine.Rendering.StencilOp)] _StencilFrontZFailOp ("Front ZFail Op", Float) = 0
		[Enum(UnityEngine.Rendering.CompareFunction)] _StencilFrontCompareFunction ("Front Compare Function", Float) = 8
		[HideInInspector] m_end_StencilPassFrontOptions("Front", Float) = 0
		
		[HideInInspector] m_end_StencilPassOptions ("Stencil", Float) = 0
		
	}
	SubShader
	{
		Tags { "RenderType" = "Opaque" "Queue" = "Geometry" "VRCFallback" = "Standard" }
		
		Pass
		{
			Tags { "LightMode" = "ForwardBase" }
			
			Stencil
			{
				Ref [_StencilRef]
				ReadMask [_StencilReadMask]
				WriteMask [_StencilWriteMask]
				//ifex _StencilType==1
				Comp [_StencilCompareFunction]
				Pass [_StencilPassOp]
				Fail [_StencilFailOp]
				ZFail [_StencilZFailOp]
				//endex
				
				//ifex _StencilType==0
				CompBack [_StencilBackCompareFunction]
				PassBack [_StencilBackPassOp]
				FailBack [_StencilBackFailOp]
				ZFailBack [_StencilBackZFailOp]
				
				CompFront [_StencilFrontCompareFunction]
				PassFront [_StencilFrontPassOp]
				FailFront [_StencilFrontFailOp]
				ZFailFront [_StencilFrontZFailOp]
				//endex
			}
			
			ZWrite [_ZWrite]
			Cull [_Cull]
			
			AlphaToMask [_AlphaToCoverage]
			ZTest [_ZTest]
			ColorMask [_ColorMask]
			Offset [_OffsetFactor], [_OffsetUnits]
			
			BlendOp [_BlendOp], [_BlendOpAlpha]
			Blend [_SrcBlend] [_DstBlend], [_SrcBlendAlpha] [_DstBlendAlpha]
			
			CGPROGRAM
			/*
			// Disable warnings we aren't interested in
			#if defined(UNITY_COMPILER_HLSL)
			#pragma warning(disable : 3205) // conversion of larger type to smaller
			#pragma warning(disable : 3568) // unknown pragma ignored
			#pragma warning(disable : 3571) // "pow(f,e) will not work for negative f"; however in majority of our calls to pow we know f is not negative
			#pragma warning(disable : 3206) // implicit truncation of vector type
			#endif
			*/
			#pragma target 5.0
			
			#pragma shader_feature_local _STOCHASTICMODE_DELIOT_HEITZ _STOCHASTICMODE_HEXTILE _STOCHASTICMODE_NONE
			
			//ifex _MainColorAdjustToggle==0
			#pragma shader_feature COLOR_GRADING_HDR
			//endex
			
			//#pragma shader_feature KEYWORD
			
			//ifex _GlobalMaskTexturesEnable==0
			#pragma shader_feature_local POI_GLOBALMASK_TEXTURES
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#pragma shader_feature_local POI_UDIMDISCARD
			//endex
			
			//ifex _EnableDistortion==0
			#pragma shader_feature USER_LUT
			//endex
			
			//ifex _PoiParallax==0
			#pragma shader_feature_local POI_PARALLAX
			//endex
			
			//ifex _EnableAudioLink==0
			#pragma shader_feature_local POI_AUDIOLINK
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#pragma shader_feature_local POI_BLACKLIGHTMASKING
			//endex
			
			//ifex _DetailEnabled==0
			#pragma shader_feature FINALPASS
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#pragma shader_feature AUTO_EXPOSURE
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#pragma shader_feature_local POI_VERTEX_GLITCHING
			#pragma shader_feature_local POI_VERTEX_GLITCHING_TEXTURE
			//endex
			
			//ifex _EnableDepthBulge==0
			#pragma shader_feature_local POI_DEPTHBULGE
			//endex
			
			//ifex _BackFaceEnabled!=1
			#pragma shader_feature_local POI_BACKFACE
			//endex
			
			//ifex _RGBMaskEnabled==0
			#pragma shader_feature VIGNETTE
			#pragma shader_feature GEOM_TYPE_MESH
			//endex
			
			//ifex _DecalEnabled==0
			#pragma shader_feature GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#pragma shader_feature GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#pragma shader_feature GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#pragma shader_feature DEPTH_OF_FIELD_COC_VIEW
			//endex
			
			//ifex _EnableDissolve==0
			#pragma shader_feature DISTORT
			//endex
			
			//ifex _ShadingEnabled==0
			#pragma shader_feature_local VIGNETTE_MASKED
			#pragma shader_feature_local _LIGHTINGMODE_TEXTURERAMP _LIGHTINGMODE_MULTILAYER_MATH _LIGHTINGMODE_SHADEMAP _LIGHTINGMODE_REALISTIC _LIGHTINGMODE_WRAPPED _LIGHTINGMODE_SKIN _LIGHTINGMODE_FLAT _LIGHTINGMODE_CLOTH _LIGHTINGMODE_SDF
			//endex
			
			//ifex _EnableAniso==0
			#pragma shader_feature_local POI_ANISOTROPICS
			//endex
			
			//ifex _MatcapEnable==0
			#pragma shader_feature_local POI_MATCAP0
			#pragma shader_feature_local POI_MATCAP0_CUSTOM_NORMAL
			//endex
			//ifex _Matcap2Enable==0
			#pragma shader_feature COLOR_GRADING_HDR_3D
			#pragma shader_feature_local POI_MATCAP1_CUSTOM_NORMAL
			//endex
			//ifex _Matcap3Enable==0
			#pragma shader_feature_local POI_MATCAP2
			#pragma shader_feature_local POI_MATCAP2_CUSTOM_NORMAL
			//endex
			//ifex _Matcap4Enable==0
			#pragma shader_feature_local POI_MATCAP3
			#pragma shader_feature_local POI_MATCAP3_CUSTOM_NORMAL
			//endex
			
			//ifex _CubeMapEnabled==0
			#pragma shader_feature_local _CUBEMAP
			//endex
			
			//ifex _EnableALDecal==0
			#pragma shader_feature_local POI_AL_DECAL
			//endex
			
			//ifex _EnableVolumeColor==0
			#pragma shader_feature_local POI_AL_VOLUMECOLOR
			//endex
			
			//ifex _EnableFlipbook==0
			#pragma shader_feature _SUNDISK_HIGH_QUALITY
			//endex
			
			//ifex _EnableEmission==0
			#pragma shader_feature _EMISSION
			//endex
			//ifex _EnableEmission1==0
			#pragma shader_feature_local POI_EMISSION_1
			//endex
			//ifex _EnableEmission2==0
			#pragma shader_feature_local POI_EMISSION_2
			//endex
			//ifex _EnableEmission3==0
			#pragma shader_feature_local POI_EMISSION_3
			//endex
			
			//ifex _EnableRimLighting==0
			#pragma shader_feature_local _GLOSSYREFLECTIONS_OFF
			#pragma shader_feature_local _RIMSTYLE_POIYOMI _RIMSTYLE_UTS2 _RIMSTYLE_LILTOON
			//endex
			//ifex _EnableRim2Lighting==0
			#pragma shader_feature_local POI_RIM2
			#pragma shader_feature_local _RIM2STYLE_POIYOMI _RIM2STYLE_UTS2 _RIM2STYLE_LILTOON
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#pragma shader_feature_local _POI_DEPTH_RIMLIGHT
			//endex
			
			//ifex _GlitterEnable==0
			#pragma shader_feature _SUNDISK_SIMPLE
			//endex
			
			//ifex _SubsurfaceScattering==0
			#pragma shader_feature_local POI_SUBSURFACESCATTERING
			//endex
			
			//ifex _MochieBRDF==0
			#pragma shader_feature_local MOCHIE_PBR
			//endex
			//ifex _ClearCoatBRDF==0
			#pragma shader_feature_local POI_CLEARCOAT
			//endex
			
			//ifex _EnableEnvironmentalRim==0
			#pragma shader_feature_local POI_ENVIRORIM
			//endex
			
			//ifex _StylizedSpecular==0
			#pragma shader_feature_local POI_STYLIZED_StylizedSpecular
			//endex
			
			//ifex _EnablePathing==0
			#pragma shader_feature_local POI_PATHING
			//endex
			
			//ifex _EnableMirrorOptions==0
			#pragma shader_feature_local POI_MIRROR
			//endex
			
			//ifex _EnableTouchGlow==0
			#pragma shader_feature GRAIN
			//endex
			
			//ifex _EnableIridescence==0
			#pragma shader_feature_local POI_IRIDESCENCE
			//endex
			
			//ifex _TextEnabled==0
			#pragma shader_feature EFFECT_BUMP
			//endex
			
			//ifex _PostProcess==0
			#pragma shader_feature_local POSTPROCESS
			//endex
			
			//ifex _PoiInternalParallax==0
			#pragma shader_feature_local POI_INTERNALPARALLAX
			//endex
			
			//ifex _NormalCorrect==0
			#pragma shader_feature_local POI_NORMALCORRECT
			//endex
			
			//ifex _BacklightEnabled!=1
			#pragma shader_feature_local POI_BACKLIGHT
			//endex
			
			#pragma multi_compile_fwdbase
			#pragma multi_compile_instancing
			#pragma multi_compile_fog
			#pragma multi_compile _ VERTEXLIGHT_ON
			#define POI_PASS_BASE
			
			#define POI_WORLD
			
			// UNITY Includes
			#include "UnityCG.cginc"
			#include "UnityStandardUtils.cginc"
			#include "AutoLight.cginc"
			#include "UnityLightingCommon.cginc"
			#include "UnityPBSLighting.cginc"
			#ifdef POI_PASS_META
			#include "UnityMetaPass.cginc"
			#endif
			#pragma vertex vert
			
			#pragma fragment frag
			
			#define DielectricSpec float4(0.04, 0.04, 0.04, 1.0 - 0.04)
			#define PI float(3.14159265359)
			
			#define POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex,samplertex,coord,dx,dy) tex.SampleGrad (sampler##samplertex,coord,dx,dy)
			
			#define POI_PAN_UV(uv, pan) (uv + _Time.x * pan)
			#define POI2D_SAMPLER_PAN(tex, texSampler, uv, pan) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, POI_PAN_UV(uv, pan)))
			#define POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, POI_PAN_UV(uv, pan), dx, dy))
			#define POI2D_SAMPLER(tex, texSampler, uv) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_GRAD(tex, texSampler, uv, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, uv, dx, dy))
			#define POI2D_PAN(tex, uv, pan) (tex2D(tex, POI_PAN_UV(uv, pan)))
			#define POI2D(tex, uv) (tex2D(tex, uv))
			#define POI_SAMPLE_TEX2D(tex, uv) (UNITY_SAMPLE_TEX2D(tex, uv))
			#define POI_SAMPLE_TEX2D_PAN(tex, uv, pan) (UNITY_SAMPLE_TEX2D(tex, POI_PAN_UV(uv, pan)))
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_MAINTEX_SAMPLER_PAN_INLINED(tex, poiMesh) (POI2D_SAMPLER_PAN(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan))
			
			#define POI_SAFE_RGB0 float4(mainTexture.rgb * .0001, 0)
			#define POI_SAFE_RGB1 float4(mainTexture.rgb * .0001, 1)
			#define POI_SAFE_RGBA mainTexture
			
			#if defined(UNITY_COMPILER_HLSL)
			#define PoiInitStruct(type, name) name = (type)0;
			#else
			#define PoiInitStruct(type, name)
			#endif
			
			#define POI_ERROR(poiMesh, gridSize) lerp(float3(1, 0, 1), float3(0, 0, 0), fmod(floor((poiMesh.worldPos.x) * gridSize) + floor((poiMesh.worldPos.y) * gridSize) + floor((poiMesh.worldPos.z) * gridSize), 2) == 0)
			#define POI_NAN (asfloat(-1))
			
			#define POI_MODE_OPAQUE 0
			#define POI_MODE_CUTOUT 1
			#define POI_MODE_FADE 2
			#define POI_MODE_TRANSPARENT 3
			#define POI_MODE_ADDITIVE 4
			#define POI_MODE_SOFTADDITIVE 5
			#define POI_MODE_MULTIPLICATIVE 6
			#define POI_MODE_2XMULTIPLICATIVE 7
			#define POI_MODE_TRANSCLIPPING 9
			
			/*
			Texture2D ;
			float4 _ST;
			float2 Pan;
			float UV;
			float Stochastic;
			
			[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7 )]
			*/
			
			#define POI_DECLARETEX_ST_UV(tex) float4 tex##_ST; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN_STOCHASTIC(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV; float tex##Stochastic;
			//ifex _EnableAudioLink==0
			// Map of where features in AudioLink are.
			#define ALPASS_DFT                      uint2(0,4)   //Size: 128, 2
			#define ALPASS_WAVEFORM                 uint2(0,6)   //Size: 128, 16
			#define ALPASS_AUDIOLINK                uint2(0,0)   //Size: 128, 4
			#define ALPASS_AUDIOBASS                uint2(0,0)   //Size: 128, 1
			#define ALPASS_AUDIOLOWMIDS             uint2(0,1)   //Size: 128, 1
			#define ALPASS_AUDIOHIGHMIDS            uint2(0,2)   //Size: 128, 1
			#define ALPASS_AUDIOTREBLE              uint2(0,3)   //Size: 128, 1
			#define ALPASS_AUDIOLINKHISTORY         uint2(1,0)   //Size: 127, 4
			#define ALPASS_GENERALVU                uint2(0,22)  //Size: 12, 1
			#define ALPASS_CCINTERNAL               uint2(12,22) //Size: 12, 2
			#define ALPASS_CCCOLORS                 uint2(25,22) //Size: 11, 1
			#define ALPASS_CCSTRIP                  uint2(0,24)  //Size: 128, 1
			#define ALPASS_CCLIGHTS                 uint2(0,25)  //Size: 128, 2
			#define ALPASS_AUTOCORRELATOR           uint2(0,27)  //Size: 128, 1
			#define ALPASS_GENERALVU_INSTANCE_TIME  uint2(2,22)
			#define ALPASS_GENERALVU_LOCAL_TIME     uint2(3,22)
			#define ALPASS_GENERALVU_NETWORK_TIME   uint2(4,22)
			#define ALPASS_GENERALVU_PLAYERINFO     uint2(6,22)
			// Added in version 2.5
			#define ALPASS_FILTEREDAUDIOLINK        uint2(0,28)  //Size: 16, 4
			// Added in version 2.6
			#define ALPASS_CHRONOTENSITY            uint2(16,28) //Size: 8, 4
			#define ALPASS_THEME_COLOR0             uint2(0,23)
			#define ALPASS_THEME_COLOR1             uint2(1,23)
			#define ALPASS_THEME_COLOR2             uint2(2,23)
			#define ALPASS_THEME_COLOR3             uint2(3,23)
			#define ALPASS_FILTEREDVU               uint2(24,28) //Size: 4, 4
			#define ALPASS_FILTEREDVU_INTENSITY     uint2(24,28) //Size: 4, 1
			#define ALPASS_FILTEREDVU_MARKER        uint2(24,29) //Size: 4, 1
			
			// Some basic constants to use (Note, these should be compatible with
			// future version of AudioLink, but may change.
			#define AUDIOLINK_SAMPHIST              3069        // Internal use for algos, do not change.
			#define AUDIOLINK_SAMPLEDATA24          2046
			#define AUDIOLINK_EXPBINS               24
			#define AUDIOLINK_EXPOCT                10
			#define AUDIOLINK_ETOTALBINS (AUDIOLINK_EXPBINS * AUDIOLINK_EXPOCT)
			#define AUDIOLINK_WIDTH                 128
			#define AUDIOLINK_SPS                   48000       // Samples per second
			#define AUDIOLINK_ROOTNOTE              0
			#define AUDIOLINK_4BAND_FREQFLOOR       0.123
			#define AUDIOLINK_4BAND_FREQCEILING     1
			#define AUDIOLINK_BOTTOM_FREQUENCY      13.75
			#define AUDIOLINK_BASE_AMPLITUDE        2.5
			#define AUDIOLINK_DELAY_COEFFICIENT_MIN 0.3
			#define AUDIOLINK_DELAY_COEFFICIENT_MAX 0.9
			#define AUDIOLINK_DFT_Q                 4.0
			#define AUDIOLINK_TREBLE_CORRECTION     5.0
			
			// ColorChord constants
			#define COLORCHORD_EMAXBIN              192
			#define COLORCHORD_IIR_DECAY_1          0.90
			#define COLORCHORD_IIR_DECAY_2          0.85
			#define COLORCHORD_CONSTANT_DECAY_1     0.01
			#define COLORCHORD_CONSTANT_DECAY_2     0.0
			#define COLORCHORD_NOTE_CLOSEST         3.0
			#define COLORCHORD_NEW_NOTE_GAIN        8.0
			#define COLORCHORD_MAX_NOTES            10
			
			uniform float4               _AudioTexture_TexelSize;
			
			#ifdef SHADER_TARGET_SURFACE_ANALYSIS
			#define AUDIOLINK_STANDARD_INDEXING
			#endif
			
			// Mechanism to index into texture.
			#ifdef AUDIOLINK_STANDARD_INDEXING
			sampler2D _AudioTexture;
			#define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, float4(uint2(xycoord) * _AudioTexture_TexelSize.xy, 0, 0))
			#else
			uniform Texture2D<float4> _AudioTexture;
			SamplerState sampler_AudioTexture;
			#define AudioLinkData(xycoord) _AudioTexture[uint2(xycoord)]
			#endif
			uniform sampler2D _Stored;
			uniform float4 _Stored_TexelSize;
			#define LumaData(x,y) tex2Dlod(_Stored, float4(x, y, 0, 0))
			//endex
			
			float _Mode;
			
			float _StochasticDeliotHeitzDensity;
			float _StochasticHexGridDensity;
			float _StochasticHexRotationStrength;
			float _StochasticHexFallOffContrast;
			float _StochasticHexFallOffPower;
			
			#if defined(PROP_LIGHTINGAOMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _LightingAOMaps;
			#endif
			float4 _LightingAOMaps_ST;
			float2 _LightingAOMapsPan;
			float _LightingAOMapsUV;
			float _LightDataAOStrengthR;
			float _LightDataAOStrengthG;
			float _LightDataAOStrengthB;
			float _LightDataAOStrengthA;
			float _LightDataAOGlobalMaskR;
			float _LightDataAOGlobalMaskBlendTypeR;
			
			#if defined(PROP_LIGHTINGDETAILSHADOWMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _LightingDetailShadowMaps;
			#endif
			float4 _LightingDetailShadowMaps_ST;
			float2 _LightingDetailShadowMapsPan;
			float _LightingDetailShadowMapsUV;
			float _LightingDetailShadowStrengthR;
			float _LightingDetailShadowStrengthG;
			float _LightingDetailShadowStrengthB;
			float _LightingDetailShadowStrengthA;
			float _LightingAddDetailShadowStrengthR;
			float _LightingAddDetailShadowStrengthG;
			float _LightingAddDetailShadowStrengthB;
			float _LightingAddDetailShadowStrengthA;
			float _LightDataDetailShadowGlobalMaskR;
			float _LightDataDetailShadowGlobalMaskBlendTypeR;
			
			#if defined(PROP_LIGHTINGSHADOWMASKS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _LightingShadowMasks;
			#endif
			float4 _LightingShadowMasks_ST;
			float2 _LightingShadowMasksPan;
			float _LightingShadowMasksUV;
			float _LightingShadowMaskStrengthR;
			float _LightingShadowMaskStrengthG;
			float _LightingShadowMaskStrengthB;
			float _LightingShadowMaskStrengthA;
			float _LightDataShadowMaskGlobalMaskR;
			float _LightDataShadowMaskGlobalMaskBlendTypeR;
			
			// Lighting Data
			float _Unlit_Intensity;
			float _LightingColorMode;
			float _LightingMapMode;
			float _LightingDirectionMode;
			float3 _LightngForcedDirection;
			float _LightingIndirectUsesNormals;
			float _LightingCapEnabled;
			float _LightingCap;
			float _LightingForceColorEnabled;
			float3 _LightingForcedColor;
			float _LightingForcedColorThemeIndex;
			float _LightingCastedShadows;
			float _LightingMonochromatic;
			float _LightingMinLightBrightness;
			// Additive Lighting Data
			float _LightingAdditiveEnable;
			float _LightingAdditiveLimited;
			float _LightingAdditiveLimit;
			float _LightingAdditiveCastedShadows;
			float _LightingAdditiveMonochromatic;
			float _LightingAdditivePassthrough;
			float _DisableDirectionalInAdd;
			float _LightingVertexLightingEnabled;
			// Lighting Data Debug
			float _LightDataDebugEnabled;
			float _LightingDebugVisualize;
			
			float _IgnoreFog;
			float _RenderingReduceClipDistance;
			float _AddBlendOp;
			
			float4 _Color;
			float _ColorThemeIndex;
			UNITY_DECLARE_TEX2D(_MainTex);
			UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);
			float _MainPixelMode;
			float4 _MainTex_ST;
			float2 _MainTexPan;
			float _MainTexUV;
			float4 _MainTex_TexelSize;
			float _MainTexStochastic;
			#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BumpMap;
			#endif
			float4 _BumpMap_ST;
			float2 _BumpMapPan;
			float _BumpMapUV;
			float _BumpScale;
			float _BumpMapStochastic;
			Texture2D _ClippingMask;
			float4 _ClippingMask_ST;
			float2 _ClippingMaskPan;
			float _ClippingMaskUV;
			float _Inverse_Clipping;
			float _Cutoff;
			//ifex _MainColorAdjustToggle==0
			float _MainColorAdjustToggle;
			#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MainColorAdjustTexture;
			#endif
			float4 _MainColorAdjustTexture_ST;
			float2 _MainColorAdjustTexturePan;
			float _MainColorAdjustTextureUV;
			float _MainHueShiftToggle;
			float _MainHueShiftReplace;
			float _MainHueShift;
			float _MainHueShiftSpeed;
			float _Saturation;
			float _MainBrightness;
			
			float _MainHueALCTEnabled;
			float _MainALHueShiftBand;
			float _MainALHueShiftCTIndex;
			float _MainHueALMotionSpeed;
			
			float _MainHueGlobalMask;
			float _MainHueGlobalMaskBlendType;
			float _MainSaturationGlobalMask;
			float _MainSaturationGlobalMaskBlendType;
			float _MainBrightnessGlobalMask;
			float _MainBrightnessGlobalMaskBlendType;
			//endex
			
			SamplerState sampler_linear_clamp;
			SamplerState sampler_linear_repeat;
			
			float _AlphaForceOpaque;
			float _AlphaMod;
			float _AlphaPremultiply;
			float _AlphaBoostFA;
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			float _AlphaToCoverage;
			float _AlphaSharpenedA2C;
			float _AlphaMipScale;
			//endex
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			float _AlphaDithering;
			float _AlphaDitherGradient;
			float _AlphaDitherBias;
			//endex
			
			//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
			float _AlphaDistanceFade;
			float _AlphaDistanceFadeType;
			float _AlphaDistanceFadeMinAlpha;
			float _AlphaDistanceFadeMaxAlpha;
			float _AlphaDistanceFadeMin;
			float _AlphaDistanceFadeMax;
			float _AlphaDistanceFadeGlobalMask;
			float _AlphaDistanceFadeGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
			float _AlphaFresnel;
			float _AlphaFresnelAlpha;
			float _AlphaFresnelSharpness;
			float _AlphaFresnelWidth;
			float _AlphaFresnelInvert;
			float _AlphaFresnelGlobalMask;
			float _AlphaFresnelGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
			float _AlphaAngular;
			float _AngleType;
			float _AngleCompareTo;
			float3 _AngleForwardDirection;
			float _CameraAngleMin;
			float _CameraAngleMax;
			float _ModelAngleMin;
			float _ModelAngleMax;
			float _AngleMinAlpha;
			float _AlphaAngularGlobalMask;
			float _AlphaAngularGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
			float _AlphaAudioLinkEnabled;
			float2 _AlphaAudioLinkAddRange;
			float _AlphaAudioLinkAddBand;
			//endex
			
			float _AlphaGlobalMask;
			float _AlphaGlobalMaskBlendType;
			
			float4 _GlobalThemeColor0;
			float4 _GlobalThemeColor1;
			float4 _GlobalThemeColor2;
			float4 _GlobalThemeColor3;
			float _GlobalThemeHue0;
			float _GlobalThemeHue1;
			float _GlobalThemeHue2;
			float _GlobalThemeHue3;
			float _GlobalThemeHueSpeed0;
			float _GlobalThemeHueSpeed1;
			float _GlobalThemeHueSpeed2;
			float _GlobalThemeHueSpeed3;
			float _GlobalThemeSaturation0;
			float _GlobalThemeSaturation1;
			float _GlobalThemeSaturation2;
			float _GlobalThemeSaturation3;
			float _GlobalThemeValue0;
			float _GlobalThemeValue1;
			float _GlobalThemeValue2;
			float _GlobalThemeValue3;
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture0;
			#endif
			float4 _GlobalMaskTexture0_ST;
			float2 _GlobalMaskTexture0Pan;
			float _GlobalMaskTexture0UV;
			int _GlobalMaskTexture0Split;
			float4 _GlobalMaskTexture0SplitTilingOffset_G;
			float4 _GlobalMaskTexture0SplitPan_G;
			float4 _GlobalMaskTexture0SplitTilingOffset_B;
			float4 _GlobalMaskTexture0SplitPan_B;
			float4 _GlobalMaskTexture0SplitTilingOffset_A;
			float4 _GlobalMaskTexture0SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture1;
			#endif
			float4 _GlobalMaskTexture1_ST;
			float2 _GlobalMaskTexture1Pan;
			float _GlobalMaskTexture1UV;
			int _GlobalMaskTexture1Split;
			float4 _GlobalMaskTexture1SplitTilingOffset_G;
			float4 _GlobalMaskTexture1SplitPan_G;
			float4 _GlobalMaskTexture1SplitTilingOffset_B;
			float4 _GlobalMaskTexture1SplitPan_B;
			float4 _GlobalMaskTexture1SplitTilingOffset_A;
			float4 _GlobalMaskTexture1SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture2;
			#endif
			float4 _GlobalMaskTexture2_ST;
			float2 _GlobalMaskTexture2Pan;
			float _GlobalMaskTexture2UV;
			int _GlobalMaskTexture2Split;
			float4 _GlobalMaskTexture2SplitTilingOffset_G;
			float4 _GlobalMaskTexture2SplitPan_G;
			float4 _GlobalMaskTexture2SplitTilingOffset_B;
			float4 _GlobalMaskTexture2SplitPan_B;
			float4 _GlobalMaskTexture2SplitTilingOffset_A;
			float4 _GlobalMaskTexture2SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture3;
			#endif
			float4 _GlobalMaskTexture3_ST;
			float2 _GlobalMaskTexture3Pan;
			float _GlobalMaskTexture3UV;
			int _GlobalMaskTexture3Split;
			float4 _GlobalMaskTexture3SplitTilingOffset_G;
			float4 _GlobalMaskTexture3SplitPan_G;
			float4 _GlobalMaskTexture3SplitTilingOffset_B;
			float4 _GlobalMaskTexture3SplitPan_B;
			float4 _GlobalMaskTexture3SplitTilingOffset_A;
			float4 _GlobalMaskTexture3SplitPan_A;
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			float _GlobalMaskOptionsEnable;
			int _GlobalMaskOptionsType;
			
			//ifex _GlobalMaskOptionsType!=0
			float _GlobalMaskSlider_0;
			float _GlobalMaskSlider_1;
			float _GlobalMaskSlider_2;
			float _GlobalMaskSlider_3;
			float _GlobalMaskSlider_4;
			float _GlobalMaskSlider_5;
			float _GlobalMaskSlider_6;
			float _GlobalMaskSlider_7;
			float _GlobalMaskSlider_8;
			float _GlobalMaskSlider_9;
			float _GlobalMaskSlider_10;
			float _GlobalMaskSlider_11;
			float _GlobalMaskSlider_12;
			float _GlobalMaskSlider_13;
			float _GlobalMaskSlider_14;
			float _GlobalMaskSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=1
			float2 _GlobalMaskMinMaxSlider_0;
			float2 _GlobalMaskMinMaxSlider_1;
			float2 _GlobalMaskMinMaxSlider_2;
			float2 _GlobalMaskMinMaxSlider_3;
			float2 _GlobalMaskMinMaxSlider_4;
			float2 _GlobalMaskMinMaxSlider_5;
			float2 _GlobalMaskMinMaxSlider_6;
			float2 _GlobalMaskMinMaxSlider_7;
			float2 _GlobalMaskMinMaxSlider_8;
			float2 _GlobalMaskMinMaxSlider_9;
			float2 _GlobalMaskMinMaxSlider_10;
			float2 _GlobalMaskMinMaxSlider_11;
			float2 _GlobalMaskMinMaxSlider_12;
			float2 _GlobalMaskMinMaxSlider_13;
			float2 _GlobalMaskMinMaxSlider_14;
			float2 _GlobalMaskMinMaxSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=2
			int  _GlobalMaskToggleOn_0;
			int _GlobalMaskToggleOff_0;
			int  _GlobalMaskToggleOn_1;
			int _GlobalMaskToggleOff_1;
			int  _GlobalMaskToggleOn_2;
			int _GlobalMaskToggleOff_2;
			int  _GlobalMaskToggleOn_3;
			int _GlobalMaskToggleOff_3;
			int  _GlobalMaskToggleOn_4;
			int _GlobalMaskToggleOff_4;
			int  _GlobalMaskToggleOn_5;
			int _GlobalMaskToggleOff_5;
			int  _GlobalMaskToggleOn_6;
			int _GlobalMaskToggleOff_6;
			int  _GlobalMaskToggleOn_7;
			int _GlobalMaskToggleOff_7;
			int  _GlobalMaskToggleOn_8;
			int _GlobalMaskToggleOff_8;
			int  _GlobalMaskToggleOn_9;
			int _GlobalMaskToggleOff_9;
			int  _GlobalMaskToggleOn_10;
			int _GlobalMaskToggleOff_10;
			int  _GlobalMaskToggleOn_11;
			int _GlobalMaskToggleOff_11;
			int  _GlobalMaskToggleOn_12;
			int _GlobalMaskToggleOff_12;
			int  _GlobalMaskToggleOn_13;
			int _GlobalMaskToggleOff_13;
			int  _GlobalMaskToggleOn_14;
			int _GlobalMaskToggleOff_14;
			int  _GlobalMaskToggleOn_15;
			int _GlobalMaskToggleOff_15;
			//endex
			//endex
			//ifex _GlobalMaskModifiersBackfaceEnable==0
			float _GlobalMaskModifiersBackfaceEnable;
			float _GlobalMaskBackface_0;
			float _GlobalMaskBackface_1;
			float _GlobalMaskBackface_2;
			float _GlobalMaskBackface_3;
			float _GlobalMaskBackface_4;
			float _GlobalMaskBackface_5;
			float _GlobalMaskBackface_6;
			float _GlobalMaskBackface_7;
			float _GlobalMaskBackface_8;
			float _GlobalMaskBackface_9;
			float _GlobalMaskBackface_10;
			float _GlobalMaskBackface_11;
			float _GlobalMaskBackface_12;
			float _GlobalMaskBackface_13;
			float _GlobalMaskBackface_14;
			float _GlobalMaskBackface_15;
			//endex
			
			//ifex _GlobalMaskModifiersMirrorEnable==0
			float _GlobalMaskModifiersMirrorEnable;
			float _GlobalMaskMirrorVisibilityMode;
			float _GlobalMaskMirror_0;
			float _GlobalMaskMirror_1;
			float _GlobalMaskMirror_2;
			float _GlobalMaskMirror_3;
			float _GlobalMaskMirror_4;
			float _GlobalMaskMirror_5;
			float _GlobalMaskMirror_6;
			float _GlobalMaskMirror_7;
			float _GlobalMaskMirror_8;
			float _GlobalMaskMirror_9;
			float _GlobalMaskMirror_10;
			float _GlobalMaskMirror_11;
			float _GlobalMaskMirror_12;
			float _GlobalMaskMirror_13;
			float _GlobalMaskMirror_14;
			float _GlobalMaskMirror_15;
			//endex
			
			//ifex _GlobalMaskModifiersCameraEnable==0
			float _GlobalMaskModifiersCameraEnable;
			float _GlobalMaskCamera_0;
			float _GlobalMaskCamera_1;
			float _GlobalMaskCamera_2;
			float _GlobalMaskCamera_3;
			float _GlobalMaskCamera_4;
			float _GlobalMaskCamera_5;
			float _GlobalMaskCamera_6;
			float _GlobalMaskCamera_7;
			float _GlobalMaskCamera_8;
			float _GlobalMaskCamera_9;
			float _GlobalMaskCamera_10;
			float _GlobalMaskCamera_11;
			float _GlobalMaskCamera_12;
			float _GlobalMaskCamera_13;
			float _GlobalMaskCamera_14;
			float _GlobalMaskCamera_15;
			//endex
			
			//ifex _GlobalMaskModifiersDistanceEnable==0
			int _GlobalMaskModifiersDistanceEnable;
			
			//ifex _GlobalMaskDistanceEnable_0==0
			int _GlobalMaskDistanceEnable_0;
			int _GlobalMaskDistanceType_0;
			float _GlobalMaskDistanceMin_0;
			float _GlobalMaskDistanceMax_0;
			float _GlobalMaskDistanceMinAlpha_0;
			float _GlobalMaskDistanceMaxAlpha_0;
			int _GlobalMaskDistanceBlendType_0;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_1==0
			int _GlobalMaskDistanceEnable_1;
			int _GlobalMaskDistanceType_1;
			float _GlobalMaskDistanceMin_1;
			float _GlobalMaskDistanceMax_1;
			float _GlobalMaskDistanceMinAlpha_1;
			float _GlobalMaskDistanceMaxAlpha_1;
			int _GlobalMaskDistanceBlendType_1;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_2==0
			int _GlobalMaskDistanceEnable_2;
			int _GlobalMaskDistanceType_2;
			float _GlobalMaskDistanceMin_2;
			float _GlobalMaskDistanceMax_2;
			float _GlobalMaskDistanceMinAlpha_2;
			float _GlobalMaskDistanceMaxAlpha_2;
			int _GlobalMaskDistanceBlendType_2;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_3==0
			int _GlobalMaskDistanceEnable_3;
			int _GlobalMaskDistanceType_3;
			float _GlobalMaskDistanceMin_3;
			float _GlobalMaskDistanceMax_3;
			float _GlobalMaskDistanceMinAlpha_3;
			float _GlobalMaskDistanceMaxAlpha_3;
			int _GlobalMaskDistanceBlendType_3;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_4==0
			int _GlobalMaskDistanceEnable_4;
			int _GlobalMaskDistanceType_4;
			float _GlobalMaskDistanceMin_4;
			float _GlobalMaskDistanceMax_4;
			float _GlobalMaskDistanceMinAlpha_4;
			float _GlobalMaskDistanceMaxAlpha_4;
			int _GlobalMaskDistanceBlendType_4;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_5==0
			int _GlobalMaskDistanceEnable_5;
			int _GlobalMaskDistanceType_5;
			float _GlobalMaskDistanceMin_5;
			float _GlobalMaskDistanceMax_5;
			float _GlobalMaskDistanceMinAlpha_5;
			float _GlobalMaskDistanceMaxAlpha_5;
			int _GlobalMaskDistanceBlendType_5;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_6==0
			int _GlobalMaskDistanceEnable_6;
			int _GlobalMaskDistanceType_6;
			float _GlobalMaskDistanceMin_6;
			float _GlobalMaskDistanceMax_6;
			float _GlobalMaskDistanceMinAlpha_6;
			float _GlobalMaskDistanceMaxAlpha_6;
			int _GlobalMaskDistanceBlendType_6;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_7==0
			int _GlobalMaskDistanceEnable_7;
			int _GlobalMaskDistanceType_7;
			float _GlobalMaskDistanceMin_7;
			float _GlobalMaskDistanceMax_7;
			float _GlobalMaskDistanceMinAlpha_7;
			float _GlobalMaskDistanceMaxAlpha_7;
			int _GlobalMaskDistanceBlendType_7;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_8==0
			int _GlobalMaskDistanceEnable_8;
			int _GlobalMaskDistanceType_8;
			float _GlobalMaskDistanceMin_8;
			float _GlobalMaskDistanceMax_8;
			float _GlobalMaskDistanceMinAlpha_8;
			float _GlobalMaskDistanceMaxAlpha_8;
			int _GlobalMaskDistanceBlendType_8;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_9==0
			int _GlobalMaskDistanceEnable_9;
			int _GlobalMaskDistanceType_9;
			float _GlobalMaskDistanceMin_9;
			float _GlobalMaskDistanceMax_9;
			float _GlobalMaskDistanceMinAlpha_9;
			float _GlobalMaskDistanceMaxAlpha_9;
			int _GlobalMaskDistanceBlendType_9;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_10==0
			int _GlobalMaskDistanceEnable_10;
			int _GlobalMaskDistanceType_10;
			float _GlobalMaskDistanceMin_10;
			float _GlobalMaskDistanceMax_10;
			float _GlobalMaskDistanceMinAlpha_10;
			float _GlobalMaskDistanceMaxAlpha_10;
			int _GlobalMaskDistanceBlendType_10;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_11==0
			int _GlobalMaskDistanceEnable_11;
			int _GlobalMaskDistanceType_11;
			float _GlobalMaskDistanceMin_11;
			float _GlobalMaskDistanceMax_11;
			float _GlobalMaskDistanceMinAlpha_11;
			float _GlobalMaskDistanceMaxAlpha_11;
			int _GlobalMaskDistanceBlendType_11;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_12==0
			int _GlobalMaskDistanceEnable_12;
			int _GlobalMaskDistanceType_12;
			float _GlobalMaskDistanceMin_12;
			float _GlobalMaskDistanceMax_12;
			float _GlobalMaskDistanceMinAlpha_12;
			float _GlobalMaskDistanceMaxAlpha_12;
			int _GlobalMaskDistanceBlendType_12;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_13==0
			int _GlobalMaskDistanceEnable_13;
			int _GlobalMaskDistanceType_13;
			float _GlobalMaskDistanceMin_13;
			float _GlobalMaskDistanceMax_13;
			float _GlobalMaskDistanceMinAlpha_13;
			float _GlobalMaskDistanceMaxAlpha_13;
			int _GlobalMaskDistanceBlendType_13;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_14==0
			int _GlobalMaskDistanceEnable_14;
			int _GlobalMaskDistanceType_14;
			float _GlobalMaskDistanceMin_14;
			float _GlobalMaskDistanceMax_14;
			float _GlobalMaskDistanceMinAlpha_14;
			float _GlobalMaskDistanceMaxAlpha_14;
			int _GlobalMaskDistanceBlendType_14;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_15==0
			int _GlobalMaskDistanceEnable_15;
			int _GlobalMaskDistanceType_15;
			float _GlobalMaskDistanceMin_15;
			float _GlobalMaskDistanceMax_15;
			float _GlobalMaskDistanceMinAlpha_15;
			float _GlobalMaskDistanceMaxAlpha_15;
			int _GlobalMaskDistanceBlendType_15;
			//endex
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			float _UDIMDiscardMode;
			float _UDIMDiscardUV;
			float _UDIMDiscardRow3_0;
			float _UDIMDiscardRow3_1;
			float _UDIMDiscardRow3_2;
			float _UDIMDiscardRow3_3;
			float _UDIMDiscardRow2_0;
			float _UDIMDiscardRow2_1;
			float _UDIMDiscardRow2_2;
			float _UDIMDiscardRow2_3;
			float _UDIMDiscardRow1_0;
			float _UDIMDiscardRow1_1;
			float _UDIMDiscardRow1_2;
			float _UDIMDiscardRow1_3;
			float _UDIMDiscardRow0_0;
			float _UDIMDiscardRow0_1;
			float _UDIMDiscardRow0_2;
			float _UDIMDiscardRow0_3;
			#endif
			//endex
			
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture;
			float4 _DistortionFlowTexture_ST;
			float2 _DistortionFlowTexturePan;
			float _DistortionFlowTextureUV;
			#endif
			
			#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture1;
			float4 _DistortionFlowTexture1_ST;
			float2 _DistortionFlowTexture1Pan;
			float _DistortionFlowTexture1UV;
			#endif
			
			#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionMask;
			float4 _DistortionMask_ST;
			float2 _DistortionMaskPan;
			float _DistortionMaskUV;
			float _DistortionMaskChannel;
			#endif
			
			float _DistortionUvToDistort;
			float _DistortionStrength;
			float _DistortionStrength1;
			
			#ifdef POI_AUDIOLINK
			half _EnableDistortionAudioLink;
			half2 _DistortionStrengthAudioLink;
			half _DistortionStrengthAudioLinkBand;
			half2 _DistortionStrength1AudioLink;
			half _DistortionStrength1AudioLinkBand;
			#endif
			#endif
			//endex
			float _StereoEnabled;
			float _PolarUV;
			float2 _PolarCenter;
			float _PolarRadialScale;
			float _PolarLengthScale;
			float _PolarSpiralPower;
			float _PanoUseBothEyes;
			
			float _UVModWorldPos0;
			float _UVModWorldPos1;
			float _UVModLocalPos0;
			float _UVModLocalPos1;
			
			//ifex _PoiParallax==0
			#ifdef POI_PARALLAX
			
			sampler2D _HeightMap;
			float4 _HeightMap_ST;
			float2 _HeightMapPan;
			float _HeightMapUV;
			
			#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Heightmask;
			float4 _Heightmask_ST;
			float2 _HeightmaskPan;
			float _HeightmaskUV;
			float _HeightmaskChannel;
			float _HeightmaskInvert;
			SamplerState _linear_repeat;
			#endif
			
			float _ParallaxUV;
			float _HeightStrength;
			float _HeightOffset;
			float _HeightStepsMin;
			float _HeightStepsMax;
			
			float _CurvatureU;
			float _CurvatureV;
			float _CurvFix;
			#endif
			//endex
			
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			float _AudioLinkDelay;
			float _AudioLinkAnimToggle;
			
			float _AudioLinkSmoothingBass;
			float _AudioLinkSmoothingLowMid;
			float _AudioLinkSmoothingHighMid;
			float _AudioLinkSmoothingTreble;
			
			float _DebugWaveform;
			float _DebugDFT;
			float _DebugBass;
			float _DebugLowMids;
			float _DebugHighMids;
			float _DebugTreble;
			float _DebugCCColors;
			float _DebugCCStrip;
			float _DebugCCLights;
			float _DebugAutocorrelator;
			float _DebugChronotensity;
			float _AudioLinkCCStripY;
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			float _BlackLightMasking0Key;
			float2 _BlackLightMasking0Range;
			float _BlackLightMasking0GlobalMaskIndex;
			float _BlackLightMasking0GlobalMaskBlendType;
			
			float _BlackLightMasking1Key;
			float2 _BlackLightMasking1Range;
			float _BlackLightMasking1GlobalMaskIndex;
			float _BlackLightMasking1GlobalMaskBlendType;
			
			float _BlackLightMasking2Key;
			float2 _BlackLightMasking2Range;
			float _BlackLightMasking2GlobalMaskIndex;
			float _BlackLightMasking2GlobalMaskBlendType;
			
			float _BlackLightMasking3Key;
			float2 _BlackLightMasking3Range;
			float _BlackLightMasking3GlobalMaskIndex;
			float _BlackLightMasking3GlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _DetailEnabled==0
			#ifdef FINALPASS
			#if defined(PROP_DETAILMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailMask;
			#endif
			float4 _DetailMask_ST;
			float2 _DetailMaskPan;
			float _DetailMaskUV;
			float _DetailMaskStochastic;
			
			#if defined(PROP_DETAILNORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailNormalMap;
			#endif
			float4 _DetailNormalMap_ST;
			float2 _DetailNormalMapPan;
			float _DetailNormalMapUV;
			float _DetailNormalMapScale;
			float _DetailNormalMapStochastic;
			float _DetailNormalGlobalMask;
			float _DetailNormalGlobalMaskBlendType;
			
			#if defined(PROP_DETAILTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailTex;
			#endif
			float4 _DetailTex_ST;
			float2 _DetailTexPan;
			float _DetailTexUV;
			float _DetailTexStochastic;
			
			float3 _DetailTint;
			float _DetailTintThemeIndex;
			float _DetailTexIntensity;
			float _DetailBrightness;
			float _DetailTexGlobalMask;
			float _DetailTexGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#ifdef AUTO_EXPOSURE
			float4 _VertexManipulationLocalTranslation;
			float4 _VertexManipulationLocalRotation;
			float3 _VertexManipulationLocalRotationSpeed;
			float4 _VertexManipulationLocalScale;
			float4 _VertexManipulationWorldTranslation;
			float _VertexManipulationHeight;
			sampler2D _VertexManipulationHeightMask;
			float4 _VertexManipulationHeightMask_ST;
			float2 _VertexManipulationHeightMaskPan;
			float _VertexManipulationHeightMaskUV;
			float _VertexManipulationHeightMaskChannel;
			float _VertexManipulationHeightBias;
			float _VertexRoundingEnabled;
			int _VertexRoundingSpace;
			float _VertexRoundingDivision;
			
			//AL
			float _VertexAudioLinkEnabled;
			float3 _VertexLocalTranslationALMin;
			float3 _VertexLocalTranslationALMax;
			float _VertexLocalTranslationALBand;
			
			float3 _VertexLocalRotationAL;
			float _VertexLocalRotationALBand;
			
			float3 _VertexLocalRotationCTALSpeed;
			float _VertexLocalRotationCTALBandX;
			float _VertexLocalRotationCTALBandY;
			float _VertexLocalRotationCTALBandZ;
			float _VertexLocalRotationCTALTypeX;
			float _VertexLocalRotationCTALTypeY;
			float _VertexLocalRotationCTALTypeZ;
			
			float4 _VertexLocalScaleALMin;
			float4 _VertexLocalScaleALMax;
			float _VertexLocalScaleALBand;
			
			float3 _VertexWorldTranslationALMin;
			float3 _VertexWorldTranslationALMax;
			float _VertexWorldTranslationALBand;
			
			float2 _VertexManipulationHeightAL;
			float _VertexManipulationHeightBand;
			
			float2 _VertexRoundingRangeAL;
			float _VertexRoundingRangeBand;
			
			float _VertexBarrelMode;
			float _VertexBarrelWidth;
			float _VertexBarrelAlpha;
			float _VertexBarrelHeight;
			
			float _VertexSphereMode;
			float _VertexSphereRadius;
			float _VertexSphereHeight;
			float _VertexSphereAlpha;
			float4 _VertexSphereCenter;
			
			float _VertexSpectrumMotion;
			float3 _VertexSpectrumOffsetMin;
			float3 _VertexSpectrumOffsetMax;
			float _VertexSpectrumUV;
			float _VertexSpectrumUVDirection;
			#endif
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#ifdef POI_VERTEX_GLITCHING
			//Vertex Glitching
			#if defined(POI_VERTEX_GLITCHING_TEXTURE)
			float _VertexGlitchingUseTexture;
			sampler2D _VertexGlitchMap;
			float4 _VertexGlitchMap_ST;
			#endif
			float _VertexGlitchThreshold;
			float _VertexGlitchFrequency;
			float _VertexGlitchStrength;
			float _VertexGlitchDensity;
			
			float _VertexGlitchMirrorEnable;
			float _VertexGlitchMirror;
			
			float _VertexGlitchMapPanSpeed;
			float _VertexGlitchingAudioLinkEnabled;
			float _VertexGlitchingAudioLinkBand;
			float _VertexGlitchingAudiolinkOverride;
			#endif
			//endex
			
			//ifex _EnableDepthBulge==0
			#ifdef POI_DEPTHBULGE
			float _DepthBulgeFadeLength;
			float _DepthBulgeHeight;
			
			#if defined(PROP_DEPTHBULGEMASK) || !defined(OPTIMIZER_ENABLED)
			sampler2D _DepthBulgeMask;
			#endif
			float _DepthBulgeMaskUV;
			float4 _DepthBulgeMask_ST;
			float _DepthBulgeMaskChannel;
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			float _MainVertexColoringEnabled;
			float _MainVertexColoringLinearSpace;
			float _MainVertexColoring;
			float _MainUseVertexColorAlpha;
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			float _BackFaceEnabled;
			float _BackFaceDetailIntensity;
			float _BackFaceEmissionStrength;
			float2 _BackFacePanning;
			float4 _BackFaceColor;
			float _BackFaceColorThemeIndex;
			float _BackFaceReplaceAlpha;
			
			#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceTexture;
			#endif
			float4 _BackFaceTexture_ST;
			float2 _BackFaceTexturePan;
			float _BackFaceTextureUV;
			
			#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceMask;
			#endif
			float4 _BackFaceMask_ST;
			float2 _BackFaceMaskPan;
			float _BackFaceMaskUV;
			float _BackFaceMaskChannel;
			
			float _BackFaceHueShiftEnabled;
			float _BackFaceHueShift;
			float _BackFaceHueShiftSpeed;
			float _BackFaceEmissionLimiter;
			#endif
			
			//TODO detail strength stuff
			//endex
			
			//ifex _RGBMaskEnabled==0
			#ifdef VIGNETTE
			#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RGBMask;
			#endif
			float4 _RGBMask_ST;
			float2 _RGBMaskPan;
			float _RGBMaskUV;
			
			#if defined(PROP_REDTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RedTexture;
			#endif
			float4 _RedTexture_ST;
			float2 _RedTexturePan;
			float _RedTextureUV;
			float _RedAlphaAdd;
			float _RedTextureStochastic;
			float _RgbRedMaskChannel;
			float _RgbRedGlobalMaskChannel;
			float _RgbRedGlobalMaskBlendType;
			
			#if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GreenTexture;
			#endif
			float4 _GreenTexture_ST;
			float2 _GreenTexturePan;
			float _GreenTextureUV;
			float _GreenAlphaAdd;
			float _GreenTextureStochastic;
			float _RgbGreenMaskChannel;
			float _RgbGreenGlobalMaskChannel;
			float _RgbGreenGlobalMaskBlendType;
			
			#if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BlueTexture;
			#endif
			float4 _BlueTexture_ST;
			float2 _BlueTexturePan;
			float _BlueTextureUV;
			float _BlueAlphaAdd;
			float _BlueTextureStochastic;
			float _RgbBlueMaskChannel;
			float _RgbBlueGlobalMaskChannel;
			float _RgbBlueGlobalMaskBlendType;
			
			#if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AlphaTexture;
			#endif
			float4 _AlphaTexture_ST;
			float2 _AlphaTexturePan;
			float _AlphaTextureUV;
			float _AlphaAlphaAdd;
			float _AlphaTextureStochastic;
			float _RgbAlphaMaskChannel;
			float _RgbAlphaGlobalMaskChannel;
			float _RgbAlphaGlobalMaskBlendType;
			
			//ifex _RgbNormalsEnabled==0
			#ifdef GEOM_TYPE_MESH
			#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalR;
			#endif
			float4 _RgbNormalR_ST;
			float2 _RgbNormalRPan;
			float _RgbNormalRUV;
			float _RgbNormalRScale;
			float _RgbNormalRStochastic;
			float _RgbNormalRMaskChannel;
			float _RgbNormalRGlobalMaskChannel;
			float _RgbNormalRGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalG;
			#endif
			float4 _RgbNormalG_ST;
			float2 _RgbNormalGPan;
			float _RgbNormalGUV;
			float _RgbNormalGScale;
			float _RgbNormalGStochastic;
			float _RgbNormalGMaskChannel;
			float _RgbNormalGGlobalMaskChannel;
			float _RgbNormalGGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalB;
			#endif
			float4 _RgbNormalB_ST;
			float2 _RgbNormalBPan;
			float _RgbNormalBUV;
			float _RgbNormalBScale;
			float _RgbNormalBStochastic;
			float _RgbNormalBMaskChannel;
			float _RgbNormalBGlobalMaskChannel;
			float _RgbNormalBGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalA;
			#endif
			float4 _RgbNormalA_ST;
			float2 _RgbNormalAPan;
			float _RgbNormalAUV;
			float _RgbNormalAScale;
			float _RgbNormalAStochastic;
			float _RgbNormalAMaskChannel;
			float _RgbNormalAGlobalMaskChannel;
			float _RgbNormalAGlobalMaskBlendType;
			
			float _RgbNormalsEnabled;
			#endif
			//endex
			
			float4 _RedColor;
			float4 _GreenColor;
			float4 _BlueColor;
			float4 _AlphaColor;
			
			float _RedColorThemeIndex;
			float _GreenColorThemeIndex;
			float _BlueColorThemeIndex;
			float _AlphaColorThemeIndex;
			
			float _RGBBlendMultiplicative;
			float _RGBUseVertexColors;
			float _RGBNormalBlend;
			#endif
			//endex
			
			//ifex _DecalEnabled==0 && _DecalEnabled1==0 && _DecalEnabled2==0 && _DecalEnabled3==0
			#if defined(PROP_DECALMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DecalMask;
			float4 _DecalMask_ST;
			float2 _DecalMaskPan;
			float _DecalMaskUV;
			#endif
			float _DecalTPSDepthMaskEnabled;
			float _Decal0TPSMaskStrength;
			float _Decal1TPSMaskStrength;
			float _Decal2TPSMaskStrength;
			float _Decal3TPSMaskStrength;
			#ifdef POI_AUDIOLINK
			//ifex _DecalEnabled==0
			#ifdef GEOM_TYPE_BRANCH
			// Audio Link
			half _AudioLinkDecal0ScaleBand;
			float4 _AudioLinkDecal0Scale;
			half _AudioLinkDecal0RotationBand;
			float2 _AudioLinkDecal0Rotation;
			half _AudioLinkDecal0AlphaBand;
			float2 _AudioLinkDecal0Alpha;
			half _AudioLinkDecal0EmissionBand;
			float2 _AudioLinkDecal0Emission;
			float _DecalRotationCTALBand0;
			float _DecalRotationCTALSpeed0;
			float _DecalRotationCTALType0;
			float _AudioLinkDecalCC0;
			float _AudioLinkDecal0SideBand;
			float4 _AudioLinkDecal0SideMin;
			float4 _AudioLinkDecal0SideMax;
			float2 _AudioLinkDecal0ChannelSeparation;
			float _AudioLinkDecal0ChannelSeparationBand;
			#endif //GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#ifdef GEOM_TYPE_BRANCH_DETAIL
			half _AudioLinkDecal1ScaleBand;
			float4 _AudioLinkDecal1Scale;
			half _AudioLinkDecal1RotationBand;
			float2 _AudioLinkDecal1Rotation;
			half _AudioLinkDecal1AlphaBand;
			float2 _AudioLinkDecal1Alpha;
			half _AudioLinkDecal1EmissionBand;
			float2 _AudioLinkDecal1Emission;
			float _DecalRotationCTALBand1;
			float _DecalRotationCTALSpeed1;
			float _DecalRotationCTALType1;
			float _AudioLinkDecalCC1;
			float _AudioLinkDecal1SideBand;
			float4 _AudioLinkDecal1SideMin;
			float4 _AudioLinkDecal1SideMax;
			float2 _AudioLinkDecal1ChannelSeparation;
			float _AudioLinkDecal1ChannelSeparationBand;
			#endif //GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#ifdef GEOM_TYPE_FROND
			half _AudioLinkDecal2ScaleBand;
			float4 _AudioLinkDecal2Scale;
			half _AudioLinkDecal2RotationBand;
			float2 _AudioLinkDecal2Rotation;
			half _AudioLinkDecal2AlphaBand;
			float2 _AudioLinkDecal2Alpha;
			half _AudioLinkDecal2EmissionBand;
			float2 _AudioLinkDecal2Emission;
			float _DecalRotationCTALBand2;
			float _DecalRotationCTALSpeed2;
			float _DecalRotationCTALType2;
			float _AudioLinkDecalCC2;
			float _AudioLinkDecal2SideBand;
			float4 _AudioLinkDecal2SideMin;
			float4 _AudioLinkDecal2SideMax;
			float2 _AudioLinkDecal2ChannelSeparation;
			float _AudioLinkDecal2ChannelSeparationBand;
			#endif //GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#ifdef DEPTH_OF_FIELD_COC_VIEW
			half _AudioLinkDecal3ScaleBand;
			float4 _AudioLinkDecal3Scale;
			half _AudioLinkDecal3RotationBand;
			float2 _AudioLinkDecal3Rotation;
			half _AudioLinkDecal3AlphaBand;
			float2 _AudioLinkDecal3Alpha;
			half _AudioLinkDecal3EmissionBand;
			float2 _AudioLinkDecal3Emission;
			float _DecalRotationCTALBand3;
			float _DecalRotationCTALSpeed3;
			float _DecalRotationCTALType3;
			float _AudioLinkDecalCC3;
			float _AudioLinkDecal3SideBand;
			float4 _AudioLinkDecal3SideMin;
			float4 _AudioLinkDecal3SideMax;
			float2 _AudioLinkDecal3ChannelSeparation;
			float _AudioLinkDecal3ChannelSeparationBand;
			#endif //DEPTH_OF_FIELD_COC_VIEW
			//endex
			#endif
			//endex
			//ifex _DecalEnabled==0
			#ifdef GEOM_TYPE_BRANCH
			sampler2D _DecalTexture;
			
			float _Decal0MaskChannel;
			float _Decal0GlobalMask;
			float _Decal0GlobalMaskBlendType;
			float _Decal0ApplyGlobalMaskIndex;
			float _Decal0ApplyGlobalMaskBlendType;
			float4 _DecalTexture_ST;
			float2 _DecalTexturePan;
			float _DecalTextureUV;
			float4 _DecalColor;
			float _DecalColorThemeIndex;
			float _DecalTiled;
			float _DecalBlendType;
			half _DecalRotation;
			half2 _DecalScale;
			float4 _DecalSideOffset;
			half2 _DecalPosition;
			half _DecalRotationSpeed;
			float _DecalEmissionStrength;
			float _DecalBlendAlpha;
			float _DecalOverrideAlpha;
			float _DecalHueShiftEnabled;
			float _DecalHueShift;
			float _DecalHueShiftSpeed;
			float _Decal0Depth;
			float _Decal0HueAngleStrength;
			float _Decal0ChannelSeparationEnable;
			float _Decal0ChannelSeparation;
			float _Decal0ChannelSeparationPremultiply;
			float _Decal0ChannelSeparationHue;
			float _Decal0ChannelSeparationVertical;
			float _Decal0ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled1==0
			#ifdef GEOM_TYPE_BRANCH_DETAIL
			sampler2D _DecalTexture1;
			
			float _Decal1MaskChannel;
			float _Decal1GlobalMask;
			float _Decal1GlobalMaskBlendType;
			float _Decal1ApplyGlobalMaskIndex;
			float _Decal1ApplyGlobalMaskBlendType;
			float4 _DecalTexture1_ST;
			float2 _DecalTexture1Pan;
			float _DecalTexture1UV;
			float4 _DecalColor1;
			float _DecalColor1ThemeIndex;
			fixed _DecalTiled1;
			float _DecalBlendType1;
			half _DecalRotation1;
			half2 _DecalScale1;
			float4 _DecalSideOffset1;
			half2 _DecalPosition1;
			half _DecalRotationSpeed1;
			float _DecalEmissionStrength1;
			float _DecalBlendAlpha1;
			float _DecalOverrideAlpha1;
			float _DecalHueShiftEnabled1;
			float _DecalHueShift1;
			float _DecalHueShiftSpeed1;
			float _Decal1Depth;
			float _Decal1HueAngleStrength;
			float _Decal1ChannelSeparationEnable;
			float _Decal1ChannelSeparation;
			float _Decal1ChannelSeparationPremultiply;
			float _Decal1ChannelSeparationHue;
			float _Decal1ChannelSeparationVertical;
			float _Decal1ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled2==0
			#ifdef GEOM_TYPE_FROND
			sampler2D _DecalTexture2;
			
			float _Decal2MaskChannel;
			float _Decal2GlobalMask;
			float _Decal2GlobalMaskBlendType;
			float _Decal2ApplyGlobalMaskIndex;
			float _Decal2ApplyGlobalMaskBlendType;
			float4 _DecalTexture2_ST;
			float2 _DecalTexture2Pan;
			float _DecalTexture2UV;
			float4 _DecalColor2;
			float _DecalColor2ThemeIndex;
			fixed _DecalTiled2;
			float _DecalBlendType2;
			half _DecalRotation2;
			half2 _DecalScale2;
			float4 _DecalSideOffset2;
			half2 _DecalPosition2;
			half _DecalRotationSpeed2;
			float _DecalEmissionStrength2;
			float _DecalBlendAlpha2;
			float _DecalOverrideAlpha2;
			float _DecalHueShiftEnabled2;
			float _DecalHueShift2;
			float _DecalHueShiftSpeed2;
			float _Decal2Depth;
			float _Decal2HueAngleStrength;
			float _Decal2ChannelSeparationEnable;
			float _Decal2ChannelSeparation;
			float _Decal2ChannelSeparationPremultiply;
			float _Decal2ChannelSeparationHue;
			float _Decal2ChannelSeparationVertical;
			float _Decal2ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled3==0
			#ifdef DEPTH_OF_FIELD_COC_VIEW
			sampler2D _DecalTexture3;
			
			float _Decal3MaskChannel;
			float _Decal3GlobalMask;
			float _Decal3GlobalMaskBlendType;
			float _Decal3ApplyGlobalMaskIndex;
			float _Decal3ApplyGlobalMaskBlendType;
			float4 _DecalTexture3_ST;
			float2 _DecalTexture3Pan;
			float _DecalTexture3UV;
			float4 _DecalColor3;
			float _DecalColor3ThemeIndex;
			fixed _DecalTiled3;
			float _DecalBlendType3;
			half _DecalRotation3;
			half2 _DecalScale3;
			float4 _DecalSideOffset3;
			half2 _DecalPosition3;
			half _DecalRotationSpeed3;
			float _DecalEmissionStrength3;
			float _DecalBlendAlpha3;
			float _DecalOverrideAlpha3;
			float _DecalHueShiftEnabled3;
			float _DecalHueShift3;
			float _DecalHueShiftSpeed3;
			float _Decal3Depth;
			float _Decal3HueAngleStrength;
			float _Decal3ChannelSeparationEnable;
			float _Decal3ChannelSeparation;
			float _Decal3ChannelSeparationPremultiply;
			float _Decal3ChannelSeparationHue;
			float _Decal3ChannelSeparationVertical;
			float _Decal3ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			float _DissolveType;
			float _DissolveEdgeWidth;
			float4 _DissolveEdgeColor;
			sampler2D _DissolveEdgeGradient;
			float4 _DissolveEdgeGradient_ST;
			float2 _DissolveEdgeGradientPan;
			float _DissolveEdgeGradientUV;
			float _DissolveEdgeEmission;
			float4 _DissolveTextureColor;
			float _DissolveEdgeColorThemeIndex;
			float _DissolveTextureColorThemeIndex;
			
			#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveToTexture;
			#endif
			float4 _DissolveToTexture_ST;
			float2 _DissolveToTexturePan;
			float _DissolveToTextureUV;
			
			#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveNoiseTexture;
			#endif
			float4 _DissolveNoiseTexture_ST;
			float2 _DissolveNoiseTexturePan;
			float _DissolveNoiseTextureUV;
			
			#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveDetailNoise;
			#endif
			float4 _DissolveDetailNoise_ST;
			float2 _DissolveDetailNoisePan;
			float _DissolveDetailNoiseUV;
			
			#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveMask;
			#endif
			float4 _DissolveMask_ST;
			float2 _DissolveMaskPan;
			float _DissolveMaskUV;
			
			float _DissolveMaskGlobalMask;
			float _DissolveMaskGlobalMaskBlendType;
			float _DissolveMaskInvert;
			float _DissolveAlpha;
			float _ContinuousDissolve;
			float _DissolveDetailStrength;
			float _DissolveDetailEdgeSmoothing;
			float _DissolveEdgeHardness;
			float _DissolveInvertNoise;
			float _DissolveInvertDetailNoise;
			float _DissolveToEmissionStrength;
			
			// Point to Point
			float _DissolveP2PWorldLocal;
			float _DissolveP2PEdgeLength;
			float _DissolveP2PClamp;
			float4 _DissolveStartPoint;
			float4 _DissolveEndPoint;
			
			// Spherical
			float3 _SphericalDissolveCenter;
			float _SphericalDissolveRadius;
			float _SphericalDissolveInvert;
			float _SphericalDissolveClamp;
			
			// CenterOut
			float _CenterOutDissolveMode;
			float3 _CenterOutDissolveDirection;
			float _CenterOutDissolveInvert;
			float _CenterOutDissolveNormals;
			float _CenterOutDissolvePower;
			
			// World Dissolve
			float _DissolveWorldShape;
			float4 _DissolveShapePosition;
			float4 _DissolveShapeRotation;
			float _DissolveShapeScale;
			float _DissolveInvertShape;
			float _DissolveShapeEdgeLength;
			
			// UV Tile Dissolve
			float _UVTileDissolveEnabled;
			float _UVTileDissolveDiscardAtMax;
			float _UVTileDissolveUV;
			
			float _UVTileDissolveAlpha_Row3_0;
			float _UVTileDissolveAlpha_Row3_1;
			float _UVTileDissolveAlpha_Row3_2;
			float _UVTileDissolveAlpha_Row3_3;
			float _UVTileDissolveAlpha_Row2_0;
			float _UVTileDissolveAlpha_Row2_1;
			float _UVTileDissolveAlpha_Row2_2;
			float _UVTileDissolveAlpha_Row2_3;
			float _UVTileDissolveAlpha_Row1_0;
			float _UVTileDissolveAlpha_Row1_1;
			float _UVTileDissolveAlpha_Row1_2;
			float _UVTileDissolveAlpha_Row1_3;
			float _UVTileDissolveAlpha_Row0_0;
			float _UVTileDissolveAlpha_Row0_1;
			float _UVTileDissolveAlpha_Row0_2;
			float _UVTileDissolveAlpha_Row0_3;
			
			float _DissolveAlpha0;
			float _DissolveAlpha1;
			float _DissolveAlpha2;
			float _DissolveAlpha3;
			float _DissolveAlpha4;
			float _DissolveAlpha5;
			float _DissolveAlpha6;
			float _DissolveAlpha7;
			float _DissolveAlpha8;
			float _DissolveAlpha9;
			// Masking
			float _DissolveEmissionSide;
			float _DissolveEmission1Side;
			float _DissolveUseVertexColors;
			
			float4 edgeColor;
			float edgeAlpha;
			float dissolveAlpha;
			float4 dissolveToTexture;
			
			float _DissolveHueShiftEnabled;
			float _DissolveHueShiftSpeed;
			float _DissolveHueShift;
			float _DissolveEdgeHueShiftEnabled;
			float _DissolveEdgeHueShiftSpeed;
			float _DissolveEdgeHueShift;
			
			// Audio Link
			#ifdef POI_AUDIOLINK
			fixed _EnableDissolveAudioLink;
			half _AudioLinkDissolveAlphaBand;
			float2 _AudioLinkDissolveAlpha;
			half _AudioLinkDissolveDetailBand;
			float2 _AudioLinkDissolveDetail;
			#endif
			#endif
			//endex
			
			//ifex _ShadingEnabled==0
			float _ShadowStrength;
			float _LightingIgnoreAmbientColor;
			float3 _LightingShadowColor;
			
			// Toon Lighting
			#ifdef _LIGHTINGMODE_TEXTURERAMP
			UNITY_DECLARE_TEX2D(_ToonRamp);
			float _ShadowOffset;
			#endif
			
			#ifdef _LIGHTINGMODE_WRAPPED
			float _LightingWrappedWrap;
			float _LightingWrappedNormalization;
			float _LightingGradientStart;
			float _LightingGradientEnd;
			#endif
			
			#ifdef _LIGHTINGMODE_SHADEMAP
			float3 _1st_ShadeColor;
			#if defined(PROP_1ST_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _1st_ShadeMap;
			#endif
			float4 _1st_ShadeMap_ST;
			float2 _1st_ShadeMapPan;
			float _1st_ShadeMapUV;
			float _Use_1stShadeMapAlpha_As_ShadowMask;
			float _1stShadeMapMask_Inverse;
			float _Use_BaseAs1st;
			float3 _2nd_ShadeColor;
			#if defined(PROP_2ND_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _2nd_ShadeMap;
			#endif
			float4 _2nd_ShadeMap_ST;
			float2 _2nd_ShadeMapPan;
			float _2nd_ShadeMapUV;
			float _Use_2ndShadeMapAlpha_As_ShadowMask;
			float _2ndShadeMapMask_Inverse;
			float _Use_1stAs2nd;
			float _BaseColor_Step;
			float _BaseShade_Feather;
			float _ShadeColor_Step;
			float _1st2nd_Shades_Feather;
			float _ShadingShadeMapBlendType;
			#endif
			
			#ifdef _LIGHTINGMODE_SKIN
			sampler2D _SkinLUT;
			float _SssScale;
			#if defined(PROP_SKINTHICKNESS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _SkinThicknessMap;
			#endif
			float4 _SkinThicknessMap_ST;
			float2 _SkinThicknessMapPan;
			float _SkinThicknessMapUV;
			float _SkinThicknessMapInvert;
			float _SkinThicknessPower;
			float _SssBumpBlur;
			float3 _SssTransmissionAbsorption;
			float3 _SssColorBleedAoWeights;
			#endif
			
			#ifdef _LIGHTINGMODE_MULTILAYER_MATH
			float4 _ShadowColor;
			float _LightingMulitlayerNonLinear;
			#if defined(PROP_SHADOWCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ShadowColorTex;
			float4 _ShadowColorTex_ST;
			float2 _ShadowColorTexPan;
			float _ShadowColorTexUV;
			#endif
			#if defined(PROP_MULTILAYERMATHBLURMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MultilayerMathBlurMap;
			float4 _MultilayerMathBlurMap_ST;
			float2 _MultilayerMathBlurMapPan;
			float _MultilayerMathBlurMapUV;
			#endif
			float _ShadowBorder;
			float _ShadowBlur;
			float _ShadowReceive;
			float4 _Shadow2ndColor;
			#if defined(PROP_SHADOW2NDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Shadow2ndColorTex;
			float4 _Shadow2ndColorTex_ST;
			float2 _Shadow2ndColorTexPan;
			float _Shadow2ndColorTexUV;
			#endif
			float _Shadow2ndBorder;
			float _Shadow2ndBlur;
			float _Shadow2ndReceive;
			float4 _Shadow3rdColor;
			#if defined(PROP_SHADOW3RDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Shadow3rdColorTex;
			float4 _Shadow3rdColorTex_ST;
			float2 _Shadow3rdColorTexPan;
			float _Shadow3rdColorTexUV;
			#endif
			float _Shadow3rdBorder;
			float _Shadow3rdBlur;
			float _Shadow3rdReceive;
			float4 _ShadowBorderColor;
			float _ShadowBorderRange;
			float _ShadowMainStrength;
			#endif
			
			#ifdef _LIGHTINGMODE_CLOTH
			Texture2D_float _ClothDFG;
			SamplerState sampler_ClothDFG;
			
			#if defined(PROP_CLOTHMETALLICSMOOTHNESSMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ClothMetallicSmoothnessMap;
			#endif
			
			float4 _ClothMetallicSmoothnessMap_ST;
			float2 _ClothMetallicSmoothnessMapPan;
			float _ClothMetallicSmoothnessMapUV;
			float _ClothMetallicSmoothnessMapInvert;
			
			float _ClothLerp;
			float _ClothMetallic;
			float _ClothReflectance;
			float _ClothSmoothness;
			#endif
			
			#ifdef _LIGHTINGMODE_SDF
			#if defined(PROP_SDFSHADINGTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _SDFShadingTexture;
			float _SDFShadingTextureUV;
			float2 _SDFShadingTexturePan;
			float4 _SDFShadingTexture_ST;
			float _SDFBlur;
			float4 _SDFForward;
			float4 _SDFLeft;
			#endif
			#endif
			
			// Additive
			float _LightingAdditiveType;
			float _LightingAdditiveGradientStart;
			float _LightingAdditiveGradientEnd;
			float _LightingAdditiveDetailStrength;
			//endex
			
			//ifex _EnableAniso==0
			#ifdef POI_ANISOTROPICS
			
			#if defined(PROP_ANISOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AnisoColorMap;
			float4 _AnisoColorMap_ST;
			float2 _AnisoColorMapPan;
			float _AnisoColorMapUV;
			#endif
			/*
			#if defined(PROP_ANISONOISEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AnisoNoiseMap;
			float4 _AnisoNoiseMap_ST;
			float2 _AnisoNoiseMapPan;
			float _AnisoNoiseMapUV;
			#endif
			*/
			float _AnisoHideInShadow;
			float _AnisoReplace;
			float _AnisoAdd;
			float _AnisoUseBaseColor;
			float _AnisoUseLightColor;
			
			float _Aniso0Strength;
			float _Aniso0Power;
			float _Aniso0Offset;
			float _Aniso0SwitchDirection;
			float4 _Aniso0Tint;
			float _Aniso0TintIndex;
			float _Aniso0OffsetMapStrength;
			float _Aniso0ToonMode;
			float _Aniso0Edge;
			float _Aniso0Blur;
			
			float _Aniso1Strength;
			float _Aniso1Power;
			float _Aniso1Offset;
			float _Aniso1SwitchDirection;
			float4 _Aniso1Tint;
			float _Aniso1TintIndex;
			float _Aniso1OffsetMapStrength;
			float _Aniso1ToonMode;
			float _Aniso1Edge;
			float _Aniso1Blur;
			
			float _AnisoDebugToggle;
			float _AnisoDebugMode;
			#endif
			//endex
			
			//ifex _MatcapEnable==0
			#ifdef POI_MATCAP0
			#if defined(PROP_MATCAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap;
			float4 _Matcap_ST;
			float4 _Matcap_TexelSize;
			float2 _MatcapPan;
			float _MatcapUV;
			#endif
			#if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MatcapMask;
			float4 _MatcapMask_ST;
			float2 _MatcapMaskPan;
			float _MatcapMaskUV;
			float _MatcapMaskChannel;
			#endif
			#ifdef POI_MATCAP0_CUSTOM_NORMAL
			#if defined(PROP_MATCAP0NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap0NormalMap;
			#endif
			float4 _Matcap0NormalMap_ST;
			float2 _Matcap0NormalMapPan;
			float _Matcap0NormalMapUV;
			float _Matcap0NormalMapScale;
			#endif
			float _MatcapUVToBlend;
			float4 _MatCapBlendUV1;
			float _MatcapUVMode;
			float _MatcapMaskInvert;
			float _MatcapMaskGlobalMask;
			float _MatcapMaskGlobalMaskBlendType;
			float _MatcapBorder;
			float _MatcapRotation;
			float _MatcapSmoothnessEnabled;
			float _MatcapSmoothness;
			float _MatcapMaskSmoothnessChannel;
			float _MatcapMaskSmoothnessApply;
			float4 _MatcapColor;
			float _MatcapBaseColorMix;
			float _MatcapColorThemeIndex;
			float _MatcapIntensity;
			float _MatcapReplace;
			float _MatcapMultiply;
			float _MatcapAdd;
			float _MatcapAddToLight;
			float _MatcapMixed;
			float _MatcapScreen;
			float _MatcapAlphaOverride;
			float _MatcapEnable;
			float _MatcapLightMask;
			float _MatcapEmissionStrength;
			float _MatcapNormal;
			float _MatcapHueShiftEnabled;
			float _MatcapHueShiftSpeed;
			float _MatcapHueShift;
			float _MatcapTPSDepthEnabled;
			float _MatcapTPSMaskStrength;
			#endif
			//endex
			//ifex _Matcap2Enable==0
			#ifdef COLOR_GRADING_HDR_3D
			#if defined(PROP_MATCAP2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap2;
			float4 _Matcap2_ST;
			float4 _Matcap2_TexelSize;
			float2 _Matcap2Pan;
			float _Matcap2UV;
			#endif
			#if defined(PROP_MATCAP2MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap2Mask;
			float4 _Matcap2Mask_ST;
			float2 _Matcap2MaskPan;
			float _Matcap2MaskUV;
			float _Matcap2MaskChannel;
			#endif
			#ifdef POI_MATCAP1_CUSTOM_NORMAL
			#if defined(PROP_MATCAP1NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap1NormalMap;
			#endif
			float4 _Matcap1NormalMap_ST;
			float2 _Matcap1NormalMapPan;
			float _Matcap1NormalMapUV;
			float _Matcap1NormalMapScale;
			#endif
			float _Matcap2UVToBlend;
			float4 _MatCap2ndBlendUV1;
			float _Matcap2UVMode;
			float _Matcap2MaskInvert;
			float _Matcap2MaskGlobalMask;
			float _Matcap2MaskGlobalMaskBlendType;
			float _Matcap2Border;
			float _Matcap2Rotation;
			float _Matcap2SmoothnessEnabled;
			float _Matcap2Smoothness;
			float _Matcap2MaskSmoothnessChannel;
			float _Matcap2MaskSmoothnessApply;
			float4 _Matcap2Color;
			float _Matcap2BaseColorMix;
			float _Matcap2ColorThemeIndex;
			float _Matcap2Intensity;
			float _Matcap2Replace;
			float _Matcap2Multiply;
			float _Matcap2Add;
			float _Matcap2AddToLight;
			float _Matcap2Mixed;
			float _Matcap2Screen;
			float _Matcap2AlphaOverride;
			float _Matcap2Enable;
			float _Matcap2LightMask;
			float _Matcap2EmissionStrength;
			float _Matcap2Normal;
			float _Matcap2HueShiftEnabled;
			float _Matcap2HueShiftSpeed;
			float _Matcap2HueShift;
			float _Matcap2TPSDepthEnabled;
			float _Matcap2TPSMaskStrength;
			#endif
			//endex
			
			//ifex _Matcap3Enable==0
			#ifdef POI_MATCAP2
			#if defined(PROP_MATCAP3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap3;
			float4 _Matcap3_ST;
			float4 _Matcap3_TexelSize;
			float2 _Matcap3Pan;
			float _Matcap3UV;
			#endif
			#if defined(PROP_MATCAP3MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap3Mask;
			float4 _Matcap3Mask_ST;
			float2 _Matcap3MaskPan;
			float _Matcap3MaskUV;
			float _Matcap3MaskChannel;
			#endif
			#ifdef POI_MATCAP2_CUSTOM_NORMAL
			#if defined(PROP_MATCAP2NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap2NormalMap;
			#endif
			float4 _Matcap2NormalMap_ST;
			float2 _Matcap2NormalMapPan;
			float _Matcap2NormalMapUV;
			float _Matcap2NormalMapScale;
			#endif
			float _Matcap3UVToBlend;
			float4 _MatCap3rdBlendUV1;
			float _Matcap3UVMode;
			float _Matcap3MaskInvert;
			float _Matcap3MaskGlobalMask;
			float _Matcap3MaskGlobalMaskBlendType;
			float _Matcap3Border;
			float _Matcap3Rotation;
			float _Matcap3SmoothnessEnabled;
			float _Matcap3Smoothness;
			float _Matcap3MaskSmoothnessChannel;
			float _Matcap3MaskSmoothnessApply;
			float4 _Matcap3Color;
			float _Matcap3BaseColorMix;
			float _Matcap3ColorThemeIndex;
			float _Matcap3Intensity;
			float _Matcap3Replace;
			float _Matcap3Multiply;
			float _Matcap3Add;
			float _Matcap3AddToLight;
			float _Matcap3Mixed;
			float _Matcap3Screen;
			float _Matcap3AlphaOverride;
			float _Matcap3Enable;
			float _Matcap3LightMask;
			float _Matcap3EmissionStrength;
			float _Matcap3Normal;
			float _Matcap3HueShiftEnabled;
			float _Matcap3HueShiftSpeed;
			float _Matcap3HueShift;
			float _Matcap3TPSDepthEnabled;
			float _Matcap3TPSMaskStrength;
			#endif
			//endex
			
			//ifex _Matcap4Enable==0
			#ifdef POI_MATCAP3
			#if defined(PROP_MATCAP4) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap4;
			float4 _Matcap4_ST;
			float4 _Matcap4_TexelSize;
			float2 _Matcap4Pan;
			float _Matcap4UV;
			#endif
			#if defined(PROP_MATCAP4MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap4Mask;
			float4 _Matcap4Mask_ST;
			float2 _Matcap4MaskPan;
			float _Matcap4MaskUV;
			float _Matcap4MaskChannel;
			#endif
			#ifdef POI_MATCAP3_CUSTOM_NORMAL
			#if defined(PROP_MATCAP3NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap3NormalMap;
			#endif
			float4 _Matcap3NormalMap_ST;
			float2 _Matcap3NormalMapPan;
			float _Matcap3NormalMapUV;
			float _Matcap3NormalMapScale;
			#endif
			float _Matcap4UVToBlend;
			float4 _MatCap4thBlendUV1;
			float _Matcap4UVMode;
			float _Matcap4MaskInvert;
			float _Matcap4MaskGlobalMask;
			float _Matcap4MaskGlobalMaskBlendType;
			float _Matcap4Border;
			float _Matcap4Rotation;
			float _Matcap4SmoothnessEnabled;
			float _Matcap4Smoothness;
			float _Matcap4MaskSmoothnessChannel;
			float _Matcap4MaskSmoothnessApply;
			float4 _Matcap4Color;
			float _Matcap4BaseColorMix;
			float _Matcap4ColorThemeIndex;
			float _Matcap4Intensity;
			float _Matcap4Replace;
			float _Matcap4Multiply;
			float _Matcap4Add;
			float _Matcap4AddToLight;
			float _Matcap4Mixed;
			float _Matcap4Screen;
			float _Matcap4AlphaOverride;
			float _Matcap4Enable;
			float _Matcap4LightMask;
			float _Matcap4EmissionStrength;
			float _Matcap4Normal;
			float _Matcap4HueShiftEnabled;
			float _Matcap4HueShiftSpeed;
			float _Matcap4HueShift;
			float _Matcap4TPSDepthEnabled;
			float _Matcap4TPSMaskStrength;
			#endif
			//endex
			
			//ifex _CubeMapEnabled==0
			#ifdef _CUBEMAP
			#if defined(PROP_CUBEMAP) || !defined(OPTIMIZER_ENABLED)
			samplerCUBE _CubeMap;
			float3 _CubeMapRotation;
			float3 _CubeMapRotationPan;
			#endif
			#if defined(PROP_CUBEMAPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _CubeMapMask;
			float4 _CubeMapMask_ST;
			float2 _CubeMapMaskPan;
			float _CubeMapMaskUV;
			float _CubeMapMaskChannel;
			#endif
			float _CubeMapUVMode;
			float _CubeMapWorldNormalsStrength;
			float _CubeMapMaskInvert;
			float _CubeMapMaskGlobalMask;
			float _CubeMapMaskGlobalMaskBlendType;
			float4 _CubeMapColor;
			float _CubeMapColorThemeIndex;
			float _CubeMapIntensity;
			float _CubeMapReplace;
			float _CubeMapMultiply;
			float _CubeMapAdd;
			float _CubeMapEnable;
			float _CubeMapLightMask;
			float _CubeMapEmissionStrength;
			float _CubeMapNormal;
			float _CubeMapHueShiftEnabled;
			float _CubeMapHueShiftSpeed;
			float _CubeMapHueShift;
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			float _ALDecalUV;
			float4 _ALUVScale;
			float2 _ALUVPosition;
			float _ALUVRotation;
			float _ALUVRotationSpeed;
			float4 _ALDecaldCircleDimensions;
			
			float _ALDecalUVMode;
			
			float _ALDecalVolumeStep;
			float _ALDecalVolumeClipMin;
			float _ALDecalVolumeClipMax;
			
			float _ALDecalBandStep;
			float _ALDecalBandClipMin;
			float _ALDecalBandClipMax;
			
			float _ALDecalShapeClip;
			float _ALDecalShapeClipVolumeWidth;
			float _ALDecalShapeClipBandWidth;
			
			#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ALDecalColorMask;
			float4 _ALDecalColorMask_ST;
			float2 _ALDecalColorMaskPan;
			float _ALDecalColorMaskUV;
			#endif
			
			float _ALDecalVolume;
			float _ALDecalBaseBoost;
			float _ALDecalTrebleBoost;
			float _ALDecalLineWidth;
			float _ALDecalVolumeColorSource;
			float3 _ALDecalVolumeColorLow;
			float _ALDecalVolumeColorLowThemeIndex;
			float3 _ALDecalVolumeColorMid;
			float _ALDecalVolumeColorMidThemeIndex;
			float3 _ALDecalVolumeColorHigh;
			float _ALDecalVolumeColorHighThemeIndex;
			float _ALDecalLowEmission;
			float _ALDecalMidEmission;
			float _ALDecalHighEmission;
			float _ALDecalBlendType;
			float _ALDecalBlendAlpha;
			float _ALDecalControlsAlpha;
			#endif
			#endif
			//endex
			
			//ifex _EnableVolumeColor==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_VOLUMECOLOR
			float _ALVolumeColorUV;
			float _ALVolumeColorDirection;
			float _ALVolumeColorBlendType;
			float _ALVolumeColorBlendAlpha;
			float3 _ALVolumeColorLow;
			float _ALVolumeColorLowThemeIndex;
			float3 _ALVolumeColorMid;
			float _ALVolumeColorMidThemeIndex;
			float3 _ALVolumeColorHigh;
			float _ALVolumeColorHighThemeIndex;
			float _ALLowEmission;
			float _ALMidEmission;
			float _ALHighEmission;
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			UNITY_DECLARE_TEX2DARRAY(_FlipbookTexArray);
			float4 _FlipbookTexArray_ST;
			
			float4 _FlipbookColor;
			float _FlipbookColorThemeIndex;
			float _FlipbookFPS;
			// float _FlipbookTotalFrames;
			float4 _FlipbookScaleOffset;
			float4 _FlipbookSideOffset;
			float _FlipbookTiled;
			float _FlipbookManualFrameControl;
			float _FlipbookCurrentFrame;
			float _FlipbookStartAndEnd;
			float _FlipbookStartFrame;
			float _FlipbookEndFrame;
			float _FlipbookEmissionStrength;
			float _FlipbookRotation;
			float _EnableFlipbook;
			float _FlipbookTexArrayUV;
			float _FlipbookAlphaControlsFinalAlpha;
			float _FlipbookRotationSpeed;
			float _FlipbookIntensityControlsAlpha;
			float _FlipbookColorReplaces;
			float2 _FlipbookTexArrayPan;
			float _FlipbookFrameOffset;
			// blending
			float _FlipbookReplace;
			float _FlipbookMultiply;
			float _FlipbookAdd;
			
			#if defined(PROP_FLIPBOOKMASSK) || !defined(OPTIMIZED_ENABLED)
			Texture2D _FlipbookMask;
			#endif
			float4 _FlipbookMask_ST;
			float2 _FlipbookMaskPan;
			float _FlipbookMaskUV;
			float _FlipbookMaskChannel;
			float _FlipbookMaskGlobalMask;
			float _FlipbookMaskGlobalMaskBlendType;
			
			// anim
			float _FlipbookMovementType;
			float4 _FlipbookStartEndOffset;
			float _FlipbookMovementSpeed;
			
			// Crossfade
			float _FlipbookCrossfadeEnabled;
			float2 _FlipbookCrossfadeRange;
			
			// Hueshift
			float _FlipbookHueShiftEnabled;
			float _FlipbookHueShiftSpeed;
			float _FlipbookHueShift;
			
			#ifdef POI_AUDIOLINK
			float _FlipbookChronotensityEnabled;
			float _FlipbookChronotensityBand;
			float _FlipbookChronotensitySpeed;
			float _FlipbookChronoType;
			half _AudioLinkFlipbookScaleBand;
			half4 _AudioLinkFlipbookScale;
			half _AudioLinkFlipbookAlphaBand;
			half2 _AudioLinkFlipbookAlpha;
			half _AudioLinkFlipbookEmissionBand;
			half2 _AudioLinkFlipbookEmission;
			half _AudioLinkFlipbookFrameBand;
			half2 _AudioLinkFlipbookFrame;
			#endif
			#endif
			//endex
			
			//ifex _EnableEmission==0
			#ifdef _EMISSION
			#if defined(PROP_EMISSIONMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap;
			#endif
			float4 _EmissionMap_ST;
			float2 _EmissionMapPan;
			float _EmissionMapUV;
			#if defined(PROP_EMISSIONMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask;
			#endif
			float4 _EmissionMask_ST;
			float2 _EmissionMaskPan;
			float _EmissionMaskUV;
			float _EmissionMaskInvert;
			float _EmissionMaskChannel;
			float _EmissionMask0GlobalMask;
			float _EmissionMask0GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve;
			#endif
			float4 _EmissionScrollingCurve_ST;
			
			float4 _EmissionColor;
			float _EmissionBaseColorAsMap;
			float _EmissionStrength;
			float _EmissionHueShiftEnabled;
			float _EmissionHueShift;
			float _EmissionHueShiftSpeed;
			float _EmissionCenterOutEnabled;
			float _EmissionCenterOutSpeed;
			float _EnableGITDEmission;
			float _GITDEWorldOrMesh;
			float _GITDEMinEmissionMultiplier;
			float _GITDEMaxEmissionMultiplier;
			float _GITDEMinLight;
			float _GITDEMaxLight;
			float _EmissionBlinkingEnabled;
			float _EmissiveBlink_Min;
			float _EmissiveBlink_Max;
			float _EmissiveBlink_Velocity;
			float _EmissionBlinkingOffset;
			float _ScrollingEmission;
			float4 _EmissiveScroll_Direction;
			float _EmissiveScroll_Width;
			float _EmissiveScroll_Velocity;
			float _EmissiveScroll_Interval;
			float _EmissionScrollingOffset;
			
			float _EmissionReplace0;
			float _EmissionScrollingVertexColor;
			float _EmissionScrollingUseCurve;
			float _EmissionColorThemeIndex;
			
			// Audio Link
			float _EmissionAL0Enabled;
			float2 _EmissionAL0StrengthMod;
			float _EmissionAL0StrengthBand;
			float2 _AudioLinkEmission0CenterOut;
			float _AudioLinkEmission0CenterOutSize;
			float _AudioLinkEmission0CenterOutBand;
			float _AudioLinkEmission0CenterOutDuration;
			float2 _EmissionAL0Multipliers;
			float _EmissionAL0MultipliersBand;
			#endif
			//endex
			//ifex _EnableEmission1==0
			#ifdef POI_EMISSION_1
			
			#if defined(PROP_EMISSIONMAP1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap1;
			#endif
			float4 _EmissionMap1_ST;
			float2 _EmissionMap1Pan;
			float _EmissionMap1UV;
			#if defined(PROP_EMISSIONMASK1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask1;
			#endif
			float4 _EmissionMask1_ST;
			float2 _EmissionMask1Pan;
			float _EmissionMask1UV;
			float _EmissionMask1Channel;
			float _EmissionMaskInvert1;
			float _EmissionMask1GlobalMask;
			float _EmissionMask1GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve1;
			#endif
			float4 _EmissionScrollingCurve1_ST;
			
			float4 _EmissionColor1;
			float _EmissionBaseColorAsMap1;
			float _EmissionStrength1;
			float _EnableEmission1;
			float _EmissionHueShift1;
			float _EmissionHueShiftSpeed1;
			float4 _EmissiveScroll_Direction1;
			float _EmissiveScroll_Width1;
			float _EmissiveScroll_Velocity1;
			float _EmissiveScroll_Interval1;
			float _EmissionBlinkingEnabled1;
			float _EmissiveBlink_Min1;
			float _EmissiveBlink_Max1;
			float _EmissiveBlink_Velocity1;
			float _ScrollingEmission1;
			float _EnableGITDEmission1;
			float _GITDEMinEmissionMultiplier1;
			float _GITDEMaxEmissionMultiplier1;
			float _GITDEMinLight1;
			float _GITDEMaxLight1;
			float _GITDEWorldOrMesh1;
			float _EmissionCenterOutEnabled1;
			float _EmissionCenterOutSpeed1;
			float _EmissionHueShiftEnabled1;
			float _EmissionBlinkingOffset1;
			float _EmissionScrollingOffset1;
			float _EmissionScrollingVertexColor1;
			float _EmissionScrollingUseCurve1;
			float _EmissionReplace1;
			float _EmissionColor1ThemeIndex;
			
			// Audio Link
			float _EmissionAL1Enabled;
			float2 _EmissionAL1StrengthMod;
			float _EmissionAL1StrengthBand;
			float2 _AudioLinkEmission1CenterOut;
			float _AudioLinkEmission1CenterOutSize;
			float _AudioLinkEmission1CenterOutBand;
			float _AudioLinkEmission1CenterOutDuration;
			float2 _EmissionAL1Multipliers;
			float _EmissionAL1MultipliersBand;
			#endif
			//endex
			//ifex _EnableEmission2==0
			#ifdef POI_EMISSION_2
			
			#if defined(PROP_EMISSIONMAP2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap2;
			#endif
			float4 _EmissionMap2_ST;
			float2 _EmissionMap2Pan;
			float _EmissionMap2UV;
			#if defined(PROP_EMISSIONMASK2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask2;
			#endif
			float4 _EmissionMask2_ST;
			float2 _EmissionMask2Pan;
			float _EmissionMask2UV;
			float _EmissionMask2Channel;
			float _EmissionMaskInvert2;
			float _EmissionMask2GlobalMask;
			float _EmissionMask2GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve2;
			#endif
			float4 _EmissionScrollingCurve2_ST;
			
			float4 _EmissionColor2;
			float _EmissionBaseColorAsMap2;
			float _EmissionStrength2;
			float _EnableEmission2;
			float _EmissionHueShift2;
			float _EmissionHueShiftSpeed2;
			float4 _EmissiveScroll_Direction2;
			float _EmissiveScroll_Width2;
			float _EmissiveScroll_Velocity2;
			float _EmissiveScroll_Interval2;
			float _EmissionBlinkingEnabled2;
			float _EmissiveBlink_Min2;
			float _EmissiveBlink_Max2;
			float _EmissiveBlink_Velocity2;
			float _ScrollingEmission2;
			float _EnableGITDEmission2;
			float _GITDEMinEmissionMultiplier2;
			float _GITDEMaxEmissionMultiplier2;
			float _GITDEMinLight2;
			float _GITDEMaxLight2;
			float _GITDEWorldOrMesh2;
			float _EmissionCenterOutEnabled2;
			float _EmissionCenterOutSpeed2;
			float _EmissionHueShiftEnabled2;
			float _EmissionBlinkingOffset2;
			float _EmissionScrollingOffset2;
			float _EmissionScrollingVertexColor2;
			float _EmissionScrollingUseCurve2;
			float _EmissionReplace2;
			float _EmissionColor2ThemeIndex;
			
			// Audio Link
			float _EmissionAL2Enabled;
			float2 _EmissionAL2StrengthMod;
			float _EmissionAL2StrengthBand;
			float2 _AudioLinkEmission2CenterOut;
			float _AudioLinkEmission2CenterOutSize;
			float _AudioLinkEmission2CenterOutBand;
			float _AudioLinkEmission2CenterOutDuration;
			float2 _EmissionAL2Multipliers;
			float _EmissionAL2MultipliersBand;
			#endif
			//endex
			//ifex _EnableEmission3==0
			#ifdef POI_EMISSION_3
			
			#if defined(PROP_EMISSIONMAP3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap3;
			#endif
			float4 _EmissionMap3_ST;
			float2 _EmissionMap3Pan;
			float _EmissionMap3UV;
			#if defined(PROP_EMISSIONMASK3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask3;
			#endif
			float4 _EmissionMask3_ST;
			float2 _EmissionMask3Pan;
			float _EmissionMask3UV;
			float _EmissionMask3Channel;
			float _EmissionMaskInvert3;
			float _EmissionMask3GlobalMask;
			float _EmissionMask3GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve3;
			#endif
			float4 _EmissionScrollingCurve3_ST;
			
			float4 _EmissionColor3;
			float _EmissionBaseColorAsMap3;
			float _EmissionStrength3;
			float _EnableEmission3;
			float _EmissionHueShift3;
			float _EmissionHueShiftSpeed3;
			float4 _EmissiveScroll_Direction3;
			float _EmissiveScroll_Width3;
			float _EmissiveScroll_Velocity3;
			float _EmissiveScroll_Interval3;
			float _EmissionBlinkingEnabled3;
			float _EmissiveBlink_Min3;
			float _EmissiveBlink_Max3;
			float _EmissiveBlink_Velocity3;
			float _ScrollingEmission3;
			float _EnableGITDEmission3;
			float _GITDEMinEmissionMultiplier3;
			float _GITDEMaxEmissionMultiplier3;
			float _GITDEMinLight3;
			float _GITDEMaxLight3;
			float _GITDEWorldOrMesh3;
			float _EmissionCenterOutEnabled3;
			float _EmissionCenterOutSpeed3;
			float _EmissionHueShiftEnabled3;
			float _EmissionBlinkingOffset3;
			float _EmissionScrollingOffset3;
			float _EmissionScrollingVertexColor3;
			float _EmissionScrollingUseCurve3;
			float _EmissionReplace3;
			float _EmissionColor3ThemeIndex;
			
			// Audio Link
			float _EmissionAL3Enabled;
			float2 _EmissionAL3StrengthMod;
			float _EmissionAL3StrengthBand;
			float2 _AudioLinkEmission3CenterOut;
			float _AudioLinkEmission3CenterOutSize;
			float _AudioLinkEmission3CenterOutBand;
			float _AudioLinkEmission3CenterOutDuration;
			float2 _EmissionAL3Multipliers;
			float _EmissionAL3MultipliersBand;
			#endif
			//endex
			
			//ifex _EnableRimLighting==0
			#ifdef _GLOSSYREFLECTIONS_OFF
			float _Is_NormalMapToRimLight;
			float4 _RimLightColor;
			float _RimLightColorThemeIndex;
			float _RimClamp;
			#ifdef _RIMSTYLE_POIYOMI
			float _RimLightingInvert;
			float _RimWidth;
			float _RimStrength;
			float _RimSharpness;
			float _RimBaseColorMix;
			float _EnableRimLighting;
			float _RimWidthNoiseStrength;
			float4 _RimShadowAlpha;
			float _RimShadowWidth;
			float _RimBlendStrength;
			float _RimBlendMode;
			float _RimShadowToggle;
			float _RimPower;
			float _RimShadowMaskStrength;
			float _RimShadowMaskRampType;
			float _RimShadowMaskInvert;
			float _RimBrightness;
			#if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimTex;
			#endif
			float4 _RimTex_ST;
			float2 _RimTexPan;
			float _RimTexUV;
			#if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimMask;
			#endif
			float4 _RimMask_ST;
			float2 _RimMaskPan;
			float _RimMaskUV;
			float _RimMaskChannel;
			float _RimMaskInvert;
			float _RimBiasIntensity;
			#ifdef POI_AUDIOLINK
			half _AudioLinkRimWidthBand;
			float2 _AudioLinkRimWidthAdd;
			half _AudioLinkRimEmissionBand;
			float2 _AudioLinkRimEmissionAdd;
			half _AudioLinkRimBrightnessBand;
			float2 _AudioLinkRimBrightnessAdd;
			#endif
			#endif
			
			#ifdef _RIMSTYLE_UTS2
			float _RimLight;
			float _Is_LightColor_RimLight;
			float _RimLight_Power;
			float _RimLight_InsideMask;
			float _RimLight_FeatherOff;
			float _LightDirection_MaskOn;
			float _Tweak_LightDirection_MaskLevel;
			float _Add_Antipodean_RimLight;
			float4 _Ap_RimLightColor;
			float _RimApColorThemeIndex;
			float _Is_LightColor_Ap_RimLight;
			float _Ap_RimLight_Power;
			float _Ap_RimLight_FeatherOff;
			#if defined(PROP_SET_RIMLIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_RimLightMask;
			float4 _Set_RimLightMask_ST;
			float2 _Set_RimLightMaskPan;
			float _Set_RimLightMaskUV;
			float _Set_RimLightMaskChannel;
			#endif
			float _Tweak_RimLightMaskLevel;
			#endif
			
			#ifdef _RIMSTYLE_LILTOON
			float4 _RimColor;
			#if defined(PROP_RIMCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimColorTex;
			float4 _RimColorTex_ST;
			float2 _RimColorTexPan;
			float _RimColorTexUV;
			#endif
			float _RimMainStrength;
			float _RimNormalStrength;
			float _RimBorder;
			float _RimBlur;
			float _RimFresnelPower;
			float _RimEnableLighting;
			float _RimShadowMask;
			int _RimBackfaceMask;
			float _RimVRParallaxStrength;
			float _RimDirStrength;
			float _RimDirRange;
			float _RimIndirRange;
			float4 _RimIndirColor;
			float _RimIndirBorder;
			float _RimIndirBlur;
			#endif
			
			float _RimGlobalMask;
			float _RimGlobalMaskBlendType;
			float _RimApplyGlobalMaskIndex;
			float _RimApplyGlobalMaskBlendType;
			
			float _RimHueShiftEnabled;
			float _RimHueShiftSpeed;
			float _RimHueShift;
			#endif
			//endex
			//ifex _EnableRim2Lighting==0
			#ifdef POI_RIM2
			float _Is_NormalMapToRim2Light;
			float4 _Rim2LightColor;
			float _Rim2LightColorThemeIndex;
			float _Rim2Clamp;
			
			#ifdef _RIM2STYLE_POIYOMI
			float _Rim2LightingInvert;
			float _Rim2Width;
			float _Rim2Strength;
			float _Rim2Sharpness;
			float _Rim2BaseColorMix;
			float _EnableRim2Lighting;
			float _Rim2WidthNoiseStrength;
			float4 _Rim2ShadowAlpha;
			float _Rim2ShadowWidth;
			float _Rim2BlendStrength;
			float _Rim2BlendMode;
			float _Rim2ShadowToggle;
			float _Rim2Power;
			float _Rim2ShadowMaskStrength;
			float _Rim2ShadowMaskRampType;
			float _Rim2ShadowMaskInvert;
			float _Rim2Brightness;
			#if defined(PROP_RIM2TEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2Tex;
			#endif
			float4 _Rim2Tex_ST;
			float2 _Rim2TexPan;
			float _Rim2TexUV;
			#if defined(PROP_RIM2MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2Mask;
			#endif
			float4 _Rim2Mask_ST;
			float2 _Rim2MaskPan;
			float _Rim2MaskUV;
			float _Rim2MaskChannel;
			float _Rim2MaskInvert;
			float _Rim2BiasIntensity;
			#if defined(PROP_RIM2WIDTHNOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2WidthNoiseTexture;
			#endif
			#ifdef POI_AUDIOLINK
			half _AudioLinkRim2WidthBand;
			float2 _AudioLinkRim2WidthAdd;
			half _AudioLinkRim2EmissionBand;
			float2 _AudioLinkRim2EmissionAdd;
			half _AudioLinkRim2BrightnessBand;
			float2 _AudioLinkRim2BrightnessAdd;
			#endif
			#endif
			
			#ifdef _RIM2STYLE_UTS2
			float _Rim2Light;
			float _Is_LightColor_Rim2Light;
			float _Rim2Light_Power;
			float _Rim2Light_InsideMask;
			float _Rim2Light_FeatherOff;
			float _LightDirection_MaskOn2;
			float _Tweak_LightDirection_MaskLevel2;
			float _Add_Antipodean_Rim2Light;
			float4 _Ap_Rim2LightColor;
			float _Rim2ApColorThemeIndex;
			float _Is_LightColor_Ap_Rim2Light;
			float _Ap_Rim2Light_Power;
			float _Ap_Rim2Light_FeatherOff;
			#if defined(PROP_SET_RIM2LIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_Rim2LightMask;
			float4 _Set_Rim2LightMask_ST;
			float2 _Set_Rim2LightMaskPan;
			float _Set_Rim2LightMaskUV;
			float _Set_Rim2LightMaskChannel;
			#endif
			float _Tweak_Rim2LightMaskLevel;
			#endif
			
			#ifdef _RIM2STYLE_LILTOON
			float4 _Rim2Color;
			#if defined(PROP_RIM2COLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2ColorTex;
			float4 _Rim2ColorTex_ST;
			float2 _Rim2ColorTexPan;
			float _Rim2ColorTexUV;
			#endif
			float _Rim2MainStrength;
			float _Rim2NormalStrength;
			float _Rim2Border;
			float _Rim2Blur;
			float _Rim2FresnelPower;
			float _Rim2EnableLighting;
			float _Rim2ShadowMask;
			int _Rim2BackfaceMask;
			float _Rim2VRParallaxStrength;
			// int _Rim2ApplyTransparency;
			float _Rim2DirStrength;
			float _Rim2DirRange;
			float _Rim2IndirRange;
			float4 _Rim2IndirColor;
			float _Rim2IndirBorder;
			float _Rim2IndirBlur;
			#endif
			
			float _Rim2GlobalMask;
			float _Rim2GlobalMaskBlendType;
			float _Rim2ApplyGlobalMaskIndex;
			float _Rim2ApplyGlobalMaskBlendType;
			
			float _Rim2HueShiftEnabled;
			float _Rim2HueShiftSpeed;
			float _Rim2HueShift;
			#endif
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#ifdef _POI_DEPTH_RIMLIGHT
			float _DepthRimNormalToUse;
			float _DepthRimWidth;
			float _DepthRimSharpness;
			float _DepthRimHideInShadow;
			float4 _DepthRimColor;
			float _DepthRimColorThemeIndex;
			float _DepthRimMixBaseColor;
			float _DepthRimEmission;
			float _DepthRimReplace;
			float _DepthRimAdd;
			float _DepthRimMultiply;
			float _DepthRimAdditiveLighting;
			float _DepthRimMixLightColor;
			float _DepthRimType;
			float _DepthRimBrightness;
			
			static float2 sobelSamplePoints[9] = {
				float2(-1, 1), float2(0, 1), float2(1, 1),
				float2(-1, 0), float2(0, 0), float2(1, 01),
				float2(-1, -1), float2(0, -1), float2(1, -1)
			};
			
			static float sobelXMatrix[9] = {
				1, 0, -1,
				2, 0, -2,
				1, 0, -1
			};
			static float sobelYMatrix[9] = {
				1, 2, 1,
				0, 0, 0,
				- 1, -2, -1
			};
			#endif
			//endex
			
			//ifex _GlitterEnable==0
			#ifdef _SUNDISK_SIMPLE
			float _GlitterUseNormals;
			float _GlitterUV;
			half3 _GlitterColor;
			float _GlitterColorThemeIndex;
			float2 _GlitterPan;
			half _GlitterSpeed;
			half _GlitterBrightness;
			float _GlitterFrequency;
			float _GlitterJitter;
			half _GlitterSize;
			half _GlitterContrast;
			half _GlitterAngleRange;
			half _GlitterMinBrightness;
			half _GlitterBias;
			fixed _GlitterUseSurfaceColor;
			float _GlitterBlendType;
			float _GlitterMode;
			float _GlitterShape;
			float _GlitterCenterSize;
			float _glitterFrequencyLinearEmissive;
			float _GlitterJaggyFix;
			float _GlitterTextureRotation;
			float2 _GlitterUVPanning;
			
			float _GlitterHueShiftEnabled;
			float _GlitterHueShiftSpeed;
			float _GlitterHueShift;
			float _GlitterHideInShadow;
			
			float _GlitterRandomColors;
			float2 _GlitterMinMaxSaturation;
			float2 _GlitterMinMaxBrightness;
			float _GlitterRandomSize;
			float4 _GlitterMinMaxSize;
			float _GlitterRandomRotation;
			
			#if defined(PROP_GLITTERMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterMask;
			#endif
			float4 _GlitterMask_ST;
			float2 _GlitterMaskPan;
			float _GlitterMaskUV;
			float _GlitterMaskChannel;
			float _GlitterMaskGlobalMask;
			float _GlitterMaskGlobalMaskBlendType;
			#if defined(PROP_GLITTERCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterColorMap;
			#endif
			float4 _GlitterColorMap_ST;
			float2 _GlitterColorMapPan;
			float _GlitterColorMapUV;
			#if defined(PROP_GLITTERTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterTexture;
			#endif
			float4 _GlitterTexture_ST;
			float2 _GlitterTexturePan;
			float _GlitterTextureUV;
			#endif
			//endex
			
			//ifex _SubsurfaceScattering==0
			#ifdef POI_SUBSURFACESCATTERING
			float4 _SSSColor;
			#if defined(PROP_SSSTHICKNESSMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _SSSThicknessMap;
			#endif
			float4 _SSSThicknessMap_ST;
			float2 _SSSThicknessMapPan;
			float _SSSThicknessMapUV;
			float _SSSThicknessMapChannel;
			
			float _SSSThicknessMod;
			float _SSSStrength;
			float _SSSSpread;
			float _SSSDistortion;
			#endif
			//endex
			
			//ifex _MochieBRDF==0
			#ifdef MOCHIE_PBR
			#if defined(PROP_MOCHIEMETALLICMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MochieMetallicMaps;
			float _PBRMapsStochastic;
			#endif
			POI_DECLARETEX_ST_UV_PAN_STOCHASTIC(_MochieMetallicMaps);
			float _MochieMetallicMapInvert;
			float _MochieRoughnessMapInvert;
			float _MochieReflectionMaskInvert;
			float _MochieSpecularMaskInvert;
			float _MochieMetallicMapsMetallicChannel;
			float _MochieMetallicMapsRoughnessChannel;
			float _MochieMetallicMapsReflectionMaskChannel;
			float _MochieMetallicMapsSpecularMaskChannel;
			float _PBRNormalSelect;
			
			float _MochieReflectionTintThemeIndex;
			float _MochieSpecularTintThemeIndex;
			
			float _MochieRoughnessMultiplier;
			float _MochieMetallicMultiplier;
			float _MochieReflectionStrength;
			float _MochieSpecularStrength;
			float4 _MochieSpecularTint;
			float4 _MochieReflectionTint;
			float _MochieLitFallback;
			float _IgnoreCastedShadows;
			float _PBRSplitMaskSample;
			float _PBRSplitMaskStochastic;
			float4 _PBRMaskScaleTiling;
			float _MochieMetallicMasksUV;
			float4 _MochieMetallicMasksPan;
			
			float _Specular2ndLayer;
			float _MochieSpecularStrength2;
			float _MochieRoughnessMultiplier2;
			float _RefSpecFresnel;
			samplerCUBE _MochieReflCube;
			float4 _MochieReflCube_HDR;
			float _MochieForceFallback;
			float _MochieGSAAEnabled;
			float _PoiGSAAVariance;
			float _PoiGSAAThreshold;
			float _BRDFTPSReflectionMaskStrength;
			float _BRDFTPSSpecularMaskStrength;
			float _BRDFTPSDepthEnabled;
			
			float _MochieMetallicGlobalMask;
			float _MochieMetallicGlobalMaskBlendType;
			float _MochieSmoothnessGlobalMask;
			float _MochieSmoothnessGlobalMaskBlendType;
			float _MochieReflectionStrengthGlobalMask;
			float _MochieReflectionStrengthGlobalMaskBlendType;
			float _MochieSpecularStrengthGlobalMask;
			float _MochieSpecularStrengthGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _ClearCoatBRDF==0
			#ifdef POI_CLEARCOAT
			#if defined(PROP_CLEARCOATMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ClearCoatMaps;
			float4 _ClearCoatMaps_ST;
			float2 _ClearCoatMapsPan;
			float _ClearCoatMapsUV;
			float _ClearCoatMapsStochastic;
			#endif
			float _ClearCoatMapsClearCoatMaskChannel;
			float _ClearCoatMapsRoughnessChannel;
			float _ClearCoatMapsReflectionMaskChannel;
			float _ClearCoatMapsSpecularMaskChannel;
			float _ClearCoatBRDF;
			float _ClearCoatReflectionStrength;
			float _ClearCoatSpecularStrength;
			float _ClearCoatStrength;
			float _ClearCoatSmoothness;
			float4 _ClearCoatReflectionTint;
			float _ClearCoatReflectionTintThemeIndex;
			float4 _ClearCoatSpecularTint;
			float _ClearCoatSpecularTintThemeIndex;
			float _ClearCoatSmoothnessMapInvert;
			float _ClearCoatMaskInvert;
			float _ClearCoatReflectionMaskInvert;
			float _ClearCoatSpecularMaskInvert;
			float _ClearCoatTPSMaskStrength;
			float _ClearCoatTPSDepthMaskEnabled;
			float _ClearCoatNormalSelect;
			
			samplerCUBE _ClearCoatFallback;
			float4 _ClearCoatFallback_HDR;
			float _ClearCoatForceFallback;
			float _ClearCoatLitFallback;
			float _CCIgnoreCastedShadows;
			float _ClearCoatGSAAEnabled;
			float _ClearCoatGSAAVariance;
			float _ClearCoatGSAAThreshold;
			float _ClearcoatFresnel;
			
			float _ClearCoatGlobalMask;
			float _ClearCoatGlobalMaskBlendType;
			float _ClearCoatSmoothnessGlobalMask;
			float _ClearCoatSmoothnessGlobalMaskBlendType;
			float _ClearCoatReflectionStrengthGlobalMask;
			float _ClearCoatReflectionStrengthGlobalMaskBlendType;
			float _ClearCoatSpecularStrengthGlobalMask;
			float _ClearCoatSpecularStrengthGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _EnableEnvironmentalRim==0
			#ifdef POI_ENVIRORIM
			
			#if defined(PROP_RIMENVIROMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimEnviroMask;
			#endif
			float4 _RimEnviroMask_ST;
			float2 _RimEnviroMaskPan;
			float _RimEnviroMaskUV;
			float _RimEnviroChannel;
			
			float _RimEnviroBlur;
			float _RimEnviroMinBrightness;
			float _RimEnviroWidth;
			float _RimEnviroSharpness;
			float _RimEnviroIntensity;
			#endif
			//endex
			
			//ifex _StylizedSpecular==0
			#ifdef POI_STYLIZED_StylizedSpecular
			#if defined(PROP_HIGHCOLOR_TEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _HighColor_Tex;
			#endif
			float4 _HighColor_Tex_ST;
			float2 _HighColor_TexPan;
			float _HighColor_TexUV;
			
			#if defined(PROP_SET_HIGHCOLORMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_HighColorMask;
			#endif
			float4 _Set_HighColorMask_ST;
			float2 _Set_HighColorMaskPan;
			float _Set_HighColorMaskUV;
			float _Set_HighColorMaskChannel;
			float _Tweak_HighColorMaskLevel;
			
			/*
			#if defined(PROP_StylizedSpecularOPTMAP1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _StylizedSpecularOptMap1;
			#endif
			float4 _StylizedSpecularOptMap1_ST;
			float2 _StylizedSpecularOptMap1Pan;
			float _StylizedSpecularOptMap1UV;
			
			#if defined(PROP_StylizedSpecularOPTMAP2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _StylizedSpecularOptMap2;
			#endif
			float4 _StylizedSpecularOptMap2_ST;
			float2 _StylizedSpecularOptMap2Pan;
			float _StylizedSpecularOptMap2UV;
			*/
			
			float4 _HighColor;
			float _UseLightColor;
			
			float _HighColor_Power;
			float _StylizedSpecularFeather;
			float _Layer1Strength;
			
			float _StylizedSpecularIgnoreNormal;
			float _StylizedSpecularIgnoreShadow;
			
			float _Layer2Size;
			float _StylizedSpecular2Feather;
			float _Layer2Strength;
			float _SSIgnoreCastedShadows;
			float _StylizedSpecularStrength;
			float _UseSpecularOptMap2;
			float _HighColorThemeIndex;
			float _Is_BlendAddToHiColor;
			float _Is_SpecularToHighColor;
			#endif
			//endex
			
			//ifex _EnablePathing==0
			#ifdef POI_PATHING
			
			#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PathingMap;
			SamplerState SmpRepeatPoint;
			#endif
			float4 _PathingMap_ST;
			float2 _PathingMapPan;
			float _PathingMapUV;
			
			#if defined(PROP_PATHINGCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PathingColorMap;
			#endif
			float4 _PathingColorMap_ST;
			float2 _PathingColorMapPan;
			float _PathingColorMapUV;
			float _PathingOverrideAlpha;
			// Fill, 0, Path, 1, Loop, 2
			float _PathTypeR;
			float _PathTypeG;
			float _PathTypeB;
			float _PathTypeA;
			float _PathGradientType;
			half4 _PathWidth;
			float4 _PathTime;
			float4 _PathOffset;
			float4 _PathSpeed;
			float4 _PathColorR;
			float4 _PathColorG;
			float4 _PathColorB;
			float4 _PathColorA;
			float4 _PathEmissionStrength;
			float4 _PathSoftness;
			float4 _PathSegments;
			
			float _PathColorRThemeIndex;
			float _PathColorGThemeIndex;
			float _PathColorBThemeIndex;
			float _PathColorAThemeIndex;
			
			#ifdef POI_AUDIOLINK
			float _PathALAutoCorrelator;
			float _PathALAutoCorrelatorMode;
			float _PathALAutoCorrelatorR;
			float2 _PathALAutoCorrelatorRangeR;
			float _PathALAutoCorrelatorG;
			float2 _PathALAutoCorrelatorRangeG;
			float _PathALAutoCorrelatorB;
			float2 _PathALAutoCorrelatorRangeB;
			float _PathALAutoCorrelatorA;
			float2 _PathALAutoCorrelatorRangeA;
			
			float _PathALHistory;
			float _PathALHistoryMode;
			float _PathALHistoryBandR;
			float2 _PathALHistoryRangeR;
			float _PathALHistoryR;
			float _PathALHistoryBandG;
			float2 _PathALHistoryRangeG;
			float _PathALHistoryG;
			float _PathALHistoryBandB;
			float2 _PathALHistoryRangeB;
			float _PathALHistoryB;
			float _PathALHistoryBandA;
			float2 _PathALHistoryRangeA;
			float _PathALHistoryA;
			
			float _PathALColorChord;
			float _PathALCCR;
			float _PathALCCG;
			float _PathALCCB;
			float _PathALCCA;
			
			// Time Offset
			float _PathALTimeOffset;
			half _AudioLinkPathTimeOffsetBandR;
			half2 _AudioLinkPathTimeOffsetR;
			half _AudioLinkPathTimeOffsetBandG;
			half2 _AudioLinkPathTimeOffsetG;
			half _AudioLinkPathTimeOffsetBandB;
			half2 _AudioLinkPathTimeOffsetB;
			half _AudioLinkPathTimeOffsetBandA;
			half2 _AudioLinkPathTimeOffsetA;
			
			// Emission Offset
			float _PathALEmissionOffset;
			half _AudioLinkPathEmissionAddBandR;
			half2 _AudioLinkPathEmissionAddR;
			half _AudioLinkPathEmissionAddBandG;
			half2 _AudioLinkPathEmissionAddG;
			half _AudioLinkPathEmissionAddBandB;
			half2 _AudioLinkPathEmissionAddB;
			half _AudioLinkPathEmissionAddBandA;
			half2 _AudioLinkPathEmissionAddA;
			
			// Length Offset
			float _PathALWidthOffset;
			half _AudioLinkPathWidthOffsetBandR;
			half2 _AudioLinkPathWidthOffsetR;
			half _AudioLinkPathWidthOffsetBandG;
			half2 _AudioLinkPathWidthOffsetG;
			half _AudioLinkPathWidthOffsetBandB;
			half2 _AudioLinkPathWidthOffsetB;
			half _AudioLinkPathWidthOffsetBandA;
			half2 _AudioLinkPathWidthOffsetA;
			
			// Chrono Time
			float _PathALChrono;
			float _PathChronoBandR;
			float _PathChronoTypeR;
			float _PathChronoSpeedR;
			float _PathChronoBandG;
			float _PathChronoTypeG;
			float _PathChronoSpeedG;
			float _PathChronoBandB;
			float _PathChronoTypeB;
			float _PathChronoSpeedB;
			float _PathChronoBandA;
			float _PathChronoTypeA;
			float _PathChronoSpeedA;
			#endif
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			float _VisibilityMode;
			float _Mirror;
			#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MirrorTexture;
			#endif
			float4 _MirrorColor;
			float _MirrorColorThemeIndex;
			float _MirrorTextureBlendType;
			float4 _MirrorTexture_ST;
			float2 _MirrorTexturePan;
			float _MirrorTextureUV;
			
			float _VisibilityVRCRegular;
			float _VisibilityVRCMirrorVR;
			float _VisibilityVRCMirrorDesktop;
			float _VisibilityVRCCameraVR;
			float _VisibilityVRCCameraDesktop;
			float _VisibilityVRCCameraScreenshot;
			#endif
			//endex
			
			//ifex _EnableTouchGlow==0
			#if defined(PROP_DEPTHMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DepthMask;
			#endif
			float4 _DepthMask_ST;
			float2 _DepthMaskPan;
			float _DepthMaskUV;
			float _DepthMaskChannel;
			float _DepthMaskGlobalMask;
			float _DepthMaskGlobalMaskBlendType;
			
			// Color
			float _DepthColorToggle;
			float _DepthColorBlendMode;
			#if defined(PROP_DEPTHTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DepthTexture;
			#endif
			float4 _DepthTexture_ST;
			float2 _DepthTexturePan;
			float _DepthTextureUV;
			
			float3 _DepthColor;
			float _DepthColorThemeIndex;
			float _DepthColorMinDepth;
			float _DepthColorMaxDepth;
			float _DepthColorMinValue;
			float _DepthColorMaxValue;
			float _DepthEmissionStrength;
			
			// Emission
			
			// Alpha
			float _DepthAlphaToggle;
			float _DepthAlphaMinValue;
			float _DepthAlphaMaxValue;
			float _DepthAlphaMinDepth;
			float _DepthAlphaMaxDepth;
			//endex
			
			//ifex _EnableIridescence==0
			#ifdef POI_IRIDESCENCE
			#if defined(PROP_IRIDESCENCERAMP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _IridescenceRamp;
			#endif
			float4 _IridescenceRamp_ST;
			float2 _IridescenceRampPan;
			
			#if defined(PROP_IRIDESCENCEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _IridescenceMask;
			#endif
			float4 _IridescenceMask_ST;
			float2 _IridescenceMaskPan;
			float _IridescenceMaskUV;
			float _IridescenceMaskChannel;
			float _IridescenceMaskInvert;
			float _IridescenceMaskGlobalMask;
			float _IridescenceMaskGlobalMaskBlendType;
			
			#if defined(PROP_IRIDESCENCENORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _IridescenceNormalMap;
			#endif
			float4 _IridescenceNormalMap_ST;
			float2 _IridescenceNormalMapPan;
			float _IridescenceNormalMapUV;
			
			float _IridescenceIntensity;
			float _IridescenceHueShiftEnabled;
			float _IridescenceHueShiftSpeed;
			float _IridescenceHueShift;
			
			float _IridescenceNormalSelection;
			float _IridescenceNormalIntensity;
			float _IridescenceNormalToggle;
			float _IridescenceAddBlend;
			float _IridescenceReplaceBlend;
			float _IridescenceMultiplyBlend;
			float _IridescenceEmissionStrength;
			
			#ifdef POI_AUDIOLINK
			float _IridescenceAudioLinkEmissionAddBand;
			float2 _IridescenceAudioLinkEmissionAdd;
			float _IridescenceAudioLinkIntensityAddBand;
			float2 _IridescenceAudioLinkIntensityAdd;
			float _IridescenceAudioLinkChronoPanType;
			float _IridescenceAudioLinkChronoPanBand;
			float _IridescenceAudioLinkChronoPanSpeed;
			#endif
			#endif
			//endex
			
			float _PPLightingMultiplier;
			float _PPLightingAddition;
			float _PPEmissionMultiplier;
			float _PPFinalColorMultiplier;
			
			//ifex _TextEnabled==0
			#ifdef EFFECT_BUMP
			sampler2D _TextGlyphs;
			float4 _TextGlyphs_ST;
			float4 _TextGlyphs_TexelSize;
			float _TextFPSUV;
			float _TextTimeUV;
			float _TextPositionUV;
			float _TextNumericUV;
			float _TextPixelRange;
			
			float _TextFPSEnabled;
			float _TextPositionEnabled;
			float _TextTimeEnabled;
			float _TextNumericEnabled;
			
			float4 _TextFPSColor;
			float _TextFPSEmissionStrength;
			fixed4 _TextFPSPadding;
			float2 _TextFPSOffset;
			float2 _TextFPSScale;
			float _TextFPSRotation;
			
			fixed _TextPositionVertical;
			float4 _TextPositionColor;
			float _TextPositionEmissionStrength;
			fixed4 _TextPositionPadding;
			float2 _TextPositionOffset;
			float2 _TextPositionScale;
			float _TextPositionRotation;
			
			float4 _TextTimeColor;
			float _TextTimeEmissionStrength;
			fixed4 _TextTimePadding;
			float2 _TextTimeOffset;
			float2 _TextTimeScale;
			float _TextTimeRotation;
			
			float4 _TextNumericColor;
			float _TextNumericEmissionStrength;
			fixed4 _TextNumericPadding;
			float2 _TextNumericOffset;
			float2 _TextNumericScale;
			float _TextNumericRotation;
			float _TextNumericValue;
			float _TextNumericWholeDigits;
			float _TextNumericDecimalDigits;
			float _TextNumericTrimZeroes;
			
			float _TextFPSColorThemeIndex;
			float _TextPositionColorThemeIndex;
			float _TextTimeColorThemeIndex;
			float _TextNumericColorThemeIndex;
			
			float3 globalTextEmission;
			
			#define ASCII_SPACE 32
			#define ASCII_LEFT_PARENTHESIS 40
			#define ASCII_RIGHT_PARENTHESIS 41
			#define ASCII_POSITIVE 43
			#define ASCII_PERIOD 46
			#define ASCII_NEGATIVE 45
			#define ASCII_COMMA 44
			#define ASCII_E 69
			#define ASCII_F 70
			#define ASCII_I 73
			#define ASCII_M 77
			#define ASCII_O 79
			#define ASCII_P 80
			#define ASCII_R 82
			#define ASCII_S 83
			#define ASCII_T 84
			#define ASCII_SEMICOLON 58
			#define glyphWidth 0.0625
			
			#endif
			//endex
			
			//ifex _FXProximityColor==0
			float _FXProximityColor;
			float _FXProximityColorType;
			float3 _FXProximityColorMinColor;
			float3 _FXProximityColorMaxColor;
			float _FXProximityColorMinColorThemeIndex;
			float _FXProximityColorMaxColorThemeIndex;
			float _FXProximityColorMinDistance;
			float _FXProximityColorMaxDistance;
			float _FXProximityColorBackFace;
			//endex
			
			//ifex _PostProcess==0
			#ifdef POSTPROCESS
			#if defined(PROP_PPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PPMask;
			#endif
			float4 _PPMask_ST;
			float2 _PPMaskPan;
			float _PPMaskUV;
			float _PPMaskChannel;
			float _PPMaskInvert;
			
			float3 _PPTint;
			float3 _PPRGB;
			float _PPHue;
			float _PPContrast;
			float _PPSaturation;
			float _PPBrightness;
			float _PPLightness;
			float _PPHDR;
			
			float _PPPosterization;
			float _PPPosterizationAmount;
			const static float COLORS = 32;
			
			#endif
			//endex
			
			//ifex _PoiInternalParallax==0
			#ifdef POI_INTERNALPARALLAX
			#if defined(PROP_PARALLAXINTERNALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ParallaxInternalMap;
			#endif
			float4 _ParallaxInternalMap_ST;
			float2 _ParallaxInternalMapPan;
			
			#if defined(PROP_PARALLAXINTERNALMAPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ParallaxInternalMapMask;
			#endif
			float4 _ParallaxInternalMapMask_ST;
			float2 _ParallaxInternalMapMaskPan;
			float _ParallaxInternalMapMaskUV;
			float _ParallaxInternalMapMaskChannel;
			
			float _ParallaxInternalIterations;
			float _ParallaxInternalMinDepth;
			float _ParallaxInternalMaxDepth;
			float _ParallaxInternalMinFade;
			float _ParallaxInternalMaxFade;
			float4 _ParallaxInternalMinColor;
			float4 _ParallaxInternalMaxColor;
			float _ParallaxInternalMinColorThemeIndex;
			float _ParallaxInternalMaxColorThemeIndex;
			// float4 _ParallaxInternalPanSpeed;
			float4 _ParallaxInternalPanDepthSpeed;
			float _ParallaxInternalHeightmapMode;
			float _ParallaxInternalHeightFromAlpha;
			
			float _ParallaxInternalHueShiftEnabled;
			float _ParallaxInternalHueShift;
			float _ParallaxInternalHueShiftSpeed;
			float _ParallaxInternalHueShiftPerLevel;
			// float _ParallaxInternalHueShiftPerLevelSpeed;
			#endif
			//endex
			
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			float _NormalCorrectAmount;
			float3 _NormalCorrectOrigin;
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float _VideoEffectsEnable;
			#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
			sampler2D _VideoPixelTexture;
			float4 _VideoPixelTexture_ST;
			float _VideoPixelTextureUV;
			#endif
			#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _VideoMaskTexture;
			float4 _VideoMaskTexture_ST;
			float2 _VideoMaskTexturePan;
			float _VideoMaskTextureUV;
			float _VideoMaskTextureChannel;
			#endif
			
			float _VideoType;
			float2 _VideoResolution;
			sampler2D _VideoGameboyRamp;
			float _VideoBacklight;
			float _VideoCRTRefreshRate;
			float _VideoCRTPixelEnergizedTime;
			float _VideoRepeatVideoTexture;
			float _VideoPixelateToResolution;
			float2 _VideoMaskPanning;
			
			float _VideoSaturation;
			float _VideoContrast;
			float _VideoEmissionEnabled;
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			float4 _BacklightColor;
			#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BacklightColorTex;
			float4 _BacklightColorTex_ST;
			float2 _BacklightColorTexPan;
			float _BacklightColorTexUV;
			#endif
			float _BacklightMainStrength;
			float _BacklightNormalStrength;
			float _BacklightBorder;
			float _BacklightBlur;
			float _BacklightDirectivity;
			float _BacklightViewStrength;
			int _BacklightReceiveShadow;
			int _BacklightBackfaceMask;
			#endif
			//endex
			
			struct appdata
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
				float4 color : COLOR;
				float2 uv0 : TEXCOORD0;
				float2 uv1 : TEXCOORD1;
				float2 uv2 : TEXCOORD2;
				float2 uv3 : TEXCOORD3;
				uint vertexId : SV_VertexID;
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};
			
			struct VertexOut
			{
				float4 pos : SV_POSITION;
				float2 uv[4] : TEXCOORD0;
				float3 objNormal : TEXCOORD4;
				float3 normal : TEXCOORD5;
				float3 tangent : TEXCOORD6;
				float3 binormal : TEXCOORD7;
				float4 worldPos : TEXCOORD8;
				float4 localPos : TEXCOORD9;
				float3 objectPos : TEXCOORD10;
				float4 vertexColor : TEXCOORD11;
				float4 lightmapUV : TEXCOORD12;
				float4 grabPos: TEXCOORD13;
				float4 worldDirection: TEXCOORD14;
				float4 extra: TEXCOORD15;
				UNITY_SHADOW_COORDS(16)
				UNITY_FOG_COORDS(17)
				
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};
			
			struct PoiMesh
			{
				
				// 0 Vertex normal
				// 1 Fragment normal
				float3 normals[2];
				float3 objNormal;
				float3 tangentSpaceNormal;
				float3 binormal[2];
				float3 tangent[2];
				float3 worldPos;
				float3 localPos;
				float3 objectPosition;
				float isFrontFace;
				float4 vertexColor;
				float4 lightmapUV;
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 7 Distorted UV
				float2 uv[9];
				float2 parallaxUV;
			};
			
			struct PoiCam
			{
				float3 viewDir;
				float3 forwardDir;
				float3 worldPos;
				float distanceToVert;
				float4 clipPos;
				float3 reflectionDir;
				float3 vertexReflectionDir;
				float3 tangentViewDir;
				float4 grabPos;
				float2 screenUV;
				float vDotN;
				float4 worldDirection;
				
			};
			
			struct PoiMods
			{
				float4 PBR; // smoothness, metallic, smoothness mask, metallic mask
				float4 Mask;
				float4 audioLink;
				float audioLinkAvailable;
				float audioLinkVersion;
				float4 audioLinkTexture;
				float audioLinkViaLuma;
				float2 detailMask;
				float2 backFaceDetailIntensity;
				float globalEmission;
				float4 globalColorTheme[12];
				float globalMask[16];
				float ALTime[8];
			};
			
			struct PoiLight
			{
				
				float3 direction;
				float attenuation;
				float attenuationStrength;
				float3 directColor;
				float3 indirectColor;
				float occlusion;
				float shadowMask;
				float detailShadow;
				float3 halfDir;
				float lightMap;
				float lightMapNoAttenuation;
				float3 rampedLightMap;
				float vertexNDotL;
				float nDotL;
				float nDotV;
				float vertexNDotV;
				float nDotH;
				float vertexNDotH;
				float lDotv;
				float lDotH;
				float nDotLSaturated;
				float nDotLNormalized;
				#ifdef POI_PASS_ADD
				float additiveShadow;
				#endif
				float3 finalLighting;
				float3 finalLightAdd;
				
				#if defined(VERTEXLIGHT_ON)
				// Non Important Lights
				float4 vDotNL;
				float4 vertexVDotNL;
				float3 vColor[4];
				float4 vCorrectedDotNL;
				float4 vAttenuation;
				float4 vAttenuationDotNL;
				float3 vPosition[4];
				float3 vDirection[4];
				float3 vFinalLighting;
				float3 vHalfDir[4];
				half4 vDotNH;
				half4 vertexVDotNH;
				half4 vDotLH;
				#endif
				
			};
			
			struct PoiVertexLights
			{
				
				float3 direction;
				float3 color;
				float attenuation;
			};
			
			struct PoiFragData
			{
				float3 baseColor;
				float3 finalColor;
				float alpha;
				float3 emission;
			};
			
			// glsl_mod behaves better on negative numbers, and
			// in some situations actually outperforms HLSL's fmod()
			#ifndef glsl_mod
			#define glsl_mod(x, y) (((x) - (y) * floor((x) / (y))))
			#endif
			
			uniform float random_uniform_float_only_used_to_stop_compiler_warnings = 0.0f;
			
			float2 poiUV(float2 uv, float4 tex_st)
			{
				return uv * tex_st.xy + tex_st.zw;
			}
			
			float2 vertexUV(in VertexOut o, int index)
			{
				switch(index)
				{
					case 0:
					return o.uv[0];
					case 1:
					return o.uv[1];
					case 2:
					return o.uv[2];
					case 3:
					return o.uv[3];
					default:
					return o.uv[0];
				}
			}
			
			float2 vertexUV(in appdata v, int index)
			{
				switch(index)
				{
					case 0:
					return v.uv0;
					case 1:
					return v.uv1;
					case 2:
					return v.uv2;
					case 3:
					return v.uv3;
					default:
					return v.uv0;
				}
			}
			
			//Lighting Helpers
			float calculateluminance(float3 color)
			{
				return color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
			}
			
			// Set by VRChat (as of open beta 1245)
			// _VRChatCameraMode: 0 => Normal, 1 => VR HandCam, 2 => Desktop Handcam, 3 => Screenshot/Photo
			// _VRChatMirrorMode: 0 => Normal, 1 => Mirror (VR), 2 => Mirror (Deskie)
			float _VRChatCameraMode;
			float _VRChatMirrorMode;
			
			float VRCCameraMode()
			{
				return _VRChatCameraMode;
			}
			
			float VRCMirrorMode()
			{
				return _VRChatMirrorMode;
			}
			
			bool IsInMirror()
			{
				return unity_CameraProjection[2][0] != 0.f || unity_CameraProjection[2][1] != 0.f;
			}
			
			bool IsOrthographicCamera()
			{
				return unity_OrthoParams.w == 1 || UNITY_MATRIX_P[3][3] == 1;
			}
			
			float shEvaluateDiffuseL1Geomerics_local(float L0, float3 L1, float3 n)
			{
				// average energy
				float R0 = max(0, L0);
				
				// avg direction of incoming light
				float3 R1 = 0.5f * L1;
				
				// directional brightness
				float lenR1 = length(R1);
				
				// linear angle between normal and direction 0-1
				//float q = 0.5f * (1.0f + dot(R1 / lenR1, n));
				//float q = dot(R1 / lenR1, n) * 0.5 + 0.5;
				float q = dot(normalize(R1), n) * 0.5 + 0.5;
				q = saturate(q); // Thanks to ScruffyRuffles for the bug identity.
				
				// power for q
				// lerps from 1 (linear) to 3 (cubic) based on directionality
				float p = 1.0f + 2.0f * lenR1 / R0;
				
				// dynamic range constant
				// should vary between 4 (highly directional) and 0 (ambient)
				float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);
				
				return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));
			}
			
			half3 BetterSH9(half4 normal)
			{
				float3 indirect;
				float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;
				indirect.r = shEvaluateDiffuseL1Geomerics_local(L0.r, unity_SHAr.xyz, normal.xyz);
				indirect.g = shEvaluateDiffuseL1Geomerics_local(L0.g, unity_SHAg.xyz, normal.xyz);
				indirect.b = shEvaluateDiffuseL1Geomerics_local(L0.b, unity_SHAb.xyz, normal.xyz);
				indirect = max(0, indirect);
				indirect += SHEvalLinearL2(normal);
				return indirect;
			}
			
			// Silent's code ends here
			
			float3 getCameraForward()
			{
				#if UNITY_SINGLE_PASS_STEREO
				float3 p1 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 1, 1));
				float3 p2 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 0, 1));
				#else
				float3 p1 = mul(unity_CameraToWorld, float4(0, 0, 1, 1)).xyz;
				float3 p2 = mul(unity_CameraToWorld, float4(0, 0, 0, 1)).xyz;
				#endif
				return normalize(p2 - p1);
			}
			
			half3 GetSHLength()
			{
				half3 x, x1;
				x.r = length(unity_SHAr);
				x.g = length(unity_SHAg);
				x.b = length(unity_SHAb);
				x1.r = length(unity_SHBr);
				x1.g = length(unity_SHBg);
				x1.b = length(unity_SHBb);
				return x + x1;
			}
			
			float3 BoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
			{
				#if UNITY_SPECCUBE_BOX_PROJECTION
				//UNITY_BRANCH
				if (cubemapPosition.w > 0)
				{
					float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
					float scalar = min(min(factors.x, factors.y), factors.z);
					direction = direction * scalar + (position - cubemapPosition.xyz);
				}
				#endif
				return direction;
			}
			
			float poiMax(float2 i)
			{
				return max(i.x, i.y);
			}
			
			float poiMax(float3 i)
			{
				return max(max(i.x, i.y), i.z);
			}
			
			float poiMax(float4 i)
			{
				return max(max(max(i.x, i.y), i.z), i.w);
			}
			
			float3 calculateNormal(in float3 baseNormal, in PoiMesh poiMesh, in Texture2D normalTexture, in float4 normal_ST, in float2 normalPan, in float normalUV, in float normalIntensity)
			{
				float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
				return normalize(
				normal.x * poiMesh.tangent[0] +
				normal.y * poiMesh.binormal[0] +
				normal.z * baseNormal
				);
			}
			
			float remap(float x, float minOld, float maxOld, float minNew = 0, float maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float2 remap(float2 x, float2 minOld, float2 maxOld, float2 minNew = 0, float2 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float3 remap(float3 x, float3 minOld, float3 maxOld, float3 minNew = 0, float3 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float4 remap(float4 x, float4 minOld, float4 maxOld, float4 minNew = 0, float4 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float remapClamped(float minOld, float maxOld, float x, float minNew = 0, float maxNew = 1)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float2 remapClamped(float2 minOld, float2 maxOld, float2 x, float2 minNew, float2 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float3 remapClamped(float3 minOld, float3 maxOld, float3 x, float3 minNew, float3 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float4 remapClamped(float4 minOld, float4 maxOld, float4 x, float4 minNew, float4 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			float2 calcParallax(in float height, in PoiCam poiCam)
			{
				return ((height * - 1) + 1) * (poiCam.tangentViewDir.xy / poiCam.tangentViewDir.z);
			}
			
			/*
			0: Zero	                float4(0.0, 0.0, 0.0, 0.0),
			1: One	                float4(1.0, 1.0, 1.0, 1.0),
			2: DstColor	            destinationColor,
			3: SrcColor	            sourceColor,
			4: OneMinusDstColor	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
			5: SrcAlpha	            sourceColor.aaaa,
			6: OneMinusSrcColor	    float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
			7: DstAlpha	            destinationColor.aaaa,
			8: OneMinusDstAlpha	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor.,
			9: SrcAlphaSaturate     saturate(sourceColor.aaaa),
			10: OneMinusSrcAlpha	float4(1.0, 1.0, 1.0, 1.0) - sourceColor.aaaa,
			*/
			
			float4 poiBlend(const float sourceFactor, const  float4 sourceColor, const  float destinationFactor, const  float4 destinationColor, const float4 blendFactor)
			{
				float4 sA = 1 - blendFactor;
				const float4 blendData[11] = {
					float4(0.0, 0.0, 0.0, 0.0),
					float4(1.0, 1.0, 1.0, 1.0),
					destinationColor,
					sourceColor,
					float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sA,
					saturate(sourceColor.aaaa),
					1 - sA,
				};
				
				return lerp(blendData[sourceFactor] * sourceColor + blendData[destinationFactor] * destinationColor, sourceColor, sA);
			}
			
			// Average
			float blendAverage(float base, float blend)
			{
				return (base + blend) / 2.0;
			}
			float3 blendAverage(float3 base, float3 blend)
			{
				return (base + blend) / 2.0;
			}
			
			// Color burn
			float blendColorBurn(float base, float blend)
			{
				return (blend == 0.0) ? blend : max((1.0 - ((1.0 - base) * rcp(random_uniform_float_only_used_to_stop_compiler_warnings + blend))), 0.0);
			}
			
			float3 blendColorBurn(float3 base, float3 blend)
			{
				return float3(blendColorBurn(base.r, blend.r), blendColorBurn(base.g, blend.g), blendColorBurn(base.b, blend.b));
			}
			
			// Color Dodge
			float blendColorDodge(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0);
			}
			
			float3 blendColorDodge(float3 base, float3 blend)
			{
				return float3(blendColorDodge(base.r, blend.r), blendColorDodge(base.g, blend.g), blendColorDodge(base.b, blend.b));
			}
			
			// Darken
			float blendDarken(float base, float blend)
			{
				return min(blend, base);
			}
			
			float3 blendDarken(float3 base, float3 blend)
			{
				return float3(blendDarken(base.r, blend.r), blendDarken(base.g, blend.g), blendDarken(base.b, blend.b));
			}
			
			// Exclusion
			float blendExclusion(float base, float blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			float3 blendExclusion(float3 base, float3 blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			
			// Reflect
			float blendReflect(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0);
			}
			
			float3 blendReflect(float3 base, float3 blend)
			{
				return float3(blendReflect(base.r, blend.r), blendReflect(base.g, blend.g), blendReflect(base.b, blend.b));
			}
			
			// Glow
			float blendGlow(float base, float blend)
			{
				return blendReflect(blend, base);
			}
			float3 blendGlow(float3 base, float3 blend)
			{
				return blendReflect(blend, base);
			}
			
			// Overlay
			float blendOverlay(float base, float blend)
			{
				return base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend));
			}
			
			float3 blendOverlay(float3 base, float3 blend)
			{
				return float3(blendOverlay(base.r, blend.r), blendOverlay(base.g, blend.g), blendOverlay(base.b, blend.b));
			}
			
			// Hard Light
			float blendHardLight(float base, float blend)
			{
				return blendOverlay(blend, base);
			}
			float3 blendHardLight(float3 base, float3 blend)
			{
				return blendOverlay(blend, base);
			}
			
			// Vivid light
			float blendVividLight(float base, float blend)
			{
				return (blend < 0.5) ? blendColorBurn(base, (2.0 * blend)) : blendColorDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendVividLight(float3 base, float3 blend)
			{
				return float3(blendVividLight(base.r, blend.r), blendVividLight(base.g, blend.g), blendVividLight(base.b, blend.b));
			}
			
			// Hard mix
			float blendHardMix(float base, float blend)
			{
				return (blendVividLight(base, blend) < 0.5) ? 0.0 : 1.0;
			}
			
			float3 blendHardMix(float3 base, float3 blend)
			{
				return float3(blendHardMix(base.r, blend.r), blendHardMix(base.g, blend.g), blendHardMix(base.b, blend.b));
			}
			
			// Lighten
			float blendLighten(float base, float blend)
			{
				return max(blend, base);
			}
			
			float3 blendLighten(float3 base, float3 blend)
			{
				return float3(blendLighten(base.r, blend.r), blendLighten(base.g, blend.g), blendLighten(base.b, blend.b));
			}
			
			// Linear Burn
			float blendLinearBurn(float base, float blend)
			{
				// Note : Same implementation as BlendSubtractf
				return max(base + blend - 1.0, 0.0);
			}
			
			float3 blendLinearBurn(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendSubtract
				return max(base + blend - float3(1.0, 1.0, 1.0), float3(0.0, 0.0, 0.0));
			}
			
			// Linear Dodge
			float blendLinearDodge(float base, float blend)
			{
				// Note : Same implementation as BlendAddf
				return min(base + blend, 1.0);
			}
			
			float3 blendLinearDodge(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendAdd
				return min(base + blend, float3(1.0, 1.0, 1.0));
			}
			
			// Linear light
			float blendLinearLight(float base, float blend)
			{
				return blend < 0.5 ? blendLinearBurn(base, (2.0 * blend)) : blendLinearDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendLinearLight(float3 base, float3 blend)
			{
				return float3(blendLinearLight(base.r, blend.r), blendLinearLight(base.g, blend.g), blendLinearLight(base.b, blend.b));
			}
			
			// Multiply
			float blendMultiply(float base, float blend)
			{
				return base * blend;
			}
			float3 blendMultiply(float3 base, float3 blend)
			{
				return base * blend;
			}
			
			// Negation
			float blendNegation(float base, float blend)
			{
				return 1.0 - abs(1.0 - base - blend);
			}
			float3 blendNegation(float3 base, float3 blend)
			{
				return float3(1.0, 1.0, 1.0) - abs(float3(1.0, 1.0, 1.0) - base - blend);
			}
			
			// Normal
			float blendNormal(float base, float blend)
			{
				return blend;
			}
			float3 blendNormal(float3 base, float3 blend)
			{
				return blend;
			}
			
			// Phoenix
			float blendPhoenix(float base, float blend)
			{
				return min(base, blend) - max(base, blend) + 1.0;
			}
			float3 blendPhoenix(float3 base, float3 blend)
			{
				return min(base, blend) - max(base, blend) + float3(1.0, 1.0, 1.0);
			}
			
			// Pin light
			float blendPinLight(float base, float blend)
			{
				return (blend < 0.5) ? blendDarken(base, (2.0 * blend)) : blendLighten(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendPinLight(float3 base, float3 blend)
			{
				return float3(blendPinLight(base.r, blend.r), blendPinLight(base.g, blend.g), blendPinLight(base.b, blend.b));
			}
			
			// Screen
			float blendScreen(float base, float blend)
			{
				return 1.0 - ((1.0 - base) * (1.0 - blend));
			}
			
			float3 blendScreen(float3 base, float3 blend)
			{
				return float3(blendScreen(base.r, blend.r), blendScreen(base.g, blend.g), blendScreen(base.b, blend.b));
			}
			
			// Soft Light
			float blendSoftLight(float base, float blend)
			{
				return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
			}
			
			float3 blendSoftLight(float3 base, float3 blend)
			{
				return float3(blendSoftLight(base.r, blend.r), blendSoftLight(base.g, blend.g), blendSoftLight(base.b, blend.b));
			}
			
			// Subtract
			float blendSubtract(float base, float blend)
			{
				return max(base - blend, 0.0);
			}
			
			float3 blendSubtract(float3 base, float3 blend)
			{
				return max(base - blend, 0.0);
			}
			
			// Difference
			float blendDifference(float base, float blend)
			{
				return abs(base - blend);
			}
			
			float3 blendDifference(float3 base, float3 blend)
			{
				return abs(base - blend);
			}
			
			// Divide
			float blendDivide(float base, float blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float3 blendDivide(float3 base, float3 blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float blendMixed(float base, float blend)
			{
				return base + base * blend;
			}
			
			float3 blendMixed(float3 base, float3 blend)
			{
				return base + base * blend;
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float customBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType, float alpha)
			{
				float3 output = base;
				switch(blendType)
				{
					case 0: output = lerp(base, blend, alpha); break;
					case 2: output = base * lerp(1, blend, alpha); break;
					case 6: output = lerp(base, blendScreen(base, blend), alpha); break;
					case 8: output = lerp(base, blendLinearDodge(base, blend), alpha); break;
					case 9: output = lerp(base, blendOverlay(base, blend), alpha); break;
					case 20: output = lerp(base, blendMixed(base, blend), alpha); break;
					default: output = 0; break;
				}
				return output;
			}
			
			#define REPLACE 0
			#define SUBSTRACT 1
			#define MULTIPLY 2
			#define DIVIDE 3
			#define MIN 4
			#define MAX 5
			#define AVERAGE 6
			#define ADD 7
			
			float maskBlend(float baseMask, float blendMask, float blendType)
			{
				float output = 0;
				switch(blendType)
				{
					case REPLACE: output = blendMask; break;
					case SUBSTRACT: output = baseMask - blendMask; break;
					case MULTIPLY: output = baseMask * blendMask; break;
					case DIVIDE: output = baseMask / blendMask; break;
					case MIN: output = min(baseMask, blendMask); break;
					case MAX: output = max(baseMask, blendMask); break;
					case AVERAGE: output = (baseMask + blendMask) * 0.5; break;
					case ADD: output = baseMask + blendMask; break;
				}
				return saturate(output);
			}
			
			float random(float2 p)
			{
				return frac(sin(dot(p, float2(12.9898, 78.2383))) * 43758.5453123);
			}
			
			float2 random2(float2 p)
			{
				return frac(sin(float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)))) * 43758.5453);
			}
			
			float3 random3(float2 p)
			{
				return frac(sin(float3(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)), dot(p, float2(248.3, 315.9)))) * 43758.5453);
			}
			
			float3 random3(float3 p)
			{
				return frac(sin(float3(dot(p, float3(127.1, 311.7, 248.6)), dot(p, float3(269.5, 183.3, 423.3)), dot(p, float3(248.3, 315.9, 184.2)))) * 43758.5453);
			}
			
			float3 randomFloat3(float2 Seed, float maximum)
			{
				return (.5 + float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed), float2(12.9898, 78.233))) * 43758.5453)
				) * .5) * (maximum);
			}
			
			float3 randomFloat3Range(float2 Seed, float Range)
			{
				return (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1) * Range;
			}
			
			float3 randomFloat3WiggleRange(float2 Seed, float Range, float wiggleSpeed)
			{
				float3 rando = (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1);
				float speed = 1 + wiggleSpeed;
				return float3(sin((_Time.x + rando.x * PI) * speed), sin((_Time.x + rando.y * PI) * speed), sin((_Time.x + rando.z * PI) * speed)) * Range;
			}
			
			void poiDither(float4 In, float4 ScreenPosition, out float4 Out)
			{
				float2 uv = ScreenPosition.xy * _ScreenParams.xy;
				float DITHER_THRESHOLDS[16] = {
					1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0,
					13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0,
					4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0,
					16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0
				};
				uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
				Out = In - DITHER_THRESHOLDS[index];
			}
			
			static const float Epsilon = 1e-10;
			// The weights of RGB contributions to luminance.
			// Should sum to unity.
			static const float3 HCYwts = float3(0.299, 0.587, 0.114);
			static const float HCLgamma = 3;
			static const float HCLy0 = 100;
			static const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
			static const float3 wref = float3(1.0, 1.0, 1.0);
			#define TAU 6.28318531
			
			float3 HUEtoRGB(in float H)
			{
				float R = abs(H * 6 - 3) - 1;
				float G = 2 - abs(H * 6 - 2);
				float B = 2 - abs(H * 6 - 4);
				return saturate(float3(R, G, B));
			}
			
			float3 RGBtoHCV(in float3 RGB)
			{
				// Based on work by Sam Hocevar and Emil Persson
				float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
				float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
				float C = Q.x - min(Q.w, Q.y);
				float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
				return float3(H, C, Q.x);
			}
			
			float3 HSVtoRGB(in float3 HSV)
			{
				float3 RGB = HUEtoRGB(HSV.x);
				return ((RGB - 1) * HSV.y + 1) * HSV.z;
			}
			
			float3 RGBtoHSV(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float S = HCV.y / (HCV.z + Epsilon);
				return float3(HCV.x, S, HCV.z);
			}
			
			float3 HSLtoRGB(in float3 HSL)
			{
				float3 RGB = HUEtoRGB(HSL.x);
				float C = (1 - abs(2 * HSL.z - 1)) * HSL.y;
				return (RGB - 0.5) * C + HSL.z;
			}
			
			float3 RGBtoHSL(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float L = HCV.z - HCV.y * 0.5;
				float S = HCV.y / (1 - abs(L * 2 - 1) + Epsilon);
				return float3(HCV.x, S, L);
			}
			
			void DecomposeHDRColor(in float3 linearColorHDR, out float3 baseLinearColor, out float exposure)
			{
				// Optimization/adaptation of https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/GUI/ColorMutator.cs#L23 but skips weird photoshop stuff
				float maxColorComponent = max(linearColorHDR.r, max(linearColorHDR.g, linearColorHDR.b));
				bool isSDR = maxColorComponent <= 1.0;
				
				float scaleFactor = isSDR ? 1.0 : (1.0 / maxColorComponent);
				exposure = isSDR ? 0.0 : log(maxColorComponent) * 1.44269504089; // ln(2)
				
				baseLinearColor = scaleFactor * linearColorHDR;
			}
			
			float3 ApplyHDRExposure(float3 linearColor, float exposure)
			{
				return linearColor * pow(2, exposure);
			}
			
			// Transforms an RGB color using a matrix. Note that S and V are absolute values here
			float3 ModifyViaHSV(float3 color, float h, float s, float v)
			{
				float3 colorHSV = RGBtoHSV(color);
				colorHSV.x = frac(colorHSV.x + h);
				colorHSV.y = saturate(colorHSV.y + s);
				colorHSV.z = saturate(colorHSV.z + v);
				return HSVtoRGB(colorHSV);
			}
			
			float3 ModifyViaHSV(float3 color, float3 HSVMod)
			{
				return ModifyViaHSV(color, HSVMod.x, HSVMod.y, HSVMod.z);
			}
			
			float3 hueShift(float3 color, float hueOffset)
			{
				color = RGBtoHSV(color);
				color.x = frac(hueOffset +color.x);
				return HSVtoRGB(color);
			}
			
			// LCH
			float xyzF(float t)
			{
				return lerp(pow(t, 1. / 3.), 7.787037 * t + 0.139731, step(t, 0.00885645));
			}
			float xyzR(float t)
			{
				return lerp(t * t * t, 0.1284185 * (t - 0.139731), step(t, 0.20689655));
			}
			
			float4x4 poiRotationMatrixFromAngles(float x, float y, float z)
			{
				float angleX = radians(x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float4x4 poiRotationMatrixFromAngles(float3 angles)
			{
				float angleX = radians(angles.x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(angles.y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(angles.z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float3 getCameraPosition()
			{
				#ifdef USING_STEREO_MATRICES
				return lerp(unity_StereoWorldSpaceCameraPos[0], unity_StereoWorldSpaceCameraPos[1], 0.5);
				#endif
				return _WorldSpaceCameraPos;
			}
			
			half2 calcScreenUVs(half4 grabPos)
			{
				half2 uv = grabPos.xy / (grabPos.w + 0.0000000001);
				#if UNITY_SINGLE_PASS_STEREO
				uv.xy *= half2(_ScreenParams.x * 2, _ScreenParams.y);
				#else
				uv.xy *= _ScreenParams.xy;
				#endif
				
				return uv;
			}
			
			float CalcMipLevel(float2 texture_coord)
			{
				float2 dx = ddx(texture_coord);
				float2 dy = ddy(texture_coord);
				float delta_max_sqr = max(dot(dx, dx), dot(dy, dy));
				
				return 0.5 * log2(delta_max_sqr);
			}
			
			float inverseLerp(float A, float B, float T)
			{
				return (T - A) / (B - A);
			}
			
			float inverseLerp2(float2 a, float2 b, float2 value)
			{
				float2 AB = b - a;
				float2 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp3(float3 a, float3 b, float3 value)
			{
				float3 AB = b - a;
				float3 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp4(float4 a, float4 b, float4 value)
			{
				float4 AB = b - a;
				float4 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			/*
			MIT License
			
			Copyright (c) 2019 wraikny
			
			Permission is hereby granted, free of charge, to any person obtaining a copy
			of this software and associated documentation files (the "Software"), to deal
			in the Software without restriction, including without limitation the rights
			to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			copies of the Software, and to permit persons to whom the Software is
			furnished to do so, subject to the following conditions:
			
			The above copyright notice and this permission notice shall be included in all
			copies or substantial portions of the Software.
			
			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			SOFTWARE.
			
			VertexTransformShader is dependent on:
			*/
			
			float4 quaternion_conjugate(float4 v)
			{
				return float4(
				v.x, -v.yzw
				);
			}
			
			float4 quaternion_mul(float4 v1, float4 v2)
			{
				float4 result1 = (v1.x * v2 + v1 * v2.x);
				
				float4 result2 = float4(
				- dot(v1.yzw, v2.yzw),
				cross(v1.yzw, v2.yzw)
				);
				
				return float4(result1 + result2);
			}
			
			// angle : radians
			float4 get_quaternion_from_angle(float3 axis, float angle)
			{
				float sn = sin(angle * 0.5);
				float cs = cos(angle * 0.5);
				return float4(axis * sn, cs);
			}
			
			float4 quaternion_from_vector(float3 inVec)
			{
				return float4(0.0, inVec);
			}
			
			float degree_to_radius(float degree)
			{
				return (
				degree / 180.0 * PI
				);
			}
			
			float3 rotate_with_quaternion(float3 inVec, float3 rotation)
			{
				float4 qx = get_quaternion_from_angle(float3(1, 0, 0), radians(rotation.x));
				float4 qy = get_quaternion_from_angle(float3(0, 1, 0), radians(rotation.y));
				float4 qz = get_quaternion_from_angle(float3(0, 0, 1), radians(rotation.z));
				
				#define MUL3(A, B, C) quaternion_mul(quaternion_mul((A), (B)), (C))
				float4 quaternion = normalize(MUL3(qx, qy, qz));
				float4 conjugate = quaternion_conjugate(quaternion);
				
				float4 inVecQ = quaternion_from_vector(inVec);
				
				float3 rotated = (
				MUL3(quaternion, inVecQ, conjugate)
				).yzw;
				
				return rotated;
			}
			
			float4 transform(float4 input, float4 pos, float4 rotation, float4 scale)
			{
				input.rgb *= (scale.xyz * scale.w);
				input = float4(rotate_with_quaternion(input.xyz, rotation.xyz * rotation.w) + (pos.xyz * pos.w), input.w);
				return input;
			}
			
			float2 RotateUV(float2 _uv, float _radian, float2 _piv, float _time)
			{
				float RotateUV_ang = _radian;
				float RotateUV_cos = cos(_time * RotateUV_ang);
				float RotateUV_sin = sin(_time * RotateUV_ang);
				return (mul(_uv - _piv, float2x2(RotateUV_cos, -RotateUV_sin, RotateUV_sin, RotateUV_cos)) + _piv);
			}
			
			/*
			MIT END
			*/
			
			float3 poiThemeColor(in PoiMods poiMods, in float3 srcColor, in float themeIndex)
			{
				if (themeIndex == 0) return srcColor;
				themeIndex -= 1;
				
				if (themeIndex <= 3)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				#endif
				
				return srcColor;
			}
			
			float3 lilToneCorrection(float3 c, float4 hsvg)
			{
				// gamma
				c = pow(abs(c), hsvg.w);
				// rgb -> hsv
				float4 p = (c.b > c.g) ? float4(c.bg, -1.0, 2.0 / 3.0) : float4(c.gb, 0.0, -1.0 / 3.0);
				float4 q = (p.x > c.r) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
				float d = q.x - min(q.w, q.y);
				float e = 1.0e-10;
				float3 hsv = float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
				// shift
				hsv = float3(hsv.x + hsvg.x, saturate(hsv.y * hsvg.y), saturate(hsv.z * hsvg.z));
				// hsv -> rgb
				return hsv.z - hsv.z * hsv.y + hsv.z * hsv.y * saturate(abs(frac(hsv.x + float3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 1.0);
			}
			
			float lilIsIn0to1(float f)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, 1.0));
			}
			
			float lilIsIn0to1(float f, float nv)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, nv));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border)
			{
				return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
			}
			
			float3 poiEdgeLinearNoSaturate(float value, float3 border)
			{
				return float3(
				(value - border.x) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.y) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.z) / clamp(fwidth(value), 0.0001, 1.0)
				);
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur)
			{
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border)
			{
				//return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
				
				float fwidthValue = fwidth(value);
				return smoothstep(border - fwidthValue, border + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinear(float value, float border)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur, borderRange));
			}
			
			float poiEdgeLinear(float value, float border)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border));
			}
			
			float poiEdgeLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur, borderRange));
			}
			// From https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl
			float3 OpenLitLinearToSRGB(float3 col)
			{
				return LinearToGammaSpace(col);
			}
			
			float3 OpenLitSRGBToLinear(float3 col)
			{
				return GammaToLinearSpace(col);
			}
			
			float OpenLitLuminance(float3 rgb)
			{
				#if defined(UNITY_COLORSPACE_GAMMA)
				return dot(rgb, float3(0.22, 0.707, 0.071));
				#else
				return dot(rgb, float3(0.0396819152, 0.458021790, 0.00609653955));
				#endif
			}
			
			float OpenLitGray(float3 rgb)
			{
				return dot(rgb, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
			}
			
			void OpenLitShadeSH9ToonDouble(float3 lightDirection, out float3 shMax, out float3 shMin)
			{
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 N = lightDirection * 0.666666;
				float4 vB = N.xyzz * N.yzzx;
				// L0 L2
				float3 res = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				res.r += dot(unity_SHBr, vB);
				res.g += dot(unity_SHBg, vB);
				res.b += dot(unity_SHBb, vB);
				res += unity_SHC.rgb * (N.x * N.x - N.y * N.y);
				// L1
				float3 l1;
				l1.r = dot(unity_SHAr.rgb, N);
				l1.g = dot(unity_SHAg.rgb, N);
				l1.b = dot(unity_SHAb.rgb, N);
				shMax = res + l1;
				shMin = res - l1;
				#if defined(UNITY_COLORSPACE_GAMMA)
				shMax = OpenLitLinearToSRGB(shMax);
				shMin = OpenLitLinearToSRGB(shMin);
				#endif
				#else
				shMax = 0.0;
				shMin = 0.0;
				#endif
			}
			
			float3 OpenLitComputeCustomLightDirection(float4 lightDirectionOverride)
			{
				float3 customDir = length(lightDirectionOverride.xyz) * normalize(mul((float3x3)unity_ObjectToWorld, lightDirectionOverride.xyz));
				return lightDirectionOverride.w ? customDir : lightDirectionOverride.xyz; // .w isn't doc'd anywhere and is always 0 unless end user changes it
				
			}
			
			float3 OpenLitLightingDirectionForSH9()
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				
				float3 lightDirectionForSH9 = sh9Dir + mainDir;
				lightDirectionForSH9 = dot(lightDirectionForSH9, lightDirectionForSH9) < 0.000001 ? 0 : normalize(lightDirectionForSH9);
				return lightDirectionForSH9;
			}
			
			float3 OpenLitLightingDirection(float4 lightDirectionOverride)
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				float3 customDir = OpenLitComputeCustomLightDirection(lightDirectionOverride);
				
				return normalize(sh9DirAbs + mainDir + customDir);
			}
			
			float3 OpenLitLightingDirection()
			{
				float4 customDir = float4(0.001, 0.002, 0.001, 0.0);
				return OpenLitLightingDirection(customDir);
			}
			
			inline float4 CalculateFrustumCorrection()
			{
				float x1 = -UNITY_MATRIX_P._31 / (UNITY_MATRIX_P._11 * UNITY_MATRIX_P._34);
				float x2 = -UNITY_MATRIX_P._32 / (UNITY_MATRIX_P._22 * UNITY_MATRIX_P._34);
				return float4(x1, x2, 0, UNITY_MATRIX_P._33 / UNITY_MATRIX_P._34 + x1 * UNITY_MATRIX_P._13 + x2 * UNITY_MATRIX_P._23);
			}
			
			inline float CorrectedLinearEyeDepth(float z, float B)
			{
				return 1.0 / (z / UNITY_MATRIX_P._34 + B);
			}
			
			//Silent's code
			float2 sharpSample(float4 texelSize, float2 p)
			{
				p = p * texelSize.zw;
				float2 c = max(0.0, fwidth(p));
				p = floor(p) + saturate(frac(p) / c);
				p = (p - 0.5) * texelSize.xy;
				return p;
			}
			
			void applyToGlobalMask(inout PoiMods poiMods, int index, int blendType, float val)
			{
				float valBlended = saturate(maskBlend(poiMods.globalMask[index], val, blendType));
				switch(index)
				{
					case 0: poiMods.globalMask[0] = valBlended; break;
					case 1: poiMods.globalMask[1] = valBlended; break;
					case 2: poiMods.globalMask[2] = valBlended; break;
					case 3: poiMods.globalMask[3] = valBlended; break;
					case 4: poiMods.globalMask[4] = valBlended; break;
					case 5: poiMods.globalMask[5] = valBlended; break;
					case 6: poiMods.globalMask[6] = valBlended; break;
					case 7: poiMods.globalMask[7] = valBlended; break;
					case 8: poiMods.globalMask[8] = valBlended; break;
					case 9: poiMods.globalMask[9] = valBlended; break;
					case 10: poiMods.globalMask[10] = valBlended; break;
					case 11: poiMods.globalMask[11] = valBlended; break;
					case 12: poiMods.globalMask[12] = valBlended; break;
					case 13: poiMods.globalMask[13] = valBlended; break;
					case 14: poiMods.globalMask[14] = valBlended; break;
					case 15: poiMods.globalMask[15] = valBlended; break;
				}
			}
			
			void assignValueToVectorFromIndex(inout float4 vec, int index, float value)
			{
				switch(index)
				{
					case 0: vec[0] = value; break;
					case 1: vec[1] = value; break;
					case 2: vec[2] = value; break;
					case 3: vec[3] = value; break;
				}
			}
			
			// SNose
			float3 mod289(float3 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float2 mod289(float2 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float3 permute(float3 x)
			{
				return mod289(((x * 34.0) + 1.0) * x);
			}
			
			float snoise(float2 v)
			{
				const float4 C = float4(0.211324865405187, // (3.0-sqrt(3.0))/6.0
				0.366025403784439, // 0.5*(sqrt(3.0)-1.0)
				- 0.577350269189626, // -1.0 + 2.0 * C.x
				0.024390243902439); // 1.0 / 41.0
				float2 i = floor(v + dot(v, C.yy));
				float2 x0 = v - i + dot(i, C.xx);
				float2 i1;
				i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
				float4 x12 = x0.xyxy + C.xxzz;
				x12.xy -= i1;
				i = mod289(i); // Avoid truncation effects in permutation
				float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0))
				+ i.x + float3(0.0, i1.x, 1.0));
				
				float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
				m = m * m ;
				m = m * m ;
				float3 x = 2.0 * frac(p * C.www) - 1.0;
				float3 h = abs(x) - 0.5;
				float3 ox = floor(x + 0.5);
				float3 a0 = x - ox;
				m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
				float3 g;
				g.x = a0.x * x0.x + h.x * x0.y;
				g.yz = a0.yz * x12.xz + h.yz * x12.yw;
				return 130.0 * dot(m, g);
			}
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			
			// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.
			float4 AudioLinkDataMultiline(uint2 xycoord) { return AudioLinkData(uint2(xycoord.x % AUDIOLINK_WIDTH, xycoord.y + xycoord.x/AUDIOLINK_WIDTH)); }
			
			// Mechanism to sample between two adjacent pixels and lerp between them, like "linear" supesampling
			float4 AudioLinkLerp(float2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(xy+int2(1,0)), frac( xy.x ) ); }
			
			// Same as AudioLinkLerp but properly handles multiline reading.
			float4 AudioLinkLerpMultiline(float2 xy) { return lerp(AudioLinkDataMultiline(xy), AudioLinkDataMultiline(xy+float2(1,0)), frac(xy.x)); }
			
			//Tests to see if Audio Link texture is available
			bool AudioLinkIsAvailable()
			{
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				int width, height;
				_AudioTexture.GetDimensions(width, height);
				return width > 16;
				#else
				return _AudioTexture_TexelSize.z > 16;
				#endif
			}
			
			//Get version of audiolink present in the world, 0 if no audiolink is present
			float AudioLinkGetVersion()
			{
				int2 dims;
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				_AudioTexture.GetDimensions(dims.x, dims.y);
				#else
				dims = _AudioTexture_TexelSize.zw;
				#endif
				
				if (dims.x >= 128)
				return AudioLinkData(ALPASS_GENERALVU).x;
				else if (dims.x > 16)
				return 1;
				else
				return 0;
			}
			
			// This pulls data from this texture.
			#define AudioLinkGetSelfPixelData(xy) _SelfTexture2D[xy]
			
			// Extra utility functions for time.
			uint AudioLinkDecodeDataAsUInt(uint2 indexloc)
			{
				uint4 rpx = AudioLinkData(indexloc);
				return rpx.r + rpx.g*1024 + rpx.b * 1048576 + rpx.a * 1073741824;
			}
			
			//Note: This will truncate time to every 134,217.728 seconds (~1.5 days of an instance being up) to prevent floating point aliasing.
			// if your code will alias sooner, you will need to use a different function.  It should be safe to use this on all times.
			float AudioLinkDecodeDataAsSeconds(uint2 indexloc)
			{
				uint time = AudioLinkDecodeDataAsUInt(indexloc) & 0x7ffffff;
				//Can't just divide by float.  Bug in Unity's HLSL compiler.
				return float(time / 1000) + float( time % 1000 ) / 1000.;
			}
			
			#define ALDecodeDataAsSeconds( x ) AudioLinkDecodeDataAsSeconds( x )
			#define ALDecodeDataAsUInt( x ) AudioLinkDecodeDataAsUInt( x )
			
			float AudioLinkRemap(float t, float a, float b, float u, float v) { return ((t-a) / (b-a)) * (v-u) + u; }
			
			float3 AudioLinkHSVtoRGB(float3 HSV)
			{
				float3 RGB = 0;
				float C = HSV.z * HSV.y;
				float H = HSV.x * 6;
				float X = C * (1 - abs(fmod(H, 2) - 1));
				if (HSV.y != 0)
				{
					float I = floor(H);
					if (I == 0) { RGB = float3(C, X, 0); }
					else if (I == 1) { RGB = float3(X, C, 0); }
					else if (I == 2) { RGB = float3(0, C, X); }
					else if (I == 3) { RGB = float3(0, X, C); }
					else if (I == 4) { RGB = float3(X, 0, C); }
					else { RGB = float3(C, 0, X); }
				}
				float M = HSV.z - C;
				return RGB + M;
			}
			
			float3 AudioLinkCCtoRGB(float bin, float intensity, int rootNote)
			{
				float note = bin / AUDIOLINK_EXPBINS;
				
				float hue = 0.0;
				note *= 12.0;
				note = glsl_mod(4. - note + rootNote, 12.0);
				{
					if(note < 4.0)
					{
						//Needs to be YELLOW->RED
						hue = (note) / 24.0;
					}
					else if(note < 8.0)
					{
						//            [4]  [8]
						//Needs to be RED->BLUE
						hue = (note-2.0) / 12.0;
					}
					else
					{
						//             [8] [12]
						//Needs to be BLUE->YELLOW
						hue = (note - 4.0) / 8.0;
					}
				}
				float val = intensity - 0.1;
				return AudioLinkHSVtoRGB(float3(fmod(hue, 1.0), 1.0, clamp(val, 0.0, 1.0)));
			}
			
			// Sample the amplitude of a given frequency in the DFT, supports frequencies in [13.75; 14080].
			float4 AudioLinkGetAmplitudeAtFrequency(float hertz)
			{
				float note = AUDIOLINK_EXPBINS * log2(hertz / AUDIOLINK_BOTTOM_FREQUENCY);
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(note, 0));
			}
			
			// Sample the amplitude of a given semitone in an octave. Octave is in [0; 9] while note is [0; 11].
			float AudioLinkGetAmplitudeAtNote(float octave, float note)
			{
				float quarter = note * 2.0;
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(octave * AUDIOLINK_EXPBINS + quarter, 0));
			}
			
			// Get a reasonable drop-in replacement time value for _Time.y with the
			// given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTime(uint index, uint band)
			{
				return (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY + uint2(index, band))) / 100000.0;
			}
			
			// Get a chronotensity value in the interval [0; 1], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeNormalized(uint index, uint band, float speed)
			{
				return frac(AudioLinkGetChronoTime(index, band) * speed);
			}
			
			// Get a chronotensity value in the interval [0; interval], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeInterval(uint index, uint band, float speed, float interval)
			{
				return AudioLinkGetChronoTimeNormalized(index, band, speed) * interval;
			}
			
			float getBandAtTime(float band, float time, float size = 1.0f)
			{
				//return remap(UNITY_SAMPLE_TEX2D(_AudioTexture, float2(time * width, band/128.0)).r, min(size,.9999), 1);
				return remapClamped(min(size,.9999), 1, AudioLinkData(ALPASS_AUDIOBASS + uint2(time * AUDIOLINK_WIDTH,band)).r);
			}
			
			fixed3 maximize(fixed3 c) {
				if (c.x == 0 && c.y == 0 && c.z == 0)
				return fixed3(1.0, 1.0, 1.0);
				else
				return c / max(c.r, max(c.g, c.b));
			}
			
			bool LumaIsAvailable()
			{
				return LumaData(0.629, 0.511).r > 0.9;
			}
			
			float3 getLumaGradient(uint index, float offset) {
				return LumaData(0.57 + (index * 0.11) + lerp(0, 0.107, offset), 0.493);
			}
			
			void initPoiAudioLink(inout PoiMods poiMods)
			{
				if (!_AudioLinkAnimToggle) return;
				
				if (AudioLinkIsAvailable())
				{
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkVersion = AudioLinkGetVersion();
					poiMods.audioLink[0] = _AudioLinkSmoothingBass    == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 0))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingBass   ) * 15.95, 0))[0];
					poiMods.audioLink[1] = _AudioLinkSmoothingLowMid  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 1))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingLowMid ) * 15.95, 1))[0];
					poiMods.audioLink[2] = _AudioLinkSmoothingHighMid == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 2))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingHighMid) * 15.95, 2))[0];
					poiMods.audioLink[3] = _AudioLinkSmoothingTreble  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 3))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingTreble ) * 15.95, 3))[0];
					/*
					poiMods.globalColorTheme[4] = AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) );
					poiMods.globalColorTheme[5] = AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) );
					poiMods.globalColorTheme[6] = AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) );
					poiMods.globalColorTheme[7] = AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) );
					
					poiMods.globalColorTheme[4] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) )),1.0);
					poiMods.globalColorTheme[5] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) )),1.0);
					poiMods.globalColorTheme[6] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) )),1.0);
					poiMods.globalColorTheme[7] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) )),1.0);
					*/
					
					poiMods.globalColorTheme[4] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(2, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[5] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(3, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[6] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(4, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[7] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(5, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					
					poiMods.globalColorTheme[8] = AudioLinkData(ALPASS_THEME_COLOR0);
					poiMods.globalColorTheme[9] = AudioLinkData(ALPASS_THEME_COLOR1);
					poiMods.globalColorTheme[10] = AudioLinkData(ALPASS_THEME_COLOR2);
					poiMods.globalColorTheme[11] = AudioLinkData(ALPASS_THEME_COLOR3);
					return;
				}
				
				if (LumaIsAvailable())
				{
					// Gradients:
					// 0.570 - 0.677, 0.493
					// 0.680 - 0.788, 0.493
					// 0.791 - 0.898, 0.493
					float4 audioPixel = LumaData(0.578, 0.515);
					float audioLows = audioPixel.r;
					float audioHighs = audioPixel.g;
					float4 zone1 = LumaData(0.856, 0.522);
					float4 zone2 = LumaData(0.856, 0.507);
					float4 zone3 = LumaData(0.864, 0.522);
					float4 zone4 = LumaData(0.864, 0.507);
					// float4 lumaEnabledPixel = LumaData(0.629, 0.511);
					// float fakeLight = (lumaEnabledPixel.g > 0) ? 1 : (1 - lumaEnabledPixel.r);
					
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkViaLuma = true;
					poiMods.audioLink.xy = audioLows;
					poiMods.audioLink.zw = audioHighs;
					
					poiMods.globalColorTheme[8] = zone1;
					poiMods.globalColorTheme[9] = zone2;
					poiMods.globalColorTheme[10] = zone3;
					poiMods.globalColorTheme[11] = zone4;
				}
			}
			
			void DebugVisualizer(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods){
				if (_DebugWaveform){
					float waveform = AudioLinkLerpMultiline(ALPASS_WAVEFORM + float2( 500. * poiMesh.uv[0].x, 0)).r;
					poiFragData.emission += clamp(1 - 50 * abs(waveform - poiMesh.uv[0].y * 2. + 1), 0, 1);
				}
				if (_DebugDFT){
					poiFragData.emission += AudioLinkLerpMultiline(ALPASS_DFT + uint2(poiMesh.uv[0].x * AUDIOLINK_ETOTALBINS, 0)).rrr;
				}
				if (_DebugBass){
					poiFragData.emission += poiMods.audioLink.x;
				}
				if (_DebugLowMids){
					poiFragData.emission += poiMods.audioLink.y;
				}
				if (_DebugHighMids){
					poiFragData.emission += poiMods.audioLink.z;
				}
				if (_DebugTreble){
					poiFragData.emission += poiMods.audioLink.w;
				}
				if (_DebugCCColors){
					poiFragData.emission += AudioLinkData(ALPASS_CCCOLORS + uint2(3 + 1, 0));
				}
				if (_DebugCCStrip){
					poiFragData.emission += AudioLinkLerp(ALPASS_CCSTRIP + float2(poiMesh.uv[0].x * AUDIOLINK_WIDTH, 0));
				}
				if (_DebugCCLights){
					poiFragData.emission += AudioLinkData(ALPASS_CCLIGHTS + uint2(uint(poiMesh.uv[0].x * 8) + uint(poiMesh.uv[0].y * 16) * 8, 0));
				}
				if (_DebugAutocorrelator){
					poiFragData.emission += saturate(AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2((abs(1. - poiMesh.uv[0].x * 2.)) * AUDIOLINK_WIDTH, 0)).rrr);
				}
				if (_DebugChronotensity){
					poiFragData.emission += (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY  + uint2(1, 0)) % 1000000) / 1000000.0;
				}
			}
			
			void SetupAudioLink(inout PoiFragData poiFragData, inout PoiMods poiMods, in PoiMesh poiMesh){
				initPoiAudioLink(poiMods);
				DebugVisualizer(poiFragData, poiMesh, poiMods);
				
				if(_AudioLinkCCStripY)
				{
					poiFragData.emission += AudioLinkLerp( ALPASS_CCSTRIP + float2( poiMesh.uv[0].y * AUDIOLINK_WIDTH, 0 ) ).rgb * .5;
				}
			}
			
			#endif
			//endex
			
			//ifex _EnableDepthBulge==0
			#if defined(POI_DEPTHBULGE)
			void applyDepthBulgeFX(inout VertexOut o)
			{
				float4 pos = UnityObjectToClipPos(o.localPos);
				float4 grabPos = ComputeGrabScreenPos(pos);
				float depth = SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, float4(grabPos.xy / grabPos.w, 0, 0));
				
				#if defined(PROP_DEPTHBULGEMASK) || !defined(OPTIMIZER_ENABLED)
				float depthBulgeMask = tex2Dlod(_DepthBulgeMask, float4(poiUV(vertexUV(o, _DepthBulgeMaskUV), _DepthBulgeMask_ST), 0, 0))[_DepthBulgeMaskChannel];
				#else
				float depthBulgeMask = 1.0;
				#endif
				
				depth = Linear01Depth(depth);
				
				float intersect = 0;
				if (depth != 1)
				{
					float diff = distance(depth, Linear01Depth(pos.z / pos.w));
					if (diff > 0)
					{
						intersect = 1 - smoothstep(0, _ProjectionParams.w * _DepthBulgeFadeLength, diff);
					}
				}
				float4 offset = intersect * _DepthBulgeHeight * float4(o.normal, 0);
				
				offset = IsInMirror() ? 0 : offset;
				offset *= depthBulgeMask;
				
				o.worldPos.xyz += offset.xyz;
				o.localPos.xyz += mul(unity_WorldToObject, float4(offset.xyz, 0)).xyz;
			}
			#endif
			//endex
			
			VertexOut vert(
			#ifndef POI_TESSELLATED
			appdata v
			#else
			tessAppData v
			#endif
			)
			{
				UNITY_SETUP_INSTANCE_ID(v);
				VertexOut o;
				PoiInitStruct(VertexOut, o);
				UNITY_TRANSFER_INSTANCE_ID(v, o);
				#ifdef POI_TESSELLATED
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v);
				#endif
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
				
				//ifex _EnableUDIMDiscardOptions==0
				#ifdef POI_UDIMDISCARD
				UNITY_BRANCH
				if(_UDIMDiscardMode == 0) // Discard Vertices instead of just pixels
				{
					// Branchless (inspired by s-ilent)
					float2 udim = 0;
					// Select UV
					udim += (v.uv0.xy * (_UDIMDiscardUV == 0));
					udim += (v.uv1.xy * (_UDIMDiscardUV == 1));
					udim += (v.uv2.xy * (_UDIMDiscardUV == 2));
					udim += (v.uv3.xy * (_UDIMDiscardUV == 3));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 0, but not exactly 0
					const float threshold = 0.001;
					if(isDiscarded > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _VertexManipulationsEnabled==0
				#ifdef AUTO_EXPOSURE
				float4 audioLinkBands = 0;
				float3 ALrotation = 0;
				float3 ALLocalTranslation = 0;
				float3 CTALRotation = 0;
				float3 ALScale = 0;
				float3 ALWorldTranslation = 0;
				float ALHeight = 0;
				float ALRoundingAmount = 0;
				float4 ALSpectrumLocalOffset = float4(0, 0, 0, 0);
				#ifdef POI_AUDIOLINK
				if (AudioLinkIsAvailable() && _VertexAudioLinkEnabled && _AudioLinkAnimToggle)
				{
					audioLinkBands.x = AudioLinkData(ALPASS_AUDIOBASS).r;
					audioLinkBands.y = AudioLinkData(ALPASS_AUDIOLOWMIDS).r;
					audioLinkBands.z = AudioLinkData(ALPASS_AUDIOHIGHMIDS).r;
					audioLinkBands.w = AudioLinkData(ALPASS_AUDIOTREBLE).r;
					
					if (any(_VertexLocalTranslationALMin) || any(_VertexLocalTranslationALMax))
					{
						ALLocalTranslation = lerp(_VertexLocalTranslationALMin, _VertexLocalTranslationALMax, audioLinkBands[_VertexLocalTranslationALBand]);
					}
					if (any(_VertexLocalRotationAL))
					{
						ALrotation = audioLinkBands[_VertexLocalRotationALBand] * _VertexLocalRotationAL;
					}
					if (any(_VertexLocalRotationCTALSpeed))
					{
						CTALRotation.x = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeX, _VertexLocalRotationCTALBandX) * _VertexLocalRotationCTALSpeed.x * 360;
						CTALRotation.y = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeY, _VertexLocalRotationCTALBandY) * _VertexLocalRotationCTALSpeed.y * 360;
						CTALRotation.z = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeZ, _VertexLocalRotationCTALBandZ) * _VertexLocalRotationCTALSpeed.z * 360;
					}
					if (any(_VertexLocalScaleALMin) || any(_VertexLocalScaleALMax))
					{
						ALScale = lerp(_VertexLocalScaleALMin.xyz + _VertexLocalScaleALMin.w, _VertexLocalScaleALMax.xyz + _VertexLocalScaleALMax.w, audioLinkBands[_VertexLocalScaleALBand]);
					}
					if (any(_VertexWorldTranslationALMin) || any(_VertexWorldTranslationALMax))
					{
						ALWorldTranslation = lerp(_VertexWorldTranslationALMin, _VertexWorldTranslationALMax, audioLinkBands[_VertexWorldTranslationALBand]);
					}
					if (any(_VertexManipulationHeightAL))
					{
						ALHeight = lerp(_VertexManipulationHeightAL.x, _VertexManipulationHeightAL.y, audioLinkBands[_VertexManipulationHeightBand]);
					}
					if (any(_VertexRoundingRangeAL))
					{
						ALRoundingAmount = lerp(_VertexRoundingRangeAL.x, _VertexRoundingRangeAL.y, audioLinkBands[_VertexRoundingRangeBand]);
					}
					if (_VertexSpectrumMotion)
					{
						ALSpectrumLocalOffset.xyz = lerp(_VertexSpectrumOffsetMin.xyz, _VertexSpectrumOffsetMax.xyz, AudioLinkLerpMultiline(ALPASS_DFT + float2(vertexUV(v, _VertexSpectrumUV)[_VertexSpectrumUVDirection] * AUDIOLINK_ETOTALBINS, 0.)));
					}
				}
				#endif
				
				// Local Transformation
				float4 rotation = float4(_VertexManipulationLocalRotation.xyz + float3(180, 0, 0) + _VertexManipulationLocalRotationSpeed * _Time.x + ALrotation + CTALRotation, _VertexManipulationLocalRotation.w);
				v.normal = rotate_with_quaternion(v.normal, rotation.xyz);
				v.tangent.xyz = rotate_with_quaternion(v.tangent.xyz, rotation.xyz);
				v.vertex = transform(v.vertex, _VertexManipulationLocalTranslation + float4(ALLocalTranslation, 0) + ALSpectrumLocalOffset, rotation, _VertexManipulationLocalScale + float4(ALScale, 0));
				o.normal = UnityObjectToWorldNormal(v.normal);
				
				#if defined(PROP_VERTEXMANIPULATIONHEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float3 heightOffset = (tex2Dlod(_VertexManipulationHeightMask, float4(poiUV(vertexUV(v, _VertexManipulationHeightMaskUV), _VertexManipulationHeightMask_ST) + _VertexManipulationHeightMaskPan * _Time.x, 0, 0))[_VertexManipulationHeightMaskChannel] - _VertexManipulationHeightBias) * (_VertexManipulationHeight + ALHeight) * o.normal;
				#else
				float3 heightOffset = (_VertexManipulationHeight + ALHeight) * o.normal;
				#endif
				
				if (_VertexBarrelMode)
				{
					v.vertex.xz = lerp(v.vertex.xz, normalize(v.vertex.xz) * _VertexBarrelWidth + v.vertex.xz * _VertexBarrelHeight, _VertexBarrelAlpha);
				}
				
				if (_VertexSphereMode)
				{
					v.vertex.xyz = lerp(v.vertex.xyz, normalize(v.vertex.xyz + _VertexSphereCenter.xyz) * _VertexSphereRadius + v.vertex.xyz * _VertexSphereHeight, _VertexSphereAlpha);
				}
				
				v.vertex.xyz += mul(unity_WorldToObject, _VertexManipulationWorldTranslation.xyz + ALWorldTranslation + heightOffset).xyz;
				
				// rounding
				UNITY_BRANCH
				if (_VertexRoundingEnabled)
				{
					float divisionAmount = max(_VertexRoundingDivision + ALRoundingAmount, 0.0000001);
					float3 vertexPos = v.vertex.xyz;
					if (_VertexRoundingSpace == 0)
					{
						vertexPos = mul(unity_ObjectToWorld, v.vertex.xyz);
					}
					float3 worldRoundPosition = (ceil(vertexPos / divisionAmount) * divisionAmount) - divisionAmount * .5;
					v.vertex.xyz = worldRoundPosition;
					if (_VertexRoundingSpace == 0)
					{
						v.vertex.xyz = mul(unity_WorldToObject, worldRoundPosition);
					}
				}
				#endif
				//endex
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				UNITY_BRANCH
				if(_UVTileDissolveEnabled && _UVTileDissolveDiscardAtMax)
				{
					// Branchless (inspired by s-ilent)
					float2 dissolveUdim = 0;
					// Select UV
					dissolveUdim += (v.uv0.xy * (_UVTileDissolveUV == 0));
					dissolveUdim += (v.uv1.xy * (_UVTileDissolveUV == 1));
					dissolveUdim += (v.uv2.xy * (_UVTileDissolveUV == 2));
					dissolveUdim += (v.uv3.xy * (_UVTileDissolveUV == 3));
					
					float isDiscardedFromDissolve = 0;
					float4 xMaskDissolve = float4(  (dissolveUdim.x >= 0 && dissolveUdim.x < 1),
					(dissolveUdim.x >= 1 && dissolveUdim.x < 2),
					(dissolveUdim.x >= 2 && dissolveUdim.x < 3),
					(dissolveUdim.x >= 3 && dissolveUdim.x < 4));
					
					isDiscardedFromDissolve += (dissolveUdim.y >= 0 && dissolveUdim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 1 && dissolveUdim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 2 && dissolveUdim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 3 && dissolveUdim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMaskDissolve);
					
					isDiscardedFromDissolve *= any(float4(dissolveUdim.y >= 0, dissolveUdim.y < 4, dissolveUdim.x >= 0, dissolveUdim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 1, but not exactly 1
					const float threshold = 0.999;
					if(isDiscardedFromDissolve > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				float notVisible = 0;
				
				if (_VisibilityMode == 1) // VRC
				{
					float mirrorMode = VRCMirrorMode();
					float cameraMode = VRCCameraMode();
					
					notVisible += (!_VisibilityVRCRegular 		&& ((mirrorMode == 0) && (cameraMode == 0)));
					notVisible += (!_VisibilityVRCMirrorVR 		&&  (mirrorMode == 1));
					notVisible += (!_VisibilityVRCMirrorDesktop &&  (mirrorMode == 2));
					notVisible += (!_VisibilityVRCCameraVR			&& (cameraMode == 1));
					notVisible += (!_VisibilityVRCCameraDesktop 	&& (cameraMode == 2));
					notVisible += (!_VisibilityVRCCameraScreenshot 	&& (cameraMode == 3));
				}
				else if (_Mirror != 0) // Generic (CVR, etc)
				{
					notVisible += (_Mirror == 1) ^ IsInMirror();
				}
				
				if(notVisible) // Early Return skips rest of vertex shader
				{
					return (VertexOut)POI_NAN;
				}
				#endif
				//endex
				
				o.objectPos = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
				o.objNormal = v.normal;
				o.normal = UnityObjectToWorldNormal(v.normal);
				o.tangent = UnityObjectToWorldDir(v.tangent);
				
				o.binormal = cross(o.normal, o.tangent) * (v.tangent.w * unity_WorldTransformParams.w);
				o.vertexColor = v.color;
				
				o.uv[0] = v.uv0;
				o.uv[1] = v.uv1;
				o.uv[2] = v.uv2;
				o.uv[3] = v.uv3;
				
				#if defined(LIGHTMAP_ON)
				o.lightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
				#endif
				#ifdef DYNAMICLIGHTMAP_ON
				o.lightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
				#endif
				
				o.localPos = v.vertex;
				o.worldPos = mul(unity_ObjectToWorld, o.localPos);
				
				float3 localOffset = float3(0, 0, 0);
				float3 worldOffset = float3(0, 0, 0);
				
				//ifex _VertexGlitchingEnabled==0
				#if defined(POI_VERTEX_GLITCHING)
				
				bool canGlitch = true;
				if (_VertexGlitchMirrorEnable && _VertexGlitchMirror > 0)
				{
					bool inMirror = IsInMirror();
					if (_VertexGlitchMirror == 1 && !inMirror)	canGlitch = false;
					if (_VertexGlitchMirror == 2 && inMirror)	canGlitch = false;
				}
				if (canGlitch)
				{
					float3 forward = getCameraPosition() - mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
					forward.y = 0;
					forward = normalize(forward);
					float3 glitchDirection = normalize(cross(float3(0, 1, 0), forward));
					
					float glitchAmount = 0;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE)
					// if(_VertexGlitchingUseTexture)
					// {
					float uvl = o.worldPos.y * _VertexGlitchDensity + _Time.x * _VertexGlitchMapPanSpeed;
					float uvr = o.worldPos.y * _VertexGlitchDensity - _Time.x * _VertexGlitchMapPanSpeed;
					
					float3 glitchTextureL = 1;
					float3 glitchTextureR = 1;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE) || !defined(OPTIMIZER_ENABLED)
					glitchTextureL = tex2Dlod(_VertexGlitchMap, float4(uvl, uvl, 0, 0)).rgb;
					glitchTextureR = tex2Dlod(_VertexGlitchMap, float4(uvr, uvr, 0, 0)).rgb;
					#endif
					
					glitchAmount += (glitchTextureL.r - 0.5) * 2;
					glitchAmount += - (glitchTextureR.r - 0.5) * 2;
					
					glitchAmount += (glitchTextureL.g - 0.5) * 2;
					glitchAmount += - (glitchTextureR.b - 0.5) * 2;
					// } else {
					#else
					glitchAmount += frac(sin(dot(_Time.xy + o.worldPos.y, float2(12.9898, 78.233))) * 43758.5453123) * 2 - 1;
					// }
					#endif
					
					float time = _Time.y * _VertexGlitchFrequency;
					
					float randomGlitch = (sin(time) + sin(2.2 * time + 5.52) + sin(2.9 * time + 0.93) + sin(4.6 * time + 8.94)) / 4;
					float3 glitchOffset = 0;
					
					#ifdef POI_AUDIOLINK
					if (AudioLinkIsAvailable() && _VertexGlitchingAudioLinkEnabled)
					{
						// float4 audioLinkData = AudioLinkData(ALPASS_AUDIOBASS);
						
						float audioIntensity =
						AudioLinkData(ALPASS_AUDIOBASS).r 		* (_VertexGlitchingAudioLinkBand == 0) +
						AudioLinkData(ALPASS_AUDIOLOWMIDS).r 	* (_VertexGlitchingAudioLinkBand == 1) +
						AudioLinkData(ALPASS_AUDIOHIGHMIDS).r	* (_VertexGlitchingAudioLinkBand == 2) +
						AudioLinkData(ALPASS_AUDIOTREBLE).r 	* (_VertexGlitchingAudioLinkBand == 3) +
						AudioLinkData(ALPASS_FILTEREDVU_INTENSITY).r * (_VertexGlitchingAudioLinkBand == 4);
						
						if(_VertexGlitchingAudiolinkOverride)
						{
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
							// glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						} else {
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
							glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						}
					} else {
						glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					}
					#else
					glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					#endif
					
					localOffset += glitchOffset;
					worldOffset += mul(unity_ObjectToWorld, glitchOffset);
				}
				#endif
				//endex
				
				o.localPos.rgb += localOffset;
				o.worldPos.rgb += worldOffset;
				
				//ifex _EnableDepthBulge==0
				#if defined(POI_DEPTHBULGE) && (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				applyDepthBulgeFX(o);
				#endif
				//endex
				
				o.pos = UnityObjectToClipPos(o.localPos);
				
				#ifdef POI_PASS_OUTLINE
				#if defined(UNITY_REVERSED_Z)
				//DX
				o.pos.z += _Offset_Z * - 0.01;
				#else
				//OpenGL
				o.pos.z += _Offset_Z * 0.01;
				#endif
				#endif
				o.grabPos = ComputeGrabScreenPos(o.pos);
				
				#ifndef FORWARD_META_PASS
				#if !defined(UNITY_PASS_SHADOWCASTER)
				UNITY_TRANSFER_SHADOW(o, o.uv[0].xy);
				#else
				v.vertex.xyz = o.localPos.xyz;
				TRANSFER_SHADOW_CASTER_NOPOS(o, o.pos);
				#endif
				#endif
				
				UNITY_TRANSFER_FOG(o, o.pos);
				
				if (_RenderingReduceClipDistance)
				{
					if (o.pos.w < _ProjectionParams.y * 1.01 && o.pos.w > 0)
					{
						o.pos.z = o.pos.z * 0.0001 + o.pos.w * 0.999;
					}
				}
				
				#ifdef POI_PASS_META
				o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
				#endif
				
				#if defined(GRAIN)
				float4 worldDirection;
				
				worldDirection.xyz = o.worldPos.xyz - _WorldSpaceCameraPos;
				worldDirection.w = dot(o.pos, CalculateFrustumCorrection());
				o.worldDirection = worldDirection;
				#endif
				return o;
			}
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, uv) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan)) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			#if defined(_STOCHASTICMODE_HEXTILE)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, uv, false) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false, dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			#ifndef POI2D_SAMPLER_STOCHASTIC
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (POI2D_SAMPLER(tex, texSampler, uv))
			#endif
			#ifndef POI2D_SAMPLER_PAN_STOCHASTIC
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#endif
			#ifndef POI2D_SAMPLER_PANGRAD_STOCHASTIC
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_SAMPLER_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_SAMPLER_PAN_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// #define POI2D_MAINTEX_SAMPLER_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_MAINTEX_SAMPLER_PAN_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// Deliot, Heitz 2019 - Fast, but non-histogram-preserving (ends up looking a bit blurry and lower contrast)
			// https://eheitzresearch.wordpress.com/738-2/
			
			// Classic Magic Numbers fracsin
			#if !defined(_STOCHASTICMODE_NONE)
			float2 StochasticHash2D2D (float2 s)
			{
				return frac(sin(glsl_mod(float2(dot(s, float2(127.1,311.7)), dot(s, float2(269.5,183.3))), 3.14159)) * 43758.5453);
			}
			#endif
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			// UV Offsets and blend weights
			// UVBW[0...2].xy = UV Offsets
			// UVBW[0...2].z = Blend Weights
			float3x3 DeliotHeitzStochasticUVBW(float2 uv)
			{
				// UV transformed into triangular grid space with UV scaled by approximation of 2*sqrt(3)
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewUV = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticDeliotHeitzDensity);
				
				// Vertex IDs and barycentric coords
				float2 vxID = floor(skewUV);
				float3 bary = float3(frac(skewUV), 0);
				bary.z = 1.0 - bary.x - bary.y;
				
				float3x3 pos = float3x3(
				float3(vxID, 				bary.z),
				float3(vxID + float2(0, 1), bary.y),
				float3(vxID + float2(1, 0), bary.x)
				);
				
				float3x3 neg = float3x3(
				float3(vxID + float2(1, 1), 	 -bary.z),
				float3(vxID + float2(1, 0), 1.0 - bary.y),
				float3(vxID + float2(0, 1), 1.0 - bary.x)
				);
				
				return (bary.z > 0) ? pos : neg;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, float2 dx, float2 dy)
			{
				// UVBW[0...2].xy = UV Offsets
				// UVBW[0...2].z = Blend Weights
				float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
				
				//blend samples with calculated weights
				return 	mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv)
			{
				float2 dx = ddx(uv), dy = ddy(uv);
				return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
			}
			#endif // defined(_STOCHASTICMODE_DELIOT_HEITZ)
			
			#if defined(_STOCHASTICMODE_HEXTILE)
			// HexTiling: Slower, but histogram-preserving
			// SPDX-License-Idenfitier: MIT
			// Copyright (c) 2022 mmikk
			// https://github.com/mmikk/hextile-demo
			float2 HextileMakeCenUV(float2 vertex)
			{
				// 0.288675 ~= 1/(2*sqrt(3))
				const float2x2 stochasticInverseSkewedGrid = float2x2(1.0, 0.5, 0.0, 1.0/1.15470054);
				return mul(stochasticInverseSkewedGrid, vertex) * 0.288675;
			}
			
			float2x2 HextileLoadRot2x2(float2 idx, float rotStrength)
			{
				float angle = abs(idx.x * idx.y) + abs(idx.x + idx.y) + PI;
				
				// remap to +/-pi
				angle = glsl_mod(angle, 2 * PI);
				if(angle < 0)  angle += 2 * PI;
				if(angle > PI) angle -= 2 * PI;
				
				angle *= rotStrength;
				
				float cs = cos(angle), si = sin(angle);
				return float2x2(cs, -si, si, cs);
			}
			
			// UV Offsets and base blend weights
			// UVBWR[0...2].xy = UV Offsets
			// UVBWR[0...2].zw = rotation costh/sinth -> reconstruct rotation matrix with float2x2(UVBWR[n].z, -UVBWR[n].w, UVBWR[n].w, UVBWR[n].z)
			// UVBWR[3].xyz = Blend Weights (w unused) - needs luminance weighting
			float4x4 HextileUVBWR(float2 uv)
			{
				// Create Triangle Grid
				// Skew input space into simplex triangle grid (3.4641 ~= 2*sqrt(3))
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewedCoord = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticHexGridDensity);
				
				float2 baseId = float2(floor(skewedCoord));
				float3 temp = float3(frac(skewedCoord), 0);
				temp.z = 1 - temp.x - temp.y;
				
				float s = step(0.0, -temp.z);
				float s2 = 2 * s - 1;
				
				float3 weights = float3(-temp.z * s2, s - temp.y * s2, s - temp.x * s2);
				
				float2 vertex0 = baseId + float2(s, s);
				float2 vertex1 = baseId + float2(s, 1 - s);
				float2 vertex2 = baseId + float2(1 - s, s);
				
				float2 cen0 = HextileMakeCenUV(vertex0), cen1 = HextileMakeCenUV(vertex1), cen2 = HextileMakeCenUV(vertex2);
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = HextileLoadRot2x2(vertex0, _StochasticHexRotationStrength);
					rot1 = HextileLoadRot2x2(vertex1, _StochasticHexRotationStrength);
					rot2 = HextileLoadRot2x2(vertex2, _StochasticHexRotationStrength);
				}
				
				return float4x4(
				float4(mul(uv - cen0, rot0) + cen0 + StochasticHash2D2D(vertex0), rot0[0].x, -rot0[0].y),
				float4(mul(uv - cen1, rot1) + cen1 + StochasticHash2D2D(vertex1), rot1[0].x, -rot1[0].y),
				float4(mul(uv - cen2, rot2) + cen2 + StochasticHash2D2D(vertex2), rot2[0].x, -rot2[0].y),
				float4(weights, 0)
				);
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap, float2 dUVdx, float2 dUVdy)
			{
				// For some reason doing this instead of just calculating it directly prevents it from \
				// breaking after a certain number of textures use it. I don't understand why yet
				float4x4 UVBWR = HextileUVBWR(uv);
				
				// 2D Rotation Matrices for dUVdx/dy
				// Not sure if this constant folds during compiling when rot is locked at 0, so force it
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = float2x2(UVBWR[0].z, -UVBWR[0].w, UVBWR[0].w, UVBWR[0].z);
					rot1 = float2x2(UVBWR[1].z, -UVBWR[1].w, UVBWR[1].w, UVBWR[1].z);
					rot2 = float2x2(UVBWR[2].z, -UVBWR[2].w, UVBWR[2].w, UVBWR[2].z);
				}
				
				// Weights
				float3 W = UVBWR[3].xyz;
				
				// Sample texture
				// float3x4 c = float3x4(
				// 	tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0)),
				// 	tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1)),
				// 	tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2))
				// );
				
				float4 c0 = tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0));
				float4 c1 = tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1));
				float4 c2 = tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2));
				
				// Blend samples using luminance
				// This is technically incorrect for normal maps, but produces very similar
				// results to blending using normal map gradients (steepness)
				const float3 Lw = float3(0.299, 0.587, 0.114);
				float3 Dw = float3(dot(c0.xyz, Lw), dot(c1.xyz, Lw), dot(c2.xyz, Lw));
				
				Dw = lerp(1.0, Dw, _StochasticHexFallOffContrast);
				W = Dw * pow(W, _StochasticHexFallOffPower);
				// In the original hextiling there's a Gain3 step here, but it seems to slow things down \
				// and cause the UVs to break, so I've omitted it. Looks fine without
				
				W /= (W.x + W.y + W.z);
				return W.x * c0 + W.y * c1 + W.z * c2;
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap)
			{
				return HextileSampleTexture(tex, texSampler, uv, isNormalMap, ddx(uv), ddy(uv));
			}
			#endif // defined(_STOCHASTICMODE_HEXTILE)
			
			void applyAlphaOptions(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiMods poiMods)
			{
				poiFragData.alpha = saturate(poiFragData.alpha + _AlphaMod);
				
				if (_AlphaGlobalMask > 0)
				{
					poiFragData.alpha = maskBlend(poiFragData.alpha, poiMods.globalMask[_AlphaGlobalMask-1], _AlphaGlobalMaskBlendType);
				}
				
				//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
				if (_AlphaDistanceFade)
				{
					float3 position = _AlphaDistanceFadeType ? poiMesh.worldPos : poiMesh.objectPosition;
					float distanceFadeMultiplier = lerp(_AlphaDistanceFadeMinAlpha, _AlphaDistanceFadeMaxAlpha, smoothstep(_AlphaDistanceFadeMin, _AlphaDistanceFadeMax, distance(position, poiCam.worldPos)));
					if(_AlphaDistanceFadeGlobalMask > 0)
					{
						distanceFadeMultiplier = lerp(1, distanceFadeMultiplier, poiMods.globalMask[_AlphaDistanceFadeGlobalMask-1]);
					}
					poiFragData.alpha *= distanceFadeMultiplier;
				}
				//endex
				
				//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
				if (_AlphaFresnel)
				{
					float holoRim = saturate(1 - smoothstep(min(_AlphaFresnelSharpness, _AlphaFresnelWidth), _AlphaFresnelWidth, (poiCam.vDotN)));
					holoRim = abs(lerp(1, holoRim, _AlphaFresnelAlpha));
					holoRim = _AlphaFresnelInvert ? 1 - holoRim : holoRim;
					if(_AlphaFresnelGlobalMask > 0)
					{
						holoRim = lerp(1, holoRim, poiMods.globalMask[_AlphaFresnelGlobalMask-1]);
					}
					poiFragData.alpha *= holoRim;
				}
				//endex
				
				//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
				if (_AlphaAngular)
				{
					half cameraAngleMin = _CameraAngleMin / 180;
					half cameraAngleMax = _CameraAngleMax / 180;
					half modelAngleMin = _ModelAngleMin / 180;
					half modelAngleMax = _ModelAngleMax / 180;
					float3 pos = _AngleCompareTo == 0 ? poiMesh.objectPosition : poiMesh.worldPos;
					half3 cameraToModelDirection = normalize(pos - getCameraPosition());
					half3 modelForwardDirection = normalize(mul(unity_ObjectToWorld, normalize(_AngleForwardDirection.rgb)));
					half cameraLookAtModel = remapClamped(cameraAngleMax, cameraAngleMin, .5 * dot(cameraToModelDirection, getCameraForward()) + .5);
					half modelLookAtCamera = remapClamped(modelAngleMax, modelAngleMin, .5 * dot(-cameraToModelDirection, modelForwardDirection) + .5);
					float angularAlphaMod = 1;
					if (_AngleType == 0)
					{
						angularAlphaMod = max(cameraLookAtModel, _AngleMinAlpha);
					}
					else if (_AngleType == 1)
					{
						angularAlphaMod = max(modelLookAtCamera, _AngleMinAlpha);
					}
					else if (_AngleType == 2)
					{
						angularAlphaMod = max(cameraLookAtModel * modelLookAtCamera, _AngleMinAlpha);
					}
					if(_AlphaAngularGlobalMask > 0)
					{
						angularAlphaMod = lerp(1, angularAlphaMod, poiMods.globalMask[_AlphaAngularGlobalMask-1]);
					}
					poiFragData.alpha *= angularAlphaMod;
				}
				//endex
				
				//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && _AlphaAudioLinkEnabled)
				{
					poiFragData.alpha = saturate(poiFragData.alpha + lerp(_AlphaAudioLinkAddRange.x, _AlphaAudioLinkAddRange.y, poiMods.audioLink[_AlphaAudioLinkAddBand]));
				}
				#endif
				//endex
				
			}
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			inline half Dither8x8Bayer(int x, int y)
			{
				// Premultiplied by 1/64
				const half dither[ 64 ] = {
					0.015625, 0.765625, 0.203125, 0.953125, 0.06250, 0.81250, 0.25000, 1.00000,
					0.515625, 0.265625, 0.703125, 0.453125, 0.56250, 0.31250, 0.75000, 0.50000,
					0.140625, 0.890625, 0.078125, 0.828125, 0.18750, 0.93750, 0.12500, 0.87500,
					0.640625, 0.390625, 0.578125, 0.328125, 0.68750, 0.43750, 0.62500, 0.37500,
					0.046875, 0.796875, 0.234375, 0.984375, 0.03125, 0.78125, 0.21875, 0.96875,
					0.546875, 0.296875, 0.734375, 0.484375, 0.53125, 0.28125, 0.71875, 0.46875,
					0.171875, 0.921875, 0.109375, 0.859375, 0.15625, 0.90625, 0.09375, 0.84375,
					0.671875, 0.421875, 0.609375, 0.359375, 0.65625, 0.40625, 0.59375, 0.34375
				};
				int r = y * 8 + x;
				return dither[r];
			}
			
			half calcDither(half2 grabPos)
			{
				return Dither8x8Bayer(glsl_mod(grabPos.x, 8), glsl_mod(grabPos.y, 8));
			}
			
			void applyDithering(inout PoiFragData poiFragData, in PoiCam poiCam)
			{
				if (_AlphaDithering)
				{
					float dither = calcDither(poiCam.screenUV.xy) - _AlphaDitherBias;
					poiFragData.alpha = saturate(poiFragData.alpha - (dither * (1 - poiFragData.alpha) * _AlphaDitherGradient));
				}
			}
			//endex
			
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			void ApplyAlphaToCoverage(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				// Force Model Opacity to 1 if desired
				UNITY_BRANCH
				if (_Mode == 1)
				{
					UNITY_BRANCH
					if (_AlphaSharpenedA2C && _AlphaToCoverage)
					{
						// rescale alpha by mip level
						poiFragData.alpha *= 1 + max(0, CalcMipLevel(poiMesh.uv[0] * _MainTex_TexelSize.zw)) * _AlphaMipScale;
						// rescale alpha by partial derivative
						poiFragData.alpha = (poiFragData.alpha - _Cutoff) / max(fwidth(poiFragData.alpha), 0.0001) + _Cutoff;
						poiFragData.alpha = saturate(poiFragData.alpha);
					}
				}
			}
			//endex
			
			void calculateGlobalThemes(inout PoiMods poiMods)
			{
				// Theme colors are defined as HDR; convert to SDR and do the HSV adjustment, then re-apply exposure
				float4 themeColorExposures = 0;
				float4 themeColor0, themeColor1, themeColor2, themeColor3 = 0;
				
				DecomposeHDRColor(_GlobalThemeColor0.rgb, themeColor0.rgb, themeColorExposures.x);
				DecomposeHDRColor(_GlobalThemeColor1.rgb, themeColor1.rgb, themeColorExposures.y);
				DecomposeHDRColor(_GlobalThemeColor2.rgb, themeColor2.rgb, themeColorExposures.z);
				DecomposeHDRColor(_GlobalThemeColor3.rgb, themeColor3.rgb, themeColorExposures.w);
				
				poiMods.globalColorTheme[0] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor0.rgb, frac(_GlobalThemeHue0 + _GlobalThemeHueSpeed0 * _Time.x), _GlobalThemeSaturation0, _GlobalThemeValue0), themeColorExposures.x), _GlobalThemeColor0.a);
				poiMods.globalColorTheme[1] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor1.rgb, frac(_GlobalThemeHue1 + _GlobalThemeHueSpeed1 * _Time.x), _GlobalThemeSaturation1, _GlobalThemeValue1), themeColorExposures.y), _GlobalThemeColor1.a);
				poiMods.globalColorTheme[2] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor2.rgb, frac(_GlobalThemeHue2 + _GlobalThemeHueSpeed2 * _Time.x), _GlobalThemeSaturation2, _GlobalThemeValue2), themeColorExposures.z), _GlobalThemeColor2.a);
				poiMods.globalColorTheme[3] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor3.rgb, frac(_GlobalThemeHue3 + _GlobalThemeHueSpeed3 * _Time.x), _GlobalThemeSaturation3, _GlobalThemeValue3), themeColorExposures.w), _GlobalThemeColor3.a);
			}
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			void ApplyGlobalMaskTextures(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol0 = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0_ST), _GlobalMaskTexture0Pan);
				if (_GlobalMaskTexture0Split)
				{
					poiMods.globalMask[0] = gmcol0.r;
					poiMods.globalMask[1] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_G), _GlobalMaskTexture0SplitPan_G).g;
					poiMods.globalMask[2] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_B), _GlobalMaskTexture0SplitPan_B).b;
					poiMods.globalMask[3] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_A), _GlobalMaskTexture0SplitPan_A).a;
				} else {
					poiMods.globalMask[0] = gmcol0[0];
					poiMods.globalMask[1] = gmcol0[1];
					poiMods.globalMask[2] = gmcol0[2];
					poiMods.globalMask[3] = gmcol0[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol1 = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1_ST), _GlobalMaskTexture1Pan);
				if (_GlobalMaskTexture1Split)
				{
					poiMods.globalMask[4] = gmcol1.r;
					poiMods.globalMask[5] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_G), _GlobalMaskTexture1SplitPan_G).g;
					poiMods.globalMask[6] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_B), _GlobalMaskTexture1SplitPan_B).b;
					poiMods.globalMask[7] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_A), _GlobalMaskTexture1SplitPan_A).a;
				} else {
					poiMods.globalMask[4] = gmcol1[0];
					poiMods.globalMask[5] = gmcol1[1];
					poiMods.globalMask[6] = gmcol1[2];
					poiMods.globalMask[7] = gmcol1[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol2 = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2_ST), _GlobalMaskTexture2Pan);
				if (_GlobalMaskTexture2Split)
				{
					poiMods.globalMask[8] = gmcol2.r;
					poiMods.globalMask[9] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_G), _GlobalMaskTexture2SplitPan_G).g;
					poiMods.globalMask[10] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_B), _GlobalMaskTexture2SplitPan_B).b;
					poiMods.globalMask[11] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_A), _GlobalMaskTexture2SplitPan_A).a;
				} else {
					poiMods.globalMask[8] = gmcol2[0];
					poiMods.globalMask[9] = gmcol2[1];
					poiMods.globalMask[10] = gmcol2[2];
					poiMods.globalMask[11] = gmcol2[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol3 = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3_ST), _GlobalMaskTexture3Pan);
				if (_GlobalMaskTexture3Split)
				{
					poiMods.globalMask[12] = gmcol3.r;
					poiMods.globalMask[13] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_G), _GlobalMaskTexture3SplitPan_G).g;
					poiMods.globalMask[14] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_B), _GlobalMaskTexture3SplitPan_B).b;
					poiMods.globalMask[15] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_A), _GlobalMaskTexture3SplitPan_A).a;
				} else {
					poiMods.globalMask[12] = gmcol3[0];
					poiMods.globalMask[13] = gmcol3[1];
					poiMods.globalMask[14] = gmcol3[2];
					poiMods.globalMask[15] = gmcol3[3];
				}
				#endif
			}
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			void ApplyGlobalMaskOptions(inout PoiMods poiMods)
			{
				//ifex _GlobalMaskOptionsType!=0
				if (_GlobalMaskOptionsType == 0)
				{
					poiMods.globalMask[0]  = saturate(poiMods.globalMask[0]  + _GlobalMaskSlider_0);
					poiMods.globalMask[1]  = saturate(poiMods.globalMask[1]  + _GlobalMaskSlider_1);
					poiMods.globalMask[2]  = saturate(poiMods.globalMask[2]  + _GlobalMaskSlider_2);
					poiMods.globalMask[3]  = saturate(poiMods.globalMask[3]  + _GlobalMaskSlider_3);
					poiMods.globalMask[4]  = saturate(poiMods.globalMask[4]  + _GlobalMaskSlider_4);
					poiMods.globalMask[5]  = saturate(poiMods.globalMask[5]  + _GlobalMaskSlider_5);
					poiMods.globalMask[6]  = saturate(poiMods.globalMask[6]  + _GlobalMaskSlider_6);
					poiMods.globalMask[7]  = saturate(poiMods.globalMask[7]  + _GlobalMaskSlider_7);
					poiMods.globalMask[8]  = saturate(poiMods.globalMask[8]  + _GlobalMaskSlider_8);
					poiMods.globalMask[9]  = saturate(poiMods.globalMask[9]  + _GlobalMaskSlider_9);
					poiMods.globalMask[10] = saturate(poiMods.globalMask[10] + _GlobalMaskSlider_10);
					poiMods.globalMask[11] = saturate(poiMods.globalMask[11] + _GlobalMaskSlider_11);
					poiMods.globalMask[12] = saturate(poiMods.globalMask[12] + _GlobalMaskSlider_12);
					poiMods.globalMask[13] = saturate(poiMods.globalMask[13] + _GlobalMaskSlider_13);
					poiMods.globalMask[14] = saturate(poiMods.globalMask[14] + _GlobalMaskSlider_14);
					poiMods.globalMask[15] = saturate(poiMods.globalMask[15] + _GlobalMaskSlider_15);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=1
				if (_GlobalMaskOptionsType == 1)
				{
					poiMods.globalMask[0]  = lerp(_GlobalMaskMinMaxSlider_0.x,  _GlobalMaskMinMaxSlider_0.y,  poiMods.globalMask[0]);
					poiMods.globalMask[1]  = lerp(_GlobalMaskMinMaxSlider_1.x,  _GlobalMaskMinMaxSlider_1.y,  poiMods.globalMask[1]);
					poiMods.globalMask[2]  = lerp(_GlobalMaskMinMaxSlider_2.x,  _GlobalMaskMinMaxSlider_2.y,  poiMods.globalMask[2]);
					poiMods.globalMask[3]  = lerp(_GlobalMaskMinMaxSlider_3.x,  _GlobalMaskMinMaxSlider_3.y,  poiMods.globalMask[3]);
					poiMods.globalMask[4]  = lerp(_GlobalMaskMinMaxSlider_4.x,  _GlobalMaskMinMaxSlider_4.y,  poiMods.globalMask[4]);
					poiMods.globalMask[5]  = lerp(_GlobalMaskMinMaxSlider_5.x,  _GlobalMaskMinMaxSlider_5.y,  poiMods.globalMask[5]);
					poiMods.globalMask[6]  = lerp(_GlobalMaskMinMaxSlider_6.x,  _GlobalMaskMinMaxSlider_6.y,  poiMods.globalMask[6]);
					poiMods.globalMask[7]  = lerp(_GlobalMaskMinMaxSlider_7.x,  _GlobalMaskMinMaxSlider_7.y,  poiMods.globalMask[7]);
					poiMods.globalMask[8]  = lerp(_GlobalMaskMinMaxSlider_8.x,  _GlobalMaskMinMaxSlider_8.y,  poiMods.globalMask[8]);
					poiMods.globalMask[9]  = lerp(_GlobalMaskMinMaxSlider_9.x,  _GlobalMaskMinMaxSlider_9.y,  poiMods.globalMask[9]);
					poiMods.globalMask[10] = lerp(_GlobalMaskMinMaxSlider_10.x, _GlobalMaskMinMaxSlider_10.y, poiMods.globalMask[10]);
					poiMods.globalMask[11] = lerp(_GlobalMaskMinMaxSlider_11.x, _GlobalMaskMinMaxSlider_11.y, poiMods.globalMask[11]);
					poiMods.globalMask[12] = lerp(_GlobalMaskMinMaxSlider_12.x, _GlobalMaskMinMaxSlider_12.y, poiMods.globalMask[12]);
					poiMods.globalMask[13] = lerp(_GlobalMaskMinMaxSlider_13.x, _GlobalMaskMinMaxSlider_13.y, poiMods.globalMask[13]);
					poiMods.globalMask[14] = lerp(_GlobalMaskMinMaxSlider_14.x, _GlobalMaskMinMaxSlider_14.y, poiMods.globalMask[14]);
					poiMods.globalMask[15] = lerp(_GlobalMaskMinMaxSlider_15.x, _GlobalMaskMinMaxSlider_15.y, poiMods.globalMask[15]);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=2
				if (_GlobalMaskOptionsType == 2)
				{
					if (_GlobalMaskToggleOn_0)  poiMods.globalMask[0]  = 1;
					if (_GlobalMaskToggleOn_1)  poiMods.globalMask[1]  = 1;
					if (_GlobalMaskToggleOn_2)  poiMods.globalMask[2]  = 1;
					if (_GlobalMaskToggleOn_3)  poiMods.globalMask[3]  = 1;
					if (_GlobalMaskToggleOn_4)  poiMods.globalMask[4]  = 1;
					if (_GlobalMaskToggleOn_5)  poiMods.globalMask[5]  = 1;
					if (_GlobalMaskToggleOn_6)  poiMods.globalMask[6]  = 1;
					if (_GlobalMaskToggleOn_7)  poiMods.globalMask[7]  = 1;
					if (_GlobalMaskToggleOn_8)  poiMods.globalMask[8]  = 1;
					if (_GlobalMaskToggleOn_9)  poiMods.globalMask[9]  = 1;
					if (_GlobalMaskToggleOn_10) poiMods.globalMask[10] = 1;
					if (_GlobalMaskToggleOn_11) poiMods.globalMask[11] = 1;
					if (_GlobalMaskToggleOn_12) poiMods.globalMask[12] = 1;
					if (_GlobalMaskToggleOn_13) poiMods.globalMask[13] = 1;
					if (_GlobalMaskToggleOn_14) poiMods.globalMask[14] = 1;
					if (_GlobalMaskToggleOn_15) poiMods.globalMask[15] = 1;
					
					poiMods.globalMask[0]  *= (1-_GlobalMaskToggleOff_0);
					poiMods.globalMask[1]  *= (1-_GlobalMaskToggleOff_1);
					poiMods.globalMask[2]  *= (1-_GlobalMaskToggleOff_2);
					poiMods.globalMask[3]  *= (1-_GlobalMaskToggleOff_3);
					poiMods.globalMask[4]  *= (1-_GlobalMaskToggleOff_4);
					poiMods.globalMask[5]  *= (1-_GlobalMaskToggleOff_5);
					poiMods.globalMask[6]  *= (1-_GlobalMaskToggleOff_6);
					poiMods.globalMask[7]  *= (1-_GlobalMaskToggleOff_7);
					poiMods.globalMask[8]  *= (1-_GlobalMaskToggleOff_8);
					poiMods.globalMask[9]  *= (1-_GlobalMaskToggleOff_9);
					poiMods.globalMask[10] *= (1-_GlobalMaskToggleOff_10);
					poiMods.globalMask[11] *= (1-_GlobalMaskToggleOff_11);
					poiMods.globalMask[12] *= (1-_GlobalMaskToggleOff_12);
					poiMods.globalMask[13] *= (1-_GlobalMaskToggleOff_13);
					poiMods.globalMask[14] *= (1-_GlobalMaskToggleOff_14);
					poiMods.globalMask[15] *= (1-_GlobalMaskToggleOff_15);
				}
				//endex
			}
			//endex
			
			float customDistanceBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					default: return 0; break;
				}
			}
			
			void ApplyGlobalMaskModifiers(in PoiMesh poiMesh, inout PoiMods poiMods, in PoiCam poiCam)
			{
				//ifex _GlobalMaskModifiersBackfaceEnable==0
				if(_GlobalMaskModifiersBackfaceEnable)
				{
					float facingMode = saturate(poiMesh.isFrontFace) + 1;
					// _GlobalMaskBackface is 0 for ignore, 1 for back only, 2 for front only
					poiMods.globalMask[0]  *= _GlobalMaskBackface_0  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskBackface_1  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskBackface_2  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskBackface_3  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskBackface_4  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskBackface_5  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskBackface_6  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskBackface_7  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskBackface_8  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskBackface_9  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_9 ));
					poiMods.globalMask[10] *= _GlobalMaskBackface_10 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_10));
					poiMods.globalMask[11] *= _GlobalMaskBackface_11 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_11));
					poiMods.globalMask[12] *= _GlobalMaskBackface_12 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_12));
					poiMods.globalMask[13] *= _GlobalMaskBackface_13 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_13));
					poiMods.globalMask[14] *= _GlobalMaskBackface_14 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_14));
					poiMods.globalMask[15] *= _GlobalMaskBackface_15 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersMirrorEnable==0
				if(_GlobalMaskModifiersMirrorEnable)
				{
					float mirrorMode = 0;
					if (_GlobalMaskMirrorVisibilityMode == 1) // VRC
					mirrorMode = VRCMirrorMode() > 0;
					else // Generic (CVR, etc)
					mirrorMode = IsInMirror();
					
					mirrorMode += 1;
					// _GlobalMaskMirror is 0 for ignore, 1 for outside mirror only, 2 for in mirror only
					poiMods.globalMask[0]  *= _GlobalMaskMirror_0  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskMirror_1  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskMirror_2  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskMirror_3  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskMirror_4  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskMirror_5  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskMirror_6  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskMirror_7  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskMirror_8  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskMirror_9  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_9 ));
					poiMods.globalMask[10] *= _GlobalMaskMirror_10 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_10));
					poiMods.globalMask[11] *= _GlobalMaskMirror_11 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_11));
					poiMods.globalMask[12] *= _GlobalMaskMirror_12 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_12));
					poiMods.globalMask[13] *= _GlobalMaskMirror_13 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_13));
					poiMods.globalMask[14] *= _GlobalMaskMirror_14 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_14));
					poiMods.globalMask[15] *= _GlobalMaskMirror_15 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersCameraEnable==0
				if(_GlobalMaskModifiersCameraEnable)
				{
					float isCamera = VRCCameraMode() > 0;
					isCamera += 1;
					// _GlobalMaskCamera is 0 for ignore, 1 for outside camera only, 2 for in camera only
					poiMods.globalMask[0]  *= _GlobalMaskCamera_0  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskCamera_1  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskCamera_2  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskCamera_3  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskCamera_4  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskCamera_5  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskCamera_6  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskCamera_7  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskCamera_8  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskCamera_9  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_9 ));
					poiMods.globalMask[10] *= _GlobalMaskCamera_10 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_10));
					poiMods.globalMask[11] *= _GlobalMaskCamera_11 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_11));
					poiMods.globalMask[12] *= _GlobalMaskCamera_12 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_12));
					poiMods.globalMask[13] *= _GlobalMaskCamera_13 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_13));
					poiMods.globalMask[14] *= _GlobalMaskCamera_14 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_14));
					poiMods.globalMask[15] *= _GlobalMaskCamera_15 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_15));
				}
				//endex
				//ifex _GlobalMaskModifiersDistanceEnable==0
				if (_GlobalMaskModifiersDistanceEnable)
				{
					//ifex _GlobalMaskDistanceEnable_0==0
					if (_GlobalMaskDistanceEnable_0)
					{
						float3 position = _GlobalMaskDistanceType_0 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_0, _GlobalMaskDistanceMaxAlpha_0, smoothstep(_GlobalMaskDistanceMin_0, _GlobalMaskDistanceMax_0, distance(position, poiCam.worldPos)));
						poiMods.globalMask[0] = saturate(customDistanceBlend(poiMods.globalMask[0], val, _GlobalMaskDistanceBlendType_0));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_1==0
					if (_GlobalMaskDistanceEnable_1)
					{
						float3 position = _GlobalMaskDistanceType_1 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_1, _GlobalMaskDistanceMaxAlpha_1, smoothstep(_GlobalMaskDistanceMin_1, _GlobalMaskDistanceMax_1, distance(position, poiCam.worldPos)));
						poiMods.globalMask[1] = saturate(customDistanceBlend(poiMods.globalMask[1], val, _GlobalMaskDistanceBlendType_1));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_2==0
					if (_GlobalMaskDistanceEnable_2)
					{
						float3 position = _GlobalMaskDistanceType_2 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_2, _GlobalMaskDistanceMaxAlpha_2, smoothstep(_GlobalMaskDistanceMin_2, _GlobalMaskDistanceMax_2, distance(position, poiCam.worldPos)));
						poiMods.globalMask[2] = saturate(customDistanceBlend(poiMods.globalMask[2], val, _GlobalMaskDistanceBlendType_2));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_3==0
					if (_GlobalMaskDistanceEnable_3)
					{
						float3 position = _GlobalMaskDistanceType_3 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_3, _GlobalMaskDistanceMaxAlpha_3, smoothstep(_GlobalMaskDistanceMin_3, _GlobalMaskDistanceMax_3, distance(position, poiCam.worldPos)));
						poiMods.globalMask[3] = saturate(customDistanceBlend(poiMods.globalMask[3], val, _GlobalMaskDistanceBlendType_3));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_4==0
					if (_GlobalMaskDistanceEnable_4)
					{
						float3 position = _GlobalMaskDistanceType_4 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_4, _GlobalMaskDistanceMaxAlpha_4, smoothstep(_GlobalMaskDistanceMin_4, _GlobalMaskDistanceMax_4, distance(position, poiCam.worldPos)));
						poiMods.globalMask[4] = saturate(customDistanceBlend(poiMods.globalMask[4], val, _GlobalMaskDistanceBlendType_4));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_5==0
					if (_GlobalMaskDistanceEnable_5)
					{
						float3 position = _GlobalMaskDistanceType_5 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_5, _GlobalMaskDistanceMaxAlpha_5, smoothstep(_GlobalMaskDistanceMin_5, _GlobalMaskDistanceMax_5, distance(position, poiCam.worldPos)));
						poiMods.globalMask[5] = saturate(customDistanceBlend(poiMods.globalMask[5], val, _GlobalMaskDistanceBlendType_5));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_6==0
					if (_GlobalMaskDistanceEnable_6)
					{
						float3 position = _GlobalMaskDistanceType_6 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_6, _GlobalMaskDistanceMaxAlpha_6, smoothstep(_GlobalMaskDistanceMin_6, _GlobalMaskDistanceMax_6, distance(position, poiCam.worldPos)));
						poiMods.globalMask[6] = saturate(customDistanceBlend(poiMods.globalMask[6], val, _GlobalMaskDistanceBlendType_6));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_7==0
					if (_GlobalMaskDistanceEnable_7)
					{
						float3 position = _GlobalMaskDistanceType_7 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_7, _GlobalMaskDistanceMaxAlpha_7, smoothstep(_GlobalMaskDistanceMin_7, _GlobalMaskDistanceMax_7, distance(position, poiCam.worldPos)));
						poiMods.globalMask[7] = saturate(customDistanceBlend(poiMods.globalMask[7], val, _GlobalMaskDistanceBlendType_7));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_8==0
					if (_GlobalMaskDistanceEnable_8)
					{
						float3 position = _GlobalMaskDistanceType_8 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_8, _GlobalMaskDistanceMaxAlpha_8, smoothstep(_GlobalMaskDistanceMin_8, _GlobalMaskDistanceMax_8, distance(position, poiCam.worldPos)));
						poiMods.globalMask[8] = saturate(customDistanceBlend(poiMods.globalMask[8], val, _GlobalMaskDistanceBlendType_8));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_9==0
					if (_GlobalMaskDistanceEnable_9)
					{
						float3 position = _GlobalMaskDistanceType_9 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_9, _GlobalMaskDistanceMaxAlpha_9, smoothstep(_GlobalMaskDistanceMin_9, _GlobalMaskDistanceMax_9, distance(position, poiCam.worldPos)));
						poiMods.globalMask[9] = saturate(customDistanceBlend(poiMods.globalMask[9], val, _GlobalMaskDistanceBlendType_9));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_10==0
					if (_GlobalMaskDistanceEnable_10)
					{
						float3 position = _GlobalMaskDistanceType_10 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_10, _GlobalMaskDistanceMaxAlpha_10, smoothstep(_GlobalMaskDistanceMin_10, _GlobalMaskDistanceMax_10, distance(position, poiCam.worldPos)));
						poiMods.globalMask[10] = saturate(customDistanceBlend(poiMods.globalMask[10], val, _GlobalMaskDistanceBlendType_10));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_11==0
					if (_GlobalMaskDistanceEnable_11)
					{
						float3 position = _GlobalMaskDistanceType_11 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_11, _GlobalMaskDistanceMaxAlpha_11, smoothstep(_GlobalMaskDistanceMin_11, _GlobalMaskDistanceMax_11, distance(position, poiCam.worldPos)));
						poiMods.globalMask[11] = saturate(customDistanceBlend(poiMods.globalMask[11], val, _GlobalMaskDistanceBlendType_11));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_12==0
					if (_GlobalMaskDistanceEnable_12)
					{
						float3 position = _GlobalMaskDistanceType_12 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_12, _GlobalMaskDistanceMaxAlpha_12, smoothstep(_GlobalMaskDistanceMin_12, _GlobalMaskDistanceMax_12, distance(position, poiCam.worldPos)));
						poiMods.globalMask[12] = saturate(customDistanceBlend(poiMods.globalMask[12], val, _GlobalMaskDistanceBlendType_12));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_13==0
					if (_GlobalMaskDistanceEnable_13)
					{
						float3 position = _GlobalMaskDistanceType_13 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_13, _GlobalMaskDistanceMaxAlpha_13, smoothstep(_GlobalMaskDistanceMin_13, _GlobalMaskDistanceMax_13, distance(position, poiCam.worldPos)));
						poiMods.globalMask[13] = saturate(customDistanceBlend(poiMods.globalMask[13], val, _GlobalMaskDistanceBlendType_13));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_14==0
					if (_GlobalMaskDistanceEnable_14)
					{
						float3 position = _GlobalMaskDistanceType_14 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_14, _GlobalMaskDistanceMaxAlpha_14, smoothstep(_GlobalMaskDistanceMin_14, _GlobalMaskDistanceMax_14, distance(position, poiCam.worldPos)));
						poiMods.globalMask[14] = saturate(customDistanceBlend(poiMods.globalMask[14], val, _GlobalMaskDistanceBlendType_14));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_15==0
					if (_GlobalMaskDistanceEnable_15)
					{
						float3 position = _GlobalMaskDistanceType_15 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_15, _GlobalMaskDistanceMaxAlpha_15, smoothstep(_GlobalMaskDistanceMin_15, _GlobalMaskDistanceMax_15, distance(position, poiCam.worldPos)));
						poiMods.globalMask[15] = saturate(customDistanceBlend(poiMods.globalMask[15], val, _GlobalMaskDistanceBlendType_15));
					}
					//endex
				}
				//endex
			}
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			void applyUDIMDiscard(in VertexOut i)
			{
				if(_UDIMDiscardMode == 1) // Don't run if in vertex mode
				{
					float2 udim = floor(vertexUV(i, _UDIMDiscardUV));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					const float threshold = 0.001;
					clip(threshold - isDiscarded); // Clip if discarded
				}
				
				return;
			}
			#endif
			//endex
			
			float2 calculatePolarCoordinate(in PoiMesh poiMesh)
			{
				float2 delta = poiMesh.uv[_PolarUV] - _PolarCenter;
				float radius = length(delta) * 2 * _PolarRadialScale;
				float angle = atan2(delta.x, delta.y);
				float phi = angle / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				angle = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				angle *= _PolarLengthScale;
				
				return float2(radius, angle + distance(poiMesh.uv[_PolarUV], _PolarCenter) * _PolarSpiralPower);
			}
			
			float2 MonoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(1.0, 1.0 / UNITY_PI);
				sphereCoords = float2(1.0, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).zw;
			}
			
			float2 StereoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(0.5, 1.0 / UNITY_PI);
				sphereCoords = float2(0.5, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).zw;
			}
			
			float2 calculateWorldUV(in PoiMesh poiMesh)
			{
				return float2(_UVModWorldPos0 != 3 ? poiMesh.worldPos[ _UVModWorldPos0] : 0.0f, _UVModWorldPos1 != 3 ? poiMesh.worldPos[_UVModWorldPos1] : 0.0f);
			}
			
			float2 calculatelocalUV(in PoiMesh poiMesh)
			{
				float localUVs[8];
				localUVs[0] = poiMesh.localPos.x;
				localUVs[1] = poiMesh.localPos.y;
				localUVs[2] = poiMesh.localPos.z;
				localUVs[3] = 0;
				localUVs[4] = poiMesh.vertexColor.r;
				localUVs[5] = poiMesh.vertexColor.g;
				localUVs[6] = poiMesh.vertexColor.b;
				localUVs[7] = poiMesh.vertexColor.a;
				
				return float2(localUVs[_UVModLocalPos0],localUVs[_UVModLocalPos1]);
			}
			
			float2 calculatePanosphereUV(in PoiMesh poiMesh)
			{
				float3 viewDirection = normalize(lerp(getCameraPosition().xyz, _WorldSpaceCameraPos.xyz, _PanoUseBothEyes) - poiMesh.worldPos.xyz) * - 1;
				return lerp(MonoPanoProjection(viewDirection), StereoPanoProjection(viewDirection), _StereoEnabled);
			}
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			float2 distortedUV(in PoiMesh poiMesh)
			{
				#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector = POI2D_SAMPLER_PAN(_DistortionFlowTexture, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTextureUV], _DistortionFlowTexture_ST), _DistortionFlowTexturePan) * 2 - 1;
				#else
				float4 flowVector = -1;
				#endif
				
				#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector1 = POI2D_SAMPLER_PAN(_DistortionFlowTexture1, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTexture1UV], _DistortionFlowTexture1_ST), _DistortionFlowTexture1Pan) * 2 - 1;
				#else
				float4 flowVector1 = -1;
				#endif
				
				#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
				half distortionMask = POI2D_SAMPLER_PAN(_DistortionMask, _MainTex, poiMesh.uv[_DistortionMaskUV], _DistortionMaskPan)[_DistortionMaskChannel];
				#else
				half distortionMask = 1;
				#endif
				
				half distortionStrength = _DistortionStrength;
				half distortionStrength1 = _DistortionStrength1;
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (AudioLinkIsAvailable() && _EnableDistortionAudioLink && _AudioLinkAnimToggle)
				{
					distortionStrength += lerp(_DistortionStrengthAudioLink.x, _DistortionStrengthAudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrengthAudioLinkBand))).r);
					distortionStrength1 += lerp(_DistortionStrength1AudioLink.x, _DistortionStrength1AudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrength1AudioLinkBand))).r);
				}
				#endif
				
				flowVector *= distortionStrength;
				flowVector1 *= distortionStrength1;
				return poiMesh.uv[_DistortionUvToDistort] + ((flowVector.xy + flowVector1.xy) / 2) * distortionMask;
			}
			#endif
			//endex
			
			//ifex _PoiParallax==0
			#ifdef POI_PARALLAX
			inline float2 POM(in PoiLight poiLight, sampler2D heightMap, in PoiMesh poiMesh, float3 worldViewDir, float3 viewDirTan, int minSamples, int maxSamples, float parallax, float refPlane, float2 tilling, float2 curv)
			{
				#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float heightMask = POI2D_SAMPLER_PAN(_Heightmask, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmask_ST), _HeightmaskPan)[_HeightmaskChannel];
				if (_HeightmaskInvert)
				{
					heightMask = 1 - heightMask;
				}
				#else
				float heightMask = 1;
				#endif
				
				float2 uvs = poiUV(poiMesh.uv[_HeightMapUV], _HeightMap_ST);
				float2 dx = ddx(uvs);
				float2 dy = ddy(uvs);
				float3 result = 0;
				int stepIndex = 0;
				int numSteps = (int)lerp(maxSamples, minSamples, saturate(dot(poiMesh.normals[0], worldViewDir)));
				float layerHeight = 1.0 / numSteps;
				float2 plane = parallax * heightMask * (viewDirTan.xy / viewDirTan.z);
				uvs += refPlane * plane;
				float2 deltaTex = -plane * layerHeight;
				float2 prevTexOffset = 0;
				float prevRayZ = 1.0f;
				float prevHeight = 0.0f;
				float2 currTexOffset = deltaTex;
				float currRayZ = 1.0f - layerHeight;
				float currHeight = 0.0f;
				float intersection = 0;
				float2 finalTexOffset = 0;
				while (stepIndex < numSteps + 1)
				{
					result.z = dot(curv, currTexOffset * currTexOffset);
					currHeight = tex2Dgrad(heightMap, uvs + currTexOffset, dx, dy).r * (1 - result.z);
					if (currHeight > currRayZ)
					{
						stepIndex = numSteps + 1;
					}
					else
					{
						stepIndex++;
						prevTexOffset = currTexOffset;
						prevRayZ = currRayZ;
						prevHeight = currHeight;
						currTexOffset += deltaTex;
						currRayZ -= layerHeight * (1 - result.z) * (1 + _CurvFix);
					}
				}
				int sectionSteps = 10;
				int sectionIndex = 0;
				float newZ = 0;
				float newHeight = 0;
				while (sectionIndex < sectionSteps)
				{
					intersection = (prevHeight - prevRayZ) / (prevHeight - currHeight + currRayZ - prevRayZ);
					finalTexOffset = prevTexOffset +intersection * deltaTex;
					newZ = prevRayZ - intersection * layerHeight;
					newHeight = tex2Dgrad(heightMap, uvs + finalTexOffset, dx, dy).r;
					if (newHeight > newZ)
					{
						currTexOffset = finalTexOffset;
						currHeight = newHeight;
						currRayZ = newZ;
						deltaTex = intersection * deltaTex;
						layerHeight = intersection * layerHeight;
					}
					else
					{
						prevTexOffset = finalTexOffset;
						prevHeight = newHeight;
						prevRayZ = newZ;
						deltaTex = (1 - intersection) * deltaTex;
						layerHeight = (1 - intersection) * layerHeight;
					}
					sectionIndex++;
				}
				#ifdef UNITY_PASS_SHADOWCASTER
				if (unity_LightShadowBias.z == 0.0)
				{
					#endif
					if (result.z > 1)
					clip(-1);
					#ifdef UNITY_PASS_SHADOWCASTER
				}
				#endif
				
				return uvs + finalTexOffset;
			}
			/*
			float2 ParallaxOffsetMultiStep(float surfaceHeight, float strength, float2 uv, float3 tangentViewDir)
			{
				float2 uvOffset = 0;
				float2 prevUVOffset = 0;
				float stepSize = 1.0 / _HeightSteps;
				float stepHeight = 1;
				float2 uvDelta = tangentViewDir.xy * (stepSize * strength);
				float prevStepHeight = stepHeight;
				float prevSurfaceHeight = surfaceHeight;
				
				[unroll(20)]
				for (int j = 1; j <= _HeightSteps && stepHeight > surfaceHeight; j++)
				{
					prevUVOffset = uvOffset;
					prevStepHeight = stepHeight;
					prevSurfaceHeight = surfaceHeight;
					uvOffset -= uvDelta;
					stepHeight -= stepSize;
					surfaceHeight = POI2D_SAMPLER_PAN(_Heightmap, _MainTex, poiUV(uv + uvOffset, _Heightmap_ST), _HeightmapPan) + _HeightOffset;
				}
				
				[unroll(3)]
				for (int k = 0; k < 3; k++)
				{
					uvDelta *= 0.5;
					stepSize *= 0.5;
					
					if (stepHeight < surfaceHeight)
					{
						uvOffset += uvDelta;
						stepHeight += stepSize;
					}
					else
					{
						uvOffset -= uvDelta;
						stepHeight -= stepSize;
					}
					surfaceHeight = POI2D_SAMPLER_PAN(_Heightmap, _MainTex, poiUV(uv + uvOffset, _Heightmap_ST), _HeightmapPan) + _HeightOffset;
				}
				return uvOffset;
			}
			*/
			void applyParallax(inout PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam)
			{
				/*
				half h = POI2D_SAMPLER_PAN(_Heightmap, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmap_ST), _HeightmapPan).r + _HeightOffset;
				#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				half m = POI2D_SAMPLER_PAN(_Heightmask, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmask_ST), _HeightmaskPan).r + _HeightOffset;
				#else
				half m = 1 + _HeightOffset;
				#endif
				h = clamp(h, 0, 0.999);
				m = lerp(m, 1 - m, _HeightmaskInvert);
				#if defined(OPTIMIZER_ENABLED)das
				poiMesh.uv[_ParallaxUV] += ParallaxOffsetMultiStep(h, _HeightStrength * m, poiMesh.uv[_HeightmapUV], tangentViewDir / tangentViewDir.z);
				#else
				float2 offset = ParallaxOffsetMultiStep(h, _HeightStrength * m, poiMesh.uv[_HeightmapUV], tangentViewDir / tangentViewDir.z);
				if (_ParallaxUV == 0)       poiMesh.uv[0] += offset;
				if (_ParallaxUV == 1)       poiMesh.uv[1] += offset;
				if (_ParallaxUV == 2)       poiMesh.uv[2] += offset;
				if (_ParallaxUV == 3)       poiMesh.uv[3] += offset;
				if (_ParallaxUV == 4)       poiMesh.uv[4] += offset;
				if (_ParallaxUV == 5)       poiMesh.uv[5] += offset;
				if (_ParallaxUV == 6)       poiMesh.uv[6] += offset;
				if (_ParallaxUV == 7)       poiMesh.uv[7] += offset;
				#endif
				*/
				
				#if defined(OPTIMIZER_ENABLED)
				poiMesh.uv[_ParallaxUV] = POM(poiLight, _HeightMap, poiMesh, poiCam.viewDir, poiCam.tangentViewDir, _HeightStepsMin, _HeightStepsMax, _HeightStrength, 0, _HeightMap_ST.xy, float2(_CurvatureU, _CurvatureV));
				#else
				float2 offset = POM(poiLight, _HeightMap, poiMesh, poiCam.viewDir, poiCam.tangentViewDir, _HeightStepsMin, _HeightStepsMax, _HeightStrength, 0, _HeightMap_ST.xy, float2(_CurvatureU, _CurvatureV));
				if (_ParallaxUV == 0)       poiMesh.uv[0] = offset;
				if (_ParallaxUV == 1)       poiMesh.uv[1] = offset;
				if (_ParallaxUV == 2)       poiMesh.uv[2] = offset;
				if (_ParallaxUV == 3)       poiMesh.uv[3] = offset;
				if (_ParallaxUV == 4)       poiMesh.uv[4] = offset;
				if (_ParallaxUV == 5)       poiMesh.uv[5] = offset;
				if (_ParallaxUV == 6)       poiMesh.uv[6] = offset;
				if (_ParallaxUV == 7)       poiMesh.uv[7] = offset;
				#endif
			}
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			void calculateBlackLightMasks(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#ifdef VERTEXLIGHT_ON
				for (int lightIndex = 0; lightIndex < 4; lightIndex ++)
				{
					float3 lightPos = float3(unity_4LightPosX0[lightIndex], unity_4LightPosY0[lightIndex], unity_4LightPosZ0[lightIndex]);
					if (!distance(unity_LightColor[lightIndex].rgb, float3(0, 0, 0)))
					{
						if (_BlackLightMasking0GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking0Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking0GlobalMaskIndex-1, _BlackLightMasking0GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking1GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking1Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking1GlobalMaskIndex-1, _BlackLightMasking1GlobalMaskBlendType, smoothstep(_BlackLightMasking1Range.y, _BlackLightMasking1Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking2GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking2Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking2GlobalMaskIndex-1, _BlackLightMasking2GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking3GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking3Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking3GlobalMaskIndex-1, _BlackLightMasking3GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
					}
				}
				#endif
			}
			#endif
			//endex
			
			//ifex _DetailEnabled==0
			#ifdef FINALPASS
			void ApplyDetailColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_DETAILTEX) || !defined(OPTIMIZER_ENABLED)
				half3 detailTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_DetailTex, _MainTex, poiUV(poiMesh.uv[_DetailTexUV], _DetailTex_ST), _DetailTexPan, _DetailTexStochastic).rgb * poiThemeColor(poiMods, _DetailTint, _DetailTintThemeIndex);
				#else
				half3 detailTexture = 0.21763764082 * poiThemeColor(poiMods, _DetailTint, _DetailTintThemeIndex);
				#endif
				
				poiFragData.baseColor.rgb *= LerpWhiteTo(detailTexture * _DetailBrightness * unity_ColorSpaceDouble.rgb, poiMods.detailMask.r * _DetailTexIntensity);
			}
			
			void ApplyDetailNormal(inout PoiMods poiMods, inout PoiMesh poiMesh)
			{
				#if defined(PROP_DETAILMASK) || !defined(OPTIMIZER_ENABLED)
				poiMods.detailMask = POI2D_SAMPLER_PAN_STOCHASTIC(_DetailMask, _MainTex, poiUV(poiMesh.uv[_DetailMaskUV], _DetailMask_ST), _DetailMaskPan, _DetailMaskStochastic).rg;
				#else
				poiMods.detailMask = 1;
				#endif
				
				#ifdef POI_BACKFACE
				if (!poiMesh.isFrontFace)
				{
					poiMods.detailMask.rg *= _BackFaceDetailIntensity;
				}
				#endif
				
				if (_DetailTexGlobalMask > 0)
				{
					poiMods.detailMask.r = maskBlend(poiMods.detailMask.r, poiMods.globalMask[_DetailTexGlobalMask-1], _DetailTexGlobalMaskBlendType);
				}
				if (_DetailNormalGlobalMask > 0)
				{
					poiMods.detailMask.g = maskBlend(poiMods.detailMask.g, poiMods.globalMask[_DetailNormalGlobalMask-1], _DetailNormalGlobalMaskBlendType);
				}
				
				#if defined(PROP_DETAILNORMALMAP) || !defined(OPTIMIZER_ENABLED)
				half3 detailNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_DetailNormalMap, _MainTex, poiUV(poiMesh.uv[_DetailNormalMapUV], _DetailNormalMap_ST), _DetailNormalMapPan, _DetailNormalMapStochastic), _DetailNormalMapScale * poiMods.detailMask.g);
				poiMesh.tangentSpaceNormal = BlendNormals(detailNormal, poiMesh.tangentSpaceNormal);
				#endif
			}
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			void applyVertexColor(inout PoiFragData poiFragData, PoiMesh poiMesh)
			{
				if (_MainVertexColoringEnabled)
				{
					#ifndef POI_PASS_OUTLINE
					float3 vertCol = lerp(poiMesh.vertexColor.rgb, GammaToLinearSpace(poiMesh.vertexColor.rgb), _MainVertexColoringLinearSpace);
					poiFragData.baseColor *= lerp(1, vertCol, _MainVertexColoring);
					#endif
					poiFragData.alpha *= lerp(1, poiMesh.vertexColor.a, _MainUseVertexColorAlpha);
				}
			}
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			void ApplyBackFaceColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				if (!poiMesh.isFrontFace)
				{
					float4 backFaceColor = _BackFaceColor;
					backFaceColor.rgb = poiThemeColor(poiMods, backFaceColor.rgb, _BackFaceColorThemeIndex);
					#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
					backFaceColor *= POI2D_SAMPLER_PAN(_BackFaceTexture, _MainTex, poiUV(poiMesh.uv[_BackFaceTextureUV], _BackFaceTexture_ST), _BackFaceTexturePan);
					#endif
					backFaceColor.rgb = hueShift(backFaceColor.rgb, frac(_BackFaceHueShift + _BackFaceHueShiftSpeed * _Time.x) * _BackFaceHueShiftEnabled);
					
					float backFaceMask = 1;
					#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
					backFaceMask *= POI2D_SAMPLER_PAN(_BackFaceMask, _MainTex, poiUV(poiMesh.uv[_BackFaceMaskUV], _BackFaceMask_ST), _BackFaceMaskPan)[_BackFaceMaskChannel];
					#endif
					if (!_BackFaceReplaceAlpha)
					{
						backFaceMask *= backFaceColor.a;
					}
					
					poiFragData.baseColor = lerp(poiFragData.baseColor, backFaceColor.rgb, backFaceMask);
					
					UNITY_BRANCH
					if (_BackFaceReplaceAlpha)
					{
						poiFragData.alpha = backFaceColor.a;
					}
					
					poiFragData.emission += backFaceColor.rgb * _BackFaceEmissionStrength * backFaceMask;
					poiMods.globalEmission = min(poiMods.globalEmission, _BackFaceEmissionLimiter);
				}
			}
			#endif
			//endex
			
			//ifex _RGBMaskEnabled==0
			#ifdef VIGNETTE
			//ifex _RgbNormalsEnabled==0
			#if defined(GEOM_TYPE_MESH) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
			void calculateRGBNormals(inout PoiMesh poiMesh, inout PoiMods poiMods)
			{
				// Only define this if we actually have any normal map textures. Can't do the same in color textures because users can tint
				#if defined(PROP_RGBNORMALR) || defined(PROP_RGBNORMALG) || defined(PROP_RGBNORMALB) || defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
				float4 rgbMask;
				
				if (_RGBUseVertexColors)
				{
					rgbMask = poiMesh.vertexColor;
				}
				else
				{
					#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
					rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
					#else
					rgbMask = 1;
					#endif
				}
				
				float4 maskFinal = 1;
				maskFinal.r = rgbMask[_RgbNormalRMaskChannel];
				maskFinal.g = rgbMask[_RgbNormalGMaskChannel];
				maskFinal.b = rgbMask[_RgbNormalBMaskChannel];
				maskFinal.a = rgbMask[_RgbNormalAMaskChannel];
				
				if (_RgbNormalRGlobalMaskChannel > 0) maskFinal.r = customBlend(maskFinal.r, poiMods.globalMask[_RgbNormalRGlobalMaskChannel-1], _RgbNormalRGlobalMaskBlendType);
				if (_RgbNormalGGlobalMaskChannel > 0) maskFinal.g = customBlend(maskFinal.g, poiMods.globalMask[_RgbNormalGGlobalMaskChannel-1], _RgbNormalGGlobalMaskBlendType);
				if (_RgbNormalBGlobalMaskChannel > 0) maskFinal.b = customBlend(maskFinal.b, poiMods.globalMask[_RgbNormalBGlobalMaskChannel-1], _RgbNormalBGlobalMaskBlendType);
				if (_RgbNormalAGlobalMaskChannel > 0) maskFinal.a = customBlend(maskFinal.a, poiMods.globalMask[_RgbNormalAGlobalMaskChannel-1], _RgbNormalAGlobalMaskBlendType);
				
				if (_RGBNormalBlend == 0)
				{
					#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalRScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan, _RgbNormalRStochastic), _RgbNormalRScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.r);
					}
					#endif
					#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalGScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan, _RgbNormalGStochastic), _RgbNormalGScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.g);
					}
					#endif
					#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalBScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan, _RgbNormalBStochastic), _RgbNormalBScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.b);
					}
					#endif
					#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalAScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan, _RgbNormalAStochastic), _RgbNormalAScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.a);
					}
					#endif
				}
				else
				{
					half3 newNormal = half3(0, 0, 1);
					half3 normalToBlendWith = half3(0, 0, 1);
					#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan, _RgbNormalRStochastic), _RgbNormalRScale * maskFinal.r);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan, _RgbNormalGStochastic), _RgbNormalGScale * maskFinal.g);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan, _RgbNormalBStochastic), _RgbNormalBScale * maskFinal.b);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan, _RgbNormalAStochastic), _RgbNormalAScale * maskFinal.a);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					poiMesh.tangentSpaceNormal = BlendNormals(newNormal, poiMesh.tangentSpaceNormal);
				}
				#endif
			}
			#endif
			//endex
			void calculateRGBMask(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				//If RGB normals are in use this data will already exist
				float4 rgbMask = float4(1, 1, 1, 1);
				//UNITY_BRANCH
				if (_RGBUseVertexColors)
				{
					rgbMask = poiMesh.vertexColor;
				}
				else
				{
					#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
					rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
					#else
					rgbMask = 1;
					#endif
				}
				
				#if defined(PROP_REDTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 red = POI2D_SAMPLER_PAN_STOCHASTIC(_RedTexture, _MainTex, poiUV(poiMesh.uv[_RedTextureUV], _RedTexture_ST), _RedTexturePan, _RedTextureStochastic);
				#else
				float4 red = 1;
				#endif
				#if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 green = POI2D_SAMPLER_PAN_STOCHASTIC(_GreenTexture, _MainTex, poiUV(poiMesh.uv[_GreenTextureUV], _GreenTexture_ST), _GreenTexturePan, _GreenTextureStochastic);
				#else
				float4 green = 1;
				#endif
				#if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 blue = POI2D_SAMPLER_PAN_STOCHASTIC(_BlueTexture, _MainTex, poiUV(poiMesh.uv[_BlueTextureUV], _BlueTexture_ST), _BlueTexturePan, _BlueTextureStochastic);
				#else
				float4 blue = 1;
				#endif
				#if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 alpha = POI2D_SAMPLER_PAN_STOCHASTIC(_AlphaTexture, _MainTex, poiUV(poiMesh.uv[_AlphaTextureUV], _AlphaTexture_ST), _AlphaTexturePan, _AlphaTextureStochastic);
				#else
				float4 alpha = 1;
				#endif
				
				float4 maskFinal = 1;
				maskFinal.r = red.a   * saturate((rgbMask[_RgbRedMaskChannel  ] * _RedColor.a  ) + _RedAlphaAdd  );
				maskFinal.g = green.a * saturate((rgbMask[_RgbGreenMaskChannel] * _GreenColor.a) + _GreenAlphaAdd);
				maskFinal.b = blue.a  * saturate((rgbMask[_RgbBlueMaskChannel ] * _BlueColor.a ) + _BlueAlphaAdd );
				maskFinal.a = alpha.a * saturate((rgbMask[_RgbAlphaMaskChannel] * _AlphaColor.a) + _AlphaAlphaAdd);
				
				if (_RgbRedGlobalMaskChannel   > 0) maskFinal.r = customBlend(maskFinal.r, poiMods.globalMask[_RgbRedGlobalMaskChannel-1],   _RgbRedGlobalMaskBlendType  );
				if (_RgbGreenGlobalMaskChannel > 0) maskFinal.g = customBlend(maskFinal.g, poiMods.globalMask[_RgbGreenGlobalMaskChannel-1], _RgbGreenGlobalMaskBlendType);
				if (_RgbBlueGlobalMaskChannel  > 0) maskFinal.b = customBlend(maskFinal.b, poiMods.globalMask[_RgbBlueGlobalMaskChannel-1],  _RgbBlueGlobalMaskBlendType );
				if (_RgbAlphaGlobalMaskChannel > 0) maskFinal.a = customBlend(maskFinal.a, poiMods.globalMask[_RgbAlphaGlobalMaskChannel-1], _RgbAlphaGlobalMaskBlendType);
				
				//UNITY_BRANCH
				if (_RGBBlendMultiplicative)
				{
					float3 RGBColor = 1;
					RGBColor = lerp(RGBColor, red.rgb * poiThemeColor(poiMods, _RedColor.rgb, _RedColorThemeIndex), maskFinal.r);
					RGBColor = lerp(RGBColor, green.rgb * poiThemeColor(poiMods, _GreenColor.rgb, _GreenColorThemeIndex), maskFinal.g);
					RGBColor = lerp(RGBColor, blue.rgb * poiThemeColor(poiMods, _BlueColor.rgb, _BlueColorThemeIndex), maskFinal.b);
					RGBColor = lerp(RGBColor, alpha.rgb * poiThemeColor(poiMods, _AlphaColor.rgb, _AlphaColorThemeIndex), maskFinal.a);
					
					poiFragData.baseColor *= RGBColor;
				}
				else
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, red.rgb * poiThemeColor(poiMods, _RedColor.rgb, _RedColorThemeIndex), maskFinal.r);
					poiFragData.baseColor = lerp(poiFragData.baseColor, green.rgb * poiThemeColor(poiMods, _GreenColor.rgb, _GreenColorThemeIndex), maskFinal.g);
					poiFragData.baseColor = lerp(poiFragData.baseColor, blue.rgb * poiThemeColor(poiMods, _BlueColor.rgb, _BlueColorThemeIndex), maskFinal.b);
					poiFragData.baseColor = lerp(poiFragData.baseColor, alpha.rgb * poiThemeColor(poiMods, _AlphaColor.rgb, _AlphaColorThemeIndex), maskFinal.a);
				}
			}
			#endif
			//endex
			
			#if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_BRANCH_DETAIL) || defined(GEOM_TYPE_FROND) || defined(DEPTH_OF_FIELD_COC_VIEW)
			float2 decalUV(float uvNumber, float2 position, half rotation, half rotationSpeed, half2 scale, float4 scaleOffset, float depth, in PoiMesh poiMesh, in PoiCam poiCam)
			{
				scaleOffset = float4(-scaleOffset.x, scaleOffset.y, -scaleOffset.z, scaleOffset.w);
				float2 centerOffset = float2((scaleOffset.x + scaleOffset.y)/2, (scaleOffset.z + scaleOffset.w)/2);
				float2 uv = poiMesh.uv[uvNumber] + calcParallax(depth + 1, poiCam);
				float2 decalCenter = position + centerOffset;
				float theta = radians(rotation + _Time.z * rotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
				uv = remap(uv, float2(0, 0) - scale / 2 + position + scaleOffset.xz, scale / 2 + position + scaleOffset.yw, float2(0, 0), float2(1, 1));
				return uv;
			}
			
			inline float3 decalHueShift(float enabled, float3 color, float shift, float shiftSpeed)
			{
				//UNITY_BRANCH
				if (enabled)
				{
					color = hueShift(color, shift + _Time.x * shiftSpeed);
				}
				return color;
			}
			
			inline float applyTilingClipping(float enabled, float2 uv)
			{
				float ret = 1;
				//UNITY_BRANCH
				if (!enabled)
				{
					if (uv.x > 1 || uv.y > 1 || uv.x < 0 || uv.y < 0)
					{
						ret = 0;
					}
				}
				return ret;
			}
			
			struct PoiDecal
			{
				float m_DecalMaskChannel;
				float m_DecalGlobalMask;
				float m_DecalGlobalMaskBlendType;
				float m_DecalApplyGlobalMaskIndex;
				float m_DecalApplyGlobalMaskBlendType;
				float4 m_DecalTexture_ST;
				float2 m_DecalTexturePan;
				float m_DecalTextureUV;
				float4 m_DecalColor;
				float m_DecalColorThemeIndex;
				fixed m_DecalTiled;
				float m_DecalBlendType;
				half m_DecalRotation;
				half2 m_DecalScale;
				float4 m_DecalSideOffset;
				half2 m_DecalPosition;
				half m_DecalRotationSpeed;
				float m_DecalEmissionStrength;
				float m_DecalBlendAlpha;
				float m_DecalOverrideAlpha;
				float m_DecalHueShiftEnabled;
				float m_DecalHueShift;
				float m_DecalHueShiftSpeed;
				float m_DecalDepth;
				float m_DecalHueAngleStrength;
				float m_DecalChannelSeparationEnable;
				float m_DecalChannelSeparation;
				float m_DecalChannelSeparationPremultiply;
				float m_DecalChannelSeparationHue;
				float m_DecalChannelSeparationVertical;
				float m_DecalChannelSeparationAngleStrength;
				
				#if defined(POI_AUDIOLINK)
				half m_AudioLinkDecalScaleBand;
				float4 m_AudioLinkDecalScale;
				half m_AudioLinkDecalRotationBand;
				float2 m_AudioLinkDecalRotation;
				half m_AudioLinkDecalAlphaBand;
				float2 m_AudioLinkDecalAlpha;
				half m_AudioLinkDecalEmissionBand;
				float2 m_AudioLinkDecalEmission;
				float m_DecalRotationCTALBand;
				float m_DecalRotationCTALSpeed;
				float m_DecalRotationCTALType;
				float m_AudioLinkDecalColorChord;
				float m_AudioLinkDecalSideBand;
				float4 m_AudioLinkDecalSideMin;
				float4 m_AudioLinkDecalSideMax;
				float2 m_AudioLinkDecalChannelSeparation;
				float m_AudioLinkDecalChannelSeparationBand;
				#endif
				
				float4 decalColor;
				float2 decalScale;
				float decalRotation;
				float2 uv;
				float4 dduv;
				float4 sideMod;
				float decalChannelOffset;
				float4 decalMask;
				
				void Init(in float4 DecalMask)
				{
					decalMask = DecalMask;
					decalScale = m_DecalScale;
				}
				
				void InitAudiolink(in PoiMods poiMods)
				{
					#ifdef POI_AUDIOLINK
					if (poiMods.audioLinkAvailable)
					{
						decalScale += lerp(m_AudioLinkDecalScale.xy, m_AudioLinkDecalScale.zw, poiMods.audioLink[m_AudioLinkDecalScaleBand]);
						sideMod += lerp(m_AudioLinkDecalSideMin, m_AudioLinkDecalSideMax, poiMods.audioLink[m_AudioLinkDecalSideBand]);
						decalRotation += lerp(m_AudioLinkDecalRotation.x, m_AudioLinkDecalRotation.y, poiMods.audioLink[m_AudioLinkDecalRotationBand]);
						decalRotation += AudioLinkGetChronoTime(m_DecalRotationCTALType, m_DecalRotationCTALBand) * m_DecalRotationCTALSpeed * 360;
						decalChannelOffset += lerp(m_AudioLinkDecalChannelSeparation[0], m_AudioLinkDecalChannelSeparation[1], poiMods.audioLink[m_AudioLinkDecalChannelSeparationBand]);
					}
					#endif
				}
				
				void SampleDecalNoTexture(in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					decalColor = float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
				}
				
				void SampleDecal(sampler2D decalTexture, in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					// Adjust derivatives for _ST of decal texture
					float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
					decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
				}
				
				void SampleDecalChannelSeparation(sampler2D decalTexture, in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					decalColor = 0;
					decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
					float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
					float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					
					float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
					float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
					
					float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					
					sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					
					float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
					
					if (m_DecalChannelSeparationPremultiply)
					{
						decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
					}
					else
					{
						decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
					}
					decalColor.a = 0.5 * (sample0.a + sample1.a);
					decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
				}
				
				void Apply(inout float alphaOverride, inout float decalAlpha, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
				{
					if (m_DecalGlobalMask > 0)
					{
						decalColor.a = maskBlend(decalColor.a, poiMods.globalMask[m_DecalGlobalMask - 1], m_DecalGlobalMaskBlendType);
					}
					
					float audioLinkDecalAlpha = 0;
					float audioLinkDecalEmission = 0;
					#ifdef POI_AUDIOLINK
					audioLinkDecalEmission = lerp(m_AudioLinkDecalEmission.x, m_AudioLinkDecalEmission.y, poiMods.audioLink[m_AudioLinkDecalEmissionBand]) * poiMods.audioLinkAvailable;
					
					if (m_AudioLinkDecalColorChord)
					{
						if (poiMods.audioLinkAvailable)
						{
							decalColor.rgb *= AudioLinkLerp(ALPASS_CCSTRIP + float2(uv.x * AUDIOLINK_WIDTH, 0)).rgb;
						}
						else
						{
							decalAlpha = 0;
						}
					}
					audioLinkDecalAlpha = lerp(m_AudioLinkDecalAlpha.x, m_AudioLinkDecalAlpha.y, poiMods.audioLink[m_AudioLinkDecalAlphaBand]) * poiMods.audioLinkAvailable;
					#endif
					
					if (m_DecalOverrideAlpha)
					{
						alphaOverride += 1;
						decalAlpha = lerp(decalAlpha, min(decalAlpha, decalColor.a), decalMask[m_DecalMaskChannel]);
					}
					
					float decalAlphaMixed = decalColor.a * saturate(m_DecalBlendAlpha + audioLinkDecalAlpha);
					
					if (m_DecalApplyGlobalMaskIndex > 0)
					{
						applyToGlobalMask(poiMods, m_DecalApplyGlobalMaskIndex - 1, m_DecalApplyGlobalMaskBlendType, decalAlphaMixed);
					}
					
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, decalColor.rgb, m_DecalBlendType), decalAlphaMixed);
					poiFragData.emission += decalColor.rgb * decalColor.a * max(m_DecalEmissionStrength + audioLinkDecalEmission, 0);
				}
			};
			
			void applyDecals(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
			{
				float decalAlpha = 1;
				float alphaOverride = 0;
				#if defined(PROP_DECALMASK) || !defined(OPTIMIZER_ENABLED)
				float4 decalMask = POI2D_SAMPLER_PAN(_DecalMask, _MainTex, poiUV(poiMesh.uv[_DecalMaskUV], _DecalMask_ST), _DecalMaskPan);
				#else
				float4 decalMask = 1;
				#endif
				
				#ifdef TPS_Penetrator
				if (_DecalTPSDepthMaskEnabled)
				{
					decalMask.r = lerp(0, decalMask.r * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal0TPSMaskStrength);
					decalMask.g = lerp(0, decalMask.g * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal1TPSMaskStrength);
					decalMask.b = lerp(0, decalMask.b * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal2TPSMaskStrength);
					decalMask.a = lerp(0, decalMask.a * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal3TPSMaskStrength);
				}
				#endif
				float4 decalColor = 1;
				float2 uv = 0;
				
				// yaes
				
				//ifex _DecalEnabled==0
				#ifdef GEOM_TYPE_BRANCH
				PoiDecal Decal0;
				PoiInitStruct(PoiDecal, Decal0)
				
				Decal0.m_DecalMaskChannel = _Decal0MaskChannel;
				Decal0.m_DecalGlobalMask = _Decal0GlobalMask;
				Decal0.m_DecalGlobalMaskBlendType = _Decal0GlobalMaskBlendType;
				Decal0.m_DecalApplyGlobalMaskIndex = _Decal0ApplyGlobalMaskIndex;
				Decal0.m_DecalApplyGlobalMaskBlendType = _Decal0ApplyGlobalMaskBlendType;
				Decal0.m_DecalTexture_ST = _DecalTexture_ST;
				Decal0.m_DecalTexturePan = _DecalTexturePan;
				Decal0.m_DecalTextureUV = _DecalTextureUV;
				Decal0.m_DecalColor = _DecalColor;
				Decal0.m_DecalColorThemeIndex = _DecalColorThemeIndex;
				Decal0.m_DecalTiled = _DecalTiled;
				Decal0.m_DecalBlendType = _DecalBlendType;
				Decal0.m_DecalRotation = _DecalRotation;
				Decal0.m_DecalScale = _DecalScale;
				Decal0.m_DecalSideOffset = _DecalSideOffset;
				Decal0.m_DecalPosition = _DecalPosition;
				Decal0.m_DecalRotationSpeed = _DecalRotationSpeed;
				Decal0.m_DecalEmissionStrength = _DecalEmissionStrength;
				Decal0.m_DecalBlendAlpha = _DecalBlendAlpha;
				Decal0.m_DecalOverrideAlpha = _DecalOverrideAlpha;
				Decal0.m_DecalHueShiftEnabled = _DecalHueShiftEnabled;
				Decal0.m_DecalHueShift = _DecalHueShift;
				Decal0.m_DecalHueShiftSpeed = _DecalHueShiftSpeed;
				Decal0.m_DecalDepth = _Decal0Depth;
				Decal0.m_DecalHueAngleStrength = _Decal0HueAngleStrength;
				Decal0.m_DecalChannelSeparationEnable = _Decal0ChannelSeparationEnable;
				Decal0.m_DecalChannelSeparation = _Decal0ChannelSeparation;
				Decal0.m_DecalChannelSeparationPremultiply = _Decal0ChannelSeparationPremultiply;
				Decal0.m_DecalChannelSeparationHue = _Decal0ChannelSeparationHue;
				Decal0.m_DecalChannelSeparationVertical = _Decal0ChannelSeparationVertical;
				Decal0.m_DecalChannelSeparationAngleStrength = _Decal0ChannelSeparationAngleStrength;
				
				Decal0.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal0.m_AudioLinkDecalScaleBand = _AudioLinkDecal0ScaleBand;
				Decal0.m_AudioLinkDecalScale = _AudioLinkDecal0Scale;
				Decal0.m_AudioLinkDecalRotationBand = _AudioLinkDecal0RotationBand;
				Decal0.m_AudioLinkDecalRotation = _AudioLinkDecal0Rotation;
				Decal0.m_AudioLinkDecalAlphaBand = _AudioLinkDecal0AlphaBand;
				Decal0.m_AudioLinkDecalAlpha = _AudioLinkDecal0Alpha;
				Decal0.m_AudioLinkDecalEmissionBand = _AudioLinkDecal0EmissionBand;
				Decal0.m_AudioLinkDecalEmission = _AudioLinkDecal0Emission;
				Decal0.m_DecalRotationCTALBand = _DecalRotationCTALBand0;
				Decal0.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed0;
				Decal0.m_DecalRotationCTALType = _DecalRotationCTALType0;
				Decal0.m_AudioLinkDecalColorChord = _AudioLinkDecalCC0;
				Decal0.m_AudioLinkDecalSideBand = _AudioLinkDecal0SideBand;
				Decal0.m_AudioLinkDecalSideMin = _AudioLinkDecal0SideMin;
				Decal0.m_AudioLinkDecalSideMax = _AudioLinkDecal0SideMax;
				Decal0.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal0ChannelSeparation;
				Decal0.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal0ChannelSeparationBand;
				
				Decal0.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal0ChannelSeparationEnable==0
				if (_Decal0ChannelSeparationEnable)
				{
					Decal0.SampleDecalChannelSeparation(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal0ChannelSeparationEnable==1
				if (!_Decal0ChannelSeparationEnable)
				{
					Decal0.SampleDecal(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal0.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal0.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled1==0
				#ifdef GEOM_TYPE_BRANCH_DETAIL
				PoiDecal Decal1;
				PoiInitStruct(PoiDecal, Decal1)
				
				Decal1.m_DecalMaskChannel = _Decal1MaskChannel;
				Decal1.m_DecalGlobalMask = _Decal1GlobalMask;
				Decal1.m_DecalGlobalMaskBlendType = _Decal1GlobalMaskBlendType;
				Decal1.m_DecalApplyGlobalMaskIndex = _Decal1ApplyGlobalMaskIndex;
				Decal1.m_DecalApplyGlobalMaskBlendType = _Decal1ApplyGlobalMaskBlendType;
				Decal1.m_DecalTexture_ST = _DecalTexture1_ST;
				Decal1.m_DecalTexturePan = _DecalTexture1Pan;
				Decal1.m_DecalTextureUV = _DecalTexture1UV;
				Decal1.m_DecalColor = _DecalColor1;
				Decal1.m_DecalColorThemeIndex = _DecalColor1ThemeIndex;
				Decal1.m_DecalTiled = _DecalTiled1;
				Decal1.m_DecalBlendType = _DecalBlendType1;
				Decal1.m_DecalRotation = _DecalRotation1;
				Decal1.m_DecalScale = _DecalScale1;
				Decal1.m_DecalSideOffset = _DecalSideOffset1;
				Decal1.m_DecalPosition = _DecalPosition1;
				Decal1.m_DecalRotationSpeed = _DecalRotationSpeed1;
				Decal1.m_DecalEmissionStrength = _DecalEmissionStrength1;
				Decal1.m_DecalBlendAlpha = _DecalBlendAlpha1;
				Decal1.m_DecalOverrideAlpha = _DecalOverrideAlpha1;
				Decal1.m_DecalHueShiftEnabled = _DecalHueShiftEnabled1;
				Decal1.m_DecalHueShift = _DecalHueShift1;
				Decal1.m_DecalHueShiftSpeed = _DecalHueShiftSpeed1;
				Decal1.m_DecalDepth = _Decal1Depth;
				Decal1.m_DecalHueAngleStrength = _Decal1HueAngleStrength;
				Decal1.m_DecalChannelSeparationEnable = _Decal1ChannelSeparationEnable;
				Decal1.m_DecalChannelSeparation = _Decal1ChannelSeparation;
				Decal1.m_DecalChannelSeparationPremultiply = _Decal1ChannelSeparationPremultiply;
				Decal1.m_DecalChannelSeparationHue = _Decal1ChannelSeparationHue;
				Decal1.m_DecalChannelSeparationVertical = _Decal1ChannelSeparationVertical;
				Decal1.m_DecalChannelSeparationAngleStrength = _Decal1ChannelSeparationAngleStrength;
				
				Decal1.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal1.m_AudioLinkDecalScaleBand = _AudioLinkDecal1ScaleBand;
				Decal1.m_AudioLinkDecalScale = _AudioLinkDecal1Scale;
				Decal1.m_AudioLinkDecalRotationBand = _AudioLinkDecal1RotationBand;
				Decal1.m_AudioLinkDecalRotation = _AudioLinkDecal1Rotation;
				Decal1.m_AudioLinkDecalAlphaBand = _AudioLinkDecal1AlphaBand;
				Decal1.m_AudioLinkDecalAlpha = _AudioLinkDecal1Alpha;
				Decal1.m_AudioLinkDecalEmissionBand = _AudioLinkDecal1EmissionBand;
				Decal1.m_AudioLinkDecalEmission = _AudioLinkDecal1Emission;
				Decal1.m_DecalRotationCTALBand = _DecalRotationCTALBand1;
				Decal1.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed1;
				Decal1.m_DecalRotationCTALType = _DecalRotationCTALType1;
				Decal1.m_AudioLinkDecalColorChord = _AudioLinkDecalCC1;
				Decal1.m_AudioLinkDecalSideBand = _AudioLinkDecal1SideBand;
				Decal1.m_AudioLinkDecalSideMin = _AudioLinkDecal1SideMin;
				Decal1.m_AudioLinkDecalSideMax = _AudioLinkDecal1SideMax;
				Decal1.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal1ChannelSeparation;
				Decal1.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal1ChannelSeparationBand;
				
				Decal1.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal1ChannelSeparationEnable==0
				if (_Decal1ChannelSeparationEnable)
				{
					Decal1.SampleDecalChannelSeparation(_DecalTexture1, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal1ChannelSeparationEnable==1
				if (!_Decal1ChannelSeparationEnable)
				{
					Decal1.SampleDecal(_DecalTexture1, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal1.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal1.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled2==0
				#ifdef GEOM_TYPE_FROND
				PoiDecal Decal2;
				PoiInitStruct(PoiDecal, Decal2)
				
				Decal2.m_DecalMaskChannel = _Decal2MaskChannel;
				Decal2.m_DecalGlobalMask = _Decal2GlobalMask;
				Decal2.m_DecalGlobalMaskBlendType = _Decal2GlobalMaskBlendType;
				Decal2.m_DecalApplyGlobalMaskIndex = _Decal2ApplyGlobalMaskIndex;
				Decal2.m_DecalApplyGlobalMaskBlendType = _Decal2ApplyGlobalMaskBlendType;
				Decal2.m_DecalTexture_ST = _DecalTexture2_ST;
				Decal2.m_DecalTexturePan = _DecalTexture2Pan;
				Decal2.m_DecalTextureUV = _DecalTexture2UV;
				Decal2.m_DecalColor = _DecalColor2;
				Decal2.m_DecalColorThemeIndex = _DecalColor2ThemeIndex;
				Decal2.m_DecalTiled = _DecalTiled2;
				Decal2.m_DecalBlendType = _DecalBlendType2;
				Decal2.m_DecalRotation = _DecalRotation2;
				Decal2.m_DecalScale = _DecalScale2;
				Decal2.m_DecalSideOffset = _DecalSideOffset2;
				Decal2.m_DecalPosition = _DecalPosition2;
				Decal2.m_DecalRotationSpeed = _DecalRotationSpeed2;
				Decal2.m_DecalEmissionStrength = _DecalEmissionStrength2;
				Decal2.m_DecalBlendAlpha = _DecalBlendAlpha2;
				Decal2.m_DecalOverrideAlpha = _DecalOverrideAlpha2;
				Decal2.m_DecalHueShiftEnabled = _DecalHueShiftEnabled2;
				Decal2.m_DecalHueShift = _DecalHueShift2;
				Decal2.m_DecalHueShiftSpeed = _DecalHueShiftSpeed2;
				Decal2.m_DecalDepth = _Decal2Depth;
				Decal2.m_DecalHueAngleStrength = _Decal2HueAngleStrength;
				Decal2.m_DecalChannelSeparationEnable = _Decal2ChannelSeparationEnable;
				Decal2.m_DecalChannelSeparation = _Decal2ChannelSeparation;
				Decal2.m_DecalChannelSeparationPremultiply = _Decal2ChannelSeparationPremultiply;
				Decal2.m_DecalChannelSeparationHue = _Decal2ChannelSeparationHue;
				Decal2.m_DecalChannelSeparationVertical = _Decal2ChannelSeparationVertical;
				Decal2.m_DecalChannelSeparationAngleStrength = _Decal2ChannelSeparationAngleStrength;
				
				Decal2.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal2.m_AudioLinkDecalScaleBand = _AudioLinkDecal2ScaleBand;
				Decal2.m_AudioLinkDecalScale = _AudioLinkDecal2Scale;
				Decal2.m_AudioLinkDecalRotationBand = _AudioLinkDecal2RotationBand;
				Decal2.m_AudioLinkDecalRotation = _AudioLinkDecal2Rotation;
				Decal2.m_AudioLinkDecalAlphaBand = _AudioLinkDecal2AlphaBand;
				Decal2.m_AudioLinkDecalAlpha = _AudioLinkDecal2Alpha;
				Decal2.m_AudioLinkDecalEmissionBand = _AudioLinkDecal2EmissionBand;
				Decal2.m_AudioLinkDecalEmission = _AudioLinkDecal2Emission;
				Decal2.m_DecalRotationCTALBand = _DecalRotationCTALBand2;
				Decal2.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed2;
				Decal2.m_DecalRotationCTALType = _DecalRotationCTALType2;
				Decal2.m_AudioLinkDecalColorChord = _AudioLinkDecalCC2;
				Decal2.m_AudioLinkDecalSideBand = _AudioLinkDecal2SideBand;
				Decal2.m_AudioLinkDecalSideMin = _AudioLinkDecal2SideMin;
				Decal2.m_AudioLinkDecalSideMax = _AudioLinkDecal2SideMax;
				Decal2.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal2ChannelSeparation;
				Decal2.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal2ChannelSeparationBand;
				
				Decal2.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal2ChannelSeparationEnable==0
				if (_Decal2ChannelSeparationEnable)
				{
					Decal2.SampleDecalChannelSeparation(_DecalTexture2, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal2ChannelSeparationEnable==1
				if (!_Decal2ChannelSeparationEnable)
				{
					Decal2.SampleDecal(_DecalTexture2, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal2.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal2.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled3==0
				#ifdef DEPTH_OF_FIELD_COC_VIEW
				PoiDecal Decal3;
				PoiInitStruct(PoiDecal, Decal3)
				
				Decal3.m_DecalMaskChannel = _Decal3MaskChannel;
				Decal3.m_DecalGlobalMask = _Decal3GlobalMask;
				Decal3.m_DecalGlobalMaskBlendType = _Decal3GlobalMaskBlendType;
				Decal3.m_DecalApplyGlobalMaskIndex = _Decal3ApplyGlobalMaskIndex;
				Decal3.m_DecalApplyGlobalMaskBlendType = _Decal3ApplyGlobalMaskBlendType;
				Decal3.m_DecalTexture_ST = _DecalTexture3_ST;
				Decal3.m_DecalTexturePan = _DecalTexture3Pan;
				Decal3.m_DecalTextureUV = _DecalTexture3UV;
				Decal3.m_DecalColor = _DecalColor3;
				Decal3.m_DecalColorThemeIndex = _DecalColor3ThemeIndex;
				Decal3.m_DecalTiled = _DecalTiled3;
				Decal3.m_DecalBlendType = _DecalBlendType3;
				Decal3.m_DecalRotation = _DecalRotation3;
				Decal3.m_DecalScale = _DecalScale3;
				Decal3.m_DecalSideOffset = _DecalSideOffset3;
				Decal3.m_DecalPosition = _DecalPosition3;
				Decal3.m_DecalRotationSpeed = _DecalRotationSpeed3;
				Decal3.m_DecalEmissionStrength = _DecalEmissionStrength3;
				Decal3.m_DecalBlendAlpha = _DecalBlendAlpha3;
				Decal3.m_DecalOverrideAlpha = _DecalOverrideAlpha3;
				Decal3.m_DecalHueShiftEnabled = _DecalHueShiftEnabled3;
				Decal3.m_DecalHueShift = _DecalHueShift3;
				Decal3.m_DecalHueShiftSpeed = _DecalHueShiftSpeed3;
				Decal3.m_DecalDepth = _Decal3Depth;
				Decal3.m_DecalHueAngleStrength = _Decal3HueAngleStrength;
				Decal3.m_DecalChannelSeparationEnable = _Decal3ChannelSeparationEnable;
				Decal3.m_DecalChannelSeparation = _Decal3ChannelSeparation;
				Decal3.m_DecalChannelSeparationPremultiply = _Decal3ChannelSeparationPremultiply;
				Decal3.m_DecalChannelSeparationHue = _Decal3ChannelSeparationHue;
				Decal3.m_DecalChannelSeparationVertical = _Decal3ChannelSeparationVertical;
				Decal3.m_DecalChannelSeparationAngleStrength = _Decal3ChannelSeparationAngleStrength;
				
				Decal3.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal3.m_AudioLinkDecalScaleBand = _AudioLinkDecal3ScaleBand;
				Decal3.m_AudioLinkDecalScale = _AudioLinkDecal3Scale;
				Decal3.m_AudioLinkDecalRotationBand = _AudioLinkDecal3RotationBand;
				Decal3.m_AudioLinkDecalRotation = _AudioLinkDecal3Rotation;
				Decal3.m_AudioLinkDecalAlphaBand = _AudioLinkDecal3AlphaBand;
				Decal3.m_AudioLinkDecalAlpha = _AudioLinkDecal3Alpha;
				Decal3.m_AudioLinkDecalEmissionBand = _AudioLinkDecal3EmissionBand;
				Decal3.m_AudioLinkDecalEmission = _AudioLinkDecal3Emission;
				Decal3.m_DecalRotationCTALBand = _DecalRotationCTALBand3;
				Decal3.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed3;
				Decal3.m_DecalRotationCTALType = _DecalRotationCTALType3;
				Decal3.m_AudioLinkDecalColorChord = _AudioLinkDecalCC3;
				Decal3.m_AudioLinkDecalSideBand = _AudioLinkDecal3SideBand;
				Decal3.m_AudioLinkDecalSideMin = _AudioLinkDecal3SideMin;
				Decal3.m_AudioLinkDecalSideMax = _AudioLinkDecal3SideMax;
				Decal3.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal3ChannelSeparation;
				Decal3.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal3ChannelSeparationBand;
				
				Decal3.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal3ChannelSeparationEnable==0
				if (_Decal3ChannelSeparationEnable)
				{
					Decal3.SampleDecalChannelSeparation(_DecalTexture3, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal3ChannelSeparationEnable==1
				if (!_Decal3ChannelSeparationEnable)
				{
					Decal3.SampleDecal(_DecalTexture3, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal3.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal3.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				if (alphaOverride)
				{
					poiFragData.alpha *= decalAlpha;
				}
				poiFragData.baseColor = saturate(poiFragData.baseColor);
			}
			#endif
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			void applyDissolve(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods, in PoiCam poiCam, in PoiLight poiLight)
			{
				#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
				float dissolveMask = POI2D_SAMPLER_PAN(_DissolveMask, _MainTex, poiUV(poiMesh.uv[_DissolveMaskUV], _DissolveMask_ST), _DissolveMaskPan).r;
				#else
				float dissolveMask = 1;
				#endif
				UNITY_BRANCH
				if (_DissolveUseVertexColors > 0)
				{
					// Vertex Color Imprecision hype
					dissolveMask = ceil(poiMesh.vertexColor[_DissolveUseVertexColors] * 100000) / 100000;
				}
				if (_DissolveMaskGlobalMask > 0)
				{
					dissolveMask = maskBlend(dissolveMask, poiMods.globalMask[_DissolveMaskGlobalMask-1], _DissolveMaskGlobalMaskBlendType);
				}
				
				#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
				dissolveToTexture = POI2D_SAMPLER_PAN(_DissolveToTexture, _MainTex, poiUV(poiMesh.uv[_DissolveToTextureUV], _DissolveToTexture_ST), _DissolveToTexturePan) * float4(poiThemeColor(poiMods, _DissolveTextureColor.rgb, _DissolveTextureColorThemeIndex), _DissolveTextureColor.a);
				#else
				dissolveToTexture = _DissolveTextureColor;
				#endif
				
				#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float dissolveNoiseTexture = POI2D_SAMPLER_PAN(_DissolveNoiseTexture, _MainTex, poiUV(poiMesh.uv[_DissolveNoiseTextureUV], _DissolveNoiseTexture_ST), _DissolveNoiseTexturePan).r;
				#else
				float dissolveNoiseTexture = 1;
				#endif
				
				float da = _DissolveAlpha
				+ _DissolveAlpha0
				+ _DissolveAlpha1
				+ _DissolveAlpha2
				+ _DissolveAlpha3
				+ _DissolveAlpha4
				+ _DissolveAlpha5
				+ _DissolveAlpha6
				+ _DissolveAlpha7
				+ _DissolveAlpha8
				+ _DissolveAlpha9;
				float dds = _DissolveDetailStrength;
				
				if(_UVTileDissolveEnabled)
				{
					float2 udim = floor(poiMesh.uv[(int)_UVTileDissolveUV]);
					
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					da += (udim.y >= 0 && udim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMask);
					da += (udim.y >= 1 && udim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMask);
					da += (udim.y >= 2 && udim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMask);
					da += (udim.y >= 3 && udim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMask);
				}
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (_EnableDissolveAudioLink && poiMods.audioLinkAvailable)
				{
					da += lerp(_AudioLinkDissolveAlpha.x, _AudioLinkDissolveAlpha.y, poiMods.audioLink[_AudioLinkDissolveAlphaBand]);
					dds += lerp(_AudioLinkDissolveDetail.x, _AudioLinkDissolveDetail.y, poiMods.audioLink[_AudioLinkDissolveDetailBand]);
				}
				#endif
				
				da = saturate(da);
				dds = saturate(dds);
				
				if (_DissolveMaskInvert)
				{
					dissolveMask = 1 - dissolveMask;
				}
				#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
				float dissolveDetailNoise = POI2D_SAMPLER_PAN(_DissolveDetailNoise, _MainTex, poiUV(poiMesh.uv[_DissolveDetailNoiseUV], _DissolveDetailNoise_ST), _DissolveDetailNoisePan);
				#else
				float dissolveDetailNoise = 0;
				#endif
				if (_DissolveInvertNoise)
				{
					dissolveNoiseTexture = 1 - dissolveNoiseTexture;
				}
				if (_DissolveInvertDetailNoise)
				{
					dissolveDetailNoise = 1 - dissolveDetailNoise;
				}
				if (_ContinuousDissolve != 0)
				{
					da = sin(_Time.x * _ContinuousDissolve) * .5 + .5;
				}
				da *= dissolveMask;
				dissolveAlpha = da;
				edgeAlpha = 0;
				
				[flatten]
				switch(_DissolveType)
				{
					default: // Basic (case 1)
					{
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						float noise = saturate(dissolveNoiseTexture - dissolveDetailNoise * dds);
						
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
					case 2: // Point to Point
					{
						float3 direction;
						float3 currentPos;
						float distanceTo = 0;
						direction = normalize(_DissolveEndPoint - _DissolveStartPoint);
						currentPos = lerp(_DissolveStartPoint, _DissolveEndPoint, dissolveAlpha);
						
						UNITY_BRANCH
						if (_DissolveP2PWorldLocal != 1)
						{
							float3 pos = _DissolveP2PWorldLocal == 0 ? poiMesh.localPos.rgb : poiMesh.vertexColor.rgb;
							distanceTo = dot(pos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = step(distanceTo, 0);
							edgeAlpha *= 1 - dissolveAlpha;
						}
						else
						{
							distanceTo = dot(poiMesh.worldPos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = (distanceTo < 0) ? 1 : 0;
							edgeAlpha *= 1 - dissolveAlpha;
						}
						
						if(_DissolveP2PClamp)
						{
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 3: // Spherical
					{
						if(_SphericalDissolveInvert)
						{
							da = remap(da, 1, 0, -_DissolveEdgeWidth, 1);
						} else {
							da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						}
						
						dissolveAlpha = da;
						dds *= smoothstep(0, 0.2*dds + 0.01, dissolveAlpha) * lerp(1, smoothstep(1, 1 - 0.2*dds - 0.01, dissolveAlpha), _DissolveDetailEdgeSmoothing);
						float currentDistance = lerp(0, _SphericalDissolveRadius, dissolveAlpha);
						float fragDistance = distance(_SphericalDissolveCenter, poiMesh.localPos.xyz);
						float normalizedDistance;
						normalizedDistance = (fragDistance - currentDistance) / (_SphericalDissolveRadius + 0.0001)  - dissolveDetailNoise * dds;
						
						if(_SphericalDissolveInvert)
						{
							dissolveAlpha = (normalizedDistance > 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, -normalizedDistance);
						} else {
							dissolveAlpha = (normalizedDistance < 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, normalizedDistance);
						}
						
						if(_SphericalDissolveClamp)
						{
							da = lerp(da, 1 - da, _SphericalDissolveInvert);
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 4: // CenterOut
					{
						float ramp = 0.5;
						float noise;
						
						[flatten]
						switch(_CenterOutDissolveMode)
						{
							case 1: // View Direction
							{
								ramp = saturate(lerp(poiLight.vertexNDotV, poiLight.nDotV, _CenterOutDissolveNormals));
								break;
							}
							case 2: // Custom Direction
							{
								ramp = dot(normalize(_CenterOutDissolveDirection), lerp(poiMesh.normals[0], poiMesh.normals[1], _CenterOutDissolveNormals));
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
							case 3: // Light Direction
							{
								ramp = lerp(poiLight.vertexNDotL, poiLight.nDotL, _CenterOutDissolveNormals);
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
						}
						
						if(_CenterOutDissolvePower != 1)
						{
							ramp = pow(ramp, _CenterOutDissolvePower);
						}
						
						if(!_CenterOutDissolveInvert)
						{
							ramp = 1 - ramp;
						}
						
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						
						noise = saturate(ramp - dissolveDetailNoise * dds);
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
				}
				
				#ifndef POI_SHADOW
				UNITY_BRANCH
				if (_DissolveHueShiftEnabled)
				{
					dissolveToTexture.rgb = hueShift(dissolveToTexture.rgb, _DissolveHueShift + _Time.x * _DissolveHueShiftSpeed);
				}
				#endif
				
				poiFragData.alpha = lerp(poiFragData.alpha, dissolveToTexture.a, dissolveAlpha * .999999);
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				poiFragData.baseColor = lerp(poiFragData.baseColor, dissolveToTexture.rgb, dissolveAlpha * .999999);
				
				UNITY_BRANCH
				if (_DissolveEdgeWidth || (_DissolveType == 2 && _DissolveP2PEdgeLength != 0))
				{
					edgeColor = tex2D(_DissolveEdgeGradient, poiUV(float2(edgeAlpha, edgeAlpha), _DissolveEdgeGradient_ST)) * float4(poiThemeColor(poiMods, _DissolveEdgeColor.rgb, _DissolveEdgeColorThemeIndex), _DissolveEdgeColor.a);
					#ifndef POI_SHADOW
					UNITY_BRANCH
					if (_DissolveEdgeHueShiftEnabled)
					{
						edgeColor.rgb = hueShift(edgeColor.rgb, _DissolveEdgeHueShift + _Time.x * _DissolveEdgeHueShiftSpeed);
					}
					#endif
					poiFragData.baseColor = lerp(poiFragData.baseColor, edgeColor.rgb, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				}
				
				poiFragData.emission += lerp(0, dissolveToTexture * _DissolveToEmissionStrength, dissolveAlpha) + lerp(0, edgeColor.rgb * _DissolveEdgeEmission, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				#endif
			}
			#endif
			//endex
			
			//ifex _ShadingEnabled==0
			#ifdef VIGNETTE_MASKED
			
			#ifdef _LIGHTINGMODE_CLOTH
			float V_SmithGGXCorrelated(float roughness, float NoV, float NoL)
			{
				// Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"
				float a2 = roughness * roughness;
				// TODO: lambdaV can be pre-computed for all the lights, it should be moved out of this function
				float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);
				float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);
				float v = 0.5 / (lambdaV + lambdaL);
				// a2=0 => v = 1 / 4*NoL*NoV   => min=1/4, max=+inf
				// a2=1 => v = 1 / 2*(NoL+NoV) => min=1/4, max=+inf
				// clamp to the maximum value representable in mediump
				return v;
			}
			
			float D_GGX(float roughness, float NoH)
			{
				// Walter et al. 2007, "Microfacet Models for Refraction through Rough Surfaces"
				
				// In mediump, there are two problems computing 1.0 - NoH^2
				// 1) 1.0 - NoH^2 suffers floating point cancellation when NoH^2 is close to 1 (highlights)
				// 2) NoH doesn't have enough precision around 1.0
				// Both problem can be fixed by computing 1-NoH^2 in highp and providing NoH in highp as well
				
				// However, we can do better using Lagrange's identity:
				//      ||a x b||^2 = ||a||^2 ||b||^2 - (a . b)^2
				// since N and H are unit vectors: ||N x H||^2 = 1.0 - NoH^2
				// This computes 1.0 - NoH^2 directly (which is close to zero in the highlights and has
				// enough precision).
				// Overall this yields better performance, keeping all computations in mediump
				float oneMinusNoHSquared = 1.0 - NoH * NoH;
				
				float a = NoH * roughness;
				float k = roughness / (oneMinusNoHSquared + a * a);
				float d = k * k * (1.0 / UNITY_PI);
				return d;
			}
			
			// https://github.com/google/filament/blob/main/shaders/src/brdf.fs#L94-L100
			float D_Charlie(float roughness, float NoH)
			{
				// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
				float invAlpha = 1.0 / roughness;
				float cos2h = NoH * NoH;
				float sin2h = max(1.0 - cos2h, 0.0078125); // 0.0078125 = 2^(-14/2), so sin2h^2 > 0 in fp16
				return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * UNITY_PI);
			}
			
			// https://github.com/google/filament/blob/main/shaders/src/brdf.fs#L136-L139
			float V_Neubelt(float NoV, float NoL)
			{
				// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
				return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
			}
			
			float Distribution(float roughness, float NoH, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(GGXTerm(roughness, NoH), D_Charlie(roughness, NoH), cloth);
				}
				//endex
				return cloth <= 0.5 ? GGXTerm(roughness, NoH) : D_Charlie(roughness, NoH);
			}
			
			float Visibility(float roughness, float NoV, float NoL, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(V_SmithGGXCorrelated(roughness, NoV, NoL), V_Neubelt(NoV, NoL), cloth);
				}
				//endex
				return cloth <= 0.5 ? V_SmithGGXCorrelated(roughness, NoV, NoL) : V_Neubelt(NoV, NoL);
			}
			
			float F_Schlick(float3 f0, float f90, float VoH)
			{
				// Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"
				return f0 + (f90 - f0) * pow(1.0 - VoH, 5);
			}
			
			float F_Schlick(float3 f0, float VoH)
			{
				float f = pow(1.0 - VoH, 5.0);
				return f + f0 * (1.0 - f);
			}
			
			float Fresnel(float3 f0, float LoH)
			{
				float f90 = saturate(dot(f0, float(50.0 * 0.33).xxx));
				return F_Schlick(f0, f90, LoH);
			}
			
			float Fd_Burley(float roughness, float NoV, float NoL, float LoH)
			{
				// Burley 2012, "Physically-Based Shading at Disney"
				float f90 = 0.5 + 2.0 * roughness * LoH * LoH;
				float lightScatter = F_Schlick(1.0, f90, NoL);
				float viewScatter = F_Schlick(1.0, f90, NoV);
				return lightScatter * viewScatter;
			}
			
			// Energy conserving wrap diffuse term, does *not* include the divide by PI
			float Fd_Wrap(float NoL, float w)
			{
				return saturate((NoL + w) / pow(1.0 + w, 2));
			}
			
			float4 SampleDFG(float NoV, float perceptualRoughness)
			{
				return _ClothDFG.Sample(sampler_ClothDFG, float3(NoV, perceptualRoughness, 0));
			}
			
			float3 EnvBRDF(float2 dfg, float3 f0)
			{
				return f0 * dfg.x + dfg.y;
			}
			
			float3 EnvBRDFMultiscatter(float3 dfg, float3 f0, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(lerp(dfg.xxx, dfg.yyy, f0), f0 * dfg.z, cloth);
				}
				//endex
				return cloth <= 0.5 ? lerp(dfg.xxx, dfg.yyy, f0) : f0 * dfg.z;
			}
			
			float3 EnvBRDFEnergyCompensation(float3 dfg, float3 f0, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(1.0 + f0 * (1.0 / dfg.y - 1.0), 1, cloth);
				}
				//endex
				return cloth <= 0.5 ? 1.0 + f0 * (1.0 / dfg.y - 1.0) : 1;
			}
			
			//
			float ClothMetallic(float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return cloth;
				}
				//endex
				return cloth <= 0.5 ? 1 : 0;
			}
			
			float3 Specular(float roughness, PoiLight poiLight, float f0, float3 normal, float cloth)
			{
				float NoL = poiLight.nDotLSaturated;
				float NoH = poiLight.nDotH;
				float LoH = poiLight.lDotH;
				float NoV = poiLight.nDotV;
				
				float D = Distribution(roughness, NoH, cloth);
				float V = Visibility(roughness, NoV, NoL, cloth);
				float3 F = Fresnel(f0, LoH);
				
				return (D * V) * F;
			}
			
			float3 getBoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
			{
				#if UNITY_SPECCUBE_BOX_PROJECTION
				if (cubemapPosition.w > 0)
				{
					float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
					float scalar = min(min(factors.x, factors.y), factors.z);
					direction = direction * scalar + (position - cubemapPosition.xyz);
				}
				#endif
				
				return direction;
			}
			
			float SpecularAO(float NoV, float ao, float roughness)
			{
				return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);
			}
			
			float3 IndirectSpecular(float3 dfg, float roughness, float occlusion, float energyCompensation, float cloth, float3 indirectDiffuse, float f0, PoiLight poiLight, PoiFragData poiFragData, PoiCam poiCam, PoiMesh poiMesh)
			{
				float3 normal = poiMesh.normals[1];
				
				float3 reflDir = reflect(-poiCam.viewDir, normal);
				
				Unity_GlossyEnvironmentData envData;
				envData.roughness = roughness;
				envData.reflUVW = getBoxProjection(reflDir, poiMesh.worldPos, unity_SpecCube0_ProbePosition,
				unity_SpecCube0_BoxMin.xyz, unity_SpecCube0_BoxMax.xyz);
				
				float3 probe0 = Unity_GlossyEnvironment(UNITY_PASS_TEXCUBE(unity_SpecCube0), unity_SpecCube0_HDR, envData);
				float3 indirectSpecular = probe0;
				
				#if UNITY_SPECCUBE_BLENDING
				UNITY_BRANCH
				if (unity_SpecCube0_BoxMin.w < 0.99999)
				{
					envData.reflUVW = getBoxProjection(reflDir, poiMesh.worldPos, unity_SpecCube1_ProbePosition, unity_SpecCube1_BoxMin.xyz, unity_SpecCube1_BoxMax.xyz);
					float3 probe1 = Unity_GlossyEnvironment(UNITY_PASS_TEXCUBE_SAMPLER(unity_SpecCube1, unity_SpecCube0), unity_SpecCube1_HDR, envData);
					indirectSpecular = lerp(probe1, probe0, unity_SpecCube0_BoxMin.w);
				}
				#endif
				
				float horizon = min(1 + dot(reflDir, normal), 1);
				indirectSpecular = indirectSpecular * horizon * horizon * energyCompensation * EnvBRDFMultiscatter(dfg, f0, cloth);
				
				indirectSpecular *= SpecularAO(poiLight.nDotV, occlusion, roughness);
				return indirectSpecular;
			};
			#endif
			
			#ifdef _LIGHTINGMODE_WRAPPED
			// Wrapped
			// Green’s model with adjustable energy
			// http://blog.stevemcauley.com/2011/12/03/energy-conserving-wrapped-diffuse/
			// Modified for adjustable conservation ratio and over-wrap to directionless
			float RTWrapFunc(in float dt, in float w, in float norm)
			{
				float cw = saturate(w);
				
				float o = (dt + cw) / ((1.0 + cw) * (1.0 + cw * norm));
				float flt = 1.0 - 0.85 * norm;
				if (w > 1.0)
				{
					o = lerp(o, flt, w - 1.0);
				}
				return o;
			}
			
			float3 GreenWrapSH(float fA) // Greens unoptimized and non-normalized
			
			{
				float fAs = saturate(fA);
				float4 t = float4(fA + 1, fAs - 1, fA - 2, fAs + 1); // DJL edit: allow wrapping to L0-only at w=2
				return float3(t.x, -t.z * t.x / 3, 0.25 * t.y * t.y * t.w);
			}
			float3 GreenWrapSHOpt(float fW) // optimised and normalized https://blog.selfshadow.com/2012/01/07/righting-wrap-part-2/
			
			{
				const float4 t0 = float4(0.0, 1.0 / 4.0, -1.0 / 3.0, -1.0 / 2.0);
				const float4 t1 = float4(1.0, 2.0 / 3.0, 1.0 / 4.0, 0.0);
				float3 fWs = float3(fW, fW, saturate(fW)); // DJL edit: allow wrapping to L0-only at w=2
				
				float3 r;
				r.xyz = t0.xxy * fWs + t0.xzw;
				r.xyz = r.xyz * fWs + t1.xyz;
				return r;
			}
			float3 ShadeSH9_wrapped(float3 normal, float wrap)
			{
				float3 x0, x1, x2;
				float3 conv = lerp(GreenWrapSH(wrap), GreenWrapSHOpt(wrap), _LightingWrappedNormalization); // Should try optimizing this...
				conv *= float3(1, 1.5, 4); // Undo pre-applied cosine convolution by using the inverse
				
				// Constant (L0)
				x0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				// Remove pre-applied constant part from L(2,0) to apply correct convolution
				float3 L2_0 = float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / - 3.0;
				x0 -= L2_0;
				
				// Linear (L1) polynomial terms
				x1.r = dot(unity_SHAr.xyz, normal);
				x1.g = dot(unity_SHAg.xyz, normal);
				x1.b = dot(unity_SHAb.xyz, normal);
				
				// 4 of the quadratic (L2) polynomials
				float4 vB = normal.xyzz * normal.yzzx;
				x2.r = dot(unity_SHBr, vB);
				x2.g = dot(unity_SHBg, vB);
				x2.b = dot(unity_SHBb, vB);
				
				// Final (5th) quadratic (L2) polynomial
				float vC = normal.x * normal.x - normal.y * normal.y;
				x2 += unity_SHC.rgb * vC;
				// Move back the constant part of L(2,0)
				x2 += L2_0;
				
				return x0 * conv.x + x1 * conv.y + x2 * conv.z;
			}
			
			float3 GetSHDirectionL1()
			{
				// For efficiency, we only get the direction from L1.
				// Because getting it from L2 would be too hard!
				return Unity_SafeNormalize((unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz));
			}
			// Returns the value from SH in the lighting direction with the
			// brightest intensity.
			half3 GetSHMaxL1()
			{
				float3 maxDirection = GetSHDirectionL1();
				return ShadeSH9_wrapped(maxDirection, 0);
			}
			#endif
			
			#ifdef _LIGHTINGMODE_SHADEMAP
			void applyShadeMapping(inout PoiFragData poiFragData, PoiMesh poiMesh, inout PoiLight poiLight)
			{
				float shadowAttenuation = lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				float attenuation = 1;
				#if defined(POINT) || defined(SPOT)
				shadowAttenuation = lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
				attenuation = poiLight.attenuation;
				#endif
				
				float MainColorFeatherStep = _BaseColor_Step - _BaseShade_Feather;
				float firstColorFeatherStep = _ShadeColor_Step - _1st2nd_Shades_Feather;
				
				#if defined(PROP_1ST_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
				float4 firstShadeMap = POI2D_SAMPLER_PAN(_1st_ShadeMap, _MainTex, poiUV(poiMesh.uv[_1st_ShadeMapUV], _1st_ShadeMap_ST), _1st_ShadeMapPan);
				#else
				float4 firstShadeMap = float4(1, 1, 1, 1);
				#endif
				firstShadeMap = lerp(firstShadeMap, float4(poiFragData.baseColor, 1), _Use_BaseAs1st);
				
				#if defined(PROP_2ND_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
				float4 secondShadeMap = POI2D_SAMPLER_PAN(_2nd_ShadeMap, _MainTex, poiUV(poiMesh.uv[_2nd_ShadeMapUV], _2nd_ShadeMap_ST), _2nd_ShadeMapPan);
				#else
				float4 secondShadeMap = float4(1, 1, 1, 1);
				#endif
				secondShadeMap = lerp(secondShadeMap, firstShadeMap, _Use_1stAs2nd);
				
				firstShadeMap.rgb *= _1st_ShadeColor.rgb; //* lighColor
				secondShadeMap.rgb *= _2nd_ShadeColor.rgb; //* LightColor;
				
				float shadowMask = 1;
				shadowMask *= _Use_1stShadeMapAlpha_As_ShadowMask ? (_1stShadeMapMask_Inverse ? (1.0 - firstShadeMap.a) : firstShadeMap.a) : 1;
				shadowMask *= _Use_2ndShadeMapAlpha_As_ShadowMask ? (_2ndShadeMapMask_Inverse ? (1.0 - secondShadeMap.a) : secondShadeMap.a) : 1;
				
				float mainShadowMask = saturate(1 - ((poiLight.lightMap) - MainColorFeatherStep) / (_BaseColor_Step - MainColorFeatherStep) * (shadowMask));
				float firstSecondShadowMask = saturate(1 - ((poiLight.lightMap) - firstColorFeatherStep) / (_ShadeColor_Step - firstColorFeatherStep) * (shadowMask));
				
				mainShadowMask *= poiLight.shadowMask * _ShadowStrength;
				firstSecondShadowMask *= poiLight.shadowMask * _ShadowStrength;
				
				// 0 lerp | 1 multiply
				if (_ShadingShadeMapBlendType == 0)
				{
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, lerp(firstShadeMap.rgb, secondShadeMap.rgb, firstSecondShadowMask), mainShadowMask) * attenuation;
				}
				else
				{
					poiFragData.baseColor.rgb *= lerp(1, lerp(firstShadeMap.rgb, secondShadeMap.rgb, firstSecondShadowMask), mainShadowMask) * attenuation;
				}
				poiLight.rampedLightMap = 1 - mainShadowMask;
			}
			#endif
			
			#ifdef _LIGHTINGMODE_REALISTIC
			// For https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html
			#if defined(LIGHTMAP_ON) && defined(SHADOWS_SCREEN)
			#if defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK)
			#define SUBTRACTIVE_LIGHTING 1
			#endif
			#endif
			
			void ApplySubtractiveLighting(inout UnityIndirect indirectLight)
			{
				#if SUBTRACTIVE_LIGHTING
				poiLight.attenuation = FadeShadows(lerp(1, poiLight.attenuation, _AttenuationMultiplier));
				
				float ndotl = saturate(dot(i.normal, _WorldSpaceLightPos0.xyz));
				float3 shadowedLightEstimate = ndotl * (1 - poiLight.attenuation) * _LightColor0.rgb;
				float3 subtractedLight = indirectLight.diffuse - shadowedLightEstimate;
				subtractedLight = max(subtractedLight, unity_ShadowColor.rgb);
				subtractedLight = lerp(subtractedLight, indirectLight.diffuse, _LightShadowData.x);
				indirectLight.diffuse = min(subtractedLight, indirectLight.diffuse);
				#endif
			}
			
			UnityIndirect CreateIndirectLight(in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight)
			{
				UnityIndirect indirectLight;
				indirectLight.diffuse = 0;
				indirectLight.specular = 0;
				
				#if defined(LIGHTMAP_ON)
				indirectLight.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, poiMesh.lightmapUV.xy));
				
				#if defined(DIRLIGHTMAP_COMBINED)
				float4 lightmapDirection = UNITY_SAMPLE_TEX2D_SAMPLER(
				unity_LightmapInd, unity_Lightmap, poiMesh.lightmapUV.xy
				);
				indirectLight.diffuse = DecodeDirectionalLightmap(
				indirectLight.diffuse, lightmapDirection, poiMesh.normals[1]
				);
				#endif
				ApplySubtractiveLighting(indirectLight);
				#endif
				
				#if defined(DYNAMICLIGHTMAP_ON)
				float3 dynamicLightDiffuse = DecodeRealtimeLightmap(
				UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, poiMesh.lightmapUV.zw)
				);
				
				#if defined(DIRLIGHTMAP_COMBINED)
				float4 dynamicLightmapDirection = UNITY_SAMPLE_TEX2D_SAMPLER(
				unity_DynamicDirectionality, unity_DynamicLightmap,
				poiMesh.lightmapUV.zw
				);
				indirectLight.diffuse += DecodeDirectionalLightmap(
				dynamicLightDiffuse, dynamicLightmapDirection, poiMesh.normals[1]
				);
				#else
				indirectLight.diffuse += dynamicLightDiffuse;
				#endif
				#endif
				
				#if !defined(LIGHTMAP_ON) && !defined(DYNAMICLIGHTMAP_ON)
				#if UNITY_LIGHT_PROBE_PROXY_VOLUME
				if (unity_ProbeVolumeParams.x == 1)
				{
					indirectLight.diffuse = SHEvalLinearL0L1_SampleProbeVolume(
					float4(poiMesh.normals[1], 1), poiMesh.worldPos
					);
					indirectLight.diffuse = max(0, indirectLight.diffuse);
					#if defined(UNITY_COLORSPACE_GAMMA)
					indirectLight.diffuse = LinearToGammaSpace(indirectLight.diffuse);
					#endif
				}
				else
				{
					indirectLight.diffuse += max(0, ShadeSH9(float4(poiMesh.normals[1], 1)));
				}
				#else
				indirectLight.diffuse += max(0, ShadeSH9(float4(poiMesh.normals[1], 1)));
				#endif
				#endif
				
				indirectLight.diffuse *= poiLight.occlusion;
				
				return indirectLight;
			}
			#endif
			
			void calculateShading(inout PoiLight poiLight, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam)
			{
				float shadowAttenuation = lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				float attenuation = 1;
				#if defined(POINT) || defined(SPOT)
				shadowAttenuation = lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
				attenuation = poiLight.attenuation;
				#endif
				
				#ifdef UNITY_PASS_FORWARDADD
				if (_LightingAdditiveType == 0) // Realistic
				{
					poiLight.rampedLightMap = max(0, poiLight.nDotL);
					poiLight.finalLighting = poiLight.directColor * attenuation * max(0, poiLight.nDotL) * poiLight.detailShadow * shadowAttenuation;
					return;
				}
				else if (_LightingAdditiveType == 1) // Toon
				{
					#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
					float passthrough = 0;
					#else
					float passthrough = _LightingAdditivePassthrough;
					#endif
					
					if (_LightingAdditiveGradientEnd == _LightingAdditiveGradientStart) _LightingAdditiveGradientEnd += 0.001;
					
					poiLight.rampedLightMap = smoothstep(_LightingAdditiveGradientEnd, _LightingAdditiveGradientStart, 1 - (.5 * poiLight.nDotL + .5));
					#if defined(POINT) || defined(SPOT)
					poiLight.finalLighting = lerp(poiLight.directColor * max(min(poiLight.additiveShadow, poiLight.detailShadow), passthrough), poiLight.indirectColor, smoothstep(_LightingAdditiveGradientStart, _LightingAdditiveGradientEnd, 1 - (.5 * poiLight.nDotL + .5))) * poiLight.attenuation;
					#else
					poiLight.finalLighting = lerp(poiLight.directColor * max(min(poiLight.attenuation, poiLight.detailShadow), passthrough), poiLight.indirectColor, smoothstep(_LightingAdditiveGradientStart, _LightingAdditiveGradientEnd, 1 - (.5 * poiLight.nDotL + .5)));
					#endif
					return;
				}
				#endif
				
				float shadowStrength = _ShadowStrength * poiLight.shadowMask;
				
				#ifdef POI_PASS_OUTLINE
				shadowStrength = lerp(0, shadowStrength, _OutlineShadowStrength);
				#endif
				
				// These blocks shouldn't need ifex, they should be removed on lock when their keywords aren't present
				
				#ifdef _LIGHTINGMODE_FLAT
				poiLight.finalLighting = poiLight.directColor * attenuation * shadowAttenuation;
				poiLight.rampedLightMap = poiLight.nDotLSaturated;
				#endif
				
				#ifdef _LIGHTINGMODE_TEXTURERAMP
				poiLight.rampedLightMap = lerp(1, UNITY_SAMPLE_TEX2D(_ToonRamp, poiLight.lightMap + _ShadowOffset).rgb, shadowStrength);
				poiLight.finalLighting = lerp(_LightingShadowColor * lerp(poiLight.indirectColor, poiLight.rampedLightMap * poiLight.directColor, _LightingIgnoreAmbientColor) * poiLight.occlusion, poiLight.directColor, poiLight.rampedLightMap) * attenuation;
				#endif
				
				#ifdef _LIGHTINGMODE_MULTILAYER_MATH
				#if defined(PROP_MULTILAYERMATHBLURMAP) || !defined(OPTIMIZER_ENABLED)
				float4 blurMap = POI2D_SAMPLER_PAN(_MultilayerMathBlurMap, _MainTex, poiUV(poiMesh.uv[_MultilayerMathBlurMapUV], _MultilayerMathBlurMap_ST), _MultilayerMathBlurMapPan);
				#else
				float4 blurMap = 1;
				#endif
				
				float4 lns = float4(1, 1, 1, 1);
				
				float3 lightMap = poiLight.lightMapNoAttenuation.xxx;
				lightMap.x *= lerp(1.0, poiLight.attenuation, _ShadowReceive);
				lightMap.y *= lerp(1.0, poiLight.attenuation, _Shadow2ndReceive);
				lightMap.z *= lerp(1.0, poiLight.attenuation, _Shadow3rdReceive);
				
				if (_LightingMulitlayerNonLinear)
				{
					lns.x = poiEdgeNonLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r);
					lns.y = poiEdgeNonLinearNoSaturate(lightMap.y, _Shadow2ndBorder, _Shadow2ndBlur * blurMap.g);
					lns.z = poiEdgeNonLinearNoSaturate(lightMap.z, _Shadow3rdBorder, _Shadow3rdBlur * blurMap.b);
					lns.w = poiEdgeNonLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r, _ShadowBorderRange);
				}
				else
				{
					lns.x = poiEdgeLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r);
					lns.y = poiEdgeLinearNoSaturate(lightMap.y, _Shadow2ndBorder, _Shadow2ndBlur * blurMap.g);
					lns.z = poiEdgeLinearNoSaturate(lightMap.z, _Shadow3rdBorder, _Shadow3rdBlur * blurMap.b);
					lns.w = poiEdgeLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r, _ShadowBorderRange);
				}
				lns = saturate(lns);
				
				float3 indirectColor = 1;
				
				if (_ShadowColor.a > 0)
				{
					#if defined(PROP_SHADOWCOLORTEX) || !defined(OPTIMIZER_ENABLED)
					float4 shadowColorTex = POI2D_SAMPLER_PAN(_ShadowColorTex, _MainTex, poiUV(poiMesh.uv[_ShadowColorTexUV], _ShadowColorTex_ST), _ShadowColorTexPan);
					#else
					float4 shadowColorTex = float4(1, 1, 1, 1);
					#endif
					indirectColor = lerp(float3(1, 1, 1), shadowColorTex.rgb, shadowColorTex.a) * _ShadowColor.rgb;
				}
				if (_Shadow2ndColor.a > 0)
				{
					#if defined(PROP_SHADOW2NDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
					float4 shadow2ndColorTex = POI2D_SAMPLER_PAN(_Shadow2ndColorTex, _MainTex, poiUV(poiMesh.uv[_Shadow2ndColorTexUV], _Shadow2ndColorTex_ST), _Shadow2ndColorTexPan);
					#else
					float4 shadow2ndColorTex = float4(1, 1, 1, 1);
					#endif
					shadow2ndColorTex.rgb = lerp(float3(1, 1, 1), shadow2ndColorTex.rgb, shadow2ndColorTex.a) * _Shadow2ndColor.rgb;
					lns.y = _Shadow2ndColor.a - lns.y * _Shadow2ndColor.a;
					indirectColor = lerp(indirectColor, shadow2ndColorTex.rgb, lns.y);
				}
				if (_Shadow3rdColor.a > 0)
				{
					#if defined(PROP_SHADOW3RDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
					float4 shadow3rdColorTex = POI2D_SAMPLER_PAN(_Shadow3rdColorTex, _MainTex, poiUV(poiMesh.uv[_Shadow3rdColorTexUV], _Shadow3rdColorTex_ST), _Shadow3rdColorTexPan);
					#else
					float4 shadow3rdColorTex = float4(1, 1, 1, 1);
					#endif
					shadow3rdColorTex.rgb = lerp(float3(1, 1, 1), shadow3rdColorTex.rgb, shadow3rdColorTex.a) * _Shadow3rdColor.rgb;
					lns.z = _Shadow3rdColor.a - lns.z * _Shadow3rdColor.a;
					indirectColor = lerp(indirectColor, shadow3rdColorTex.rgb, lns.z);
				}
				
				indirectColor = lerp(indirectColor, indirectColor * poiFragData.baseColor, _ShadowMainStrength);
				poiLight.rampedLightMap = lns.x;
				indirectColor = lerp(indirectColor, 1, lns.w * _ShadowBorderColor.rgb);
				indirectColor = indirectColor * lerp(poiLight.indirectColor, poiLight.directColor, _LightingIgnoreAmbientColor);
				indirectColor = lerp(poiLight.directColor, indirectColor, shadowStrength * poiLight.shadowMask);
				poiLight.finalLighting = lerp(indirectColor, poiLight.directColor, lns.x) * attenuation;
				#endif
				
				#ifdef _LIGHTINGMODE_SHADEMAP
				poiLight.finalLighting = poiLight.directColor;
				#endif
				
				#ifdef _LIGHTINGMODE_REALISTIC
				UnityLight light;
				light.dir = poiLight.direction;
				light.color = saturate(_LightColor0.rgb * shadowAttenuation * attenuation * poiLight.detailShadow);
				light.ndotl = poiLight.nDotLSaturated;
				UnityIndirect indirectLight = (UnityIndirect)0;
				#ifdef UNITY_PASS_FORWARDBASE
				indirectLight = CreateIndirectLight(poiMesh, poiCam, poiLight);
				#endif
				#ifdef UNITY_PASS_FORWARDBASE
				light.color = max(light.color * _PPLightingMultiplier, 0);
				light.color = max(light.color + _PPLightingAddition, 0);
				indirectLight.diffuse = max(indirectLight.diffuse * _PPLightingMultiplier, 0);
				indirectLight.diffuse = max(indirectLight.diffuse + _PPLightingAddition, 0);
				#endif
				
				poiLight.rampedLightMap = poiLight.nDotLSaturated;
				poiLight.finalLighting = max(UNITY_BRDF_PBS(1, 0, 0, 0, poiMesh.normals[1], poiCam.viewDir, light, indirectLight).xyz, _LightingMinLightBrightness);
				#endif
				
				#ifdef _LIGHTINGMODE_CLOTH
				#if defined(PROP_CLOTHMETALLICSMOOTHNESSMAP) || !defined(OPTIMIZER_ENABLED)
				float4 clothmapsample = POI2D_SAMPLER_PAN(_ClothMetallicSmoothnessMap, _MainTex, poiUV(poiMesh.uv[_ClothMetallicSmoothnessMapUV], _ClothMetallicSmoothnessMap_ST), _ClothMetallicSmoothnessMapPan);
				float roughness = 1 - (clothmapsample.a * _ClothSmoothness);
				float reflectance = _ClothReflectance * clothmapsample.b;
				float clothmask = clothmapsample.g;
				float metallic = pow(clothmapsample.r * _ClothMetallic, 2) * ClothMetallic(clothmask);
				roughness = _ClothMetallicSmoothnessMapInvert == 1 ? 1 - roughness : roughness;
				#else
				float roughness = 1 - (_ClothSmoothness);
				float metallic = pow(_ClothMetallic, 2);
				float reflectance = _ClothReflectance;
				float clothmask = 1;
				#endif
				
				float perceptualRoughness = pow(roughness, 2);
				float clampedRoughness = max(0.002, perceptualRoughness);
				
				float f0 = 0.16 * reflectance * reflectance * (1 - metallic) + poiFragData.baseColor * metallic;
				float3 fresnel = Fresnel(f0, poiLight.nDotV);
				
				float3 dfg = SampleDFG(poiLight.nDotV, perceptualRoughness);
				
				float energyCompensation = EnvBRDFEnergyCompensation(dfg, f0, clothmask);
				
				poiLight.finalLighting = Fd_Burley(perceptualRoughness, poiLight.nDotV, poiLight.nDotLSaturated, poiLight.lDotH);
				poiLight.finalLighting *= _LightColor0 * attenuation * shadowAttenuation * poiLight.nDotLSaturated;
				float3 specular = max(0, Specular(clampedRoughness, poiLight, f0, poiMesh.normals[1], clothmask) * poiLight.finalLighting * energyCompensation * UNITY_PI); // (D * V) * F
				
				#ifdef UNITY_PASS_FORWARDBASE
				float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				float3 indirectDiffuse;
				indirectDiffuse.r = shEvaluateDiffuseL1Geomerics_local(L0.r, unity_SHAr.xyz, poiMesh.normals[1]);
				indirectDiffuse.g = shEvaluateDiffuseL1Geomerics_local(L0.g, unity_SHAg.xyz, poiMesh.normals[1]);
				indirectDiffuse.b = shEvaluateDiffuseL1Geomerics_local(L0.b, unity_SHAb.xyz, poiMesh.normals[1]);
				indirectDiffuse = max(0, indirectDiffuse);
				
				float3 indirectSpecular = IndirectSpecular(dfg, roughness, poiLight.occlusion, energyCompensation, clothmask, indirectDiffuse, f0, poiLight, poiFragData, poiCam, poiMesh);
				poiLight.finalLightAdd += max(0, specular + indirectSpecular);
				poiLight.finalLighting += indirectDiffuse * poiLight.occlusion;
				#endif
				
				poiFragData.baseColor.xyz *= (1 - metallic);
				#endif
				
				#ifdef _LIGHTINGMODE_WRAPPED
				#define GREYSCALE_VECTOR float3(.33333, .33333, .33333)
				float3 directColor = _LightColor0.rgb * saturate(RTWrapFunc(poiLight.nDotL, _LightingWrappedWrap, _LightingWrappedNormalization)) * shadowAttenuation;
				float3 indirectColor = 0;
				#ifdef UNITY_PASS_FORWARDBASE
				indirectColor = ShadeSH9_wrapped(poiMesh.normals[_LightingIndirectUsesNormals], _LightingWrappedWrap) * poiLight.occlusion;
				#endif
				directColor = lerp(directColor, dot(directColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic); // Duplicated from Lightdata due to recreating the light colour
				indirectColor = lerp(indirectColor, dot(indirectColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic); // Ditto^
				
				float3 ShadeSH9Plus_2 = GetSHMaxL1();
				float bw_topDirectLighting_2 = dot(_LightColor0.rgb, GREYSCALE_VECTOR);
				float bw_directLighting = dot(directColor, GREYSCALE_VECTOR);
				float bw_indirectLighting = dot(indirectColor, GREYSCALE_VECTOR);
				float bw_topIndirectLighting = dot(ShadeSH9Plus_2, GREYSCALE_VECTOR);
				
				indirectColor = lerp(indirectColor, 1, _LightingIgnoreAmbientColor);
				
				poiLight.lightMap = smoothstep(0, bw_topIndirectLighting + bw_topDirectLighting_2, bw_indirectLighting + bw_directLighting) * poiLight.detailShadow;
				poiLight.rampedLightMap = saturate((poiLight.lightMap - (1 - _LightingGradientEnd)) / saturate((1 - _LightingGradientStart) - (1 - _LightingGradientEnd) + fwidth(poiLight.lightMap)));
				float3 mathRamp = lerp(float3(1, 1, 1), saturate(lerp((_LightingShadowColor * indirectColor), float3(1, 1, 1), saturate(poiLight.rampedLightMap))), _ShadowStrength);
				
				float3 finalWrap = directColor + indirectColor;
				if (_LightingCapEnabled)
				{
					finalWrap = clamp(finalWrap, _LightingMinLightBrightness, _LightingCap);
				}
				else
				{
					finalWrap = max(finalWrap, _LightingMinLightBrightness);
				}
				finalWrap *= attenuation;
				poiLight.finalLighting = finalWrap * saturate(mathRamp + 1 - _ShadowStrength);
				#endif
				
				#ifdef _LIGHTINGMODE_SKIN
				float3 ambientNormalWorld = poiMesh.normals[1];//aTangentToWorld(s, s.blurredNormalTangent);
				poiLight.rampedLightMap = poiLight.nDotLSaturated;
				
				// Scattering mask.
				#if defined(PROP_SKINTHICKNESS) || !defined(OPTIMIZER_ENABLED)
				float subsurface = 1 - POI2D_SAMPLER_PAN(_SkinThicknessMap, _MainTex, poiUV(poiMesh.uv[_SkinThicknessMapUV], _SkinThicknessMap_ST), _SkinThicknessMapPan).r;
				#else
				float subsurface = 1;
				#endif
				if (_SkinThicknessMapInvert)
				{
					subsurface = 1 - subsurface;
				}
				if (_SkinThicknessPower != 1)
				{
					subsurface = pow(subsurface, _SkinThicknessPower);
				}
				float skinScattering = saturate(subsurface * _SssScale * 2);
				
				// Skin subsurface depth absorption tint.
				// cf http://www.crytek.com/download/2014_03_25_CRYENGINE_GDC_Schultz.pdf pg 35
				// link dead, https://ia600902.us.archive.org/25/items/crytek_presentations/2014_03_25_CRYENGINE_GDC_Schultz.pdf
				half3 absorption = exp((1.0h - subsurface) * _SssTransmissionAbsorption.rgb);
				
				// Albedo scale for absorption assumes ~0.5 luminance for Caucasian skin.
				absorption *= saturate(poiFragData.baseColor * unity_ColorSpaceDouble.rgb);
				
				// Blurred normals for indirect diffuse and direct scattering.
				ambientNormalWorld = normalize(lerp(poiMesh.normals[1], ambientNormalWorld, _SssBumpBlur));
				
				float ndlBlur = dot(poiMesh.normals[1], poiLight.direction) * 0.5h + 0.5h;
				float lumi = dot(poiLight.directColor, half3(0.2126h, 0.7152h, 0.0722h));
				float4 sssLookupUv = float4(ndlBlur, skinScattering * lumi, 0.0f, 0.0f);
				half3 sss = poiLight.lightMap * tex2Dlod(_SkinLUT, sssLookupUv).rgb;
				poiLight.finalLighting = lerp(poiLight.directColor, min(lerp(poiLight.indirectColor * _LightingShadowColor, _LightingShadowColor, _LightingIgnoreAmbientColor) * poiLight.occlusion + (sss * poiLight.directColor), poiLight.directColor), _ShadowStrength) * attenuation;
				#endif
				
				#ifdef _LIGHTINGMODE_SDF
				float3 forward = normalize(UnityObjectToWorldDir(float4(_SDFForward.xyz, 1)));
				float3 left = normalize(UnityObjectToWorldDir(float4(_SDFLeft.xyz, 1)));
				float3 lightDirHorizontal = normalize(float3(poiLight.direction.x, 0, poiLight.direction.z));
				
				float lightAtten = 1 - (dot(lightDirHorizontal, forward) * 0.5 + 0.5);
				float filpU = sign(dot(lightDirHorizontal, left));
				
				#if defined(PROP_SDFSHADINGTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float shadowSDF = POI2D_SAMPLER_PAN(_SDFShadingTexture, _MainTex, poiUV(poiMesh.uv[_SDFShadingTextureUV], _SDFShadingTexture_ST) * float2(filpU, 1), _SDFShadingTexturePan).r;
				#else
				float shadowSDF = float2(1, 1);
				#endif
				float blur = _SDFBlur * 0.1;
				float faceShadow = smoothstep(lightAtten - blur, lightAtten + blur, shadowSDF) * poiLight.detailShadow;
				
				float3 indirectColor = _LightingShadowColor.rgb;
				indirectColor = indirectColor * lerp(poiLight.indirectColor, poiLight.directColor, _LightingIgnoreAmbientColor);
				indirectColor = lerp(poiLight.directColor, indirectColor, _ShadowStrength * poiLight.shadowMask);
				
				poiLight.finalLighting = lerp(indirectColor, poiLight.directColor, faceShadow) * attenuation;
				#endif
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					float3 vertexLighting = float3(0, 0, 0);
					for (int index = 0; index < 4; index++)
					{
						//UNITY_BRANCH
						if (_LightingAdditiveType == 0 || _LightingAdditiveType == 3)
						{
							vertexLighting += poiLight.vColor[index] * poiLight.vAttenuationDotNL[index] * poiLight.detailShadow; // Realistic
							
						}
						
						//UNITY_BRANCH
						if (_LightingAdditiveType == 1) // Toon
						
						{
							vertexLighting += lerp(poiLight.vColor[index] * poiLight.vAttenuation[index], poiLight.vColor[index] * _LightingAdditivePassthrough * poiLight.vAttenuation[index], smoothstep(_LightingAdditiveGradientStart, _LightingAdditiveGradientEnd, 1 - (.5 * poiLight.vDotNL[index] + .5))) * poiLight.detailShadow;
						}
						//UNITY_BRANCH
						/*
						if (_LightingAdditiveType == 2) //if(_LightingAdditiveType == 2) // Wrapped
						
						{
							float uv = saturate(RTWrapFunc(-poiLight.vDotNL[index], _LightingWrappedWrap, _LightingWrappedNormalization)) * poiLight.detailShadow;
							poiLight.rampedLightMap = lerp(_LightingShadowColor, float3(1, 1, 1), saturate(1 - smoothstep(_LightingGradientStart - .000001, _LightingGradientEnd, 1 - uv)));
							vertexLighting += poiLight.vColor[index] * poiLight.rampedLightMap * saturate(poiLight.vAttenuation[index] * uv);
						}
						*/
					}
					float3 mixedLight = poiLight.finalLighting;
					poiLight.finalLighting = vertexLighting + poiLight.finalLighting;
					#endif
				}
			}
			#endif
			//endex
			
			//ifex _EnableAniso==0
			#ifdef POI_ANISOTROPICS
			/*
			float D_GGX_Anisotropic(float at, float ab, float TdotH, float BdotH, float NdotH)
			{
				// Burley 2012, "Physically-Based Shading at Disney"
				
				// The values at and ab are perceptualRoughness^2, a2 is therefore perceptualRoughness^4
				// The dot product below computes perceptualRoughness^8. We cannot fit in fp16 without clamping
				// the roughness to too high values so we perform the dot product and the division in fp32
				float a2 = at * ab;
				float3 d = float3(ab * TdotH, at * BdotH, a2 * NdotH);
				float d2 = dot(d, d);
				float b2 = a2 / d2;
				return a2 * b2 * b2 * (1.0 / UNITY_PI);
			}
			
			//-------------------------------------GGX Anisotropic visibility function
			float V_SmithGGXCorrelated_Anisotropic(float at, float ab, float TdotV, float BdotV, float TdotL, float BdotL, float NdotV, float NdotL)
			{
				// Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"
				float lambdaV = NdotL * length(float3(at * TdotV, ab * BdotV, NdotV));
				float lambdaL = NdotV * length(float3(at * TdotL, ab * BdotL, NdotL));
				return 0.5 / (lambdaV + lambdaL);
			}
			*/
			
			float calculateAnisotropics(float3 binormal, float offset, float3 normal, float3 viewDir, float3 LightDirection, float exponent, float strength, float shadowMask)
			{
				float3 ShiftedTangent = normalize(binormal + offset * normal);
				float3 H = normalize(LightDirection + viewDir);
				float dotTH = dot(ShiftedTangent, H);
				float sinTH = sqrt(1.0 - dotTH * dotTH);
				float dirAtten = smoothstep(-1.0, 0.0, dotTH);
				return saturate(dirAtten * pow(sinTH, exponent) * strength) * shadowMask;
			}
			
			float aaEdgeFeather(float value, float edge, float feather)
			{
				float edgeMin = saturate(edge - feather * 0.5);
				float edgeMax = saturate(edge + feather * 0.5);
				return saturate((value - edgeMin) / saturate(edgeMax - edgeMin + fwidth(value)));
			}
			
			float3 applyAnisotropics(inout PoiFragData poiFragData, inout PoiLight poiLight, in PoiCam poiCam, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_ANISOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				float4 specMap = POI2D_SAMPLER_PAN(_AnisoColorMap, _MainTex, poiUV(poiMesh.uv[_AnisoColorMapUV], _AnisoColorMap_ST), _AnisoColorMapPan);
				#else
				float4 specMap = float4(1, 1, 1, 0);
				#endif
				
				float shadowMask = lerp(1, poiMax(poiLight.rampedLightMap), _AnisoHideInShadow);
				#ifdef POI_PASS_ADD
				shadowMask *= poiLight.attenuation * poiLight.additiveShadow;
				#endif
				
				float spec0 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso0SwitchDirection), _Aniso0Offset +_Aniso0OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.direction, _Aniso0Power * 1000, _Aniso0Strength, shadowMask);
				float spec1 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso1SwitchDirection), _Aniso1Offset +_Aniso1OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.direction, _Aniso1Power * 1000, _Aniso1Strength, shadowMask);
				
				spec0 = lerp(spec0, aaEdgeFeather(spec0, _Aniso0Edge, _Aniso0Blur), _Aniso0ToonMode);
				spec1 = lerp(spec1, aaEdgeFeather(spec1, _Aniso1Edge, _Aniso1Blur), _Aniso1ToonMode);
				
				float3 spec0Color = specMap.rgb * _Aniso0Tint;
				float3 spec1Color = specMap.rgb * _Aniso1Tint;
				
				float3 finalSpec = saturate(saturate(spec0 * spec0Color) + saturate(spec1 * spec1Color)) * lerp(1, poiFragData.baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor);
				float3 baseColor = poiFragData.baseColor;
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, spec1Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor), _AnisoReplace * spec1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, spec0Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor), _AnisoReplace * spec0);
				poiLight.finalLightAdd += max(0, finalSpec * _AnisoAdd);
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						float vSpec0 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso0SwitchDirection), _Aniso0Offset +_Aniso0OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.vDirection[index], _Aniso0Power * 1000, _Aniso0Strength, poiLight.vAttenuationDotNL[index]);
						float vSpec1 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso1SwitchDirection), _Aniso1Offset +_Aniso1OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.vDirection[index], _Aniso1Power * 1000, _Aniso1Strength, poiLight.vAttenuationDotNL[index]);
						
						vSpec0 = lerp(vSpec0, aaEdgeFeather(vSpec0, _Aniso0Edge, _Aniso0Blur), _Aniso0ToonMode);
						vSpec1 = lerp(vSpec1, aaEdgeFeather(vSpec1, _Aniso1Edge, _Aniso1Blur), _Aniso1ToonMode);
						
						float3 vSpec0Color = specMap.rgb * _Aniso0Tint;
						float3 vSpec1Color = specMap.rgb * _Aniso1Tint;
						
						poiLight.finalLightAdd += max(0, saturate(saturate(vSpec0 * spec0Color) + saturate(vSpec1 * spec1Color)) * lerp(1, poiFragData.baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor) * _AnisoAdd);
						
						poiFragData.baseColor = lerp(poiFragData.baseColor, spec1Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor), _AnisoReplace * vSpec1);
						poiFragData.baseColor = lerp(poiFragData.baseColor, spec0Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor), _AnisoReplace * vSpec0);
					}
					#endif
				}
				
				//ifex _AnisoDebugToggle==0
				if(_AnisoDebugToggle)
				{
					switch(_AnisoDebugMode)
					{
						// final Spec
						case 1:
						{
							return finalSpec;
							break;
						}
						case 2:
						{
							return spec0 * spec0Color;
							break;
						}
						case 3:
						{
							return spec1 * spec1Color;
							break;
						}
					}
				}
				//endex
				
				return float3(0, 0, 0);
			}
			#endif
			//endex
			
			//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
			void blendMatcap(inout PoiLight poiLight, inout PoiFragData poiFragData, in PoiMods poiMods, float add, float lightAdd, float multiply, float replace, float mixed, float screen, float4 matcapColor, float matcapMask, float emissionStrength, float matcapLightMask, uint globalMaskIndex, float globalMaskBlendType)
			{
				if (matcapLightMask)
				{
					matcapMask *= lerp(1, poiLight.rampedLightMap, matcapLightMask);
				}
				if (globalMaskIndex > 0)
				{
					matcapMask = maskBlend(matcapMask, poiMods.globalMask[globalMaskIndex - 1], globalMaskBlendType);
				}
				
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, matcapColor.rgb, replace * matcapMask * matcapColor.a * .999999);
				poiFragData.baseColor.rgb *= lerp(1, matcapColor.rgb, multiply * matcapMask * matcapColor.a);
				poiFragData.baseColor.rgb += matcapColor.rgb * add * matcapMask * matcapColor.a;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, blendScreen(poiFragData.baseColor.rgb, matcapColor.rgb), screen * matcapMask * matcapColor.a);
				poiLight.finalLightAdd += matcapColor.rgb * lightAdd * matcapMask * matcapColor.a;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * matcapColor.rgb, mixed * matcapMask * matcapColor.a);
				poiFragData.emission += matcapColor.rgb * emissionStrength * matcapMask * matcapColor.a;
			}
			//endex
			//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
			#if defined(POI_MATCAP0) || defined(COLOR_GRADING_HDR_3D) || defined(POI_MATCAP2) || defined(POI_MATCAP3)
			void applyMatcap(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiMods poiMods)
			{
				float4 matcap = 0;
				float matcapMask = 0;
				float4 matcap2 = 0;
				float matcap2Mask = 0;
				float4 matcap3 = 0;
				float matcap3Mask = 0;
				float4 matcap4 = 0;
				float matcap4Mask = 0;
				float2 matcapUV = 0;
				//endex
				
				//ifex _MatcapEnable==0
				// Matcap 1
				#ifdef POI_MATCAP0
				float3 normal0 = poiMesh.normals[_MatcapNormal];
				#ifdef POI_MATCAP0_CUSTOM_NORMAL
				#if defined(PROP_MATCAP0NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal0 = calculateNormal(poiMesh.normals[_MatcapNormal], poiMesh, _Matcap0NormalMap, _Matcap0NormalMap_ST, _Matcap0NormalMapPan, _Matcap0NormalMapUV, _Matcap0NormalMapScale);
				#endif
				#endif
				
				switch(_MatcapUVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal0, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _MatcapBorder + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal0), dot(worldViewUp, normal0)) * _MatcapBorder + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal0);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _MatcapBorder + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_MatcapUVToBlend], _MatCapBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _MatcapRotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcapSmoothness;
				float mipCount0 = 9;
				if (_MatcapSmoothnessEnabled)
				{
					if (_Matcap_TexelSize.z == 8192) mipCount0 = 13;
					if (_Matcap_TexelSize.z == 4096) mipCount0 = 12;
					if (_Matcap_TexelSize.z == 2048) mipCount0 = 11;
					if (_Matcap_TexelSize.z == 1024) mipCount0 = 10;
					if (_Matcap_TexelSize.z == 512) mipCount0 = 9;
					if (_Matcap_TexelSize.z == 256) mipCount0 = 8;
					if (_Matcap_TexelSize.z == 128) mipCount0 = 7;
					if (_Matcap_TexelSize.z == 64) mipCount0 = 6;
					if (_Matcap_TexelSize.z == 32) mipCount0 = 5;
					
					matcapSmoothness = _MatcapSmoothness;
					
					if (_MatcapMaskSmoothnessApply)
					{
						#if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
						matcapSmoothness *= POI2D_SAMPLER_PAN(_MatcapMask, _MainTex, poiUV(poiMesh.uv[_MatcapMaskUV], _MatcapMask_ST), _MatcapMaskPan)[_MatcapMaskSmoothnessChannel];
						#endif
					}
					matcapSmoothness = (1 - matcapSmoothness) * mipCount0;
				}
				
				#if defined(PROP_MATCAP) || !defined(OPTIMIZER_ENABLED)
				if (_MatcapSmoothnessEnabled)
				{
					matcap = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap), matcapSmoothness) * float4(poiThemeColor(poiMods, _MatcapColor.rgb, _MatcapColorThemeIndex), _MatcapColor.a);
				}
				else
				{
					matcap = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap)) * float4(poiThemeColor(poiMods, _MatcapColor.rgb, _MatcapColorThemeIndex), _MatcapColor.a);
				}
				#else
				matcap = float4(poiThemeColor(poiMods, _MatcapColor.rgb, _MatcapColorThemeIndex), _MatcapColor.a);
				#endif
				
				matcap.rgb *= _MatcapIntensity;
				matcap.rgb = lerp(matcap.rgb, matcap.rgb * poiFragData.baseColor.rgb, _MatcapBaseColorMix);
				
				#if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
				matcapMask = POI2D_SAMPLER_PAN(_MatcapMask, _MainTex, poiUV(poiMesh.uv[_MatcapMaskUV], _MatcapMask_ST), _MatcapMaskPan)[_MatcapMaskChannel];
				#else
				matcapMask = 1;
				#endif
				
				if (_MatcapMaskInvert)
				{
					matcapMask = 1 - matcapMask;
				}
				
				#ifdef TPS_Penetrator
				if (_MatcapTPSDepthEnabled)
				{
					matcapMask = lerp(0, matcapMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _MatcapTPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap.a, matcapMask * _MatcapAlphaOverride);
				
				//UNITY_BRANCH
				if (_MatcapHueShiftEnabled)
				{
					matcap.rgb = hueShift(matcap.rgb, _MatcapHueShift + _Time.x * _MatcapHueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _MatcapAdd, _MatcapAddToLight, _MatcapMultiply, _MatcapReplace, _MatcapMixed, _MatcapScreen, matcap, matcapMask, _MatcapEmissionStrength, _MatcapLightMask, _MatcapMaskGlobalMask, _MatcapMaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _Matcap2Enable==0
				// Matcap 2
				#ifdef COLOR_GRADING_HDR_3D
				
				float3 normal1 = poiMesh.normals[_Matcap2Normal];
				#ifdef POI_MATCAP1_CUSTOM_NORMAL
				#if defined(PROP_MATCAP1NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal1 = calculateNormal(poiMesh.normals[_Matcap2Normal], poiMesh, _Matcap1NormalMap, _Matcap1NormalMap_ST, _Matcap1NormalMapPan, _Matcap1NormalMapUV, _Matcap1NormalMapScale);
				#endif
				#endif
				
				matcapUV = 0;
				
				switch(_Matcap2UVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal1, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _Matcap2Border + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal1), dot(worldViewUp, normal1)) * _Matcap2Border + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal1);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _Matcap2Border + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_Matcap2UVToBlend], _MatCap2ndBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _Matcap2Rotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcap2Smoothness;
				float mipCount2 = 9;
				if (_Matcap2SmoothnessEnabled)
				{
					if (_Matcap2_TexelSize.z == 8192) mipCount2 = 13;
					if (_Matcap2_TexelSize.z == 4096) mipCount2 = 12;
					if (_Matcap2_TexelSize.z == 2048) mipCount2 = 11;
					if (_Matcap2_TexelSize.z == 1024) mipCount2 = 10;
					if (_Matcap2_TexelSize.z == 512) mipCount2 = 9;
					if (_Matcap2_TexelSize.z == 256) mipCount2 = 8;
					if (_Matcap2_TexelSize.z == 128) mipCount2 = 7;
					if (_Matcap2_TexelSize.z == 64) mipCount2 = 6;
					if (_Matcap2_TexelSize.z == 32) mipCount2 = 5;
					
					matcap2Smoothness = _Matcap2Smoothness;
					
					if (_Matcap2MaskSmoothnessApply)
					{
						#if defined(PROP_MATCAP2MASK) || !defined(OPTIMIZER_ENABLED)
						matcap2Smoothness *= POI2D_SAMPLER_PAN(_Matcap2Mask, _MainTex, poiUV(poiMesh.uv[_Matcap2MaskUV], _Matcap2Mask_ST), _Matcap2MaskPan)[_Matcap2MaskSmoothnessChannel];
						#endif
					}
					matcap2Smoothness = (1 - matcap2Smoothness) * mipCount2;
				}
				
				#if defined(PROP_MATCAP2) || !defined(OPTIMIZER_ENABLED)
				if (_Matcap2SmoothnessEnabled)
				{
					matcap2 = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap2, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap2), matcap2Smoothness) * float4(poiThemeColor(poiMods, _Matcap2Color.rgb, _Matcap2ColorThemeIndex), _Matcap2Color.a);
				}
				else
				{
					matcap2 = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap2, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap2)) * float4(poiThemeColor(poiMods, _Matcap2Color.rgb, _Matcap2ColorThemeIndex), _Matcap2Color.a);
				}
				#else
				matcap2 = float4(poiThemeColor(poiMods, _Matcap2Color.rgb, _Matcap2ColorThemeIndex), _Matcap2Color.a);
				#endif
				
				matcap2.rgb *= _Matcap2Intensity;
				matcap2.rgb = lerp(matcap2.rgb, matcap2.rgb * poiFragData.baseColor.rgb, _Matcap2BaseColorMix);
				
				#if defined(PROP_MATCAP2MASK) || !defined(OPTIMIZER_ENABLED)
				matcap2Mask = POI2D_SAMPLER_PAN(_Matcap2Mask, _MainTex, poiUV(poiMesh.uv[_Matcap2MaskUV], _Matcap2Mask_ST), _Matcap2MaskPan)[_Matcap2MaskChannel];
				#else
				matcap2Mask = 1;
				#endif
				if (_Matcap2MaskInvert)
				{
					matcap2Mask = 1 - matcap2Mask;
				}
				
				#ifdef TPS_Penetrator
				if (_Matcap2TPSDepthEnabled)
				{
					matcap2Mask = lerp(0, matcap2Mask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Matcap2TPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap2.a, matcap2Mask * _Matcap2AlphaOverride);
				
				//UNITY_BRANCH
				if (_Matcap2HueShiftEnabled)
				{
					matcap2.rgb = hueShift(matcap2.rgb, _Matcap2HueShift + _Time.x * _Matcap2HueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _Matcap2Add, _Matcap2AddToLight, _Matcap2Multiply, _Matcap2Replace, _Matcap2Mixed, _Matcap2Screen, matcap2, matcap2Mask, _Matcap2EmissionStrength, _Matcap2LightMask, _Matcap2MaskGlobalMask, _Matcap2MaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _Matcap3Enable==0
				// Matcap 3
				#ifdef POI_MATCAP2
				
				float3 normal2 = poiMesh.normals[_Matcap3Normal];
				#ifdef POI_MATCAP2_CUSTOM_NORMAL
				#if defined(PROP_MATCAP2NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal2 = calculateNormal(poiMesh.normals[_Matcap3Normal], poiMesh, _Matcap2NormalMap, _Matcap2NormalMap_ST, _Matcap2NormalMapPan, _Matcap2NormalMapUV, _Matcap2NormalMapScale);
				#endif
				#endif
				
				matcapUV = 0;
				
				switch(_Matcap3UVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal2, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _Matcap3Border + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal2), dot(worldViewUp, normal2)) * _Matcap3Border + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal2);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _Matcap3Border + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_Matcap3UVToBlend], _MatCap3rdBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _Matcap3Rotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcap3Smoothness;
				float mipCount3 = 9;
				if (_Matcap3SmoothnessEnabled)
				{
					if (_Matcap3_TexelSize.z == 8192) mipCount3 = 13;
					if (_Matcap3_TexelSize.z == 4096) mipCount3 = 12;
					if (_Matcap3_TexelSize.z == 2048) mipCount3 = 11;
					if (_Matcap3_TexelSize.z == 1024) mipCount3 = 10;
					if (_Matcap3_TexelSize.z == 512) mipCount3 = 9;
					if (_Matcap3_TexelSize.z == 256) mipCount3 = 8;
					if (_Matcap3_TexelSize.z == 128) mipCount3 = 7;
					if (_Matcap3_TexelSize.z == 64) mipCount3 = 6;
					if (_Matcap3_TexelSize.z == 32) mipCount3 = 5;
					
					matcap3Smoothness = _Matcap3Smoothness;
					
					if (_Matcap3MaskSmoothnessApply)
					{
						#if defined(PROP_MATCAP3MASK) || !defined(OPTIMIZER_ENABLED)
						matcap3Smoothness *= POI2D_SAMPLER_PAN(_Matcap3Mask, _MainTex, poiUV(poiMesh.uv[_Matcap3MaskUV], _Matcap3Mask_ST), _Matcap3MaskPan)[_Matcap3MaskSmoothnessChannel];
						#endif
					}
					matcap3Smoothness = (1 - matcap3Smoothness) * mipCount3;
				}
				
				#if defined(PROP_MATCAP3) || !defined(OPTIMIZER_ENABLED)
				if (_Matcap3SmoothnessEnabled)
				{
					matcap3 = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap3, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap3), matcap3Smoothness) * float4(poiThemeColor(poiMods, _Matcap3Color.rgb, _Matcap3ColorThemeIndex), _Matcap3Color.a);
				}
				else
				{
					matcap3 = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap3, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap3)) * float4(poiThemeColor(poiMods, _Matcap3Color.rgb, _Matcap3ColorThemeIndex), _Matcap3Color.a);
				}
				#else
				matcap3 = float4(poiThemeColor(poiMods, _Matcap3Color.rgb, _Matcap3ColorThemeIndex), _Matcap3Color.a);
				#endif
				
				matcap3.rgb *= _Matcap3Intensity;
				matcap3.rgb = lerp(matcap3.rgb, matcap3.rgb * poiFragData.baseColor.rgb, _Matcap3BaseColorMix);
				
				#if defined(PROP_MATCAP3MASK) || !defined(OPTIMIZER_ENABLED)
				matcap3Mask = POI2D_SAMPLER_PAN(_Matcap3Mask, _MainTex, poiUV(poiMesh.uv[_Matcap3MaskUV], _Matcap3Mask_ST), _Matcap3MaskPan)[_Matcap3MaskChannel];
				#else
				matcap3Mask = 1;
				#endif
				if (_Matcap3MaskInvert)
				{
					matcap3Mask = 1 - matcap3Mask;
				}
				
				#ifdef TPS_Penetrator
				if (_Matcap3TPSDepthEnabled)
				{
					matcap3Mask = lerp(0, matcap3Mask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Matcap3TPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap3.a, matcap3Mask * _Matcap3AlphaOverride);
				
				//UNITY_BRANCH
				if (_Matcap3HueShiftEnabled)
				{
					matcap3.rgb = hueShift(matcap3.rgb, _Matcap3HueShift + _Time.x * _Matcap3HueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _Matcap3Add, _Matcap3AddToLight, _Matcap3Multiply, _Matcap3Replace, _Matcap3Mixed, _Matcap3Screen, matcap3, matcap3Mask, _Matcap3EmissionStrength, _Matcap3LightMask, _Matcap3MaskGlobalMask, _Matcap3MaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _Matcap4Enable==0
				// Matcap 4
				#ifdef POI_MATCAP3
				
				float3 normal3 = poiMesh.normals[_Matcap4Normal];
				#ifdef POI_MATCAP3_CUSTOM_NORMAL
				#if defined(PROP_MATCAP3NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal3 = calculateNormal(poiMesh.normals[_Matcap4Normal], poiMesh, _Matcap3NormalMap, _Matcap3NormalMap_ST, _Matcap3NormalMapPan, _Matcap3NormalMapUV, _Matcap3NormalMapScale);
				#endif
				#endif
				
				matcapUV = 0;
				
				switch(_Matcap4UVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal3, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _Matcap4Border + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal3), dot(worldViewUp, normal3)) * _Matcap4Border + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal3);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _Matcap4Border + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_Matcap4UVToBlend], _MatCap4thBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _Matcap4Rotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcap4Smoothness;
				float mipCount4 = 9;
				if (_Matcap4SmoothnessEnabled)
				{
					if (_Matcap4_TexelSize.z == 8192) mipCount4 = 13;
					if (_Matcap4_TexelSize.z == 4096) mipCount4 = 12;
					if (_Matcap4_TexelSize.z == 2048) mipCount4 = 11;
					if (_Matcap4_TexelSize.z == 1024) mipCount4 = 10;
					if (_Matcap4_TexelSize.z == 512) mipCount4 = 9;
					if (_Matcap4_TexelSize.z == 256) mipCount4 = 8;
					if (_Matcap4_TexelSize.z == 128) mipCount4 = 7;
					if (_Matcap4_TexelSize.z == 64) mipCount4 = 6;
					if (_Matcap4_TexelSize.z == 32) mipCount4 = 5;
					
					matcap4Smoothness = _Matcap4Smoothness;
					
					if (_Matcap4MaskSmoothnessApply)
					{
						#if defined(PROP_MATCAP4MASK) || !defined(OPTIMIZER_ENABLED)
						matcap4Smoothness *= POI2D_SAMPLER_PAN(_Matcap4Mask, _MainTex, poiUV(poiMesh.uv[_Matcap4MaskUV], _Matcap4Mask_ST), _Matcap4MaskPan)[_Matcap4MaskSmoothnessChannel];
						#endif
					}
					matcap4Smoothness = (1 - matcap4Smoothness) * mipCount4;
				}
				
				#if defined(PROP_MATCAP4) || !defined(OPTIMIZER_ENABLED)
				if (_Matcap4SmoothnessEnabled)
				{
					matcap4 = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap4, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap4), matcap4Smoothness) * float4(poiThemeColor(poiMods, _Matcap4Color.rgb, _Matcap4ColorThemeIndex), _Matcap4Color.a);
				}
				else
				{
					matcap4 = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap4, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap4)) * float4(poiThemeColor(poiMods, _Matcap4Color.rgb, _Matcap4ColorThemeIndex), _Matcap4Color.a);
				}
				#else
				matcap4 = float4(poiThemeColor(poiMods, _Matcap4Color.rgb, _Matcap4ColorThemeIndex), _Matcap4Color.a);
				#endif
				
				matcap4.rgb *= _Matcap4Intensity;
				matcap4.rgb = lerp(matcap4.rgb, matcap4.rgb * poiFragData.baseColor.rgb, _Matcap4BaseColorMix);
				
				#if defined(PROP_MATCAP4MASK) || !defined(OPTIMIZER_ENABLED)
				matcap4Mask = POI2D_SAMPLER_PAN(_Matcap4Mask, _MainTex, poiUV(poiMesh.uv[_Matcap4MaskUV], _Matcap4Mask_ST), _Matcap4MaskPan)[_Matcap4MaskChannel];
				#else
				matcap4Mask = 1;
				#endif
				if (_Matcap4MaskInvert)
				{
					matcap4Mask = 1 - matcap4Mask;
				}
				
				#ifdef TPS_Penetrator
				if (_Matcap4TPSDepthEnabled)
				{
					matcap4Mask = lerp(0, matcap4Mask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Matcap4TPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap4.a, matcap4Mask * _Matcap4AlphaOverride);
				
				//UNITY_BRANCH
				if (_Matcap4HueShiftEnabled)
				{
					matcap4.rgb = hueShift(matcap4.rgb, _Matcap4HueShift + _Time.x * _Matcap4HueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _Matcap4Add, _Matcap4AddToLight, _Matcap4Multiply, _Matcap4Replace, _Matcap4Mixed, _Matcap4Screen, matcap4, matcap4Mask, _Matcap4EmissionStrength, _Matcap4LightMask, _Matcap4MaskGlobalMask, _Matcap4MaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
				
			}
			#endif
			//endex
			
			//ifex _CubeMapEnabled==0
			#ifdef _CUBEMAP
			#if defined(PROP_CUBEMAP) || !defined(OPTIMIZER_ENABLED)
			// From Unity's MIT'd Skybox-Cubed.shader
			float3 RotateAroundYInDegrees(float3 dir, float degrees)
			{
				float alpha = degrees * UNITY_PI / 180.0;
				float sina, cosa;
				sincos(alpha, sina, cosa);
				float2x2 m = float2x2(cosa, -sina, sina, cosa);
				return float3(mul(m, dir.xz), dir.y).xzy;
			}
			#endif
			void applyCubemap(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
			{
				float3 CubeMapUV = 0;
				
				switch(_CubeMapUVMode)
				{
					case 0: // Skybox
					CubeMapUV = -poiCam.viewDir;
					break;
					case 1: // Reflection
					CubeMapUV = poiCam.reflectionDir;
					break;
					case 2: // World Normal Direction
					CubeMapUV = lerp(poiMesh.normals[0], poiMesh.normals[1], _CubeMapWorldNormalsStrength);
					break;
					case 3: // Local Normal Direction
					CubeMapUV = poiMesh.objNormal;
					break;
				}
				
				#if defined(PROP_CUBEMAP) || !defined(OPTIMIZER_ENABLED)
				if (any(_CubeMapRotation.xyz) || any(_CubeMapRotationPan.xyz))
				{
					// Do funny swizzle so we don't have to make a new function for every direction
					CubeMapUV = RotateAroundYInDegrees(CubeMapUV.yxz, _CubeMapRotation.x + (_CubeMapRotationPan.x * _Time.y)).yxz;
					CubeMapUV = RotateAroundYInDegrees(CubeMapUV.xyz, _CubeMapRotation.y + (_CubeMapRotationPan.y * _Time.y)).xyz;
					CubeMapUV = RotateAroundYInDegrees(CubeMapUV.xzy, _CubeMapRotation.z + (_CubeMapRotationPan.z * _Time.y)).xzy;
				}
				float4 cubeMap = texCUBE(_CubeMap, CubeMapUV);
				cubeMap.rgb *= poiThemeColor(poiMods, _CubeMapColor, _CubeMapColorThemeIndex);
				#else
				float4 cubeMap = float4(0.21763764082, 0.21763764082, 0.21763764082, .5) * float4(poiThemeColor(poiMods, _CubeMapColor, _CubeMapColorThemeIndex), 1);
				#endif
				
				cubeMap.rgb *= _CubeMapIntensity;
				#if defined(PROP_CUBEMAPMASK) || !defined(OPTIMIZER_ENABLED)
				float CubeMapMask = POI2D_SAMPLER_PAN(_CubeMapMask, _MainTex, poiUV(poiMesh.uv[_CubeMapMaskUV], _CubeMapMask_ST), _CubeMapMaskPan)[_CubeMapMaskChannel];
				#else
				float CubeMapMask = 1;
				#endif
				
				if (_CubeMapMaskGlobalMask > 0)
				{
					CubeMapMask = maskBlend(CubeMapMask, poiMods.globalMask[_CubeMapMaskGlobalMask-1], _CubeMapMaskGlobalMaskBlendType);
				}
				
				if (_CubeMapMaskInvert)
				{
					CubeMapMask = 1 - CubeMapMask;
				}
				
				//UNITY_BRANCH
				if (_CubeMapHueShiftEnabled)
				{
					cubeMap.rgb = hueShift(cubeMap.rgb, _CubeMapHueShift + _Time.x * _CubeMapHueShiftSpeed);
				}
				CubeMapMask = min(CubeMapMask, lerp(1, poiLight.rampedLightMap, _CubeMapLightMask));
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, cubeMap.rgb, _CubeMapReplace * CubeMapMask * cubeMap.a);
				poiFragData.baseColor.rgb *= lerp(1, cubeMap.rgb, _CubeMapMultiply * CubeMapMask * cubeMap.a);
				poiFragData.baseColor.rgb += cubeMap.rgb * _CubeMapAdd * CubeMapMask * cubeMap.a;
				poiFragData.emission += cubeMap.rgb * _CubeMapEmissionStrength * CubeMapMask * cubeMap.a;
			}
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			void ApplyAudioLinkDecal(in PoiMesh poiMesh, inout PoiFragData poiFragData, in PoiMods poiMods)
			{
				float4 colorAndMask = float4(1, 1, 1, 1);
				#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
				colorAndMask = POI2D_SAMPLER_PAN(_ALDecalColorMask, _MainTex, poiUV(poiMesh.uv[_ALDecalColorMaskUV], _ALDecalColorMask_ST), _ALDecalColorMaskPan);
				#endif
				
				float2 uv = poiMesh.uv[_ALDecalUV];
				float2 decalCenter = _ALUVPosition;
				float theta = radians(_ALUVRotation + _Time.z * _ALUVRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
				uv = remap(uv, float2(0, 0) - _ALUVScale.xz / 2 + _ALUVPosition, _ALUVScale.yw / 2 + _ALUVPosition, float2(0, 0), float2(1, 1));
				
				// Mask
				float4 audioLinkMask = 1.0;
				
				// UV
				float2 aluv = uv;
				if (_ALDecalUVMode == 1)
				{
					float2 uvdir = uv * 2 - 1;
					aluv.x = frac(atan2(uvdir.y, uvdir.x) * UNITY_INV_TWO_PI);
					aluv.y = length(uvdir);
				}
				
				// Scale / Offset / Step
				float maskY = aluv.y;
				if (_ALDecalUVMode == 1)
				{
					maskY = remap(maskY, _ALDecaldCircleDimensions.x, _ALDecaldCircleDimensions.y, 0, 1);
				}
				float maskX = aluv.x;
				if (_ALDecalUVMode == 1)
				{
					maskX = remap(maskX, _ALDecaldCircleDimensions.z, _ALDecaldCircleDimensions.w, 0, 1);
				}
				
				float maskVolume = _ALDecalVolumeStep != 0.0 ? floor(maskY * _ALDecalVolumeStep) / _ALDecalVolumeStep : maskY;
				float maskBand = _ALDecalBandStep != 0.0 ? floor(maskX * _ALDecalBandStep) / _ALDecalBandStep : maskX;
				
				// Copy
				audioLinkMask.r = maskVolume;
				audioLinkMask.g = maskBand;
				
				// Clip
				audioLinkMask.b = maskVolume < _ALDecalVolumeClipMin || maskVolume > _ALDecalVolumeClipMax ? 0.0 : audioLinkMask.b;
				audioLinkMask.b = maskBand < _ALDecalBandClipMin || maskBand > _ALDecalBandClipMax ? 0.0 : audioLinkMask.b;
				
				// Shape Clip
				if (_ALDecalShapeClip)
				{
					float volumeth = _ALDecalShapeClipVolumeWidth;
					if (_ALDecalVolumeStep != 0.0) audioLinkMask.b = frac(maskY * _ALDecalVolumeStep) > volumeth ? 0.0 : audioLinkMask.b;
					
					float bandwidth = _ALDecalUVMode == 1 ? _ALDecalShapeClipBandWidth / aluv.y : _ALDecalShapeClipBandWidth;
					float bandth = 1.0 - bandwidth;
					if (_ALDecalBandStep != 0.0) audioLinkMask.b = frac(maskX * _ALDecalBandStep + bandth * 0.5) < bandth ? 0.0 : audioLinkMask.b;
				}
				
				// AudioLink
				float2 audioLinkUV = float2(frac(audioLinkMask.g * 2.0), 4.5 / 4.0 + floor(audioLinkMask.g * 2.0) / 4.0);
				audioLinkUV.y *= 0.0625;
				float4 audioTexture = _AudioTexture.Sample(sampler_linear_clamp, audioLinkUV);
				float audioVal = audioTexture.b * _ALDecalVolume * lerp(_ALDecalBaseBoost, _ALDecalTrebleBoost, audioLinkMask.g);
				float audioLinkValue = _ALDecalLineWidth < 1.0 ? abs(audioVal - audioLinkMask.r) < _ALDecalLineWidth : audioVal > audioLinkMask.r * 2.0;
				audioLinkValue = saturate(audioLinkValue) * audioLinkMask.b;
				//clip(audioLinkValue - .5);
				audioLinkValue *= colorAndMask.a;
				
				if (!poiMods.audioLinkAvailable)
				{
					audioLinkValue = 0;
				}
				
				float3 alColorChord = _AudioTexture.Sample(sampler_linear_clamp, float2(maskX, 24.5 / 64.0)).rgb;
				float volumeColorSrc = audioLinkMask.g;
				if (_ALDecalVolumeColorSource == 1) volumeColorSrc = audioLinkMask.r;
				if (_ALDecalVolumeColorSource == 2) volumeColorSrc = audioVal;
				
				float3 lowColor = _ALDecalVolumeColorLow.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorLow.rgb, _ALDecalVolumeColorLowThemeIndex);
				float3 midColor = _ALDecalVolumeColorMid.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorMid.rgb, _ALDecalVolumeColorMidThemeIndex);
				float3 highColor = _ALDecalVolumeColorHigh.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorHigh.rgb, _ALDecalVolumeColorHighThemeIndex);
				
				float3 volumeColor = lerp(lowColor, midColor, saturate(volumeColorSrc * 2));
				volumeColor = lerp(volumeColor, highColor, saturate(volumeColorSrc * 2 - 1));
				
				float3 emissionColor = lerp(lowColor * _ALDecalLowEmission, midColor * _ALDecalMidEmission, saturate(volumeColorSrc * 2));
				emissionColor = lerp(emissionColor, highColor * _ALDecalHighEmission, saturate(volumeColorSrc * 2 - 1));
				
				//poiFragData.baseColor = lerp(poiFragData.baseColor, volumeColor, audioLinkValue);
				#if defined(POI_PASS_BASE) || defined(POI_PASS_ADD)
				poiFragData.emission += emissionColor * audioLinkValue;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor, customBlend(poiFragData.baseColor, volumeColor * colorAndMask.rgb, _ALDecalBlendType), saturate(_ALDecalBlendAlpha * audioLinkValue));
				#endif
				poiFragData.alpha = lerp(poiFragData.alpha, poiFragData.alpha * audioLinkValue, _ALDecalControlsAlpha);
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableVolumeColor==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_VOLUMECOLOR
			void ApplyAudioLinkVolumeColor(in PoiMesh poiMesh, inout PoiFragData poiFragData, in PoiMods poiMods)
			{
				float volume = AudioLinkLerpMultiline(ALPASS_DFT + float2(poiMesh.uv[_ALVolumeColorUV][_ALVolumeColorDirection] * AUDIOLINK_ETOTALBINS, 0.0)).b;
				
				float3 lowColor = _ALVolumeColorLow.rgb * poiThemeColor(poiMods, _ALVolumeColorLow.rgb, _ALVolumeColorLowThemeIndex);
				float3 midColor = _ALVolumeColorMid.rgb * poiThemeColor(poiMods, _ALVolumeColorMid.rgb, _ALVolumeColorMidThemeIndex);
				float3 highColor = _ALVolumeColorHigh.rgb * poiThemeColor(poiMods, _ALVolumeColorHigh.rgb, _ALVolumeColorHighThemeIndex);
				
				float3 volumeColor = lerp(lowColor, midColor, saturate(volume * 2));
				volumeColor = lerp(volumeColor, highColor, saturate(volume * 2 - 1));
				
				float3 emissionColor = lerp(lowColor * _ALLowEmission, midColor * _ALMidEmission, saturate(volume * 2));
				emissionColor = lerp(emissionColor, highColor * _ALHighEmission, saturate(volume * 2 - 1));
				
				#if defined(POI_PASS_BASE) || defined(POI_PASS_ADD)
				poiFragData.emission += emissionColor * poiMods.audioLinkAvailable;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor, customBlend(poiFragData.baseColor, volumeColor, _ALVolumeColorBlendType), saturate(_ALVolumeColorBlendAlpha * poiMods.audioLinkAvailable));
				#endif
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			void applyFlipbook(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_FLIPBOOKTEXARRAY) || !defined(OPTIMIZER_ENABLED)
				float4 flipBookPixel = float4(0, 0, 0, 0);
				#if defined(PROP_FLIPBOOKMASK) || !defined(OPTIMIZER_ENABLED)
				float flipBookMask = POI2D_SAMPLER_PAN(_FlipbookMask, _MainTex, poiUV(poiMesh.uv[_FlipbookMaskUV], _FlipbookMask_ST), _FlipbookMaskPan)[_FlipbookMaskChannel];
				#else
				float flipBookMask = 1;
				#endif
				if (_FlipbookMaskGlobalMask > 0)
				{
					flipBookMask = maskBlend(flipBookMask, poiMods.globalMask[_FlipbookMaskGlobalMask-1], _FlipbookMaskGlobalMaskBlendType);
				}
				float4 flipbookScaleOffset = _FlipbookScaleOffset;
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookScaleOffset.xy += lerp(_AudioLinkFlipbookScale.xy, _AudioLinkFlipbookScale.zw, poiMods.audioLink[_AudioLinkFlipbookScaleBand]);
				}
				#endif
				
				flipbookScaleOffset.xy = 1 - flipbookScaleOffset.xy;
				float2 uv = frac(poiMesh.uv[_FlipbookTexArrayUV]);
				float theta = radians(_FlipbookRotation + _Time.z * _FlipbookRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				float2 spriteCenter = flipbookScaleOffset.zw + .5;
				// 2d rotation
				uv = float2((uv.x - spriteCenter.x) * cs - (uv.y - spriteCenter.y) * sn + spriteCenter.x, (uv.x - spriteCenter.x) * sn + (uv.y - spriteCenter.y) * cs + spriteCenter.y);
				float4 sideOffset = float4(-(_FlipbookSideOffset.x), _FlipbookSideOffset.y, -(_FlipbookSideOffset.z), _FlipbookSideOffset.w);
				float2 newUV = remap(uv, float2(0, 0) + flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.xz, float2(1, 1) - flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.yw, float2(0, 0), float2(1, 1));
				
				UNITY_BRANCH
				if (_FlipbookTiled == 0)
				{
					if (max(newUV.x, newUV.y) > 1 || min(newUV.x, newUV.y) < 0)
					{
						return;
					}
				}
				float currentFrame = 0;
				float width;
				float height;
				float totalFrames;
				_FlipbookTexArray.GetDimensions(width, height, totalFrames);
				
				if (_FlipbookStartAndEnd)
				{
					totalFrames -= (totalFrames - min(max(_FlipbookStartFrame, _FlipbookEndFrame), totalFrames));
					totalFrames -= max(0, _FlipbookStartFrame);
				}
				if (!_FlipbookManualFrameControl)
				{
					if (_FlipbookFPS != 0)
					{
						currentFrame = ((_Time.y / (1 / _FlipbookFPS)) + _FlipbookFrameOffset) % totalFrames;
						if (_FlipbookStartAndEnd)
						{
							currentFrame += _FlipbookStartFrame;
						}
					}
				}
				else
				{
					currentFrame = fmod(_FlipbookCurrentFrame, totalFrames);
				}
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					if (_FlipbookChronotensityEnabled)
					{
						currentFrame += AudioLinkGetChronoTime(_FlipbookChronoType, _FlipbookChronotensityBand) * _FlipbookChronotensitySpeed;
					}
					currentFrame += lerp(_AudioLinkFlipbookFrame.x, _AudioLinkFlipbookFrame.y, poiMods.audioLink[_AudioLinkFlipbookFrameBand]);
					float totalFramesAL = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesAL += max(0, _FlipbookStartFrame);
					}
					currentFrame %= totalFramesAL;
				}
				#endif
				flipBookPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor(currentFrame)));
				UNITY_BRANCH
				if (_FlipbookCrossfadeEnabled)
				{
					float totalFramesCF = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesCF += max(0, _FlipbookStartFrame);
					}
					float4 flipbookNextPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor((currentFrame + 1) % totalFramesCF)));
					flipBookPixel = lerp(flipBookPixel, flipbookNextPixel, smoothstep(_FlipbookCrossfadeRange.x, _FlipbookCrossfadeRange.y, frac(currentFrame)));
				}
				
				UNITY_BRANCH
				if (_FlipbookIntensityControlsAlpha)
				{
					flipBookPixel.a = poiMax(flipBookPixel.rgb);
				}
				UNITY_BRANCH
				if (_FlipbookColorReplaces)
				{
					flipBookPixel.rgb = poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				else
				{
					flipBookPixel.rgb *= poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				
				UNITY_BRANCH
				if (_FlipbookHueShiftEnabled)
				{
					flipBookPixel.rgb = hueShift(flipBookPixel.rgb, _FlipbookHueShift + _Time.x * _FlipbookHueShiftSpeed);
				}
				half flipbookAlpha = 1;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookAlpha += saturate(lerp(_AudioLinkFlipbookAlpha.x, _AudioLinkFlipbookAlpha.y, poiMods.audioLink[_AudioLinkFlipbookAlphaBand]));
				}
				#endif
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * _FlipbookReplace * flipBookMask * flipbookAlpha);
				poiFragData.baseColor = poiFragData.baseColor + flipBookPixel.rgb * _FlipbookAdd * flipBookMask * flipbookAlpha;
				poiFragData.baseColor = poiFragData.baseColor * lerp(1, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * flipBookMask * _FlipbookMultiply * flipbookAlpha);
				
				float flipbookEmissionStrength = _FlipbookEmissionStrength;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookEmissionStrength += max(lerp(_AudioLinkFlipbookEmission.x, _AudioLinkFlipbookEmission.y, poiMods.audioLink[_AudioLinkFlipbookEmissionBand]), 0);
				}
				#endif
				
				poiFragData.emission += lerp(0, flipBookPixel.rgb * flipbookEmissionStrength, flipBookPixel.a * _FlipbookColor.a * flipBookMask * flipbookAlpha);
				
				#endif
				
				UNITY_BRANCH
				if (_FlipbookAlphaControlsFinalAlpha)
				{
					poiFragData.alpha = lerp(poiFragData.alpha, flipBookPixel.a * _FlipbookColor.a, flipBookMask);
				}
				#endif
			}
			
			#endif
			//endex
			
			//ifex _EnableEmission==0 && _EnableEmission1==0 && _EnableEmission2==0 && _EnableEmission3==0
			float calculateGlowInTheDark(in float minLight, in float maxLight, in float minEmissionMultiplier, in float maxEmissionMultiplier, in float enabled, in float worldOrMesh, in PoiLight poiLight)
			{
				float glowInTheDarkMultiplier = 1;
				//UNITY_BRANCH
				if (enabled)
				{
					float3 lightValue = worldOrMesh ? calculateluminance(poiLight.finalLighting.rgb) : calculateluminance(poiLight.directColor.rgb);
					float gitdeAlpha = saturate(inverseLerp(minLight, maxLight, lightValue));
					glowInTheDarkMultiplier = lerp(minEmissionMultiplier, maxEmissionMultiplier, gitdeAlpha);
				}
				return glowInTheDarkMultiplier;
			}
			
			float calculateScrollingEmission(in float3 direction, in float velocity, in float interval, in float scrollWidth, float offset, float3 position)
			{
				scrollWidth = max(scrollWidth, 0);
				float phase = 0;
				phase = dot(position, direction);
				phase -= (_Time.y + offset) * velocity;
				phase /= interval;
				phase -= floor(phase);
				phase = saturate(phase);
				return (pow(phase, scrollWidth) + pow(1 - phase, scrollWidth * 4)) * 0.5;
			}
			
			float calculateBlinkingEmission(in float blinkMin, in float blinkMax, in float blinkVelocity, float offset)
			{
				float amplitude = (blinkMax - blinkMin) * 0.5f;
				float base = blinkMin + amplitude;
				return sin((_Time.y + offset) * blinkVelocity) * amplitude + base;
			}
			
			void applyALEmmissionStrength(in PoiMods poiMods, inout float emissionStrength, in float2 emissionStrengthMod, in float emissionStrengthBand, in float2 _EmissionALMultipliers, in float _EmissionALMultipliersBand, in float enabled)
			{
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && enabled)
				{
					emissionStrength += lerp(emissionStrengthMod.x, emissionStrengthMod.y, poiMods.audioLink[emissionStrengthBand]);
					emissionStrength *= lerp(_EmissionALMultipliers.x, _EmissionALMultipliers.y, poiMods.audioLink[_EmissionALMultipliersBand]);
				}
				#endif
			}
			
			void applyALCenterOutEmission(in PoiMods poiMods, in float nDotV, inout float emissionStrength, in float size, in float band, in float2 emissionToAdd, in float enabled, in float duration)
			{
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && enabled)
				{
					float intensity;
					[flatten]
					if (duration >= 0)
					{
						intensity = getBandAtTime(band, saturate(remap(nDotV, 1, 0, 0, duration)), size);
					}
					else
					{
						duration *= -1;
						intensity = getBandAtTime(band, saturate(remap(pow(nDotV, 2), 0, 1 + duration, 0, duration)), size);
					}
					emissionStrength += lerp(emissionToAdd[0], emissionToAdd[1], intensity);
				}
				#endif
			}
			void applyLumaGradient(in PoiMods poiMods, inout float3 emissionColor, in float themeIndex, in float nDotV)
			{
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && poiMods.audioLinkViaLuma && themeIndex >= 5 && themeIndex <= 7)
				{
					emissionColor = getLumaGradient(themeIndex - 5, saturate(1 - nDotV));
				}
				#endif
			}
			//endex
			
			//ifex _EnableEmission==0
			#ifdef _EMISSION
			float3 applyEmission(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// First Emission
				float3 emission0 = 0;
				float emissionStrength0 = _EmissionStrength;
				float3 emissionColor0 = 0;
				
				float glowInTheDarkMultiplier0 = calculateGlowInTheDark(_GITDEMinLight, _GITDEMaxLight, _GITDEMinEmissionMultiplier, _GITDEMaxEmissionMultiplier, _EnableGITDEmission, _GITDEWorldOrMesh, poiLight);
				
				#if defined(PROP_EMISSIONMAP) || !defined(OPTIMIZER_ENABLED)
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled)
				{
					emissionColor0 = POI2D_SAMPLER_PAN(_EmissionMap, _MainTex, poiUV(poiMesh.uv[_EmissionMapUV], _EmissionMap_ST), _EmissionMapPan).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap).rgb * poiThemeColor(poiMods, _EmissionColor.rgb, _EmissionColorThemeIndex);
				}
				else
				{
					emissionColor0 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap_ST.xy) + _Time.x * _EmissionCenterOutSpeed).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap).rgb * poiThemeColor(poiMods, _EmissionColor.rgb, _EmissionColorThemeIndex);
				}
				#else
				emissionColor0 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap).rgb * poiThemeColor(poiMods, _EmissionColor.rgb, _EmissionColorThemeIndex);
				#endif
				
				//UNITY_BRANCH
				if (_ScrollingEmission)
				{
					float3 pos = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor)
					{
						pos = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE) || !defined(OPTIMIZER_ENABLED)
						emissionStrength0 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve, _MainTex, poiUV(poiMesh.uv[_EmissionMapUV], _EmissionScrollingCurve_ST) + (dot(pos, _EmissiveScroll_Direction.xyz) * _EmissiveScroll_Interval) + _Time.x * _EmissiveScroll_Velocity).r;
						#endif
					}
					else
					{
						emissionStrength0 *= calculateScrollingEmission(_EmissiveScroll_Direction.xyz, _EmissiveScroll_Velocity, _EmissiveScroll_Interval, _EmissiveScroll_Width, _EmissionScrollingOffset, pos);
					}
				}
				
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled)
				{
					emissionStrength0 *= calculateBlinkingEmission(_EmissiveBlink_Min, _EmissiveBlink_Max, _EmissiveBlink_Velocity, _EmissionBlinkingOffset);
				}
				
				applyLumaGradient(poiMods, emissionColor0, _EmissionColorThemeIndex, poiLight.nDotV);
				emissionColor0 = hueShift(emissionColor0, frac(_EmissionHueShift + _EmissionHueShiftSpeed * _Time.x) * _EmissionHueShiftEnabled);
				
				#if defined(PROP_EMISSIONMASK) || !defined(OPTIMIZER_ENABLED)
				float emissionMask0 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask, _MainTex, poiUV(poiMesh.uv[_EmissionMaskUV], _EmissionMask_ST) + _Time.x * _EmissionMaskPan)[_EmissionMaskChannel];
				#else
				float emissionMask0 = 1;
				#endif
				
				if (_EmissionMaskInvert)
				{
					emissionMask0 = 1 - emissionMask0;
				}
				
				if (_EmissionMask0GlobalMask > 0)
				{
					emissionMask0 = maskBlend(emissionMask0, poiMods.globalMask[_EmissionMask0GlobalMask - 1], _EmissionMask0GlobalMaskBlendType);
				}
				
				applyALEmmissionStrength(poiMods, emissionStrength0, _EmissionAL0StrengthMod, _EmissionAL0StrengthBand, _EmissionAL0Multipliers, _EmissionAL0MultipliersBand, _EmissionAL0Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength0, _AudioLinkEmission0CenterOutSize, _AudioLinkEmission0CenterOutBand, _AudioLinkEmission0CenterOut, _EmissionAL0Enabled, _AudioLinkEmission0CenterOutDuration);
				
				emissionStrength0 *= glowInTheDarkMultiplier0 * emissionMask0;
				emission0 = max(emissionStrength0 * emissionColor0, 0);
				
				#ifdef POI_DISSOLVE
				//UNITY_BRANCH
				if (_DissolveEmissionSide != 2)
				{
					emission0 *= lerp(1 - dissolveAlpha, dissolveAlpha, _DissolveEmissionSide);
				}
				#endif
				
				// poiFragData.finalColor.rgb = lerp(poiFragData.finalColor.rgb, saturate(emission0 + emission1), _EmissionReplace * poiMax(emission0 + emission1));
				
				poiFragData.emission += emission0;
				return emission0 * _EmissionReplace0;
			}
			#endif
			//endex
			//ifex _EnableEmission1==0
			#ifdef POI_EMISSION_1
			float3 applyEmission1(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// Second Emission
				float3 emission1 = 0;
				float emissionStrength1 = 0;
				float3 emissionColor1 = 0;
				
				emissionStrength1 = _EmissionStrength1;
				
				float glowInTheDarkMultiplier1 = calculateGlowInTheDark(_GITDEMinLight1, _GITDEMaxLight1, _GITDEMinEmissionMultiplier1, _GITDEMaxEmissionMultiplier1, _EnableGITDEmission1, _GITDEWorldOrMesh1, poiLight);
				#if defined(PROP_EMISSIONMAP1) || !defined(OPTIMIZER_ENABLED)
				
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled1)
				{
					emissionColor1 = POI2D_SAMPLER_PAN(_EmissionMap1, _MainTex, poiUV(poiMesh.uv[_EmissionMap1UV], _EmissionMap1_ST), _EmissionMap1Pan) * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap1).rgb * poiThemeColor(poiMods, _EmissionColor1.rgb, _EmissionColor1ThemeIndex);
				}
				else
				{
					emissionColor1 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap1, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap1_ST.xy) + _Time.x * _EmissionCenterOutSpeed1).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap1).rgb * poiThemeColor(poiMods, _EmissionColor1.rgb, _EmissionColor1ThemeIndex);
				}
				#else
				emissionColor1 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap1).rgb * poiThemeColor(poiMods, _EmissionColor1.rgb, _EmissionColor1ThemeIndex);
				#endif
				//UNITY_BRANCH
				if (_ScrollingEmission1)
				{
					float3 pos1 = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor1)
					{
						pos1 = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve1)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE1) || !defined(OPTIMIZER_ENABLED)
						emissionStrength1 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve1, _MainTex, poiUV(poiMesh.uv[_EmissionMap1UV], _EmissionScrollingCurve1_ST) + (dot(pos1, _EmissiveScroll_Direction1) * _EmissiveScroll_Interval1) + _Time.x * _EmissiveScroll_Velocity1);
						#endif
					}
					else
					{
						emissionStrength1 *= calculateScrollingEmission(_EmissiveScroll_Direction1, _EmissiveScroll_Velocity1, _EmissiveScroll_Interval1, _EmissiveScroll_Width1, _EmissionScrollingOffset1, pos1);
					}
				}
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled1)
				{
					emissionStrength1 *= calculateBlinkingEmission(_EmissiveBlink_Min1, _EmissiveBlink_Max1, _EmissiveBlink_Velocity1, _EmissionBlinkingOffset1);
				}
				
				applyLumaGradient(poiMods, emissionColor1, _EmissionColor1ThemeIndex, poiLight.nDotV);
				emissionColor1 = hueShift(emissionColor1, frac(_EmissionHueShift1 + _EmissionHueShiftSpeed1 * _Time.x) * _EmissionHueShiftEnabled1);
				#if defined(PROP_EMISSIONMASK1) || !defined(OPTIMIZER_ENABLED)
				float emissionMask1 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask1, _MainTex, poiUV(poiMesh.uv[_EmissionMask1UV], _EmissionMask1_ST) + _Time.x * _EmissionMask1Pan)[_EmissionMask1Channel];
				#else
				float emissionMask1 = 1;
				#endif
				
				if (_EmissionMaskInvert1)
				{
					emissionMask1 = 1 - emissionMask1;
				}
				
				if (_EmissionMask1GlobalMask > 0)
				{
					emissionMask1 = maskBlend(emissionMask1, poiMods.globalMask[_EmissionMask1GlobalMask - 1], _EmissionMask1GlobalMaskBlendType);
				}
				applyALEmmissionStrength(poiMods, emissionStrength1, _EmissionAL1StrengthMod, _EmissionAL1StrengthBand, _EmissionAL1Multipliers, _EmissionAL1MultipliersBand, _EmissionAL1Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength1, _AudioLinkEmission1CenterOutSize, _AudioLinkEmission1CenterOutBand, _AudioLinkEmission1CenterOut, _EmissionAL1Enabled, _AudioLinkEmission1CenterOutDuration);
				
				emissionStrength1 *= glowInTheDarkMultiplier1 * emissionMask1;
				emission1 = max(emissionStrength1 * emissionColor1, 0);
				
				poiFragData.emission += emission1;
				return emission1 * _EmissionReplace1;
			}
			#endif
			//endex
			//ifex _EnableEmission2==0
			#ifdef POI_EMISSION_2
			float3 applyEmission2(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// Second Emission
				float3 emission2 = 0;
				float emissionStrength2 = 0;
				float3 emissionColor2 = 0;
				
				emissionStrength2 = _EmissionStrength2;
				
				float glowInTheDarkMultiplier2 = calculateGlowInTheDark(_GITDEMinLight2, _GITDEMaxLight2, _GITDEMinEmissionMultiplier2, _GITDEMaxEmissionMultiplier2, _EnableGITDEmission2, _GITDEWorldOrMesh2, poiLight);
				#if defined(PROP_EMISSIONMAP2) || !defined(OPTIMIZER_ENABLED)
				
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled2)
				{
					emissionColor2 = POI2D_SAMPLER_PAN(_EmissionMap2, _MainTex, poiUV(poiMesh.uv[_EmissionMap2UV], _EmissionMap2_ST), _EmissionMap2Pan) * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap2).rgb * poiThemeColor(poiMods, _EmissionColor2.rgb, _EmissionColor2ThemeIndex);
				}
				else
				{
					emissionColor2 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap2, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap2_ST.xy) + _Time.x * _EmissionCenterOutSpeed2).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap2).rgb * poiThemeColor(poiMods, _EmissionColor2.rgb, _EmissionColor2ThemeIndex);
				}
				#else
				emissionColor2 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap2).rgb * poiThemeColor(poiMods, _EmissionColor2.rgb, _EmissionColor2ThemeIndex);
				#endif
				//UNITY_BRANCH
				if (_ScrollingEmission2)
				{
					float3 pos2 = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor2)
					{
						pos2 = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve2)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE2) || !defined(OPTIMIZER_ENABLED)
						emissionStrength2 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve2, _MainTex, poiUV(poiMesh.uv[_EmissionMap2UV], _EmissionScrollingCurve2_ST) + (dot(pos2, _EmissiveScroll_Direction2) * _EmissiveScroll_Interval2) + _Time.x * _EmissiveScroll_Velocity2);
						#endif
					}
					else
					{
						emissionStrength2 *= calculateScrollingEmission(_EmissiveScroll_Direction2, _EmissiveScroll_Velocity2, _EmissiveScroll_Interval2, _EmissiveScroll_Width2, _EmissionScrollingOffset2, pos2);
					}
				}
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled2)
				{
					emissionStrength2 *= calculateBlinkingEmission(_EmissiveBlink_Min2, _EmissiveBlink_Max2, _EmissiveBlink_Velocity2, _EmissionBlinkingOffset2);
				}
				
				applyLumaGradient(poiMods, emissionColor2, _EmissionColor2ThemeIndex, poiLight.nDotV);
				emissionColor2 = hueShift(emissionColor2, frac(_EmissionHueShift2 + _EmissionHueShiftSpeed2 * _Time.x) * _EmissionHueShiftEnabled2);
				#if defined(PROP_EMISSIONMASK2) || !defined(OPTIMIZER_ENABLED)
				float emissionMask2 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask2, _MainTex, poiUV(poiMesh.uv[_EmissionMask2UV], _EmissionMask2_ST) + _Time.x * _EmissionMask2Pan)[_EmissionMask2Channel];
				#else
				float emissionMask2 = 1;
				#endif
				if (_EmissionMaskInvert2)
				{
					emissionMask2 = 1 - emissionMask2;
				}
				
				if (_EmissionMask2GlobalMask > 0)
				{
					emissionMask2 = maskBlend(emissionMask2, poiMods.globalMask[_EmissionMask2GlobalMask - 1], _EmissionMask2GlobalMaskBlendType);
				}
				applyALEmmissionStrength(poiMods, emissionStrength2, _EmissionAL2StrengthMod, _EmissionAL2StrengthBand, _EmissionAL2Multipliers, _EmissionAL2MultipliersBand, _EmissionAL2Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength2, _AudioLinkEmission2CenterOutSize, _AudioLinkEmission2CenterOutBand, _AudioLinkEmission2CenterOut, _EmissionAL2Enabled, _AudioLinkEmission2CenterOutDuration);
				emissionStrength2 *= glowInTheDarkMultiplier2 * emissionMask2;
				emission2 = max(emissionStrength2 * emissionColor2, 0);
				
				poiFragData.emission += emission2;
				return emission2 * _EmissionReplace2;
			}
			#endif
			//endex
			//ifex _EnableEmission3==0
			#ifdef POI_EMISSION_3
			float3 applyEmission3(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// Second Emission
				float3 emission3 = 0;
				float emissionStrength3 = 0;
				float3 emissionColor3 = 0;
				
				emissionStrength3 = _EmissionStrength3;
				
				float glowInTheDarkMultiplier3 = calculateGlowInTheDark(_GITDEMinLight3, _GITDEMaxLight3, _GITDEMinEmissionMultiplier3, _GITDEMaxEmissionMultiplier3, _EnableGITDEmission3, _GITDEWorldOrMesh3, poiLight);
				#if defined(PROP_EMISSIONMAP3) || !defined(OPTIMIZER_ENABLED)
				
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled3)
				{
					emissionColor3 = POI2D_SAMPLER_PAN(_EmissionMap3, _MainTex, poiUV(poiMesh.uv[_EmissionMap3UV], _EmissionMap3_ST), _EmissionMap3Pan) * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap3).rgb * poiThemeColor(poiMods, _EmissionColor3.rgb, _EmissionColor3ThemeIndex);
				}
				else
				{
					emissionColor3 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap3, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap3_ST.xy) + _Time.x * _EmissionCenterOutSpeed3).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap3).rgb * poiThemeColor(poiMods, _EmissionColor3.rgb, _EmissionColor3ThemeIndex);
				}
				#else
				emissionColor3 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap3).rgb * poiThemeColor(poiMods, _EmissionColor3.rgb, _EmissionColor3ThemeIndex);
				#endif
				//UNITY_BRANCH
				if (_ScrollingEmission3)
				{
					float3 pos3 = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor3)
					{
						pos3 = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve3)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE3) || !defined(OPTIMIZER_ENABLED)
						emissionStrength3 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve3, _MainTex, poiUV(poiMesh.uv[_EmissionMap3UV], _EmissionScrollingCurve3_ST) + (dot(pos3, _EmissiveScroll_Direction3) * _EmissiveScroll_Interval3) + _Time.x * _EmissiveScroll_Velocity3);
						#endif
					}
					else
					{
						emissionStrength3 *= calculateScrollingEmission(_EmissiveScroll_Direction3, _EmissiveScroll_Velocity3, _EmissiveScroll_Interval3, _EmissiveScroll_Width3, _EmissionScrollingOffset3, pos3);
					}
				}
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled3)
				{
					emissionStrength3 *= calculateBlinkingEmission(_EmissiveBlink_Min3, _EmissiveBlink_Max3, _EmissiveBlink_Velocity3, _EmissionBlinkingOffset3);
				}
				
				applyLumaGradient(poiMods, emissionColor3, _EmissionColor3ThemeIndex, poiLight.nDotV);
				emissionColor3 = hueShift(emissionColor3, frac(_EmissionHueShift3 + _EmissionHueShiftSpeed3 * _Time.x) * _EmissionHueShiftEnabled3);
				#if defined(PROP_EMISSIONMASK3) || !defined(OPTIMIZER_ENABLED)
				float emissionMask3 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask3, _MainTex, poiUV(poiMesh.uv[_EmissionMask3UV], _EmissionMask3_ST) + _Time.x * _EmissionMask3Pan)[_EmissionMask3Channel];
				#else
				float emissionMask3 = 1;
				#endif
				
				if (_EmissionMaskInvert3)
				{
					emissionMask3 = 1 - emissionMask3;
				}
				
				if (_EmissionMask3GlobalMask > 0)
				{
					emissionMask3 = maskBlend(emissionMask3, poiMods.globalMask[_EmissionMask3GlobalMask - 1], _EmissionMask3GlobalMaskBlendType);
				}
				applyALEmmissionStrength(poiMods, emissionStrength3, _EmissionAL3StrengthMod, _EmissionAL3StrengthBand, _EmissionAL3Multipliers, _EmissionAL3MultipliersBand, _EmissionAL3Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength3, _AudioLinkEmission3CenterOutSize, _AudioLinkEmission3CenterOutBand, _AudioLinkEmission3CenterOut, _EmissionAL3Enabled, _AudioLinkEmission3CenterOutDuration);
				emissionStrength3 *= glowInTheDarkMultiplier3 * emissionMask3;
				emission3 = max(emissionStrength3 * emissionColor3, 0);
				
				poiFragData.emission += emission3;
				return emission3 * _EmissionReplace3;
			}
			#endif
			//endex
			
			//ifex _EnableRimLighting==0 && _EnableRim2Lighting==0
			#if defined(_GLOSSYREFLECTIONS_OFF) || defined(POI_RIM2)
			#if defined(_RIMSTYLE_POIYOMI) || defined(_RIM2STYLE_POIYOMI)
			void ApplyPoiyomiRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, inout PoiMods poiMods, float Is_NormalMapToRimLight, float RimInvert, float RimPower, float RimStrength, float RimShadowWidth, float RimShadowToggle, float RimWidth, float RimBlendStrength, float RimMask, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimTex, float4 RimLightColor, float RimLightColorThemeIndex, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimSharpness, float RimShadowMaskRampType, float RimShadowMaskInvert, float RimShadowMaskStrength, float2 RimShadowAlpha, float RimApplyGlobalMaskIndex, float RimApplyGlobalMaskBlendType, float RimBaseColorMix, float RimBrightness, float RimBlendMode, half AudioLinkRimWidthBand, float2 AudioLinkRimWidthAdd, half AudioLinkRimEmissionBand, float2 AudioLinkRimEmissionAdd, half AudioLinkRimBrightnessBand, float2 AudioLinkRimBrightnessAdd, float RimClamp, float rimBias, float rimBiasIntensity)
			{
				float viewDotNormal = abs(dot(poiCam.viewDir, lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight)));
				
				UNITY_BRANCH
				if (RimInvert)
				{
					viewDotNormal = 1 - viewDotNormal;
				}
				
				viewDotNormal = pow(viewDotNormal, RimPower);
				
				if (RimShadowWidth && RimShadowToggle)
				{
					viewDotNormal += lerp(0, (1 - poiLight.nDotLNormalized) * 3, RimShadowWidth);
				}
				
				viewDotNormal *= lerp(1, rimBias, rimBiasIntensity);
				
				float rimStrength = RimStrength;
				
				float rimWidth = lerp( - .05, 1, RimWidth);
				
				float blendStrength = RimBlendStrength;
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (poiMods.audioLinkAvailable)
				{
					rimWidth = clamp(rimWidth + lerp(AudioLinkRimWidthAdd.x, AudioLinkRimWidthAdd.y, poiMods.audioLink[AudioLinkRimWidthBand]), - .05, 1);
					rimStrength += lerp(AudioLinkRimEmissionAdd.x, AudioLinkRimEmissionAdd.y, poiMods.audioLink[AudioLinkRimEmissionBand]);
					blendStrength += lerp(AudioLinkRimBrightnessAdd.x, AudioLinkRimBrightnessAdd.y, poiMods.audioLink[AudioLinkRimBrightnessBand]);
				}
				#endif
				
				float rimMask = RimMask;
				
				if (RimGlobalMask > 0)
				{
					rimMask = maskBlend(rimMask, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				
				float4 rimColor = RimTex;
				rimColor *= float4(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex), RimLightColor.a);
				
				UNITY_BRANCH
				if (RimHueShiftEnabled)
				{
					rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				
				float rim = 1 - smoothstep(min(RimSharpness, rimWidth), rimWidth, viewDotNormal);
				rim *= RimLightColor.a * rimColor.a * rimMask;
				
				if (RimShadowToggle)
				{
					switch(RimShadowMaskRampType)
					{
						case 0:
						float rampedLightMap = poiLight.rampedLightMap;
						if (RimShadowMaskInvert) rampedLightMap = 1 - rampedLightMap;
						rim = lerp(rim, rim * rampedLightMap, RimShadowMaskStrength);
						break;
						case 1:
						float nDotLNormalized = poiLight.nDotLNormalized;
						if (RimShadowMaskInvert) nDotLNormalized = 1 - nDotLNormalized;
						rim = lerp(rim, rim * smoothstep(RimShadowAlpha.x, RimShadowAlpha.y, nDotLNormalized), RimShadowMaskStrength);
						break;
					}
				}
				
				if (RimApplyGlobalMaskIndex > 0)
				{
					applyToGlobalMask(poiMods, RimApplyGlobalMaskIndex-1, RimApplyGlobalMaskBlendType, rim * blendStrength);
				}
				
				float3 finalRimColor = rimColor.rgb * lerp(1, poiFragData.baseColor, RimBaseColorMix);
				finalRimColor *= RimBrightness;
				// Add 0, Replace 1, Multiply 2, Mixed 3
				switch(RimBlendMode)
				{
					case 0: poiFragData.baseColor += finalRimColor * rim * blendStrength; break;
					case 1: poiFragData.baseColor = lerp(poiFragData.baseColor, finalRimColor, rim * blendStrength); break;
					case 2: poiFragData.baseColor = lerp(poiFragData.baseColor, poiFragData.baseColor * finalRimColor, rim * blendStrength); break;
					case 3: poiFragData.baseColor = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * finalRimColor, rim * blendStrength); break;
				}
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
				poiFragData.emission += finalRimColor * rim * rimStrength;
			}
			#endif
			#if defined(_RIMSTYLE_UTS2) || defined(_RIM2STYLE_UTS2)
			void ApplyUTS2RimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float Set_RimLightMask_var, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimLightColor, float RimLightColorThemeIndex, float Is_LightColor_RimLight, float Is_NormalMapToRimLight, float RimLight_Power, float RimLight_InsideMask, float RimLight_FeatherOff, float LightDirection_MaskOn, float Tweak_LightDirection_MaskLevel, float Add_Antipodean_RimLight, float4 Ap_RimLightColor, float RimApColorThemeIndex, float Is_LightColor_Ap_RimLight, float Ap_RimLight_Power, float Ap_RimLight_FeatherOff, float Tweak_RimLightMaskLevel, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimClamp)
			{
				if (RimGlobalMask > 0)
				{
					Set_RimLightMask_var = maskBlend(Set_RimLightMask_var, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				
				float3 rimColor = float3(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex));
				float3 _Is_LightColor_RimLight_var = lerp(rimColor, (rimColor * poiLight.directColor), Is_LightColor_RimLight);
				float _RimArea_var = (1.0 - dot(lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight), poiCam.viewDir));
				float _RimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, RimLight_Power)));
				float _Rimlight_InsideMask_var = saturate(lerp((0.0 + ((_RimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _RimLightPower_var), RimLight_FeatherOff));
				float _VertHalfLambert_var = 0.5 * dot(poiMesh.normals[0], poiLight.direction) + 0.5;
				float3 _LightDirection_MaskOn_var = lerp((_Is_LightColor_RimLight_var * _Rimlight_InsideMask_var), (_Is_LightColor_RimLight_var * saturate((_Rimlight_InsideMask_var - ((1.0 - _VertHalfLambert_var) + Tweak_LightDirection_MaskLevel)))), LightDirection_MaskOn);
				float _ApRimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, Ap_RimLight_Power)));
				float3 ApRimColor = float3(poiThemeColor(poiMods, Ap_RimLightColor.rgb, RimApColorThemeIndex));
				float3 _RimLight_var = (saturate((Set_RimLightMask_var + Tweak_RimLightMaskLevel)) * lerp(_LightDirection_MaskOn_var, (_LightDirection_MaskOn_var + (lerp(ApRimColor, (ApRimColor * poiLight.directColor), Is_LightColor_Ap_RimLight) * saturate((lerp((0.0 + ((_ApRimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _ApRimLightPower_var), Ap_RimLight_FeatherOff) - (saturate(_VertHalfLambert_var) + Tweak_LightDirection_MaskLevel))))), Add_Antipodean_RimLight));
				UNITY_BRANCH
				if (RimHueShiftEnabled)
				{
					_RimLight_var = hueShift(_RimLight_var, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				poiFragData.baseColor += _RimLight_var;
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
			}
			#endif
			#if defined(_RIMSTYLE_LILTOON) || defined(_RIM2STYLE_LILTOON)
			void ApplyLiltoonRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float4 RimColor, float4 RimIndirColor, float4 RimColorTex, float RimMainStrength, float RimNormalStrength, float RimDirRange, float RimIndirRange, float RimFresnelPower, float RimBackfaceMask, float RimDirStrength, float RimBorder, float RimBlur, float RimIndirBorder, float RimIndirBlur, float RimShadowMask, float RimEnableLighting, float RimVRParallaxStrength, float RimGlobalMask, float RimGlobalMaskBlendType, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimClamp)
			{
				if (RimGlobalMask > 0)
				{
					RimColorTex.a = maskBlend(RimColorTex.a, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				float4 rimColor = RimColor;
				float4 rimIndirColor = RimIndirColor;
				rimColor *= RimColorTex;
				rimIndirColor *= RimColorTex;
				
				if (RimHueShiftEnabled)
				{
					rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
					rimIndirColor.rgb = hueShift(rimIndirColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				
				rimColor.rgb = lerp(rimColor.rgb, rimColor.rgb * poiFragData.baseColor, RimMainStrength);
				
				// View direction
				float3 centerViewDir = !IsOrthographicCamera() ? normalize(getCameraPosition() - poiMesh.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 viewDir = lerp(centerViewDir, poiCam.viewDir, RimVRParallaxStrength);
				
				// Normal
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], RimNormalStrength);
				float nvabs = abs(dot(normal, viewDir));
				
				// Factor
				float lnRaw = dot(poiLight.direction, normal) * 0.5 + 0.5;
				float lnDir = saturate((lnRaw + RimDirRange) / (1.0 + RimDirRange));
				float lnIndir = saturate((1.0-lnRaw + RimIndirRange) / (1.0 + RimIndirRange));
				float rim = pow(saturate(1.0 - nvabs), RimFresnelPower);
				rim = !poiMesh.isFrontFace && RimBackfaceMask ? 0.0 : rim;
				float rimDir = lerp(rim, rim * lnDir, RimDirStrength);
				float rimIndir = rim * lnIndir * RimDirStrength;
				
				rimDir = poiEdgeLinear(rimDir, RimBorder, RimBlur);
				rimIndir = poiEdgeLinear(rimIndir, RimIndirBorder, RimIndirBlur);
				
				rimDir = lerp(rimDir, rimDir * poiLight.rampedLightMap, RimShadowMask);
				rimIndir = lerp(rimIndir, rimIndir * poiLight.rampedLightMap, RimShadowMask);
				
				// Blend
				float3 rimSum = rimDir * rimColor.a * rimColor.rgb + rimIndir * rimIndirColor.a * rimIndirColor.rgb;
				poiFragData.baseColor += rimSum * RimEnableLighting;
				poiFragData.emission += rimSum * (1-RimEnableLighting);
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#ifdef _POI_DEPTH_RIMLIGHT
			
			float PositivePow(float base, float power)
			{
				return pow(max(abs(base), Epsilon), power);
			}
			
			float GetScaleWithHight()
			{
				return _ScreenParams.y / 1080;
			}
			
			float GetSSRimScale(float z)
			{
				float w = (1.0 / (PositivePow(z + saturate(UNITY_MATRIX_P._m00), 1.5) + 0.75)) * GetScaleWithHight();
				w *= lerp(1, UNITY_MATRIX_P._m00, 0.60 * saturate(0.25 * z * z));
				return w < 0.01 ? 0 : w;
			}
			
			void ApplyDepthRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiLight poiLight, in PoiMods poiMods)
			{
				float rim = 0;
				float perspectiveDivide = 1.0f / poiCam.clipPos.w;
				float4 direction = poiCam.worldDirection * perspectiveDivide;
				float2 screenPos = poiCam.grabPos.xy * perspectiveDivide;
				float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, screenPos);
				
				#if UNITY_REVERSED_Z
				if (z == 0) return;
				#else
				if (z == 1) return;
				#endif
				
				float depth = CorrectedLinearEyeDepth(z, direction.w);
				
				switch(_DepthRimType)
				{
					case 0:
					{
						float3 viewPos = UnityObjectToViewPos(poiMesh.localPos);
						float3 viewDir = normalize(viewPos);
						
						float3 viewNorm = mul((float3x3)UNITY_MATRIX_V, poiMesh.normals[_DepthRimNormalToUse]);
						float3 viewCrossNorm = cross(viewDir, viewNorm);
						float2 N_View = normalize(float2(-viewCrossNorm.y, viewCrossNorm.x));
						
						float3 viewLight = mul((float3x3)UNITY_MATRIX_V, poiLight.direction);
						float3 viewCrossLight = cross(viewDir, viewLight);
						float2 L_View = normalize(float2(-viewCrossLight.y, viewCrossLight.x));
						
						//float lDotN = saturate(poiLight.nDotL + _RimLightLength);
						float scale = _DepthRimWidth * GetSSRimScale(depth);
						float2 ssUV1 = clamp(screenPos + N_View * .1 * scale, 0, _ScreenParams.xy - 1);
						float depthDiff = z - SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, ssUV1) ;
						
						rim = smoothstep(0.24 * _DepthRimSharpness * z, 0.25 * z, depthDiff);
						rim *= lerp(1, (dot(L_View, N_View) > 0), _DepthRimHideInShadow);
					}
					break;
					case 1:
					{
						//float lDotN = saturate(poiLight.nDotL + _RimLightLength);
						float scale = _DepthRimWidth * GetSSRimScale(depth);
						float depthDiff = 0;
						for (int i = 0; i < 9; i++)
						{
							float2 ssUV1 = clamp(screenPos + sobelSamplePoints[i] * .1 * scale, 0, _ScreenParams.xy - 1);
							depthDiff = max(depthDiff, z - SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, ssUV1));
						}
						rim = smoothstep(0.24 * _DepthRimSharpness * z, 0.25 * z, depthDiff);
						rim *= lerp(1, lerp(poiLight.vertexNDotL > 0, poiLight.nDotL > 0, _DepthRimNormalToUse), _DepthRimHideInShadow);
					}
					break;
				}
				
				float3 rimColor = poiThemeColor(poiMods, _DepthRimColor.rgb, _DepthRimColorThemeIndex).rgb * lerp(1, poiLight.directColor, _DepthRimMixLightColor) * lerp(1, poiFragData.baseColor, _DepthRimMixBaseColor) * _DepthRimBrightness;
				
				poiLight.finalLightAdd += rim * rimColor * _DepthRimAdditiveLighting;
				poiFragData.emission += rim * rimColor * _DepthRimEmission;
				poiFragData.baseColor = lerp(poiFragData.baseColor, rimColor, rim * _DepthRimReplace);
				poiFragData.baseColor += rim * rimColor * _DepthRimAdd;
				poiFragData.baseColor *= lerp(1, rimColor, rim * _DepthRimMultiply);
			}
			#endif
			//endex
			
			//ifex _GlitterEnable==0
			#ifdef _SUNDISK_SIMPLE
			
			float3 RandomColorFromPoint(float2 rando)
			{
				fixed hue = random2(rando.x + rando.y).x;
				fixed saturation = lerp(_GlitterMinMaxSaturation.x, _GlitterMinMaxSaturation.y, rando.x);
				fixed value = lerp(_GlitterMinMaxBrightness.x, _GlitterMinMaxBrightness.y, rando.y);
				float3 hsv = float3(hue, saturation, value);
				return HSVtoRGB(hsv);
			}
			
			void applyGlitter(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods)
			{
				// Scale
				float2 st = frac(poiMesh.uv[_GlitterUV] + _GlitterUVPanning.xy * _Time.x) * _GlitterFrequency;
				
				// Tile the space
				float2 i_st = floor(st);
				float2 f_st = frac(st);
				
				float m_dist = 10.;  // minimun distance
				float2 m_point = 0;        // minimum point
				float2 randoPoint = 0;
				float2 dank;
				for (int j = -1; j <= 1; j++)
				{
					for (int i = -1; i <= 1; i++)
					{
						float2 neighbor = float2(i, j);
						float2 pos = random2(i_st + neighbor);
						float2 rando = pos;
						pos = 0.5 + 0.5 * sin(_GlitterJitter * 6.2831 * pos);
						float2 diff = neighbor + pos - f_st;
						float dist = length(diff);
						
						if (dist < m_dist)
						{
							dank = diff;
							m_dist = dist;
							m_point = pos;
							randoPoint = rando;
						}
					}
				}
				
				float randomFromPoint = random(randoPoint);
				
				float size = _GlitterSize;
				UNITY_BRANCH
				if (_GlitterRandomSize)
				{
					size = remapClamped(0, 1, randomFromPoint, _GlitterMinMaxSize.x, _GlitterMinMaxSize.y);
				}
				
				// Assign a color using the closest point position
				//color += dot(m_point, float2(.3, .6));
				
				// Add distance field to closest point center
				// color.g = m_dist;
				
				// Show isolines
				//color -= abs(sin(40.0 * m_dist)) * 0.07;
				
				// Draw cell center
				half glitterAlpha = 1;
				switch(_GlitterShape)
				{
					case 0: //circle
					glitterAlpha = saturate((size - m_dist) / clamp(fwidth(m_dist), 0.0001, 1.0));
					break;
					case 1: //sqaure
					float jaggyFix = pow(poiCam.distanceToVert, 2) * _GlitterJaggyFix;
					
					UNITY_BRANCH
					if (_GlitterRandomRotation == 1 || _GlitterTextureRotation != 0)
					{
						float2 center = float2(0, 0);
						float randomBoy = 0;
						UNITY_BRANCH
						if (_GlitterRandomRotation)
						{
							randomBoy = random(randoPoint);
						}
						float theta = radians((randomBoy + _Time.x * _GlitterTextureRotation) * 360);
						float cs = cos(theta);
						float sn = sin(theta);
						dank = float2((dank.x - center.x) * cs - (dank.y - center.y) * sn + center.x, (dank.x - center.x) * sn + (dank.y - center.y) * cs + center.y);
						glitterAlpha = (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.x))) * (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.y)));
					}
					else
					{
						glitterAlpha = (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.x))) * (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.y)));
					}
					break;
				}
				
				float3 finalGlitter = 0;
				
				half3 glitterColor = poiThemeColor(poiMods, _GlitterColor, _GlitterColorThemeIndex);
				
				float3 norm = lerp(poiMesh.normals[0], poiMesh.normals[1], _GlitterUseNormals);
				float3 randomRotation = 0;
				switch(_GlitterMode)
				{
					case 0:
					UNITY_BRANCH
					if (_GlitterSpeed > 0)
					{
						randomRotation = randomFloat3WiggleRange(randoPoint, _GlitterAngleRange, _GlitterSpeed);
					}
					else
					{
						randomRotation = randomFloat3Range(randoPoint, _GlitterAngleRange);
					}
					
					float3 glitterReflectionDirection = normalize(mul(poiRotationMatrixFromAngles(randomRotation), norm));
					finalGlitter = lerp(0, _GlitterMinBrightness * glitterAlpha, glitterAlpha) + max(pow(saturate(dot(lerp(glitterReflectionDirection, poiCam.viewDir, _GlitterBias), poiCam.viewDir)), _GlitterContrast), 0);
					finalGlitter *= glitterAlpha;
					break;
					case 1:
					float offset = random(randoPoint);
					float brightness = sin((_Time.x + offset) * _GlitterSpeed) * _glitterFrequencyLinearEmissive - (_glitterFrequencyLinearEmissive - 1);
					finalGlitter = max(_GlitterMinBrightness * glitterAlpha, brightness * glitterAlpha * smoothstep(0, 1, 1 - m_dist * _GlitterCenterSize * 10));
					break;
					case 2:
					if (_GlitterSpeed > 0)
					{
						randomRotation = randomFloat3WiggleRange(randoPoint, _GlitterAngleRange, _GlitterSpeed);
					}
					else
					{
						randomRotation = randomFloat3Range(randoPoint, _GlitterAngleRange);
					}
					
					float3 glitterLightReflectionDirection = normalize(mul(poiRotationMatrixFromAngles(randomRotation), norm));
					
					#ifdef POI_PASS_ADD
					glitterAlpha *= poiLight.nDotLSaturated * poiLight.attenuation;
					#endif
					#ifdef UNITY_PASS_FORWARDBASE
					glitterAlpha *= poiLight.nDotLSaturated;
					#endif
					
					float3 halfDir = normalize(poiLight.direction + poiCam.viewDir);
					float specAngle = max(dot(halfDir, glitterLightReflectionDirection), 0.0);
					
					finalGlitter = lerp(0, _GlitterMinBrightness * glitterAlpha, glitterAlpha) + max(pow(specAngle, _GlitterContrast), 0);
					
					glitterColor *= poiLight.directColor;
					finalGlitter *= glitterAlpha;
					
					break;
				}
				
				glitterColor *= lerp(1, poiFragData.baseColor, _GlitterUseSurfaceColor);
				#if defined(PROP_GLITTERCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				glitterColor *= POI2D_SAMPLER_PAN(_GlitterColorMap, _MainTex, poiUV(poiMesh.uv[_GlitterColorMapUV], _GlitterColorMap_ST), _GlitterColorMapPan).rgb;
				#endif
				float2 uv = remapClamped(-size, size, dank, 0, 1);
				UNITY_BRANCH
				if (_GlitterRandomRotation == 1 || _GlitterTextureRotation != 0 && !_GlitterShape)
				{
					float2 fakeUVCenter = float2(.5, .5);
					float randomBoy = 0;
					UNITY_BRANCH
					if (_GlitterRandomRotation)
					{
						randomBoy = random(randoPoint);
					}
					float theta = radians((randomBoy + _Time.x * _GlitterTextureRotation) * 360);
					float cs = cos(theta);
					float sn = sin(theta);
					uv = float2((uv.x - fakeUVCenter.x) * cs - (uv.y - fakeUVCenter.y) * sn + fakeUVCenter.x, (uv.x - fakeUVCenter.x) * sn + (uv.y - fakeUVCenter.y) * cs + fakeUVCenter.y);
				}
				
				#if defined(PROP_GLITTERTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 glitterTexture = POI2D_SAMPLER_PAN(_GlitterTexture, _MainTex, poiUV(uv, _GlitterTexture_ST), _GlitterTexturePan);
				#else
				float4 glitterTexture = 1;
				#endif
				//float4 glitterTexture = _GlitterTexture.SampleGrad(sampler_MainTex, frac(uv), ddx(uv), ddy(uv));
				glitterColor *= glitterTexture.rgb;
				#if defined(PROP_GLITTERMASK) || !defined(OPTIMIZER_ENABLED)
				float glitterMask = POI2D_SAMPLER_PAN(_GlitterMask, _MainTex, poiUV(poiMesh.uv[_GlitterMaskUV], _GlitterMask_ST), _GlitterMaskPan)[_GlitterMaskChannel];
				#else
				float glitterMask = 1;
				#endif
				
				glitterMask *= lerp(1, poiLight.rampedLightMap, _GlitterHideInShadow);
				
				if (_GlitterMaskGlobalMask > 0)
				{
					glitterMask = maskBlend(glitterMask, poiMods.globalMask[_GlitterMaskGlobalMask - 1], _GlitterMaskGlobalMaskBlendType);
				}
				
				if (_GlitterRandomColors)
				{
					glitterColor *= RandomColorFromPoint(random2(randoPoint.x + randoPoint.y));
				}
				
				UNITY_BRANCH
				if (_GlitterHueShiftEnabled)
				{
					glitterColor.rgb = hueShift(glitterColor.rgb, _GlitterHueShift + _Time.x * _GlitterHueShiftSpeed);
				}
				
				UNITY_BRANCH
				if (_GlitterBlendType == 1)
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, finalGlitter * glitterColor * _GlitterBrightness, finalGlitter * glitterTexture.a * glitterMask);
					poiFragData.emission += finalGlitter * glitterColor * max(0, (_GlitterBrightness - 1) * glitterTexture.a) * glitterMask;
				}
				else
				{
					poiFragData.emission += finalGlitter * glitterColor * _GlitterBrightness * glitterTexture.a * glitterMask;
				}
			}
			#endif
			//endex
			
			//ifex _SubsurfaceScattering==0
			#ifdef POI_SUBSURFACESCATTERING
			void applySubsurfaceScattering(in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh)
			{
				#if defined(PROP_SSSTHICKNESSMAP) || !defined(OPTIMIZER_ENABLED)
				float SSS = 1 - POI2D_SAMPLER_PAN(_SSSThicknessMap, _MainTex, poiUV(poiMesh.uv[_SSSThicknessMapUV], _SSSThicknessMap_ST), _SSSThicknessMapPan)[_SSSThicknessMapChannel];
				#else
				float SSS = 1;
				#endif
				
				float3 vLTLight = poiLight.direction + poiMesh.normals[0] * _SSSDistortion;
				float flTDot = pow(saturate(dot(poiCam.viewDir, -vLTLight)), _SSSSpread) * _SSSStrength;
				#ifdef UNITY_PASS_FORWARDBASE
				float3 fLT = (flTDot) * saturate(SSS + - 1 * _SSSThicknessMod);
				#else
				float3 fLT = poiLight.additiveShadow * (flTDot) * saturate(SSS + - 1 * _SSSThicknessMod);
				#endif
				
				poiLight.finalLightAdd += fLT * poiLight.directColor * _SSSColor * poiLight.attenuation;
			}
			#endif
			//endex
			
			//ifex _MochieBRDF==0 && _ClearCoatBRDF==0
			#if defined(MOCHIE_PBR) || defined(POI_CLEARCOAT)
			
			/*
			* Copyright 2022 orels1
			*
			* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
			*
			* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
			*
			* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
			*/
			
			// https://github.com/orels1/orels-Unity-Shaders
			
			float GSAA_Filament(float3 worldNormal, float perceptualRoughness, float gsaaVariance, float gsaaThreshold)
			{
				// Kaplanyan 2016, "Stable specular highlights"
				// Tokuyoshi 2017, "Error Reduction and Simplification for Shading Anti-Aliasing"
				// Tokuyoshi and Kaplanyan 2019, "Improved Geometric Specular Antialiasing"
				
				// This implementation is meant for deferred rendering in the original paper but
				// we use it in forward rendering as well (as discussed in Tokuyoshi and Kaplanyan
				// 2019). The main reason is that the forward version requires an expensive transform
				// of the float vector by the tangent frame for every light. This is therefore an
				// approximation but it works well enough for our needs and provides an improvement
				// over our original implementation based on Vlachos 2015, "Advanced VR Rendering".
				
				float3 du = ddx(worldNormal);
				float3 dv = ddy(worldNormal);
				
				float variance = gsaaVariance * (dot(du, du) + dot(dv, dv));
				
				float roughness = perceptualRoughness * perceptualRoughness;
				float kernelRoughness = min(2.0 * variance, gsaaThreshold);
				float squareRoughness = saturate(roughness * roughness + kernelRoughness);
				
				return sqrt(sqrt(squareRoughness));
			}
			
			/*
			MIT END
			*/
			
			bool SceneHasReflections()
			{
				float width, height;
				unity_SpecCube0.GetDimensions(width, height);
				return !(width * height < 2);
			}
			
			float3 GetWorldReflections(float3 reflDir, float3 worldPos, float roughness)
			{
				float3 baseReflDir = reflDir;
				reflDir = BoxProjection(reflDir, worldPos, unity_SpecCube0_ProbePosition, unity_SpecCube0_BoxMin, unity_SpecCube0_BoxMax);
				float4 envSample0 = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflDir, roughness * UNITY_SPECCUBE_LOD_STEPS);
				float3 p0 = DecodeHDR(envSample0, unity_SpecCube0_HDR);
				float interpolator = unity_SpecCube0_BoxMin.w;
				UNITY_BRANCH
				if (interpolator < 0.99999)
				{
					float3 refDirBlend = BoxProjection(baseReflDir, worldPos, unity_SpecCube1_ProbePosition, unity_SpecCube1_BoxMin, unity_SpecCube1_BoxMax);
					float4 envSample1 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, refDirBlend, roughness * UNITY_SPECCUBE_LOD_STEPS);
					float3 p1 = DecodeHDR(envSample1, unity_SpecCube1_HDR);
					p0 = lerp(p1, p0, interpolator);
				}
				return p0;
			}
			
			float3 GetReflections(in PoiCam poiCam, in PoiLight pl, in PoiMesh poiMesh, float roughness, float ForceFallback, float LightFallback, samplerCUBE reflectionCube, float4 hdrData, float3 reflectionDir)
			{
				float3 reflections = 0;
				float3 lighting = pl.finalLighting;
				// This is a separate conditional so it can optimize out when ForceFallback isn't animated
				if (ForceFallback == 0)
				{
					UNITY_BRANCH
					if (SceneHasReflections())
					{
						#ifdef UNITY_PASS_FORWARDBASE
						reflections = GetWorldReflections(reflectionDir, poiMesh.worldPos.xyz, roughness);
						#endif
					}
					else
					{
						#ifdef UNITY_PASS_FORWARDBASE
						reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
						reflections = DecodeHDR(float4(reflections, 1), hdrData) * lerp(1, pl.finalLighting, LightFallback);
						#endif
						#ifdef POI_PASS_ADD
						if (LightFallback)
						{
							reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
							reflections = DecodeHDR(float4(reflections, 1), hdrData) * pl.finalLighting;
						}
						#endif
					}
				}
				else
				{
					#ifdef UNITY_PASS_FORWARDBASE
					reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
					reflections = DecodeHDR(float4(reflections, 1), hdrData) * lerp(1, pl.finalLighting, LightFallback);
					#endif
					#ifdef POI_PASS_ADD
					if (LightFallback)
					{
						reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
						reflections = DecodeHDR(float4(reflections, 1), hdrData) * pl.finalLighting;
					}
					#endif
				}
				reflections *= pl.occlusion;
				return reflections;
			}
			
			float GetGGXTerm(float nDotL, float nDotV, float nDotH, float roughness)
			{
				float visibilityTerm = 0;
				if (nDotL > 0)
				{
					float rough = roughness;
					float rough2 = roughness * roughness;
					
					float lambdaV = nDotL * (nDotV * (1 - rough) + rough);
					float lambdaL = nDotV * (nDotL * (1 - rough) + rough);
					
					visibilityTerm = 0.5f / (lambdaV + lambdaL + 1e-5f);
					float d = (nDotH * rough2 - nDotH) * nDotH + 1.0f;
					float dotTerm = UNITY_INV_PI * rough2 / (d * d + 1e-7f);
					
					visibilityTerm *= dotTerm * UNITY_PI;
				}
				return visibilityTerm;
			}
			
			void GetSpecFresTerm(float nDotL, float nDotV, float nDotH, float lDotH, inout float3 specularTerm, inout float3 fresnelTerm, float3 specCol, float roughness)
			{
				specularTerm = GetGGXTerm(nDotL, nDotV, nDotH, roughness);
				fresnelTerm = FresnelTerm(specCol, lDotH);
				specularTerm = max(0, specularTerm * max(0.00001, nDotL));
			}
			
			float GetRoughness(float smoothness)
			{
				float rough = 1 - smoothness;
				rough *= 1.7 - 0.7 * rough;
				return rough;
			}
			#endif
			//endex
			
			//ifex _MochieBRDF==0
			#ifdef MOCHIE_PBR
			void MochieBRDF(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				float smoothness = _MochieRoughnessMultiplier;
				float smoothness2 = _MochieRoughnessMultiplier2;
				float metallic = _MochieMetallicMultiplier;
				float specularMask = 1;
				float reflectionMask = 1;
				
				smoothness *= poiMods.PBR.x;
				smoothness2 *= poiMods.PBR.x;
				metallic *= poiMods.PBR.y;
				specularMask *= poiMods.PBR.z;
				reflectionMask *= poiMods.PBR.w;
				
				#if defined(PROP_MOCHIEMETALLICMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 PBRMaps = POI2D_SAMPLER_PAN_STOCHASTIC(_MochieMetallicMaps, _MainTex, poiUV(poiMesh.uv[_MochieMetallicMapsUV], _MochieMetallicMaps_ST), _MochieMetallicMapsPan, _MochieMetallicMapsStochastic);
				UNITY_BRANCH
				if (_PBRSplitMaskSample)
				{
					float4 PBRSplitMask = POI2D_SAMPLER_PAN_STOCHASTIC(_MochieMetallicMaps, _MainTex, poiUV(poiMesh.uv[_MochieMetallicMasksUV], _PBRMaskScaleTiling), _MochieMetallicMasksPan.xy, _PBRSplitMaskStochastic);
					assignValueToVectorFromIndex(PBRMaps, _MochieMetallicMapsReflectionMaskChannel, PBRSplitMask[_MochieMetallicMapsReflectionMaskChannel]);
					assignValueToVectorFromIndex(PBRMaps, _MochieMetallicMapsSpecularMaskChannel, PBRSplitMask[_MochieMetallicMapsSpecularMaskChannel]);
				}
				
				if (_MochieMetallicMapsMetallicChannel < 4)
				{
					metallic *= PBRMaps[_MochieMetallicMapsMetallicChannel];
				}
				if (_MochieMetallicMapsRoughnessChannel < 4)
				{
					smoothness *= PBRMaps[_MochieMetallicMapsRoughnessChannel];
					smoothness2 *= PBRMaps[_MochieMetallicMapsRoughnessChannel];
				}
				if (_MochieMetallicMapsReflectionMaskChannel < 4)
				{
					reflectionMask *= PBRMaps[_MochieMetallicMapsReflectionMaskChannel];
				}
				if (_MochieMetallicMapsSpecularMaskChannel < 4)
				{
					specularMask *= PBRMaps[_MochieMetallicMapsSpecularMaskChannel];
				}
				#endif
				
				reflectionMask *= _MochieReflectionStrength;
				specularMask *= _MochieSpecularStrength;
				
				if (_MochieMetallicGlobalMask > 0)
				{
					metallic = customBlend(metallic, poiMods.globalMask[_MochieMetallicGlobalMask - 1], _MochieMetallicGlobalMaskBlendType);
				}
				if (_MochieSmoothnessGlobalMask > 0)
				{
					smoothness = customBlend(smoothness, poiMods.globalMask[_MochieSmoothnessGlobalMask - 1], _MochieSmoothnessGlobalMaskBlendType);
					smoothness2 = customBlend(smoothness2, poiMods.globalMask[_MochieSmoothnessGlobalMask - 1], _MochieSmoothnessGlobalMaskBlendType);
				}
				if (_MochieReflectionStrengthGlobalMask > 0)
				{
					reflectionMask = customBlend(reflectionMask, poiMods.globalMask[_MochieReflectionStrengthGlobalMask - 1], _MochieReflectionStrengthGlobalMaskBlendType);
				}
				if (_MochieSpecularStrengthGlobalMask > 0)
				{
					specularMask = customBlend(specularMask, poiMods.globalMask[_MochieSpecularStrengthGlobalMask - 1], _MochieSpecularStrengthGlobalMaskBlendType);
				}
				
				if (_MochieMetallicMapInvert)
				{
					metallic = 1 - metallic;
				}
				if (_MochieRoughnessMapInvert)
				{
					smoothness = 1 - smoothness;
					smoothness2 = 1 - smoothness2;
				}
				if (_MochieReflectionMaskInvert)
				{
					reflectionMask = 1 - reflectionMask;
				}
				if (_MochieSpecularMaskInvert)
				{
					specularMask = 1 - specularMask;
				}
				#ifdef TPS_Penetrator
				if (_BRDFTPSDepthEnabled)
				{
					reflectionMask = lerp(0, reflectionMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _BRDFTPSReflectionMaskStrength);
					specularMask = lerp(0, specularMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _BRDFTPSSpecularMaskStrength);
				}
				#endif
				
				float roughness = GetRoughness(smoothness);
				float roughness2 = GetRoughness(smoothness2);
				float3 specCol = lerp(unity_ColorSpaceDielectricSpec.rgb, poiFragData.baseColor, metallic);
				float omr = unity_ColorSpaceDielectricSpec.a - metallic * unity_ColorSpaceDielectricSpec.a;
				float percepRough = 1 - smoothness;
				float percepRough2 = 1 - smoothness2;
				UNITY_BRANCH
				if (_MochieGSAAEnabled)
				{
					percepRough = GSAA_Filament(poiMesh.normals[_PBRNormalSelect], percepRough, _PoiGSAAVariance, _PoiGSAAThreshold);
					if (_Specular2ndLayer == 1 && _MochieSpecularStrength2 > 0)
					{
						percepRough2 = GSAA_Filament(poiMesh.normals[_PBRNormalSelect], percepRough2, _PoiGSAAVariance, _PoiGSAAThreshold);
					}
				}
				float brdfRoughness = percepRough * percepRough;
				brdfRoughness = max(brdfRoughness, 0.002);
				
				float brdfRoughness2 = percepRough2 * percepRough2;
				brdfRoughness2 = max(brdfRoughness2, 0.002);
				
				float3 diffuse = poiFragData.baseColor;
				float3 specular = 0;
				float3 specular2 = 0;
				float3 vSpecular = 0;
				float3 vSpecular2 = 0;
				float3 reflections = 0;
				float3 environment = 0;
				
				float attenuation = min(poiLight.nDotLSaturated, lerp(poiLight.attenuation, 1, _IgnoreCastedShadows));
				#ifdef POI_PASS_ADD
				attenuation *= lerp(poiLight.additiveShadow, 1, _IgnoreCastedShadows);
				#endif
				
				float3 fresnelTerm = 1;
				float3 specularTerm = 1;
				
				float pbrNDotL = lerp(poiLight.vertexNDotL, poiLight.nDotL, _PBRNormalSelect);
				float pbrNDotV = lerp(poiLight.vertexNDotV, poiLight.nDotV, _PBRNormalSelect);
				float pbrNDotH = lerp(poiLight.vertexNDotH, poiLight.nDotH, _PBRNormalSelect);
				float3 pbrReflectionDir = lerp(poiCam.vertexReflectionDir, poiCam.reflectionDir, _PBRNormalSelect);
				
				GetSpecFresTerm(pbrNDotL, pbrNDotV, pbrNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness);
				specular = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * attenuation;
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						fresnelTerm = 1;
						specularTerm = 1;
						float pbrVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], _PBRNormalSelect);
						float pbrVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], _PBRNormalSelect);
						GetSpecFresTerm(pbrVDotNL, pbrNDotV, pbrVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness);
						vSpecular += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * poiLight.vAttenuation[index];
					}
					#endif
				}
				
				if (_Specular2ndLayer == 1)
				{
					float3 fresnelTerm = 1;
					float3 specularTerm = 1;
					GetSpecFresTerm(pbrNDotL, pbrNDotV, pbrNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness2);
					specular2 = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * attenuation * _MochieSpecularStrength2;
					
					if (_LightingVertexLightingEnabled)
					{
						#if defined(VERTEXLIGHT_ON)
						for (int index = 0; index < 4; index++)
						{
							fresnelTerm = 1;
							specularTerm = 1;
							float pbrVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], _PBRNormalSelect);
							float pbrVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], _PBRNormalSelect);
							GetSpecFresTerm(pbrVDotNL, pbrNDotV, pbrVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness2);
							vSpecular2 += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * poiLight.vAttenuation[index] * _MochieSpecularStrength2;
						}
						#endif
					}
				}
				
				float surfaceReduction = (1.0 / (brdfRoughness * brdfRoughness + 1.0));
				float grazingTerm = saturate(smoothness + (1 - omr));
				float3 reflCol = GetReflections(poiCam, poiLight, poiMesh, roughness, _MochieForceFallback, _MochieLitFallback, _MochieReflCube, _MochieReflCube_HDR, pbrReflectionDir);
				reflections = surfaceReduction * reflCol * lerp(1, FresnelLerp(specCol, grazingTerm, pbrNDotV), _RefSpecFresnel);
				reflections *= poiThemeColor(poiMods, _MochieReflectionTint, _MochieReflectionTintThemeIndex);
				reflections *= reflectionMask;
				#ifdef POI_PASS_ADD
				reflections *= poiLight.attenuation;
				#endif
				diffuse = lerp(diffuse, diffuse * omr, reflectionMask);
				
				poiMods.PBR = float4(smoothness, metallic, specularMask, reflectionMask);
				
				environment = max(specular + vSpecular, specular2 + vSpecular2);
				environment += reflections;
				diffuse *= poiLight.finalLighting;
				poiFragData.finalColor = diffuse;
				poiLight.finalLightAdd += environment;
			}
			#endif
			//endex
			//ifex _ClearCoatBRDF==0
			#ifdef POI_CLEARCOAT
			void poiClearCoat(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float clearCoatMask = _ClearCoatStrength;
				float smoothness = _ClearCoatSmoothness;
				float reflectionMask = _ClearCoatReflectionStrength;
				float specularMask = _ClearCoatSpecularStrength;
				
				#if defined(PROP_CLEARCOATMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 PBRMaps = POI2D_SAMPLER_PAN_STOCHASTIC(_ClearCoatMaps, _MainTex, poiUV(poiMesh.uv[_ClearCoatMapsUV], _ClearCoatMaps_ST), _ClearCoatMapsPan, _ClearCoatMapsStochastic);
				
				if (_ClearCoatMapsClearCoatMaskChannel < 4)
				{
					clearCoatMask *= PBRMaps[_ClearCoatMapsClearCoatMaskChannel];
				}
				if (_ClearCoatMapsRoughnessChannel < 4)
				{
					smoothness *= PBRMaps[_ClearCoatMapsRoughnessChannel];
				}
				if (_ClearCoatMapsReflectionMaskChannel < 4)
				{
					reflectionMask *= PBRMaps[_ClearCoatMapsReflectionMaskChannel];
				}
				if (_ClearCoatMapsSpecularMaskChannel < 4)
				{
					specularMask *= PBRMaps[_ClearCoatMapsSpecularMaskChannel];
				}
				#endif
				
				if (_ClearCoatGlobalMask > 0)
				{
					clearCoatMask = customBlend(reflectionMask, poiMods.globalMask[_ClearCoatGlobalMask - 1], _ClearCoatGlobalMaskBlendType);
				}
				if (_ClearCoatSmoothnessGlobalMask > 0)
				{
					smoothness = customBlend(smoothness, poiMods.globalMask[_ClearCoatSmoothnessGlobalMask - 1], _ClearCoatSmoothnessGlobalMaskBlendType);
				}
				if (_ClearCoatReflectionStrengthGlobalMask > 0)
				{
					reflectionMask = customBlend(reflectionMask, poiMods.globalMask[_ClearCoatReflectionStrengthGlobalMask - 1], _ClearCoatReflectionStrengthGlobalMaskBlendType);
				}
				if (_ClearCoatSpecularStrengthGlobalMask > 0)
				{
					specularMask = customBlend(specularMask, poiMods.globalMask[_ClearCoatSpecularStrengthGlobalMask - 1], _ClearCoatSpecularStrengthGlobalMaskBlendType);
				}
				
				if (_ClearCoatMaskInvert)
				{
					clearCoatMask = 1 - clearCoatMask;
				}
				if (_ClearCoatSmoothnessMapInvert)
				{
					smoothness = 1 - smoothness;
				}
				if (_ClearCoatReflectionMaskInvert)
				{
					reflectionMask = 1 - reflectionMask;
				}
				if (_ClearCoatSpecularMaskInvert)
				{
					specularMask = 1 - specularMask;
				}
				#ifdef TPS_Penetrator
				if (_ClearCoatTPSDepthMaskEnabled)
				{
					clearCoatMask = lerp(0, clearCoatMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _ClearCoatTPSMaskStrength);
				}
				#endif
				
				float roughness = GetRoughness(smoothness);
				float3 specCol = 0.220916301;
				float omr = unity_ColorSpaceDielectricSpec.a;
				float percepRough = 1 - smoothness;
				UNITY_BRANCH
				if (_ClearCoatGSAAEnabled)
				{
					percepRough = GSAA_Filament(poiMesh.normals[_ClearCoatNormalSelect], percepRough, _ClearCoatGSAAVariance, _ClearCoatGSAAThreshold);
				}
				float brdfRoughness = percepRough * percepRough;
				brdfRoughness = max(brdfRoughness, 0.002);
				
				float3 diffuse = 0;
				float3 specular = 0;
				float3 vSpecular = 0;
				float3 reflections = 0;
				float3 environment = 0;
				float attenuation = min(poiLight.nDotLSaturated, lerp(poiLight.attenuation, 1, _CCIgnoreCastedShadows));
				
				float3 fresnelTerm = 1;
				float3 specularTerm = 1;
				
				float clearcoatNDotL = lerp(poiLight.vertexNDotL, poiLight.nDotL, _ClearCoatNormalSelect);
				float clearcoatNDotV = lerp(poiLight.vertexNDotV, poiLight.nDotV, _ClearCoatNormalSelect);
				float clearcoatNDotH = lerp(poiLight.vertexNDotH, poiLight.nDotH, _ClearCoatNormalSelect);
				float3 clearcoatReflectionDir = lerp(poiCam.vertexReflectionDir, poiCam.reflectionDir, _ClearCoatNormalSelect);
				
				GetSpecFresTerm(clearcoatNDotL, clearcoatNDotV, clearcoatNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness);
				specular = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _ClearCoatSpecularTint, _ClearCoatSpecularTintThemeIndex) * poiLight.occlusion * attenuation;
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						fresnelTerm = 1;
						specularTerm = 1;
						float clearcoatVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], _ClearCoatNormalSelect);
						float clearcoatVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], _ClearCoatNormalSelect);
						GetSpecFresTerm(clearcoatVDotNL, clearcoatNDotV, clearcoatVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness);
						vSpecular += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _ClearCoatSpecularTint, _ClearCoatSpecularTintThemeIndex) * poiLight.occlusion * poiLight.vAttenuation[index];
					}
					#endif
				}
				
				float surfaceReduction = (1.0 / (brdfRoughness * brdfRoughness + 1.0));
				float grazingTerm = saturate(smoothness + (1 - omr));
				float3 reflCol = GetReflections(poiCam, poiLight, poiMesh, roughness, _ClearCoatForceFallback, _ClearCoatLitFallback, _ClearCoatFallback, _ClearCoatFallback_HDR, clearcoatReflectionDir);
				reflections = surfaceReduction * reflCol * lerp(1, FresnelLerp(specCol, grazingTerm, clearcoatNDotV), _ClearcoatFresnel);
				reflections *= poiThemeColor(poiMods, _ClearCoatReflectionTint, _ClearCoatReflectionTintThemeIndex) * reflectionMask;
				#ifdef POI_PASS_ADD
				reflections *= poiLight.attenuation;
				#endif
				diffuse = lerp(diffuse, diffuse * omr, reflectionMask);
				
				environment = specular + vSpecular;
				#ifdef UNITY_PASS_FORWARDBASE
				environment += reflections;
				#endif
				//diffuse *= poiLight.finalLighting;
				diffuse += environment;
				poiLight.finalLightAdd += saturate(diffuse * clearCoatMask);
			}
			#endif
			//endex
			
			//ifex _EnableEnvironmentalRim==0
			#ifdef POI_ENVIRORIM
			void applyEnvironmentRim(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam)
			{
				float enviroRimAlpha = saturate(1 - smoothstep(min(_RimEnviroSharpness, _RimEnviroWidth), _RimEnviroWidth, poiCam.vDotN));
				_RimEnviroBlur *= 1.7 - 0.7 * _RimEnviroBlur;
				
				float3 enviroRimColor = 0;
				float interpolator = unity_SpecCube0_BoxMin.w;
				UNITY_BRANCH
				if (interpolator < 0.99999)
				{
					//Probe 1
					float4 reflectionData0 = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, poiMesh.normals[1], _RimEnviroBlur * UNITY_SPECCUBE_LOD_STEPS);
					float3 reflectionColor0 = DecodeHDR(reflectionData0, unity_SpecCube0_HDR);
					
					//Probe 2
					float4 reflectionData1 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, poiMesh.normals[1], _RimEnviroBlur * UNITY_SPECCUBE_LOD_STEPS);
					float3 reflectionColor1 = DecodeHDR(reflectionData1, unity_SpecCube1_HDR);
					
					enviroRimColor = lerp(reflectionColor1, reflectionColor0, interpolator);
				}
				else
				{
					float4 reflectionData = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, poiMesh.normals[1], _RimEnviroBlur * UNITY_SPECCUBE_LOD_STEPS);
					enviroRimColor = DecodeHDR(reflectionData, unity_SpecCube0_HDR);
				}
				
				half enviroMask = 1;
				#if defined(PROP_RIMENVIROMASK) || !defined(OPTIMIZER_ENABLED)
				enviroMask = POI2D_SAMPLER_PAN(_RimEnviroMask, _MainTex, poiMesh.uv[_RimEnviroMaskUV], _RimEnviroMaskPan)[_RimEnviroChannel];
				#endif
				float3 envRimCol = lerp(0, max(0, (enviroRimColor - _RimEnviroMinBrightness) * poiFragData.baseColor), enviroRimAlpha).rgb * enviroMask * _RimEnviroIntensity;
				poiFragData.finalColor += envRimCol;
			}
			#endif
			//endex
			
			//ifex _StylizedSpecular==0
			#ifdef POI_STYLIZED_StylizedSpecular
			void stylizedSpecular(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float specArea = 0.5 * poiLight.nDotH + 0.5;
				#if defined(PROP_HIGHCOLOR_TEX) || !defined(OPTIMIZER_ENABLED)
				float3 specularMap = POI2D_SAMPLER_PAN(_HighColor_Tex, _MainTex, poiUV(poiMesh.uv[_HighColor_TexUV], _HighColor_Tex_ST), _HighColor_TexPan);
				#else
				float3 specularMap = 1;
				#endif
				
				// Spec 1
				float specMask1 = 0;
				float specMask2 = 0;
				if (_Is_SpecularToHighColor)
				{
					specMask1 += pow(specArea, exp2(lerp(11, 1, _HighColor_Power))) * _Layer1Strength;
					specMask2 += pow(specArea, exp2(lerp(11, 1, _Layer2Size))) * _Layer2Strength;
				}
				else
				{
					specMask1 += poiEdgeNonLinear(specArea, (1.0 - pow(_HighColor_Power, 5)), _StylizedSpecularFeather) * _Layer1Strength;
					specMask2 += poiEdgeNonLinear(specArea, (1.0 - pow(_Layer2Size, 5)), _StylizedSpecular2Feather) * _Layer2Strength;
				}
				
				#if defined(PROP_SET_HIGHCOLORMASK) || !defined(OPTIMIZER_ENABLED)
				float specularMask = POI2D_SAMPLER_PAN(_Set_HighColorMask, _MainTex, poiUV(poiMesh.uv[_Set_HighColorMaskUV], _Set_HighColorMask_ST), _Set_HighColorMaskPan)[_Set_HighColorMaskChannel];
				#else
				float specularMask = 1;
				#endif
				
				specularMask = saturate(specularMask + _Tweak_HighColorMaskLevel);
				
				float specMask = saturate(specMask1 + specMask2) * specularMask * lerp(poiLight.rampedLightMap, 1, _StylizedSpecularIgnoreShadow);
				float attenuation = min(lerp(poiLight.nDotLSaturated, 1, _StylizedSpecularIgnoreNormal), lerp(lerp(poiLight.attenuation, 1, _SSIgnoreCastedShadows), 1, _StylizedSpecularIgnoreShadow));
				#ifdef POI_PASS_ADD
				attenuation *= lerp(poiLight.additiveShadow, 1, _SSIgnoreCastedShadows);
				#endif
				if (_Is_BlendAddToHiColor == 1)
				{
					poiLight.finalLightAdd += max(0, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.directColor, _UseLightColor) * specMask * poiLight.occlusion * attenuation * _StylizedSpecularStrength);
				}
				else
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.directColor, _UseLightColor), saturate(specMask * poiLight.occlusion * attenuation * _StylizedSpecularStrength));
				}
				//poiFragData.baseColor = _StylizedSpecularStrength;
				
				float3 vSpecMask = 0;
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						if (!any(poiLight.vPosition[index])) continue;
						specArea = 0.5 * poiLight.vDotNH[index] + 0.5;
						if (_Is_SpecularToHighColor)
						{
							vSpecMask = pow(specArea, exp2(lerp(11, 1, _HighColor_Power))) * _Layer1Strength * poiLight.vAttenuation[index];
							vSpecMask = max(vSpecMask, pow(specArea, exp2(lerp(11, 1, _Layer2Size))) * _Layer2Strength * poiLight.vAttenuation[index]);
						}
						else
						{
							vSpecMask = poiEdgeNonLinear(specArea, (1.0 - pow(_HighColor_Power, 5)), _StylizedSpecularFeather) * _Layer1Strength * poiLight.vAttenuation[index];
							vSpecMask = max(vSpecMask, poiEdgeNonLinear(specArea, (1.0 - pow(_Layer2Size, 5)), _StylizedSpecular2Feather) * _Layer2Strength * poiLight.vAttenuation[index]);
						}
						vSpecMask *= specularMask;
						if (_Is_BlendAddToHiColor == 1)
						{
							poiLight.finalLightAdd += max(0, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.vColor[index], _UseLightColor) * vSpecMask * poiLight.occlusion * _StylizedSpecularStrength);
						}
						else
						{
							poiFragData.baseColor = lerp(poiFragData.baseColor, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.vColor[index], _UseLightColor), saturate(vSpecMask * poiLight.occlusion * _StylizedSpecularStrength));
						}
					}
					#endif
				}
			}
			#endif
			//endex
			
			//ifex _EnablePathing==0
			#ifdef POI_PATHING
			void applyPathing(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float3 albedo = poiFragData.baseColor;
				float3 pathEmission;
				#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
				float4 path = _PathingMap.Sample(SmpRepeatPoint, poiUV(poiMesh.uv[_PathingMapUV], _PathingMap_ST) + _PathingMapPan.xy * _Time.x);
				#else
				float4 path = float4(1, 1, 1, 1);
				#endif
				float4 PathColor[4];
				half pathAudioLinkPathTimeOffsetBand[4] = {
					0, 0, 0, 0
				};
				half2 pathAudioLinkTimeOffset[4] = {
					half2(0, 0), half2(0, 0), half2(0, 0), half2(0, 0)
				};
				half pathAudioLinkPathWidthOffsetBand[4] = {
					0, 0, 0, 0
				};
				half2 pathAudioLinkWidthOffset[4] = {
					half2(0, 0), half2(0, 0), half2(0, 0), half2(0, 0)
				};
				PathColor[0] = _PathColorR;
				PathColor[1] = _PathColorG;
				PathColor[2] = _PathColorB;
				PathColor[3] = _PathColorA;
				
				// Combined data
				if (_PathGradientType == 1)
				{
					path = (path.r + path.g + path.b + path.a) * .25;
				}
				
				#if defined(PROP_PATHINGCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				float4 pathColorMap = POI2D_SAMPLER_PAN(_PathingColorMap, _MainTex, poiUV(poiMesh.uv[_PathingColorMapUV], _PathingColorMap_ST), _PathingColorMapPan);
				#else
				float4 pathColorMap = float4(1, 1, 1, 1);
				#endif
				
				float4 pathAudioLinkEmission = 0;
				float4 pathTime = 0;
				float3 pathAlpha[4] = {
					float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0)
				};
				
				#ifdef POI_AUDIOLINK
				float4 chronoType = float4(_PathChronoTypeR, _PathChronoTypeG, _PathChronoTypeB, _PathChronoTypeA);
				float4 chronoBand = float4(_PathChronoBandR, _PathChronoBandG, _PathChronoBandB, _PathChronoBandA);
				float4 chronoSpeed = float4(_PathChronoSpeedR, _PathChronoSpeedG, _PathChronoSpeedB, _PathChronoSpeedA);
				float3 autoCorrelator[4] = {
					float3(_PathALAutoCorrelatorR, _PathALAutoCorrelatorRangeR[0], _PathALAutoCorrelatorRangeR[1]), float3(_PathALAutoCorrelatorG, _PathALAutoCorrelatorRangeG[0], _PathALAutoCorrelatorRangeG[1]),
					float3(_PathALAutoCorrelatorB, _PathALAutoCorrelatorRangeB[0], _PathALAutoCorrelatorRangeB[1]), float3(_PathALAutoCorrelatorA, _PathALAutoCorrelatorRangeA[0], _PathALAutoCorrelatorRangeA[1])
				};
				float4 history[4] = {
					float4(_PathALHistoryR, _PathALHistoryBandR, _PathALHistoryRangeR[0], _PathALHistoryRangeR[1]), float4(_PathALHistoryG, _PathALHistoryBandG, _PathALHistoryRangeG[0], _PathALHistoryRangeG[1]),
					float4(_PathALHistoryB, _PathALHistoryBandB, _PathALHistoryRangeB[0], _PathALHistoryRangeB[1]), float4(_PathALHistoryA, _PathALHistoryBandA, _PathALHistoryRangeA[0], _PathALHistoryRangeA[1])
				};
				
				if (poiMods.audioLinkAvailable)
				{
					if (_PathALTimeOffset)
					{
						pathAudioLinkPathTimeOffsetBand[0] = _AudioLinkPathTimeOffsetBandR;
						pathAudioLinkPathTimeOffsetBand[1] = _AudioLinkPathTimeOffsetBandG;
						pathAudioLinkPathTimeOffsetBand[2] = _AudioLinkPathTimeOffsetBandB;
						pathAudioLinkPathTimeOffsetBand[3] = _AudioLinkPathTimeOffsetBandA;
						pathAudioLinkTimeOffset[0] = _AudioLinkPathTimeOffsetR.xy;
						pathAudioLinkTimeOffset[1] = _AudioLinkPathTimeOffsetG.xy;
						pathAudioLinkTimeOffset[2] = _AudioLinkPathTimeOffsetB.xy;
						pathAudioLinkTimeOffset[3] = _AudioLinkPathTimeOffsetA.xy;
					}
					
					if (_PathALWidthOffset)
					{
						pathAudioLinkPathWidthOffsetBand[0] = _AudioLinkPathWidthOffsetBandR;
						pathAudioLinkPathWidthOffsetBand[1] = _AudioLinkPathWidthOffsetBandG;
						pathAudioLinkPathWidthOffsetBand[2] = _AudioLinkPathWidthOffsetBandB;
						pathAudioLinkPathWidthOffsetBand[3] = _AudioLinkPathWidthOffsetBandA;
						pathAudioLinkWidthOffset[0] = _AudioLinkPathWidthOffsetR.xy;
						pathAudioLinkWidthOffset[1] = _AudioLinkPathWidthOffsetG.xy;
						pathAudioLinkWidthOffset[2] = _AudioLinkPathWidthOffsetB.xy;
						pathAudioLinkWidthOffset[3] = _AudioLinkPathWidthOffsetA.xy;
					}
					// Emission Offset
					if (_PathALEmissionOffset)
					{
						pathAudioLinkEmission.r += lerp(_AudioLinkPathEmissionAddR.x, _AudioLinkPathEmissionAddR.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandR]);
						pathAudioLinkEmission.g += lerp(_AudioLinkPathEmissionAddG.x, _AudioLinkPathEmissionAddG.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandG]);
						pathAudioLinkEmission.b += lerp(_AudioLinkPathEmissionAddB.x, _AudioLinkPathEmissionAddB.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandB]);
						pathAudioLinkEmission.a += lerp(_AudioLinkPathEmissionAddA.x, _AudioLinkPathEmissionAddA.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandA]);
					}
					
					if(_PathALColorChord)
					{
						if (_PathALCCR)
						{
							PathColor[0] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[0] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCG)
						{
							PathColor[1] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[1] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCB)
						{
							PathColor[2] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[2] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCA)
						{
							PathColor[3] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[3] * AUDIOLINK_WIDTH, 0));
						}
					}
				}
				#endif
				
				[unroll]
				for (int index = 0; index < 4; index++)
				{
					float timeOffset = 0;
					#ifdef POI_AUDIOLINK
					UNITY_BRANCH
					if (poiMods.audioLinkAvailable)
					{
						if (_PathALTimeOffset)
						{
							timeOffset += lerp(pathAudioLinkTimeOffset[index].x, pathAudioLinkTimeOffset[index].y, poiMods.audioLink[pathAudioLinkPathTimeOffsetBand[index]]);
						}
						
						if (_PathALChrono)
						{
							timeOffset += AudioLinkGetChronoTime(chronoType[index], chronoBand[index]) * chronoSpeed[index];
						}
					}
					#endif
					pathTime[index] = _PathTime[index] != -999.0f ? frac(_PathTime[index] + _PathOffset[index] + timeOffset) : frac(_Time.x * _PathSpeed[index] + _PathOffset[index] + timeOffset);
					
					if (_PathSegments[index])
					{
						float pathSegments = abs(_PathSegments[index]);
						pathTime = (ceil(pathTime * pathSegments) - .5) / pathSegments;
					}
					
					if (path[index])
					{
						// Cutting it in half because it goes out in both directions for now
						half pathWidth = _PathWidth[index] * .5;
						#ifdef POI_AUDIOLINK
						UNITY_BRANCH
						if (poiMods.audioLinkAvailable)
						{
							if (_PathALWidthOffset)
							{
								pathWidth += lerp(pathAudioLinkWidthOffset[index].x, pathAudioLinkWidthOffset[index].y, poiMods.audioLink[pathAudioLinkPathWidthOffsetBand[index]]);
							}
						}
						#endif
						
						//fill
						pathAlpha[index].x = pathTime[index] > path[index];
						//path
						pathAlpha[index].y = saturate((1 - abs(lerp(-pathWidth, 1 + pathWidth, pathTime[index]) - path[index])) - (1 - pathWidth)) * (1 / pathWidth);
						//loop
						pathAlpha[index].z = saturate((1 - distance(pathTime[index], path[index])) - (1 - pathWidth)) * (1 / pathWidth);
						pathAlpha[index].z += saturate(distance(pathTime[index], path[index]) - (1 - pathWidth)) * (1 / pathWidth);
						pathAlpha[index] = smoothstep(0, _PathSoftness[index] + .00001, pathAlpha[index]);
						
						#ifdef POI_AUDIOLINK
						if (poiMods.audioLinkAvailable)
						{
							if (_PathALHistory && history[index][0])
							{
								// history[index]: [0]: on/off, [1]: band, [2]/[3] min/max
								float historyUV = lerp(history[index][2], history[index][3], path[index]);
								
								if (_PathSegments[index])
								{
									float pathSegments = abs(_PathSegments[index]);
									historyUV = (ceil(historyUV * pathSegments) - .5) / pathSegments;
								}
								
								historyUV *= AUDIOLINK_WIDTH;
								
								float historyValue = AudioLinkLerp(ALPASS_AUDIOLINK + float2(historyUV, history[index][1]))[0];
								
								if(_PathALHistoryMode == 0) // Mask
								pathAlpha[index] *= historyValue;
								else // Override
								pathAlpha[index] = historyValue;
							}
							
							if (_PathALAutoCorrelator && autoCorrelator[index][0] != 0)
							{
								// autoCorrelator[index]: [0]: on/off, [1]/[2]: min/max
								// Choose from only part of the autocorrelator
								float autoCorrelatorUV = lerp(autoCorrelator[index][1], autoCorrelator[index][2], path[index]);
								if (autoCorrelator[index][0] == 2) // Mirror
								{
									autoCorrelatorUV = abs(1. - autoCorrelatorUV * 2.);
								}
								
								if (_PathSegments[index])
								{
									float pathSegments = abs(_PathSegments[index]);
									autoCorrelatorUV = (ceil(autoCorrelatorUV * pathSegments) - .5) / pathSegments;
								}
								
								// Normalize Autocorrelator Value
								float autoCorrelatorValue = AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2(autoCorrelatorUV * AUDIOLINK_WIDTH, 0))[0];
								float autoCorrelatorMax = AudioLinkLerp(ALPASS_AUTOCORRELATOR);
								autoCorrelatorValue = saturate(abs(autoCorrelatorValue) * rcp(autoCorrelatorMax));
								
								// Autocorrelator is normalized, so can look weird at lower volume levels. use Filtered VU intensity to make it smoothly fall off at low volume levels.
								float4 vu = AudioLinkData(ALPASS_FILTEREDVU_INTENSITY + uint2(0, 0));
								autoCorrelatorValue *= smoothstep(0.01, 0.2, vu);
								
								if(_PathALAutoCorrelatorMode == 0) // Mask
								pathAlpha[index] *= autoCorrelatorValue;
								else // Override
								pathAlpha[index] = autoCorrelatorValue;
								
							}
						}
						#endif
					}
				}
				
				// Emission
				pathEmission = 0;
				pathEmission += pathAlpha[0][_PathTypeR] * poiThemeColor(poiMods, PathColor[0].rgb, _PathColorRThemeIndex) * (_PathEmissionStrength[0] + pathAudioLinkEmission.r);
				pathEmission += pathAlpha[1][_PathTypeG] * poiThemeColor(poiMods, PathColor[1].rgb, _PathColorGThemeIndex) * (_PathEmissionStrength[1] + pathAudioLinkEmission.g);
				pathEmission += pathAlpha[2][_PathTypeB] * poiThemeColor(poiMods, PathColor[2].rgb, _PathColorBThemeIndex) * (_PathEmissionStrength[2] + pathAudioLinkEmission.b);
				pathEmission += pathAlpha[3][_PathTypeA] * poiThemeColor(poiMods, PathColor[3].rgb, _PathColorAThemeIndex) * (_PathEmissionStrength[3] + pathAudioLinkEmission.a);
				pathEmission *= pathColorMap.rgb * pathColorMap.a;
				
				float3 colorReplace = 0;
				colorReplace = pathAlpha[0][_PathTypeR] * poiThemeColor(poiMods, PathColor[0].rgb, _PathColorRThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[0].a * pathAlpha[0][_PathTypeR]);
				colorReplace = pathAlpha[1][_PathTypeG] * poiThemeColor(poiMods, PathColor[1].rgb, _PathColorGThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[1].a * pathAlpha[1][_PathTypeG]);
				colorReplace = pathAlpha[2][_PathTypeB] * poiThemeColor(poiMods, PathColor[2].rgb, _PathColorBThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[2].a * pathAlpha[2][_PathTypeB]);
				colorReplace = pathAlpha[3][_PathTypeA] * poiThemeColor(poiMods, PathColor[3].rgb, _PathColorAThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[3].a * pathAlpha[3][_PathTypeA]);
				
				float alpha = max(max(max(pathAlpha[0][_PathTypeR], pathAlpha[1][_PathTypeG]), pathAlpha[2][_PathTypeB]), pathAlpha[3][_PathTypeA]);
				
				poiFragData.alpha *= lerp(1, alpha, _PathingOverrideAlpha);
				poiFragData.baseColor = albedo.rgb;
				poiFragData.emission += pathEmission;
			}
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			void applyMirror(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float inMirror = 0;
				if (_VisibilityMode == 1) // VRC
				inMirror = VRCMirrorMode() > 0;
				else // Generic (CVR, etc)
				inMirror = IsInMirror();
				
				#if (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 mirrorTexture = POI2D_SAMPLER_PAN(_MirrorTexture, _MainTex, poiUV(poiMesh.uv[_MirrorTextureUV], _MirrorTexture_ST), _MirrorTexturePan);
				if (inMirror)
				{
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, mirrorTexture.rgb, _MirrorTextureBlendType), mirrorTexture.a * _MirrorColor.a);
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#else
				if (inMirror)
				{
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#endif
				#endif
			}
			#endif
			//endex
			
			//ifex _EnableTouchGlow==0
			#ifdef GRAIN
			void applyDepthFX(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float3 touchEmission = 0;
				
				float perspectiveDivide = 1.0f / poiCam.clipPos.w;
				float4 direction = poiCam.worldDirection * perspectiveDivide;
				float2 screenPos = poiCam.grabPos.xy * perspectiveDivide;
				float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, screenPos);
				
				#if UNITY_REVERSED_Z
				if (z == 0)
				#else
				if (z == 1)
				#endif
				return;
				
				float depth = CorrectedLinearEyeDepth(z, direction.w);
				float3 worldpos = direction * depth + _WorldSpaceCameraPos.xyz;
				/*
				finalColor.rgb = frac(worldpos);
				return;
				*/
				
				float diff = distance(worldpos, poiMesh.worldPos);
				//poiFragData.finalColor = diff;
				
				#if defined(PROP_DEPTHMASK) || !defined(OPTIMIZER_ENABLED)
				float depthMask = POI2D_SAMPLER_PAN(_DepthMask, _MainTex, poiUV(poiMesh.uv[_DepthMaskUV], _DepthMask_ST), _DepthMaskPan)[_DepthMaskChannel];
				#else
				float depthMask = 1;
				#endif
				
				if (_DepthMaskGlobalMask > 0)
				{
					depthMask = maskBlend(depthMask, poiMods.globalMask[_DepthMaskGlobalMask-1], _DepthMaskGlobalMaskBlendType);
				}
				
				if (_DepthColorToggle)
				{
					float colorBlendAlpha = lerp(_DepthColorMinValue, _DepthColorMaxValue, remapClamped(_DepthColorMinDepth, _DepthColorMaxDepth, diff));
					
					#if defined(PROP_DEPTHTEXTURE) || !defined(OPTIMIZER_ENABLED)
					float2 depthTextureUV = float2(0, 0);
					if (_DepthTextureUV == 8)
					{
						depthTextureUV = lerp(0, 1, remapClamped(_DepthColorMinDepth, _DepthColorMaxDepth, diff));
					}
					else
					{
						depthTextureUV = poiMesh.uv[_DepthTextureUV];
					}
					float3 depthColor = POI2D_SAMPLER_PAN(_DepthTexture, _MainTex, poiUV(depthTextureUV, _DepthTexture_ST), _DepthTexturePan).rgb * poiThemeColor(poiMods, _DepthColor, _DepthColorThemeIndex);
					#else
					float3 depthColor = poiThemeColor(poiMods, _DepthColor, _DepthColorThemeIndex);
					#endif
					
					switch(_DepthColorBlendMode)
					{
						case 0:
						{
							poiFragData.finalColor = lerp(poiFragData.finalColor, depthColor, colorBlendAlpha * depthMask);
							break;
						}
						case 1:
						{
							poiFragData.finalColor *= lerp(1, depthColor, colorBlendAlpha * depthMask);
							break;
						}
						case 2:
						{
							poiFragData.finalColor = saturate(poiFragData.finalColor + lerp(0, depthColor, colorBlendAlpha * depthMask));
							break;
						}
					}
					poiFragData.emission += depthColor * colorBlendAlpha * _DepthEmissionStrength * depthMask;
				}
				
				if (_DepthAlphaToggle)
				{
					poiFragData.alpha *= lerp(poiFragData.alpha, saturate(lerp(_DepthAlphaMinValue, _DepthAlphaMaxValue, remapClamped(_DepthAlphaMinDepth, _DepthAlphaMaxDepth, diff))), depthMask);
				}
			}
			#endif
			//endex
			
			//ifex _EnableIridescence==0
			#ifdef POI_IRIDESCENCE
			float3 calculateIridescenceNormal(PoiMesh poiMesh, float3 baseNormal, int normalSelection)
			{
				float3 normal = baseNormal;
				#if defined(PROP_IRIDESCENCENORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(_IridescenceNormalMap, _MainTex, poiUV(poiMesh.uv[_IridescenceNormalMapUV], _IridescenceNormalMap_ST), _IridescenceNormalMapPan), _IridescenceNormalIntensity);
				normal = normalize(normal.x * poiMesh.tangent[normalSelection] + normal.y * poiMesh.binormal[normalSelection] + normal.z * baseNormal);
				#endif
				return normal;
			}
			
			void applyIridescence(inout PoiFragData poiFragData, PoiMesh poiMesh, PoiCam poiCam, inout PoiMods poiMods)
			{
				float3 normal = poiMesh.normals[_IridescenceNormalSelection];
				if (_IridescenceNormalToggle)
				{
					normal = calculateIridescenceNormal(poiMesh, normal, _IridescenceNormalSelection);
				}
				float ndotv = dot(normal, poiCam.viewDir);
				
				float4 iridescenceColor = 1;
				#if defined(PROP_IRIDESCENCERAMP) || !defined(OPTIMIZER_ENABLED)
				float2 iridescencePan = _IridescenceRampPan * _Time.x + _IridescenceRamp_ST.zw;
				#ifdef POI_AUDIOLINK
				iridescencePan += AudioLinkGetChronoTime(_IridescenceAudioLinkChronoPanType, _IridescenceAudioLinkChronoPanBand) * _IridescenceAudioLinkChronoPanSpeed;
				#endif
				iridescenceColor = UNITY_SAMPLE_TEX2D_SAMPLER(_IridescenceRamp, _MainTex, (1 - abs(ndotv)) * _IridescenceRamp_ST.xy + iridescencePan);
				if (_IridescenceHueShiftEnabled == 1)
				{
					float hue = _IridescenceHueShift + frac(_Time.x * _IridescenceHueShiftSpeed);
					iridescenceColor.rgb = hueShift(iridescenceColor.rgb, hue);
				}
				#endif
				
				float iridescenceMask = 1;
				#if defined(PROP_IRIDESCENCEMASK) || !defined(OPTIMIZER_ENABLED)
				iridescenceMask = POI2D_SAMPLER_PAN(_IridescenceMask, _MainTex, poiUV(poiMesh.uv[_IridescenceMaskUV], _IridescenceMask_ST), _IridescenceMaskPan)[_IridescenceMaskChannel];
				if (_IridescenceMaskInvert == 1)
				{
					iridescenceMask = 1 - iridescenceMask;
				}
				#endif
				
				if (_IridescenceMaskGlobalMask > 0)
				{
					iridescenceMask = maskBlend(iridescenceMask, poiMods.globalMask[_IridescenceMaskGlobalMask-1], _IridescenceMaskGlobalMaskBlendType);
				}
				
				float emissionStrength = _IridescenceEmissionStrength;
				float iridescenceIntensity = _IridescenceIntensity;
				#ifdef POI_AUDIOLINK
				if (any(_IridescenceAudioLinkEmissionAdd))
				{
					emissionStrength += lerp(_IridescenceAudioLinkEmissionAdd[0], _IridescenceAudioLinkEmissionAdd[1], poiMods.audioLink[_IridescenceAudioLinkEmissionAddBand]);
				}
				if (any(_IridescenceAudioLinkIntensityAdd))
				{
					iridescenceIntensity += lerp(_IridescenceAudioLinkIntensityAdd[0], _IridescenceAudioLinkIntensityAdd[1], poiMods.audioLink[_IridescenceAudioLinkIntensityAddBand]);
				}
				#endif
				
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, saturate(iridescenceColor.rgb * iridescenceIntensity), iridescenceColor.a * _IridescenceReplaceBlend * iridescenceMask);
				poiFragData.baseColor.rgb += saturate(iridescenceColor.rgb * iridescenceIntensity * iridescenceColor.a * _IridescenceAddBlend * iridescenceMask);
				poiFragData.baseColor.rgb *= saturate(lerp(1, iridescenceColor.rgb * iridescenceIntensity, iridescenceColor.a * _IridescenceMultiplyBlend * iridescenceMask));
				
				poiFragData.emission += saturate(iridescenceColor.rgb * _IridescenceIntensity) * iridescenceColor.a * iridescenceMask * emissionStrength;
			}
			#endif
			//endex
			
			//ifex _TextEnabled==0
			#ifdef EFFECT_BUMP
			
			float2 TransformUV(float2 offset, float rotation, float2 scale, float2 uv)
			{
				float theta = radians(rotation);
				scale = 1 - scale;
				float cs = cos(theta);
				float sn = sin(theta);
				float2 centerPoint = offset + .5;
				uv = float2((uv.x - centerPoint.x) * cs - (uv.y - centerPoint.y) * sn + centerPoint.x, (uv.x - centerPoint.x) * sn + (uv.y - centerPoint.y) * cs + centerPoint.y);
				
				return remap(uv, float2(0, 0) + offset + (scale * .5), float2(1, 1) + offset - (scale * .5), float2(0, 0), float2(1, 1));
			}
			
			float2 getAsciiCoordinate(float index)
			{
				return float2((index - 1) / 16, 1 - ((floor(index / 16 - glyphWidth)) / 16));
			}
			
			float median(float r, float g, float b)
			{
				return max(min(r, g), min(max(r, g), b));
			}
			
			void ApplyPositionText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				float3 cameraPos = clamp(getCameraPosition(), -999, 999);
				float3 absCameraPos = abs(cameraPos);
				float totalCharacters = 20;
				float positionArray[20];
				positionArray[0] = cameraPos.x >= 0 ? ASCII_NEGATIVE : ASCII_POSITIVE;
				positionArray[1] = floor((absCameraPos.x * .01) % 10) + 48;
				positionArray[2] = floor((absCameraPos.x * .1) % 10) + 48;
				positionArray[3] = floor(absCameraPos.x % 10) + 48;
				positionArray[4] = ASCII_PERIOD;
				positionArray[5] = floor((absCameraPos.x * 10) % 10) + 48;
				positionArray[6] = ASCII_COMMA;
				positionArray[7] = cameraPos.y >= 0 ? ASCII_NEGATIVE : ASCII_POSITIVE;
				positionArray[8] = floor((absCameraPos.y * .01) % 10) + 48;
				positionArray[9] = floor((absCameraPos.y * .1) % 10) + 48;
				positionArray[10] = floor(absCameraPos.y % 10) + 48;
				positionArray[11] = ASCII_PERIOD;
				positionArray[12] = floor((absCameraPos.y * 10) % 10) + 48;
				positionArray[13] = ASCII_COMMA;
				positionArray[14] = cameraPos.z >= 0 ? ASCII_NEGATIVE : ASCII_POSITIVE;
				positionArray[15] = floor((absCameraPos.z * .01) % 10) + 48;
				positionArray[16] = floor((absCameraPos.z * .1) % 10) + 48;
				positionArray[17] = floor(absCameraPos.z % 10) + 48;
				positionArray[18] = ASCII_PERIOD;
				positionArray[19] = floor((absCameraPos.z * 10) % 10) + 48;
				
				uv = TransformUV(_TextPositionOffset, _TextPositionRotation, _TextPositionScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(positionArray[currentCharacter]);
				
				float2 startUV = float2(1 / totalCharacters * currentCharacter, 0);
				float2 endUV = float2(1 / totalCharacters * (currentCharacter + 1), 1);
				
				fixed4 textPositionPadding = _TextPositionPadding;
				textPositionPadding *= 1 / totalCharacters;
				
				uv = remapClamped(startUV, endUV, uv, float2(glyphPos.x + textPositionPadding.x, glyphPos.y - glyphWidth + textPositionPadding.y), float2(glyphPos.x + glyphWidth - textPositionPadding.z, glyphPos.y - textPositionPadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textPositionPadding.z - .001 || uv.x < glyphPos.x + textPositionPadding.x + .001 || uv.y > glyphPos.y - textPositionPadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textPositionPadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextPositionColor.rgb, _TextPositionColorThemeIndex), opacity * _TextPositionColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextPositionColor.rgb, _TextPositionColorThemeIndex) * opacity * _TextPositionEmissionStrength;
			}
			
			void ApplyTimeText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				float instanceTime = _Time.y;
				float hours = instanceTime / 3600;
				float minutes = (instanceTime / 60) % 60;
				float seconds = instanceTime % 60;
				float totalCharacters = 8;
				float timeArray[8];
				timeArray[0] = floor((hours * .1) % 10) + 48;
				timeArray[1] = floor(hours % 10) + 48;
				timeArray[2] = ASCII_SEMICOLON;
				timeArray[3] = floor((minutes * .1) % 10) + 48;
				timeArray[4] = floor(minutes % 10) + 48;
				timeArray[5] = ASCII_SEMICOLON;
				timeArray[6] = floor((seconds * .1) % 10) + 48;
				timeArray[7] = floor(seconds % 10) + 48;
				
				uv = TransformUV(_TextTimeOffset, _TextTimeRotation, _TextTimeScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(timeArray[currentCharacter]);
				// 0.1428571 = 1/7 = 1 / totalCharacters
				float startUV = 1 / totalCharacters * currentCharacter;
				float endUV = 1 / totalCharacters * (currentCharacter + 1);
				
				fixed4 textTimePadding = _TextTimePadding;
				textTimePadding *= 1 / totalCharacters;
				
				uv = remapClamped(float2(startUV, 0), float2(endUV, 1), uv, float2(glyphPos.x + textTimePadding.x, glyphPos.y - glyphWidth + textTimePadding.y), float2(glyphPos.x + glyphWidth - textTimePadding.z, glyphPos.y - textTimePadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textTimePadding.z - .001 || uv.x < glyphPos.x + textTimePadding.x + .001 || uv.y > glyphPos.y - textTimePadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textTimePadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextTimeColor.rgb, _TextTimeColorThemeIndex), opacity * _TextTimeColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextTimeColor.rgb, _TextTimeColorThemeIndex) * opacity * _TextTimeEmissionStrength;
			}
			
			void ApplyFPSText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				float smoothDeltaTime = clamp(unity_DeltaTime.w, 0, 999);
				float totalCharacters = 7;
				float fpsArray[7];
				fpsArray[0] = ASCII_F;
				fpsArray[1] = ASCII_P;
				fpsArray[2] = ASCII_S;
				fpsArray[3] = ASCII_SEMICOLON;
				fpsArray[4] = floor((smoothDeltaTime * .01) % 10) + 48;
				fpsArray[5] = floor((smoothDeltaTime * .1) % 10) + 48;
				fpsArray[6] = floor(smoothDeltaTime % 10) + 48;
				
				uv = TransformUV(_TextFPSOffset, _TextFPSRotation, _TextFPSScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(fpsArray[currentCharacter]);
				// 0.1428571 = 1/7 = 1 / totalCharacters
				float startUV = 1 / totalCharacters * currentCharacter;
				float endUV = 1 / totalCharacters * (currentCharacter + 1);
				
				float4 textFPSPadding = _TextFPSPadding;
				textFPSPadding *= 1 / totalCharacters;
				
				uv = remapClamped(float2(startUV, 0), float2(endUV, 1), uv, float2(glyphPos.x + textFPSPadding.x, glyphPos.y - glyphWidth + textFPSPadding.y), float2(glyphPos.x + glyphWidth - textFPSPadding.z, glyphPos.y - textFPSPadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textFPSPadding.z - .001 || uv.x < glyphPos.x + textFPSPadding.x + .001 || uv.y > glyphPos.y - textFPSPadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textFPSPadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextFPSColor.rgb, _TextFPSColorThemeIndex), opacity * _TextFPSColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextFPSColor.rgb, _TextFPSColorThemeIndex) * opacity * _TextFPSEmissionStrength;
			}
			
			void ApplyNumericText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				// If both digits are set to zero: exit.
				if (_TextNumericWholeDigits == 0 && _TextNumericDecimalDigits == 0)
				{
					return;
				}
				
				uint wholeNumber = 0;
				uint decimalNumber = 0;
				uint wholeDigits = _TextNumericWholeDigits;
				uint decimalDigits = _TextNumericDecimalDigits;
				float NumericArray[10];										// 10 is the max amount of characters = 1 sign + 4 max whole digits + 1 decimal mark + 4 max decimal digits
				uint arrayIndex = 0;
				float totalCharacters = 1 + wholeDigits + decimalDigits; 	// Sign Character + Whole Digits + Decimal Digits
				
				//Determine Sign (_TextNumericValue is usually animated)
				float charSign = _TextNumericValue >= 0 ? ASCII_SPACE : ASCII_NEGATIVE;
				
				NumericArray[arrayIndex] = charSign;						//First character is always the sign
				arrayIndex++;
				
				//Isolate whole number and fill array
				if (wholeDigits > 0)
				{
					wholeNumber = uint(glsl_mod(abs(_TextNumericValue), pow(10, wholeDigits)));
					
					int expIndex = -1 * (wholeDigits - 1);  // Exponent Index
					bool leadingZero = true;
					// Pouplate the Array
					while (arrayIndex <= wholeDigits)
					{
						// Grab the corresponding digit from the whole number going from left to right.
						int digit = floor(glsl_mod(wholeNumber * pow(10, expIndex), 10));
						// Take the resulting value and add 48 to get the corresponding location in the font array.
						NumericArray[arrayIndex] = digit + 48;
						
						//Trim Leading Zeroes, but leave at least one.
						if (_TextNumericTrimZeroes == true)
						{
							//If the digit is zero and there hasn't been any digits greater than 0 previously.
							if (digit == 0 && leadingZero == true && arrayIndex != wholeDigits)
							{
								//Overwrite the leading zero.
								NumericArray[arrayIndex] = ASCII_SPACE;
							}
							else
							{
								leadingZero = false;
							}
						}
						expIndex++;
						arrayIndex++;
					}
				}
				
				// Isolate decimal number and fill array
				if (decimalDigits > 0)
				{
					// Add a decimal point
					NumericArray[arrayIndex] = ASCII_PERIOD;
					int decimalPointer = arrayIndex;
					arrayIndex++;
					totalCharacters++;
					
					decimalNumber = uint(frac(abs(_TextNumericValue)) * pow(10.00001, decimalDigits));    // Isolate the decimal number
					
					int expIndex = -1 * (decimalDigits - 1);                                          // Exponent Index
					//Populate the Array with the remaining digits
					while (arrayIndex < (totalCharacters))
					{
						// Grab the corresponding digit from the whole number going from left to right.
						int digit = floor(glsl_mod(decimalNumber * pow(10, expIndex), 10));
						// Take the resulting value and add 48 to get the corresponding location in the font array.
						NumericArray[arrayIndex] = digit + 48;
						
						expIndex++;
						arrayIndex++;
					}
				}
				
				uv = TransformUV(_TextNumericOffset, _TextNumericRotation, _TextNumericScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(NumericArray[currentCharacter]);
				float startUV = 1 / totalCharacters * currentCharacter;
				float endUV = 1 / totalCharacters * (currentCharacter + 1);
				
				float4 textNumericPadding = _TextNumericPadding;
				textNumericPadding *= 1 / totalCharacters;
				
				uv = remapClamped(float2(startUV, 0), float2(endUV, 1), uv, float2(glyphPos.x + textNumericPadding.x, glyphPos.y - glyphWidth + textNumericPadding.y), float2(glyphPos.x + glyphWidth - textNumericPadding.z, glyphPos.y - textNumericPadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textNumericPadding.z - .001 || uv.x < glyphPos.x + textNumericPadding.x + .001 || uv.y > glyphPos.y - textNumericPadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textNumericPadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextNumericColor.rgb, _TextNumericColorThemeIndex), opacity * _TextNumericColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextNumericColor.rgb, _TextNumericColorThemeIndex) * opacity * _TextNumericEmissionStrength;
			}
			
			void ApplyTextOverlayColor(inout PoiFragData poiFragData, PoiMesh poiMesh, in PoiMods poiMods)
			{
				globalTextEmission = 0;
				float positionalOpacity = 0;
				
				if (_TextFPSEnabled == 1)
				ApplyFPSText(poiFragData, poiMesh.uv[_TextFPSUV], poiMods);
				if (_TextPositionEnabled == 1)
				ApplyPositionText(poiFragData, poiMesh.uv[_TextPositionUV], poiMods);
				if (_TextTimeEnabled == 1)
				ApplyTimeText(poiFragData, poiMesh.uv[_TextTimeUV], poiMods);
				if (_TextNumericEnabled == 1)
				ApplyNumericText(poiFragData, poiMesh.uv[_TextNumericUV], poiMods);
				
				poiFragData.emission += globalTextEmission;
			}
			#endif
			//endex
			
			//ifex _PostProcess==0
			#ifdef POSTPROCESS
			float3 poiPosterize(float3 color, float steps)
			{
				float3 newColor = color;
				steps = floor(steps);
				newColor.r = floor(newColor.r * steps) / steps;
				newColor.g = floor(newColor.g * steps) / steps;
				newColor.b = floor(newColor.b * steps) / steps;
				return newColor;
			}
			
			float oetf_sRGB_scalar(float L)
			{
				float V = 1.055 * (pow(L, 1.0 / 2.4)) - 0.055;
				if (L <= 0.0031308)
				V = L * 12.92;
				return V;
			}
			
			float3 oetf_sRGB(float3 L)
			{
				return float3(oetf_sRGB_scalar(L.r), oetf_sRGB_scalar(L.g), oetf_sRGB_scalar(L.b));
			}
			
			float eotf_sRGB_scalar(float V)
			{
				float L = pow((V + 0.055) / 1.055, 2.4);
				if (V <= oetf_sRGB_scalar(0.0031308))
				L = V / 12.92;
				return L;
			}
			
			float3 GetHDR(float3 rgb)
			{
				return float3(eotf_sRGB_scalar(rgb.r), eotf_sRGB_scalar(rgb.g), eotf_sRGB_scalar(rgb.b));
			}
			
			float3 GetContrast(float3 col, float contrast)
			{
				return lerp(float3(0.5, 0.5, 0.5), col, contrast);
			}
			
			float3 GetSaturation(float3 col, float interpolator)
			{
				return lerp(dot(col, float3(0.3, 0.59, 0.11)), col, interpolator);
			}
			
			void applyPostProcessing(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				float3 col = poiFragData.finalColor;
				col = hueShift(col, _PPHue);
				col *= _PPTint;
				col *= _PPRGB;
				col = GetSaturation(col, _PPSaturation);
				col = lerp(col, GetHDR(col), _PPHDR);
				col = GetContrast(col, _PPContrast);
				col *= _PPBrightness;
				col += _PPLightness;
				
				float ppMask = 1;
				#if defined(PROP_PPMASK) || !defined(OPTIMIZER_ENABLED)
				ppMask = POI2D_SAMPLER_PAN(_PPMask, _MainTex, poiUV(poiMesh.uv[_PPMaskUV], _PPMask_ST), _PPMaskPan)[_PPMaskChannel];
				ppMask = lerp(ppMask, 1 - ppMask, _PPMaskInvert);
				col = lerp(poiFragData.finalColor, col, ppMask);
				#endif
				
				if (_PPPosterization)
				{
					col = lerp(col, poiPosterize(col, _PPPosterizationAmount), ppMask);
				}
				
				poiFragData.finalColor = col;
			}
			#endif
			//endex
			
			//ifex _PoiInternalParallax==0
			#ifdef POI_INTERNALPARALLAX
			void applyInternalParallax(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiMods poiMods)
			{
				float3 parallax = 0;
				
				for (int j = _ParallaxInternalIterations-1; j >= 0; j --)
				{
					float ratio = saturate((float)j / max(_ParallaxInternalIterations-1, 1));
					float2 parallaxOffset = _Time.y * (_ParallaxInternalMapPan + ratio * _ParallaxInternalPanDepthSpeed);
					float fade = lerp(_ParallaxInternalMinFade, _ParallaxInternalMaxFade, ratio);
					fade = pow(fade, 2.2);
					#if defined(PROP_PARALLAXINTERNALMAP) || !defined(OPTIMIZER_ENABLED)
					float4 parallaxColor = UNITY_SAMPLE_TEX2D_SAMPLER(_ParallaxInternalMap, _MainTex, TRANSFORM_TEX(poiMesh.uv[0], _ParallaxInternalMap) + (lerp(_ParallaxInternalMinDepth, _ParallaxInternalMaxDepth, ratio)) * - (poiCam.tangentViewDir.xy / (poiCam.tangentViewDir.z)) + parallaxOffset);
					#else
					float4 parallaxColor = 0;
					#endif
					float3 minColor = poiThemeColor(poiMods, _ParallaxInternalMinColor.rgb, _ParallaxInternalMinColorThemeIndex);
					float3 maxColor = poiThemeColor(poiMods, _ParallaxInternalMaxColor.rgb, _ParallaxInternalMaxColorThemeIndex);
					float3 parallaxTint = lerp(minColor, maxColor, ratio);
					float parallaxHeight;
					if(_ParallaxInternalHeightFromAlpha)
					{
						parallaxTint *= parallaxColor.rgb;
						parallaxHeight = parallaxColor.a;
					}
					else
					{
						parallaxHeight = parallaxColor.r;
					}
					// parallaxTint = hueShift(parallaxTint, frac((ratio * _ParallaxInternalHueShiftPerLevel) + (ratio * _ParallaxInternalHueShiftPerLevelSpeed * _Time.x)) * _ParallaxInternalHueShiftEnabled);
					parallaxTint = hueShift(parallaxTint, frac(ratio * _ParallaxInternalHueShiftPerLevel) * _ParallaxInternalHueShiftEnabled);
					//float parallaxColor *= lerp(_ParallaxInternalMinColor, _ParallaxInternalMaxColor, 1 - ratio);
					UNITY_BRANCH
					if (_ParallaxInternalHeightmapMode == 1)
					{
						parallax = lerp(parallax, parallaxTint * fade, parallaxHeight >= 1 - ratio);
					}
					else
					{
						parallax += parallaxTint * parallaxHeight * fade;
					}
				}
				parallax = hueShift(parallax, frac(_ParallaxInternalHueShift + _ParallaxInternalHueShiftSpeed * _Time.x) * _ParallaxInternalHueShiftEnabled);
				//parallax /= _ParallaxInternalIterations;
				#if defined(PROP_PARALLAXINTERNALMAPMASK) || !defined(OPTIMIZER_ENABLED)
				poiFragData.baseColor.rgb += parallax * POI2D_SAMPLER_PAN(_ParallaxInternalMapMask, _MainTex, poiUV(poiMesh.uv[_ParallaxInternalMapMaskUV], _ParallaxInternalMapMask_ST), _ParallaxInternalMapMaskPan)[_ParallaxInternalMapMaskChannel];
				#else
				poiFragData.baseColor.rgb += parallax;
				#endif
			}
			#endif
			//endex
			
			// normal correct code from https://github.com/yoship1639/UniToon (MIT)
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			void applyNormalCorrect(inout VertexOut i)
			{
				float3 normalCorrectObject = i.localPos.xyz - _NormalCorrectOrigin;
				normalCorrectObject.y = 0;
				normalCorrectObject = normalize(normalCorrectObject);
				float3 normalCorrectWorld = UnityObjectToWorldDir(normalCorrectObject);
				i.normal.xyz = normalize(lerp(i.normal.xyz, normalCorrectWorld, _NormalCorrectAmount));
				i.objNormal.xyz = normalize(lerp(i.objNormal.xyz, normalCorrectObject, _NormalCorrectAmount));
			}
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float3 applyBacklight(float3 videoTexture, half backlightStrength)
			{
				return max(backlightStrength, videoTexture.rgb);
			}
			
			float3 applyViewAngleTN(float3 videoTexture, PoiCam poiCam, PoiMesh poiMesh)
			{
				float3 reflectionVector = normalize(reflect(poiCam.viewDir.rgb, poiMesh.normals[1].rgb));
				float upwardShift = dot(reflectionVector, poiMesh.binormal[0]);
				upwardShift = pow(upwardShift, 1);
				float sideShift = dot(reflectionVector, poiMesh.tangent[0]);
				sideShift *= pow(sideShift, 3);
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = LinearToGammaSpace(videoTexture);
				#endif
				videoTexture = saturate(lerp(half3(0.5, 0.5, 0.5), videoTexture, upwardShift + 1));
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = GammaToLinearSpace(videoTexture);
				#endif
				videoTexture = (lerp(videoTexture, videoTexture.gbr, sideShift));
				return videoTexture;
			}
			
			float calculateCRTPixelBrightness(float2 uv)
			{
				float totalPixels = _VideoResolution.x * _VideoResolution.y;
				float2 uvPixel = float2((floor((1 - uv.y) * _VideoResolution.y)) / _VideoResolution.y, (floor(uv.x * _VideoResolution.x)) / _VideoResolution.x);
				float currentPixelNumber = _VideoResolution.x * (_VideoResolution.y * uvPixel.x) + _VideoResolution.y * uvPixel.y;
				float currentPixelAlpha = currentPixelNumber / totalPixels;
				half electronBeamAlpha = frac(_Time.y * _VideoCRTRefreshRate);
				float electronBeamPixelNumber = totalPixels * electronBeamAlpha;
				
				float DistanceInPixelsFromCurrentElectronBeamPixel = 0;
				if (electronBeamPixelNumber >= currentPixelNumber)
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber - currentPixelNumber;
				}
				else
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber + (totalPixels - currentPixelNumber);
				}
				float CRTFrameTime = 1 / _VideoCRTRefreshRate;
				float timeSincecurrentPixelWasHitByElectronBeam = (DistanceInPixelsFromCurrentElectronBeamPixel / totalPixels);
				
				return saturate(_VideoCRTPixelEnergizedTime - timeSincecurrentPixelWasHitByElectronBeam);
			}
			
			void applyContrastSettings(inout float3 pixel)
			{
				#if !UNITY_COLORSPACE_GAMMA
				pixel = LinearToGammaSpace(pixel);
				#endif
				pixel = saturate(lerp(half3(0.5, 0.5, 0.5), pixel, _VideoContrast + 1));
				#if !UNITY_COLORSPACE_GAMMA
				pixel = GammaToLinearSpace(pixel);
				#endif
			}
			
			void applySaturationSettings(inout float3 pixel)
			{
				pixel = lerp(pixel.rgb, dot(pixel.rgb, float3(0.3, 0.59, 0.11)), -(_VideoSaturation));
			}
			
			void applyVideoSettings(inout float3 pixel)
			{
				applySaturationSettings(pixel);
				applyContrastSettings(pixel);
			}
			
			void calculateLCD(inout float4 videoTexture, float3 pixels)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateTN(inout float4 videoTexture, float3 pixels, PoiCam poiCam, PoiMesh poiMesh)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				videoTexture.rgb = applyViewAngleTN(videoTexture, poiCam, poiMesh);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateCRT(inout float4 videoTexture, float3 pixels, float2 uv)
			{
				float brightness = calculateCRTPixelBrightness(uv);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * brightness * _VideoBacklight;
			}
			void calculateOLED(inout float4 videoTexture, float3 pixels)
			{
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateGameboy(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				// half brightness = saturate((videoTexture.r + videoTexture.g + videoTexture.b) * .3333333);
				half brightness = LinearRgbToLuminance(LinearToGammaSpace(videoTexture.rgb));
				#if defined(PROP_VIDEOGAMEBOYRAMP) || !defined(OPTIMIZER_ENABLED)
				videoTexture.rgb = tex2Dlod(_VideoGameboyRamp, float4(brightness.xx, 0, 0));
				#else
				float3 dg = float3(0.00392156863, 0.0392156863, 0.00392156863);
				float3 lg = float3(0.333333333, 0.5, 0.00392156863);
				videoTexture.rgb = lerp(dg, lg, brightness);
				#endif
			}
			void calculateProjector(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				
				float3 projectorColor = videoTexture * _VideoBacklight;
				videoTexture.r = clamp(projectorColor.r, videoTexture.r, 1000);
				videoTexture.g = clamp(projectorColor.g, videoTexture.g, 1000);
				videoTexture.b = clamp(projectorColor.b, videoTexture.b, 1000);
			}
			
			void applyVideoEffectsMainTex(inout float4 mainTexture, in PoiMesh poiMesh)
			{
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					float2 originalUVs = uvs;
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
					mainTexture = _MainTex.SampleGrad(sampler_MainTex, uvs, ddx(originalUVs), ddy(originalUVs));
				}
			}
			void applyVideoEffects(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
			{
				#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float3 pixels = tex2D(_VideoPixelTexture, poiUV(poiMesh.uv[_VideoPixelTextureUV], _VideoPixelTexture_ST) * _VideoResolution);
				#else
				float3 pixels = 1;
				#endif
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				else
				{
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				float4 modifiedVideoTexture = 0;
				modifiedVideoTexture.rgb = poiFragData.baseColor;
				modifiedVideoTexture.a = poiFragData.alpha;
				
				// UNITY_BRANCH
				// if(_VideoRepeatVideoTexture == 1)
				// {
				// 	if(poiMesh.uv[_VideoUVNumber].x > 1 || poiMesh.uv[_VideoUVNumber].x < 0 || poiMesh.uv[_VideoUVNumber].y > 1 || poiMesh.uv[_VideoUVNumber].y < 0)
				// 	{
				// 		return;
				// 	}
				// }
				
				switch(_VideoType)
				{
					case 0: // LCD
					{
						calculateLCD(modifiedVideoTexture, pixels);
						break;
					}
					case 1: // TN
					{
						calculateTN(modifiedVideoTexture, pixels, poiCam, poiMesh);
						break;
					}
					case 2: // CRT
					{
						calculateCRT(modifiedVideoTexture, pixels, uvs);
						break;
					}
					case 3: // OLED
					{
						calculateOLED(modifiedVideoTexture, pixels);
						break;
					}
					case 4: // Gameboy
					{
						calculateGameboy(modifiedVideoTexture);
						break;
					}
					case 5: // Projector
					{
						calculateProjector(modifiedVideoTexture);
						break;
					}
				}
				#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float screenMask = POI2D_SAMPLER_PAN(_VideoMaskTexture, _MainTex, poiUV(poiMesh.uv[_VideoMaskTextureUV], _VideoMaskTexture_ST), _VideoMaskTexturePan)[_VideoMaskTextureChannel];
				#else
				float screenMask = 1;
				#endif
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, modifiedVideoTexture, screenMask);
				// UNITY_BRANCH
				if (_VideoEmissionEnabled)
				{
					poiFragData.emission += modifiedVideoTexture.rgb * screenMask;
				}
			}
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			void ApplyBacklight(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiCam poiCam, inout PoiMods poiMods)
			{
				
				// Color
				float3 backlightColor = _BacklightColor.rgb;
				#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				backlightColor *= POI2D_SAMPLER_PAN(_BacklightColorTex, _MainTex, poiUV(poiMesh.uv[_BacklightColorTexUV], _BacklightColorTex_ST), _BacklightColorTexPan).rgb;
				#endif
				
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], _BacklightNormalStrength);
				// Factor
				float3 headDir = normalize(getCameraPosition() - poiMesh.worldPos.xyz);
				float headDotLight = dot(headDir, poiLight.direction);
				float backlightFactor = pow(saturate(-headDotLight * 0.5 + 0.5), max(0, _BacklightDirectivity));
				float backlightLN = dot(normalize(-headDir * _BacklightViewStrength + poiLight.direction), normal) * 0.5 + 0.5;
				if(_BacklightReceiveShadow) backlightLN *= saturate(poiLight.attenuation);
				backlightLN = poiEdgeLinear(backlightLN, _BacklightBorder, _BacklightBlur);
				float backlight = saturate(backlightFactor * backlightLN);
				backlight = !poiMesh.isFrontFace && _BacklightBackfaceMask ? 0.0 : backlight;
				
				// Blend
				backlightColor = lerp(backlightColor, backlightColor * poiFragData.baseColor, _BacklightMainStrength);
				poiLight.finalLightAdd += backlight * backlightColor * poiLight.directColor;
			}
			#endif
			//endex
			
			float4 frag(VertexOut i, uint facing : SV_IsFrontFace) : SV_Target
			/*
			#ifdef
			, out float depth : SV_DEPTH
			#endif
			*/
			{
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				
				PoiMesh poiMesh;
				PoiInitStruct(PoiMesh, poiMesh);
				
				PoiLight poiLight;
				PoiInitStruct(PoiLight, poiLight);
				
				PoiVertexLights poiVertexLights;
				PoiInitStruct(PoiVertexLights, poiVertexLights);
				
				PoiCam poiCam;
				PoiInitStruct(PoiCam, poiCam);
				
				PoiMods poiMods;
				PoiInitStruct(PoiMods, poiMods);
				poiMods.globalEmission = 1;
				poiMods.PBR = 1;
				
				PoiFragData poiFragData;
				poiFragData.emission = 0;
				poiFragData.baseColor = float3(0, 0, 0);
				poiFragData.finalColor = float3(0, 0, 0);
				poiFragData.alpha = 1;
				
				#ifdef POI_UDIMDISCARD
				applyUDIMDiscard(i);
				#endif
				
				//ifex _NormalCorrect==0
				#ifdef POI_NORMALCORRECT
				applyNormalCorrect(i);
				#endif
				//endex
				
				// Mesh Data
				poiMesh.objectPosition = i.objectPos;
				poiMesh.objNormal = i.objNormal;
				poiMesh.normals[0] = i.normal;
				poiMesh.tangent[0] = i.tangent;
				poiMesh.binormal[0] = i.binormal;
				poiMesh.worldPos = i.worldPos.xyz;
				poiMesh.localPos = i.localPos.xyz;
				poiMesh.vertexColor = i.vertexColor;
				poiMesh.isFrontFace = facing;
				
				#ifndef POI_PASS_OUTLINE
				if (!poiMesh.isFrontFace)
				{
					poiMesh.normals[0] *= -1;
					poiMesh.tangent[0] *= -1;
					poiMesh.binormal[0] *= -1;
				}
				#endif
				
				poiCam.viewDir = !IsOrthographicCamera() ? normalize(_WorldSpaceCameraPos - i.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 tanToWorld0 = float3(i.tangent.x, i.binormal.x, i.normal.x);
				float3 tanToWorld1 = float3(i.tangent.y, i.binormal.y, i.normal.y);
				float3 tanToWorld2 = float3(i.tangent.z, i.binormal.z, i.normal.z);
				float3 ase_tanViewDir = tanToWorld0 * poiCam.viewDir.x + tanToWorld1 * poiCam.viewDir.y + tanToWorld2 * poiCam.viewDir.z;
				poiCam.tangentViewDir = normalize(ase_tanViewDir);
				
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 6 Distorted UV
				#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
				poiMesh.lightmapUV = i.lightmapUV;
				#endif
				poiMesh.parallaxUV = poiCam.tangentViewDir.xy / max(poiCam.tangentViewDir.z, 0.0001);
				poiMesh.uv[0] = i.uv[0];
				poiMesh.uv[1] = i.uv[1];
				poiMesh.uv[2] = i.uv[2];
				poiMesh.uv[3] = i.uv[3];
				poiMesh.uv[4] = poiMesh.uv[0];
				poiMesh.uv[5] = poiMesh.uv[0];
				poiMesh.uv[6] = poiMesh.uv[0];
				poiMesh.uv[7] = poiMesh.uv[0];
				poiMesh.uv[8] = poiMesh.uv[0];
				
				poiMesh.uv[4] = calculatePanosphereUV(poiMesh);
				poiMesh.uv[5] = calculateWorldUV(poiMesh);
				poiMesh.uv[6] = calculatePolarCoordinate(poiMesh);
				poiMesh.uv[8] = calculatelocalUV(poiMesh);
				//ifex _EnableDistortion==0
				#ifdef USER_LUT
				poiMesh.uv[7] = distortedUV(poiMesh);
				#endif
				//endex
				/*
				half3 worldViewUp = normalize(half3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, half3(0, 1, 0)));
				half3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
				poiMesh[8] = half2(dot(worldViewRight, poiMesh.normals[_MatcapNormal]), dot(worldViewUp, poiMesh.normals[_MatcapNormal])) * _MatcapBorder + 0.5;
				*/
				
				//ifex _PoiParallax==0
				#ifdef POI_PARALLAX
				#ifndef POI_PASS_OUTLINE
				//return frac(i.tangentViewDir.x);
				//return float4(i.binormal.xyz,1);
				applyParallax(poiMesh, poiLight, poiCam);
				#endif
				#endif
				//endex
				
				poiMods.globalMask[0]  = 1;
				poiMods.globalMask[1]  = 1;
				poiMods.globalMask[2]  = 1;
				poiMods.globalMask[3]  = 1;
				poiMods.globalMask[4]  = 1;
				poiMods.globalMask[5]  = 1;
				poiMods.globalMask[6]  = 1;
				poiMods.globalMask[7]  = 1;
				poiMods.globalMask[8]  = 1;
				poiMods.globalMask[9]  = 1;
				poiMods.globalMask[10] = 1;
				poiMods.globalMask[11] = 1;
				poiMods.globalMask[12] = 1;
				poiMods.globalMask[13] = 1;
				poiMods.globalMask[14] = 1;
				poiMods.globalMask[15] = 1;
				//ifex _GlobalMaskTexturesEnable==0
				#ifdef POI_GLOBALMASK_TEXTURES
				ApplyGlobalMaskTextures(poiMesh, poiMods);
				#endif
				//endex
				ApplyGlobalMaskModifiers(poiMesh, poiMods, poiCam);
				//ifex _GlobalMaskOptionsEnable==0
				if(_GlobalMaskOptionsEnable)
				{
					ApplyGlobalMaskOptions(poiMods);
				}
				//endex
				
				float2 mainUV = poiMesh.uv[_MainTexUV].xy;
				
				if (_MainPixelMode)
				{
					mainUV = sharpSample(_MainTex_TexelSize, mainUV);
				}
				
				float4 mainTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_MainTex, _MainTex, poiUV(mainUV, _MainTex_ST), _MainTexPan, _MainTexStochastic);
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffectsMainTex(mainTexture, poiMesh);
				}
				//endex
				
				#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
				poiMesh.tangentSpaceNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_BumpMap, _MainTex, poiUV(poiMesh.uv[_BumpMapUV].xy, _BumpMap_ST), _BumpMapPan, _BumpMapStochastic), _BumpScale);
				#else
				poiMesh.tangentSpaceNormal = UnpackNormal(float4(0.5, 0.5, 1, 1));
				#endif
				
				//ifex _DetailEnabled==0
				#if defined(FINALPASS) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				ApplyDetailNormal(poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				//ifex _RgbNormalsEnabled==0
				#if defined(GEOM_TYPE_MESH) && defined(VIGNETTE) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				calculateRGBNormals(poiMesh, poiMods);
				#endif
				//endex
				//endex
				
				poiMesh.normals[1] = normalize(
				poiMesh.tangentSpaceNormal.x * poiMesh.tangent[0] +
				poiMesh.tangentSpaceNormal.y * poiMesh.binormal[0] +
				poiMesh.tangentSpaceNormal.z * poiMesh.normals[0]
				);
				
				poiMesh.tangent[1] = cross(poiMesh.binormal[0], -poiMesh.normals[1]);
				poiMesh.binormal[1] = cross(-poiMesh.normals[1], poiMesh.tangent[0]);
				
				// Camera data
				poiCam.forwardDir = getCameraForward();
				poiCam.worldPos = _WorldSpaceCameraPos;
				poiCam.reflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[1]);
				poiCam.vertexReflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[0]);
				//poiCam.distanceToModel = distance(poiMesh.modelPos, poiCam.worldPos);
				poiCam.distanceToVert = distance(poiMesh.worldPos, poiCam.worldPos);
				poiCam.grabPos = i.grabPos;
				poiCam.screenUV = calcScreenUVs(i.grabPos);
				poiCam.vDotN = abs(dot(poiCam.viewDir, poiMesh.normals[1]));
				poiCam.clipPos = i.pos;
				poiCam.worldDirection = i.worldDirection;
				
				calculateGlobalThemes(poiMods);
				
				poiLight.finalLightAdd = 0;
				
				// Ambient Occlusion
				#if defined(PROP_LIGHTINGAOMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 AOMaps = POI2D_SAMPLER_PAN(_LightingAOMaps, _MainTex, poiUV(poiMesh.uv[_LightingAOMapsUV], _LightingAOMaps_ST), _LightingAOMapsPan);
				poiLight.occlusion = min(min(min(lerp(1, AOMaps.r, _LightDataAOStrengthR), lerp(1, AOMaps.g, _LightDataAOStrengthG)), lerp(1, AOMaps.b, _LightDataAOStrengthB)), lerp(1, AOMaps.a, _LightDataAOStrengthA));
				#else
				poiLight.occlusion = 1;
				#endif
				
				if (_LightDataAOGlobalMaskR > 0)
				{
					poiLight.occlusion = maskBlend(poiLight.occlusion, poiMods.globalMask[_LightDataAOGlobalMaskR - 1], _LightDataAOGlobalMaskBlendTypeR);
				}
				
				// Detail Shadows
				#if defined(PROP_LIGHTINGDETAILSHADOWMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 DetailShadows = POI2D_SAMPLER_PAN(_LightingDetailShadowMaps, _MainTex, poiUV(poiMesh.uv[_LightingDetailShadowMapsUV], _LightingDetailShadowMaps_ST), _LightingDetailShadowMapsPan);
				#ifndef POI_PASS_ADD
				poiLight.detailShadow = lerp(1, DetailShadows.r, _LightingDetailShadowStrengthR) * lerp(1, DetailShadows.g, _LightingDetailShadowStrengthG) * lerp(1, DetailShadows.b, _LightingDetailShadowStrengthB) * lerp(1, DetailShadows.a, _LightingDetailShadowStrengthA);
				#else
				poiLight.detailShadow = lerp(1, DetailShadows.r, _LightingAddDetailShadowStrengthR) * lerp(1, DetailShadows.g, _LightingAddDetailShadowStrengthG) * lerp(1, DetailShadows.b, _LightingAddDetailShadowStrengthB) * lerp(1, DetailShadows.a, _LightingAddDetailShadowStrengthA);
				#endif
				#else
				poiLight.detailShadow = 1;
				#endif
				
				if (_LightDataDetailShadowGlobalMaskR > 0)
				{
					poiLight.detailShadow = maskBlend(poiLight.detailShadow, poiMods.globalMask[_LightDataDetailShadowGlobalMaskR - 1], _LightDataDetailShadowGlobalMaskBlendTypeR);
				}
				
				// Shadow Masks
				#if defined(PROP_LIGHTINGSHADOWMASKS) || !defined(OPTIMIZER_ENABLED)
				float4 ShadowMasks = POI2D_SAMPLER_PAN(_LightingShadowMasks, _MainTex, poiUV(poiMesh.uv[_LightingShadowMasksUV], _LightingShadowMasks_ST), _LightingShadowMasksPan);
				poiLight.shadowMask = lerp(1, ShadowMasks.r, _LightingShadowMaskStrengthR) * lerp(1, ShadowMasks.g, _LightingShadowMaskStrengthG) * lerp(1, ShadowMasks.b, _LightingShadowMaskStrengthB) * lerp(1, ShadowMasks.a, _LightingShadowMaskStrengthA);
				#else
				poiLight.shadowMask = 1;
				#endif
				
				if (_LightDataShadowMaskGlobalMaskR > 0)
				{
					poiLight.shadowMask = maskBlend(poiLight.shadowMask, poiMods.globalMask[_LightDataShadowMaskGlobalMaskR - 1], _LightDataShadowMaskGlobalMaskBlendTypeR);
				}
				
				#ifdef UNITY_PASS_FORWARDBASE
				
				bool lightExists = false;
				if (any(_LightColor0.rgb >= 0.002))
				{
					lightExists = true;
				}
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					float4 toLightX = unity_4LightPosX0 - i.worldPos.x;
					float4 toLightY = unity_4LightPosY0 - i.worldPos.y;
					float4 toLightZ = unity_4LightPosZ0 - i.worldPos.z;
					float4 lengthSq = 0;
					lengthSq += toLightX * toLightX;
					lengthSq += toLightY * toLightY;
					lengthSq += toLightZ * toLightZ;
					
					float4 lightAttenSq = unity_4LightAtten0;
					float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
					float4 vLightWeight = saturate(1 - (lengthSq * lightAttenSq / 25));
					poiLight.vAttenuation = min(atten, vLightWeight * vLightWeight);
					
					poiLight.vDotNL = 0;
					poiLight.vDotNL += toLightX * poiMesh.normals[1].x;
					poiLight.vDotNL += toLightY * poiMesh.normals[1].y;
					poiLight.vDotNL += toLightZ * poiMesh.normals[1].z;
					
					float4 corr = rsqrt(lengthSq);
					poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);
					
					poiLight.vertexVDotNL = 0;
					poiLight.vertexVDotNL += toLightX * poiMesh.normals[0].x;
					poiLight.vertexVDotNL += toLightY * poiMesh.normals[0].y;
					poiLight.vertexVDotNL += toLightZ * poiMesh.normals[0].z;
					
					poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);
					
					poiLight.vAttenuationDotNL = saturate(poiLight.vAttenuation * saturate(poiLight.vDotNL));
					
					[unroll]
					for (int index = 0; index < 4; index++)
					{
						poiLight.vPosition[index] = float3(unity_4LightPosX0[index], unity_4LightPosY0[index], unity_4LightPosZ0[index]);
						
						float3 vertexToLightSource = poiLight.vPosition[index] - poiMesh.worldPos;
						poiLight.vDirection[index] = normalize(vertexToLightSource);
						//poiLight.vAttenuationDotNL[index] = 1.0 / (1.0 + unity_4LightAtten0[index] * poiLight.vDotNL[index]);
						poiLight.vColor[index] = _LightingAdditiveLimited ? min(_LightingAdditiveLimit, unity_LightColor[index].rgb) : unity_LightColor[index].rgb;
						poiLight.vColor[index] = lerp(poiLight.vColor[index], dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
						poiLight.vHalfDir[index] = Unity_SafeNormalize(poiLight.vDirection[index] + poiCam.viewDir);
						poiLight.vDotNL[index] = dot(poiMesh.normals[1], poiLight.vDirection[index]);
						poiLight.vCorrectedDotNL[index] = .5 * (poiLight.vDotNL[index] + 1);
						poiLight.vDotLH[index] = saturate(dot(poiLight.vDirection[index], poiLight.vHalfDir[index]));
						
						poiLight.vDotNH[index] = dot(poiMesh.normals[1], poiLight.vHalfDir[index]);
						poiLight.vertexVDotNH[index] = saturate(dot(poiMesh.normals[0], poiLight.vHalfDir[index]));
					}
					#endif
				}
				
				//UNITY_BRANCH
				if (_LightingColorMode == 0) // Poi Custom Light Color
				
				{
					float3 magic = max(BetterSH9(normalize(unity_SHAr + unity_SHAg + unity_SHAb)), 0);
					float3 normalLight = _LightColor0.rgb + BetterSH9(float4(0, 0, 0, 1));
					
					float magiLumi = calculateluminance(magic);
					float normaLumi = calculateluminance(normalLight);
					float maginormalumi = magiLumi + normaLumi;
					
					float magiratio = magiLumi / maginormalumi;
					float normaRatio = normaLumi / maginormalumi;
					
					float target = calculateluminance(magic * magiratio + normalLight * normaRatio);
					float3 properLightColor = magic + normalLight;
					float properLuminance = calculateluminance(magic + normalLight);
					poiLight.directColor = properLightColor * max(0.0001, (target / properLuminance));
					
					poiLight.indirectColor = BetterSH9(float4(lerp(0, poiMesh.normals[1], _LightingIndirectUsesNormals), 1));
				}
				
				//UNITY_BRANCH
				if (_LightingColorMode == 1) // More standard approach to light color
				
				{
					float3 indirectColor = BetterSH9(float4(poiMesh.normals[1], 1));
					if (lightExists)
					{
						poiLight.directColor = _LightColor0.rgb;
						poiLight.indirectColor = indirectColor;
					}
					else
					{
						poiLight.directColor = indirectColor * 0.6;
						poiLight.indirectColor = indirectColor * 0.5;
					}
				}
				
				if (_LightingColorMode == 2) // UTS style
				
				{
					poiLight.indirectColor = saturate(max(half3(0.05, 0.05, 0.05) * _Unlit_Intensity, max(ShadeSH9(half4(0.0, 0.0, 0.0, 1.0)), ShadeSH9(half4(0.0, -1.0, 0.0, 1.0)).rgb) * _Unlit_Intensity));
					poiLight.directColor = max(poiLight.indirectColor, _LightColor0.rgb);
				}
				
				if (_LightingColorMode == 3) // OpenLit
				
				{
					float3 lightDirectionForSH9 = OpenLitLightingDirectionForSH9();
					OpenLitShadeSH9ToonDouble(lightDirectionForSH9, poiLight.directColor, poiLight.indirectColor);
					poiLight.directColor += _LightColor0.rgb;
					// OpenLit does a few other things by default like clamp direct colour
					// see https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl#L174
					// Should we add (if) statements to override Poi versions of these things?
					// Or should we add new properties with same names with the same functions?
					
				}
				
				float lightMapMode = _LightingMapMode;
				//UNITY_BRANCH
				if (_LightingDirectionMode == 0)
				{
					poiLight.direction = _WorldSpaceLightPos0.xyz + unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz;
				}
				if (_LightingDirectionMode == 1 || _LightingDirectionMode == 2)
				{
					//UNITY_BRANCH
					if (_LightingDirectionMode == 1)
					{
						poiLight.direction = mul(unity_ObjectToWorld, _LightngForcedDirection).xyz;;
					}
					//UNITY_BRANCH
					if (_LightingDirectionMode == 2)
					{
						poiLight.direction = _LightngForcedDirection;
					}
					if (lightMapMode == 0)
					{
						lightMapMode == 1;
					}
				}
				
				if (_LightingDirectionMode == 3) // UTS
				
				{
					float3 defaultLightDirection = normalize(UNITY_MATRIX_V[2].xyz + UNITY_MATRIX_V[1].xyz);
					float3 lightDirection = normalize(lerp(defaultLightDirection, _WorldSpaceLightPos0.xyz, any(_WorldSpaceLightPos0.xyz)));
					poiLight.direction = lightDirection;
				}
				if (_LightingDirectionMode == 4) // OpenLit
				
				{
					poiLight.direction = OpenLitLightingDirection(); // float4 customDir = 0; // Do we want to give users to alter this (OpenLit always does!)?
					
				}
				
				if (!any(poiLight.direction))
				{
					poiLight.direction = float3(.4, 1, .4);
				}
				
				poiLight.direction = normalize(poiLight.direction);
				poiLight.attenuationStrength = _LightingCastedShadows;
				poiLight.attenuation = 1;
				if (!all(_LightColor0.rgb == 0.0))
				{
					UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos)
					poiLight.attenuation *= attenuation;
				}
				
				if (!any(poiLight.directColor) && !any(poiLight.indirectColor) && lightMapMode == 0)
				{
					lightMapMode = 1;
					if (_LightingDirectionMode == 0)
					{
						poiLight.direction = normalize(float3(.4, 1, .4));
					}
				}
				
				poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
				poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
				poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
				poiLight.nDotLSaturated = saturate(poiLight.nDotL);
				poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
				poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
				poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
				poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
				poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
				poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
				poiLight.lDotH = max(0.00001, dot(poiLight.direction, poiLight.halfDir));
				
				// Poi special light map
				if (lightMapMode == 0)
				{
					float3 ShadeSH9Plus = GetSHLength();
					float3 ShadeSH9Minus = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;
					
					float3 greyScaleVector = float3(.33333, .33333, .33333);
					float bw_lightColor = dot(poiLight.directColor, greyScaleVector);
					float bw_directLighting = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor * lerp(1, poiLight.attenuation, poiLight.attenuationStrength)) + dot(ShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
					float bw_directLightingNoAtten = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor) + dot(ShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
					float bw_bottomIndirectLighting = dot(ShadeSH9Minus, greyScaleVector);
					float bw_topIndirectLighting = dot(ShadeSH9Plus, greyScaleVector);
					float lightDifference = ((bw_topIndirectLighting + bw_lightColor) - bw_bottomIndirectLighting);
					poiLight.lightMap = smoothstep(0, lightDifference, bw_directLighting - bw_bottomIndirectLighting) * poiLight.detailShadow;
					
					poiLight.lightMap = smoothstep(0, lightDifference, bw_directLighting - bw_bottomIndirectLighting) * poiLight.detailShadow;
					poiLight.lightMapNoAttenuation = smoothstep(0, lightDifference, bw_directLightingNoAtten - bw_bottomIndirectLighting) * poiLight.detailShadow;
				}
				// Normalized nDotL
				if (lightMapMode == 1)
				{
					poiLight.lightMapNoAttenuation = poiLight.nDotLNormalized;
					poiLight.lightMap = poiLight.nDotLNormalized * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				}
				// Saturated nDotL
				if (lightMapMode == 2)
				{
					poiLight.lightMapNoAttenuation = poiLight.nDotLSaturated;
					poiLight.lightMap = poiLight.nDotLSaturated * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				}
				
				poiLight.directColor = max(poiLight.directColor, 0.0001);
				poiLight.indirectColor = max(poiLight.indirectColor, 0.0001);
				if (_LightingColorMode == 3)
				{
					// OpenLit
					poiLight.directColor = max(poiLight.directColor, _LightingMinLightBrightness);
				}
				else
				{
					poiLight.directColor = max(poiLight.directColor, poiLight.directColor * min(10000, (_LightingMinLightBrightness * rcp(calculateluminance(poiLight.directColor)))));
					poiLight.indirectColor = max(poiLight.indirectColor, poiLight.indirectColor * min(10000, (_LightingMinLightBrightness * rcp(calculateluminance(poiLight.indirectColor)))));
				}
				
				poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
				poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
				
				if (_LightingCapEnabled)
				{
					poiLight.directColor = min(poiLight.directColor, _LightingCap);
					poiLight.indirectColor = min(poiLight.indirectColor, _LightingCap);
				}
				
				if (_LightingForceColorEnabled)
				{
					poiLight.directColor = poiThemeColor(poiMods, _LightingForcedColor, _LightingForcedColorThemeIndex);
				}
				
				#ifdef UNITY_PASS_FORWARDBASE
				poiLight.directColor = max(poiLight.directColor * _PPLightingMultiplier, 0);
				poiLight.directColor = max(poiLight.directColor + _PPLightingAddition, 0);
				poiLight.indirectColor = max(poiLight.indirectColor * _PPLightingMultiplier, 0);
				poiLight.indirectColor = max(poiLight.indirectColor + _PPLightingAddition, 0);
				#endif
				
				#endif
				
				#ifdef POI_PASS_ADD
				if (!_LightingAdditiveEnable)
				{
					return float4(mainTexture.rgb * .0001, 1);
				}
				
				#if defined(DIRECTIONAL)
				if (_DisableDirectionalInAdd)
				{
					return float4(mainTexture.rgb * .0001, 1);
				}
				#endif
				
				poiLight.direction = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz * _WorldSpaceLightPos0.w);
				#if defined(POINT) || defined(SPOT)
				#ifdef POINT
				unityShadowCoord3 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1)).xyz;
				poiLight.attenuation = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).r;
				#endif
				
				#ifdef SPOT
				unityShadowCoord4 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1));
				poiLight.attenuation = (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz);
				#endif
				#else
				UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos)
				poiLight.attenuation = attenuation;
				#endif
				poiLight.additiveShadow = UNITY_SHADOW_ATTENUATION(i, poiMesh.worldPos);
				poiLight.attenuationStrength = _LightingAdditiveCastedShadows;
				poiLight.directColor = _LightingAdditiveLimited ? min(_LightingAdditiveLimit, _LightColor0.rgb) : _LightColor0.rgb;
				
				#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
				poiLight.indirectColor = 0;
				#else
				poiLight.indirectColor = lerp(0, poiLight.directColor, _LightingAdditivePassthrough);
				#endif
				
				poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
				poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
				
				poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
				poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
				poiLight.nDotLSaturated = saturate(poiLight.nDotL);
				poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
				poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
				poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
				poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
				poiLight.lDotH = dot(poiLight.direction, poiLight.halfDir);
				poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
				poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
				poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
				
				// Normalized nDotL
				if (_LightingMapMode == 1)
				{
					poiLight.lightMap = poiLight.nDotLNormalized;
				}
				// Saturated nDotL
				if (_LightingMapMode == 2 || _LightingMapMode == 0)
				{
					poiLight.lightMap = poiLight.nDotLSaturated;
				}
				poiLight.lightMap *= lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
				#endif
				
				//ifex _LightDataDebugEnabled==0
				if (_LightDataDebugEnabled)
				{
					#ifdef UNITY_PASS_FORWARDBASE
					//UNITY_BRANCH
					if (_LightingDebugVisualize <= 6)
					{
						switch(_LightingDebugVisualize)
						{
							case 0: // Direct Light Color
							return float4(poiLight.directColor + mainTexture.rgb * .0001, 1);
							break;
							case 1: // Indirect Light Color
							return float4(poiLight.indirectColor + mainTexture.rgb * .0001, 1);
							break;
							case 2: // Light Map
							return float4(poiLight.lightMap + mainTexture.rgb * .0001, 1);
							break;
							case 3: // Attenuation
							return float4(poiLight.attenuation + mainTexture.rgb * .0001, 1);
							break;
							case 4: // N Dot L
							return float4(poiLight.nDotLNormalized, poiLight.nDotLNormalized, poiLight.nDotLNormalized, 1) + mainTexture * .0001;
							break;
							case 5:
							return float4(poiLight.halfDir, 1) + mainTexture * .0001;
							break;
							case 6:
							return float4(poiLight.direction, 1) + mainTexture * .0001;
							break;
						}
					}
					else
					{
						return POI_SAFE_RGB1;
					}
					#endif
					#ifdef POI_PASS_ADD
					//UNITY_BRANCH
					if (_LightingDebugVisualize < 6)
					{
						return POI_SAFE_RGB1;
					}
					else
					{
						switch(_LightingDebugVisualize)
						{
							case 7:
							return float4(poiLight.directColor * poiLight.attenuation + mainTexture.rgb * .0001, 1);
							break;
							case 8:
							return float4(poiLight.attenuation + mainTexture.rgb * .0001, 1);
							break;
							case 9:
							return float4(poiLight.additiveShadow + mainTexture.rgb * .0001, 1);
							break;
							case 10:
							return float4(poiLight.nDotLNormalized + mainTexture.rgb * .0001, 1);
							break;
							case 11:
							return float4(poiLight.halfDir, 1) + mainTexture * .0001;
							break;
						}
					}
					#endif
				}
				//endex
				
				//ifex _EnableAudioLink==0
				#ifdef POI_AUDIOLINK
				SetupAudioLink(poiFragData, poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _BlackLightMaskingEnabled==0
				#ifdef POI_BLACKLIGHTMASKING
				calculateBlackLightMasks(poiMesh, poiMods);
				#endif
				//endex
				
				poiFragData.baseColor = mainTexture.rgb * poiThemeColor(poiMods, _Color.rgb, _ColorThemeIndex);
				poiFragData.alpha = mainTexture.a * _Color.a;
				
				//ifex _MainColorAdjustToggle==0
				#ifdef COLOR_GRADING_HDR
				#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 hueShiftAlpha = POI2D_SAMPLER_PAN(_MainColorAdjustTexture, _MainTex, poiUV(poiMesh.uv[_MainColorAdjustTextureUV], _MainColorAdjustTexture_ST), _MainColorAdjustTexturePan);
				#else
				float4 hueShiftAlpha = 1;
				#endif
				
				if (_MainHueGlobalMask > 0)
				{
					hueShiftAlpha.r = maskBlend(hueShiftAlpha.r, poiMods.globalMask[_MainHueGlobalMask-1], _MainHueGlobalMaskBlendType);
				}
				if (_MainSaturationGlobalMask > 0)
				{
					hueShiftAlpha.b = maskBlend(hueShiftAlpha.b, poiMods.globalMask[_MainSaturationGlobalMask-1], _MainSaturationGlobalMaskBlendType);
				}
				if (_MainBrightnessGlobalMask > 0)
				{
					hueShiftAlpha.g = maskBlend(hueShiftAlpha.g, poiMods.globalMask[_MainBrightnessGlobalMask-1], _MainBrightnessGlobalMaskBlendType);
				}
				
				if (_MainHueShiftToggle)
				{
					float shift = _MainHueShift;
					#ifdef POI_AUDIOLINK
					//UNITY_BRANCH
					if (poiMods.audioLinkAvailable && _MainHueALCTEnabled)
					{
						shift += AudioLinkGetChronoTime(_MainALHueShiftCTIndex, _MainALHueShiftBand) * _MainHueALMotionSpeed;
					}
					#endif
					if (_MainHueShiftReplace)
					{
						poiFragData.baseColor = lerp(poiFragData.baseColor, hueShift(poiFragData.baseColor, shift + _MainHueShiftSpeed * _Time.x), hueShiftAlpha.r);
					}
					else
					{
						poiFragData.baseColor = hueShift(poiFragData.baseColor, frac((shift - (1 - hueShiftAlpha.r) + _MainHueShiftSpeed * _Time.x)));
					}
				}
				poiFragData.baseColor = lerp(poiFragData.baseColor, dot(poiFragData.baseColor, float3(0.3, 0.59, 0.11)), -(_Saturation) * hueShiftAlpha.b);
				poiFragData.baseColor = saturate(poiFragData.baseColor + _MainBrightness * hueShiftAlpha.g);
				#endif
				//endex
				
				#if defined(PROP_CLIPPINGMASK) || !defined(OPTIMIZER_ENABLED)
				float alphaMask = POI2D_SAMPLER_PAN(_ClippingMask, _MainTex, poiUV(poiMesh.uv[_ClippingMaskUV], _ClippingMask_ST), _ClippingMaskPan).r;
				if (_Inverse_Clipping)
				{
					alphaMask = 1 - alphaMask;
				}
				
				poiFragData.alpha *= alphaMask;
				#endif
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffects(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				}
				//endex
				
				applyAlphaOptions(poiFragData, poiMesh, poiCam, poiMods);
				
				//ifex _DetailEnabled==0
				#ifdef FINALPASS
				ApplyDetailColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _MainVertexColoringEnabled==0
				applyVertexColor(poiFragData, poiMesh);
				//endex
				
				//ifex _BackFaceEnabled!=1
				#ifdef POI_BACKFACE
				ApplyBackFaceColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				#ifdef VIGNETTE
				calculateRGBMask(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				#if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_BRANCH_DETAIL) || defined(GEOM_TYPE_FROND) || defined(DEPTH_OF_FIELD_COC_VIEW)
				applyDecals(poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				applyDissolve(poiFragData, poiMesh, poiMods, poiCam, poiLight);
				#endif
				//endex
				
				//ifex _ShadingEnabled==0
				#if defined(_LIGHTINGMODE_SHADEMAP) && defined(VIGNETTE_MASKED)
				#ifndef POI_PASS_OUTLINE
				#ifdef _LIGHTINGMODE_SHADEMAP
				applyShadeMapping(poiFragData, poiMesh, poiLight);
				#endif
				#endif
				#endif
				//endex
				
				//ifex _ShadingEnabled==0
				#ifdef VIGNETTE_MASKED
				#ifdef POI_PASS_OUTLINE
				//UNITY_BRANCH
				if (_OutlineLit)
				{
					calculateShading(poiLight, poiFragData, poiMesh, poiCam);
				}
				else
				{
					poiLight.finalLighting = 1;
				}
				#else
				calculateShading(poiLight, poiFragData, poiMesh, poiCam);
				#endif
				#else
				//endex
				poiLight.finalLighting = 1;
				poiLight.rampedLightMap = poiEdgeNonLinear(poiLight.nDotL, 0.1, .1);
				//ifex _ShadingEnabled==0
				#endif
				//endex
				
				//ifex _EnableAniso==0
				#ifdef POI_ANISOTROPICS
				//ifex _AnisoDebugToggle==0
				if(_AnisoDebugToggle)
				{
					return float4(applyAnisotropics(poiFragData, poiLight, poiCam, poiMesh, poiMods), 1) + POI_SAFE_RGB1;
				}
				//endex
				applyAnisotropics(poiFragData, poiLight, poiCam, poiMesh, poiMods);
				
				#endif
				//endex
				
				//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
				#if defined(POI_MATCAP0) || defined(COLOR_GRADING_HDR_3D) || defined(POI_MATCAP2) || defined(POI_MATCAP3)
				applyMatcap(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _CubeMapEnabled==0
				#ifdef _CUBEMAP
				applyCubemap(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _EnableALDecal==0
				#ifdef POI_AUDIOLINK
				#ifdef POI_AL_DECAL
				ApplyAudioLinkDecal(poiMesh, poiFragData, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableVolumeColor==0
				#ifdef POI_AUDIOLINK
				#ifdef POI_AL_VOLUMECOLOR
				ApplyAudioLinkVolumeColor(poiMesh, poiFragData, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableFlipbook==0
				#ifdef _SUNDISK_HIGH_QUALITY
				applyFlipbook(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableRimLighting==0
				#ifdef _GLOSSYREFLECTIONS_OFF
				#ifdef _RIMSTYLE_POIYOMI
				#if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
				float4 rimMaskAndBias = POI2D_SAMPLER_PAN(_RimMask, _MainTex, poiUV(poiMesh.uv[_RimMaskUV], _RimMask_ST), _RimMaskPan);
				float rimMask = rimMaskAndBias[_RimMaskChannel];
				float rimBias = rimMaskAndBias.a;
				#else
				float rimMask = 1;
				float rimBias = 0;
				#endif
				
				if(_RimMaskInvert)
				{
					rimMask = 1 - rimMask;
				}
				
				#if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rimColor = POI2D_SAMPLER_PAN(_RimTex, _MainTex, poiUV(poiMesh.uv[_RimTexUV], _RimTex_ST), _RimTexPan);
				#else
				float4 rimColor = 1;
				#endif
				half AudioLinkRimWidthBand = 0;
				float2 AudioLinkRimWidthAdd = 0;
				half AudioLinkRimEmissionBand = 0;
				float2 AudioLinkRimEmissionAdd = 0;
				half AudioLinkRimBrightnessBand = 0;
				float2 AudioLinkRimBrightnessAdd = 0;
				#ifdef POI_AUDIOLINK
				AudioLinkRimWidthBand = _AudioLinkRimWidthBand;
				AudioLinkRimWidthAdd = _AudioLinkRimWidthAdd;
				AudioLinkRimEmissionBand = _AudioLinkRimEmissionBand;
				AudioLinkRimEmissionAdd = _AudioLinkRimEmissionAdd;
				AudioLinkRimBrightnessBand = _AudioLinkRimBrightnessBand;
				AudioLinkRimBrightnessAdd = _AudioLinkRimBrightnessAdd;
				#endif
				ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Is_NormalMapToRimLight, _RimLightingInvert, _RimPower, _RimStrength, _RimShadowWidth, _RimShadowToggle, _RimWidth, _RimBlendStrength, rimMask, _RimGlobalMask, _RimGlobalMaskBlendType, rimColor, _RimLightColor, _RimLightColorThemeIndex, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimSharpness, _RimShadowMaskRampType, _RimShadowMaskInvert, _RimShadowMaskStrength, _RimShadowAlpha, _RimApplyGlobalMaskIndex, _RimApplyGlobalMaskBlendType, _RimBaseColorMix, _RimBrightness, _RimBlendMode, AudioLinkRimWidthBand, AudioLinkRimWidthAdd, AudioLinkRimEmissionBand, AudioLinkRimEmissionAdd, AudioLinkRimBrightnessBand, AudioLinkRimBrightnessAdd, _RimClamp, rimBias, _RimBiasIntensity);
				#endif
				#ifdef _RIMSTYLE_UTS2
				#if defined(PROP_SET_RIMLIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float Set_RimLightMask_var = POI2D_SAMPLER_PAN(_Set_RimLightMask, _MainTex, poiUV(poiMesh.uv[_Set_RimLightMaskUV], _Set_RimLightMask_ST), _Set_RimLightMaskPan)[_Set_RimLightMaskChannel];
				#else
				float Set_RimLightMask_var = 1;
				#endif
				ApplyUTS2RimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, Set_RimLightMask_var, _RimGlobalMask, _RimGlobalMaskBlendType, _RimLightColor, _RimLightColorThemeIndex, _Is_LightColor_RimLight, _Is_NormalMapToRimLight, _RimLight_Power, _RimLight_InsideMask, _RimLight_FeatherOff, _LightDirection_MaskOn, _Tweak_LightDirection_MaskLevel, _Add_Antipodean_RimLight, _Ap_RimLightColor, _RimApColorThemeIndex, _Is_LightColor_Ap_RimLight, _Ap_RimLight_Power, _Ap_RimLight_FeatherOff, _Tweak_RimLightMaskLevel, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimClamp);
				#endif
				#ifdef _RIMSTYLE_LILTOON
				#if defined(PROP_RIMCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rimColorTex = POI2D_SAMPLER_PAN(_RimColorTex, _MainTex, poiUV(poiMesh.uv[_RimColorTexUV], _RimColorTex_ST), _RimColorTexPan);
				#else
				float4 rimColorTex = 1;
				#endif
				ApplyLiltoonRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _RimColor, _RimIndirColor, rimColorTex, _RimMainStrength, _RimNormalStrength, _RimDirRange, _RimIndirRange, _RimFresnelPower, _RimBackfaceMask, _RimDirStrength, _RimBorder, _RimBlur, _RimIndirBorder, _RimIndirBlur, _RimShadowMask, _RimEnableLighting, _RimVRParallaxStrength, _RimGlobalMask, _RimGlobalMaskBlendType, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimClamp);
				#endif
				#endif
				//endex
				//ifex _EnableRim2Lighting==0
				#ifdef POI_RIM2
				#ifdef _RIM2STYLE_POIYOMI
				#if defined(PROP_RIM2MASK) || !defined(OPTIMIZER_ENABLED)
				float4 rim2MaskAndBias = POI2D_SAMPLER_PAN(_Rim2Mask, _MainTex, poiUV(poiMesh.uv[_Rim2MaskUV], _Rim2Mask_ST), _Rim2MaskPan);
				float rim2Mask = rim2MaskAndBias[_Rim2MaskChannel];
				float rim2Bias = rim2MaskAndBias.a;
				#else
				float rim2Mask = 1;
				float rim2Bias = 0;
				#endif
				
				if(_Rim2MaskInvert)
				{
					rim2Mask = 1 - rim2Mask;
				}
				
				#if defined(PROP_RIM2TEX) || !defined(OPTIMIZER_ENABLED)
				float4 rim2Color = POI2D_SAMPLER_PAN(_Rim2Tex, _MainTex, poiUV(poiMesh.uv[_Rim2TexUV], _Rim2Tex_ST), _Rim2TexPan);
				#else
				float4 rim2Color = 1;
				#endif
				half AudioLinkRim2WidthBand = 0;
				float2 AudioLinkRim2WidthAdd = 0;
				half AudioLinkRim2EmissionBand = 0;
				float2 AudioLinkRim2EmissionAdd = 0;
				half AudioLinkRim2BrightnessBand = 0;
				float2 AudioLinkRim2BrightnessAdd = 0;
				#ifdef POI_AUDIOLINK
				AudioLinkRim2WidthBand = _AudioLinkRim2WidthBand;
				AudioLinkRim2WidthAdd = _AudioLinkRim2WidthAdd;
				AudioLinkRim2EmissionBand = _AudioLinkRim2EmissionBand;
				AudioLinkRim2EmissionAdd = _AudioLinkRim2EmissionAdd;
				AudioLinkRim2BrightnessBand = _AudioLinkRim2BrightnessBand;
				AudioLinkRim2BrightnessAdd = _AudioLinkRim2BrightnessAdd;
				#endif
				ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Is_NormalMapToRim2Light, _Rim2LightingInvert, _Rim2Power, _Rim2Strength, _Rim2ShadowWidth, _Rim2ShadowToggle, _Rim2Width, _Rim2BlendStrength, rim2Mask, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, rim2Color, _Rim2LightColor, _Rim2LightColorThemeIndex, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Sharpness, _Rim2ShadowMaskRampType, _Rim2ShadowMaskInvert, _Rim2ShadowMaskStrength, _Rim2ShadowAlpha, _Rim2ApplyGlobalMaskIndex, _Rim2ApplyGlobalMaskBlendType, _Rim2BaseColorMix, _Rim2Brightness, _Rim2BlendMode, AudioLinkRim2WidthBand, AudioLinkRim2WidthAdd, AudioLinkRim2EmissionBand, AudioLinkRim2EmissionAdd, AudioLinkRim2BrightnessBand, AudioLinkRim2BrightnessAdd, _Rim2Clamp, rim2Bias, _Rim2BiasIntensity);
				#endif
				#ifdef _RIM2STYLE_UTS2
				#if defined(PROP_SET_RIM2LIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float Set_Rim2LightMask_var = POI2D_SAMPLER_PAN(_Set_Rim2LightMask, _MainTex, poiUV(poiMesh.uv[_Set_Rim2LightMaskUV], _Set_Rim2LightMask_ST), _Set_Rim2LightMaskPan)[_Set_Rim2LightMaskChannel];
				#else
				float Set_Rim2LightMask_var = 1;
				#endif
				ApplyUTS2RimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, Set_Rim2LightMask_var, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, _Rim2LightColor, _Rim2LightColorThemeIndex, _Is_LightColor_Rim2Light, _Is_NormalMapToRim2Light, _Rim2Light_Power, _Rim2Light_InsideMask, _Rim2Light_FeatherOff, _LightDirection_MaskOn2, _Tweak_LightDirection_MaskLevel2, _Add_Antipodean_Rim2Light, _Ap_Rim2LightColor, _Rim2ApColorThemeIndex, _Is_LightColor_Ap_Rim2Light, _Ap_Rim2Light_Power, _Ap_Rim2Light_FeatherOff, _Tweak_Rim2LightMaskLevel, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Clamp);
				#endif
				#ifdef _RIM2STYLE_LILTOON
				#if defined(PROP_RIM2COLORTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rim2ColorTex = POI2D_SAMPLER_PAN(_Rim2ColorTex, _MainTex, poiUV(poiMesh.uv[_Rim2ColorTexUV], _Rim2ColorTex_ST), _Rim2ColorTexPan);
				#else
				float4 rim2ColorTex = 1;
				#endif
				ApplyLiltoonRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Rim2Color, _Rim2IndirColor, rim2ColorTex, _Rim2MainStrength, _Rim2NormalStrength, _Rim2DirRange, _Rim2IndirRange, _Rim2FresnelPower, _Rim2BackfaceMask, _Rim2DirStrength, _Rim2Border, _Rim2Blur, _Rim2IndirBorder, _Rim2IndirBlur, _Rim2ShadowMask, _Rim2EnableLighting, _Rim2VRParallaxStrength, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Clamp);
				#endif
				#endif
				//endex
				
				//ifex _EnableDepthRimLighting==0
				#ifdef _POI_DEPTH_RIMLIGHT
				if (!IsInMirror())
				{
					ApplyDepthRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods);
				}
				#endif
				//endex
				
				//ifex _GlitterEnable==0
				#ifdef _SUNDISK_SIMPLE
				applyGlitter(poiFragData, poiMesh, poiCam, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _StylizedSpecular==0
				#ifdef POI_STYLIZED_StylizedSpecular
				stylizedSpecular(poiFragData, poiCam, poiLight, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnablePathing==0
				#ifdef POI_PATHING
				// Only run pathing if a map exists.
				#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
				applyPathing(poiFragData, poiMesh, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				applyMirror(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableIridescence==0
				#ifdef POI_IRIDESCENCE
				applyIridescence(poiFragData, poiMesh, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _TextEnabled==0
				#ifdef EFFECT_BUMP
				ApplyTextOverlayColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _PoiInternalParallax==0
				#ifdef POI_INTERNALPARALLAX
				applyInternalParallax(poiFragData, poiMesh, poiCam, poiMods);
				#endif
				//endex
				
				UNITY_BRANCH
				if (_AlphaPremultiply)
				{
					poiFragData.baseColor *= saturate(poiFragData.alpha);
				}
				poiFragData.finalColor = poiFragData.baseColor;
				
				poiFragData.finalColor = poiFragData.baseColor * poiLight.finalLighting;
				
				//ifex _SubsurfaceScattering==0
				#ifdef POI_SUBSURFACESCATTERING
				applySubsurfaceScattering(poiCam, poiLight, poiMesh);
				#endif
				//endex
				
				//ifex _MochieBRDF==0
				#ifdef MOCHIE_PBR
				MochieBRDF(poiFragData, poiCam, poiLight, poiMesh, poiMods);
				#endif
				//endex
				//ifex _ClearCoatBRDF==0
				#ifdef POI_CLEARCOAT
				poiClearCoat(poiFragData, poiCam, poiLight, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableEnvironmentalRim==0
				#ifdef POI_ENVIRORIM
				applyEnvironmentRim(poiFragData, poiMesh, poiCam);
				#endif
				//endex
				
				//ifex _EnableTouchGlow==0
				#ifdef GRAIN
				applyDepthFX(poiFragData, poiCam, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _BacklightEnabled!=1
				#ifdef POI_BACKLIGHT
				ApplyBacklight(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _FXProximityColor==0
				if (_FXProximityColor)
				{
					float3 position = _FXProximityColorType ? poiMesh.worldPos : poiMesh.objectPosition;
					poiFragData.finalColor *= lerp(poiThemeColor(poiMods, _FXProximityColorMinColor.rgb, _FXProximityColorMinColorThemeIndex), poiThemeColor(poiMods, _FXProximityColorMaxColor.rgb, _FXProximityColorMaxColorThemeIndex), smoothstep(_FXProximityColorMinDistance, _FXProximityColorMaxDistance, distance(position, poiCam.worldPos)));
					
					if (_FXProximityColorBackFace)
					{
						poiFragData.finalColor = lerp(poiFragData.finalColor * _FXProximityColorMinColor.rgb, poiFragData.finalColor, saturate(poiMesh.isFrontFace));
					}
				}
				//endex
				
				//ifex _EnableEmission==0 && _EnableEmission1==0 && _EnableEmission2==0 && _EnableEmission3==0
				#if defined(_EMISSION) || defined(POI_EMISSION_1) || defined(POI_EMISSION_2) || defined(POI_EMISSION_3)
				float3 emissionBaseReplace = 0;
				#endif
				//endex
				
				//ifex _EnableEmission==0
				#ifdef _EMISSION
				emissionBaseReplace += applyEmission(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				//ifex _EnableEmission1==0
				#ifdef POI_EMISSION_1
				emissionBaseReplace += applyEmission1(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				//ifex _EnableEmission2==0
				#ifdef POI_EMISSION_2
				emissionBaseReplace += applyEmission2(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				//ifex _EnableEmission3==0
				#ifdef POI_EMISSION_3
				emissionBaseReplace += applyEmission3(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _EnableEmission==0 && _EnableEmission1==0 && _EnableEmission2==0 && _EnableEmission3==0
				#if defined(_EMISSION) || defined(POI_EMISSION_1) || defined(POI_EMISSION_2) || defined(POI_EMISSION_3)
				poiFragData.finalColor.rgb = lerp(poiFragData.finalColor.rgb, saturate(emissionBaseReplace), poiMax(emissionBaseReplace));
				#endif
				//endex
				
				//UNITY_BRANCH
				if (_IgnoreFog == 0)
				{
					UNITY_APPLY_FOG(i.fogCoord, poiFragData.finalColor);
				}
				
				poiFragData.alpha = _AlphaForceOpaque ? 1 : poiFragData.alpha;
				
				//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
				ApplyAlphaToCoverage(poiFragData, poiMesh);
				//endex
				
				//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
				applyDithering(poiFragData, poiCam);
				//endex
				
				poiFragData.finalColor += poiLight.finalLightAdd;
				
				#ifdef UNITY_PASS_FORWARDBASE
				poiFragData.emission = max(poiFragData.emission * _PPEmissionMultiplier, 0);
				poiFragData.finalColor = max(poiFragData.finalColor * _PPFinalColorMultiplier, 0);
				#endif
				
				//ifex _PostProcess==0
				#ifdef POSTPROCESS
				applyPostProcessing(poiFragData, poiMesh);
				#endif
				//endex
				
				if (_Mode == POI_MODE_OPAQUE)
				{
					poiFragData.alpha = 1;
				}
				
				clip(poiFragData.alpha - _Cutoff);
				
				if (_Mode == POI_MODE_CUTOUT && !_AlphaToCoverage)
				{
					poiFragData.alpha = 1;
				}
				
				return float4(poiFragData.finalColor + poiFragData.emission * poiMods.globalEmission, poiFragData.alpha) + POI_SAFE_RGB0;
			}
			
			ENDCG
		}
		
		Pass
		{
			Tags { "LightMode" = "ForwardAdd" }
			
			Stencil
			{
				Ref [_StencilRef]
				ReadMask [_StencilReadMask]
				WriteMask [_StencilWriteMask]
				//ifex _StencilType==1
				Comp [_StencilCompareFunction]
				Pass [_StencilPassOp]
				Fail [_StencilFailOp]
				ZFail [_StencilZFailOp]
				//endex
				
				//ifex _StencilType==0
				CompBack [_StencilBackCompareFunction]
				PassBack [_StencilBackPassOp]
				FailBack [_StencilBackFailOp]
				ZFailBack [_StencilBackZFailOp]
				
				CompFront [_StencilFrontCompareFunction]
				PassFront [_StencilFrontPassOp]
				FailFront [_StencilFrontFailOp]
				ZFailFront [_StencilFrontZFailOp]
				//endex
			}
			
			ZWrite Off
			Cull [_Cull]
			
			AlphaToMask [_AlphaToCoverage]
			ZTest [_ZTest]
			ColorMask [_ColorMask]
			Offset [_OffsetFactor], [_OffsetUnits]
			
			BlendOp [_AddBlendOp], [_AddBlendOpAlpha]
			Blend [_AddSrcBlend] [_AddDstBlend], [_AddSrcBlendAlpha] [_AddDstBlendAlpha]
			
			CGPROGRAM
			/*
			// Disable warnings we aren't interested in
			#if defined(UNITY_COMPILER_HLSL)
			#pragma warning(disable : 3205) // conversion of larger type to smaller
			#pragma warning(disable : 3568) // unknown pragma ignored
			#pragma warning(disable : 3571) // "pow(f,e) will not work for negative f"; however in majority of our calls to pow we know f is not negative
			#pragma warning(disable : 3206) // implicit truncation of vector type
			#endif
			*/
			#pragma target 5.0
			
			#pragma shader_feature_local _STOCHASTICMODE_DELIOT_HEITZ _STOCHASTICMODE_HEXTILE _STOCHASTICMODE_NONE
			
			//ifex _MainColorAdjustToggle==0
			#pragma shader_feature COLOR_GRADING_HDR
			//endex
			
			//#pragma shader_feature KEYWORD
			
			//ifex _GlobalMaskTexturesEnable==0
			#pragma shader_feature_local POI_GLOBALMASK_TEXTURES
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#pragma shader_feature_local POI_UDIMDISCARD
			//endex
			
			//ifex _EnableDistortion==0
			#pragma shader_feature USER_LUT
			//endex
			
			//ifex _PoiParallax==0
			#pragma shader_feature_local POI_PARALLAX
			//endex
			
			//ifex _EnableAudioLink==0
			#pragma shader_feature_local POI_AUDIOLINK
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#pragma shader_feature_local POI_BLACKLIGHTMASKING
			//endex
			
			//ifex _DetailEnabled==0
			#pragma shader_feature FINALPASS
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#pragma shader_feature AUTO_EXPOSURE
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#pragma shader_feature_local POI_VERTEX_GLITCHING
			#pragma shader_feature_local POI_VERTEX_GLITCHING_TEXTURE
			//endex
			
			//ifex _EnableDepthBulge==0
			#pragma shader_feature_local POI_DEPTHBULGE
			//endex
			
			//ifex _BackFaceEnabled!=1
			#pragma shader_feature_local POI_BACKFACE
			//endex
			
			//ifex _RGBMaskEnabled==0
			#pragma shader_feature VIGNETTE
			#pragma shader_feature GEOM_TYPE_MESH
			//endex
			
			//ifex _DecalEnabled==0
			#pragma shader_feature GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#pragma shader_feature GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#pragma shader_feature GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#pragma shader_feature DEPTH_OF_FIELD_COC_VIEW
			//endex
			
			//ifex _EnableDissolve==0
			#pragma shader_feature DISTORT
			//endex
			
			//ifex _ShadingEnabled==0
			#pragma shader_feature_local VIGNETTE_MASKED
			#pragma shader_feature_local _LIGHTINGMODE_TEXTURERAMP _LIGHTINGMODE_MULTILAYER_MATH _LIGHTINGMODE_SHADEMAP _LIGHTINGMODE_REALISTIC _LIGHTINGMODE_WRAPPED _LIGHTINGMODE_SKIN _LIGHTINGMODE_FLAT _LIGHTINGMODE_CLOTH _LIGHTINGMODE_SDF
			//endex
			
			//ifex _EnableAniso==0
			#pragma shader_feature_local POI_ANISOTROPICS
			//endex
			
			//ifex _MatcapEnable==0
			#pragma shader_feature_local POI_MATCAP0
			#pragma shader_feature_local POI_MATCAP0_CUSTOM_NORMAL
			//endex
			//ifex _Matcap2Enable==0
			#pragma shader_feature COLOR_GRADING_HDR_3D
			#pragma shader_feature_local POI_MATCAP1_CUSTOM_NORMAL
			//endex
			//ifex _Matcap3Enable==0
			#pragma shader_feature_local POI_MATCAP2
			#pragma shader_feature_local POI_MATCAP2_CUSTOM_NORMAL
			//endex
			//ifex _Matcap4Enable==0
			#pragma shader_feature_local POI_MATCAP3
			#pragma shader_feature_local POI_MATCAP3_CUSTOM_NORMAL
			//endex
			
			//ifex _CubeMapEnabled==0
			#pragma shader_feature_local _CUBEMAP
			//endex
			
			//ifex _EnableALDecal==0
			#pragma shader_feature_local POI_AL_DECAL
			//endex
			
			//ifex _EnableVolumeColor==0
			#pragma shader_feature_local POI_AL_VOLUMECOLOR
			//endex
			
			//ifex _EnableFlipbook==0
			#pragma shader_feature _SUNDISK_HIGH_QUALITY
			//endex
			
			//ifex _EnableEmission==0
			#pragma shader_feature _EMISSION
			//endex
			//ifex _EnableEmission1==0
			#pragma shader_feature_local POI_EMISSION_1
			//endex
			//ifex _EnableEmission2==0
			#pragma shader_feature_local POI_EMISSION_2
			//endex
			//ifex _EnableEmission3==0
			#pragma shader_feature_local POI_EMISSION_3
			//endex
			
			//ifex _EnableRimLighting==0
			#pragma shader_feature_local _GLOSSYREFLECTIONS_OFF
			#pragma shader_feature_local _RIMSTYLE_POIYOMI _RIMSTYLE_UTS2 _RIMSTYLE_LILTOON
			//endex
			//ifex _EnableRim2Lighting==0
			#pragma shader_feature_local POI_RIM2
			#pragma shader_feature_local _RIM2STYLE_POIYOMI _RIM2STYLE_UTS2 _RIM2STYLE_LILTOON
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#pragma shader_feature_local _POI_DEPTH_RIMLIGHT
			//endex
			
			//ifex _GlitterEnable==0
			#pragma shader_feature _SUNDISK_SIMPLE
			//endex
			
			//ifex _SubsurfaceScattering==0
			#pragma shader_feature_local POI_SUBSURFACESCATTERING
			//endex
			
			//ifex _MochieBRDF==0
			#pragma shader_feature_local MOCHIE_PBR
			//endex
			//ifex _ClearCoatBRDF==0
			#pragma shader_feature_local POI_CLEARCOAT
			//endex
			
			//ifex _EnableEnvironmentalRim==0
			#pragma shader_feature_local POI_ENVIRORIM
			//endex
			
			//ifex _StylizedSpecular==0
			#pragma shader_feature_local POI_STYLIZED_StylizedSpecular
			//endex
			
			//ifex _EnablePathing==0
			#pragma shader_feature_local POI_PATHING
			//endex
			
			//ifex _EnableMirrorOptions==0
			#pragma shader_feature_local POI_MIRROR
			//endex
			
			//ifex _EnableTouchGlow==0
			#pragma shader_feature GRAIN
			//endex
			
			//ifex _EnableIridescence==0
			#pragma shader_feature_local POI_IRIDESCENCE
			//endex
			
			//ifex _TextEnabled==0
			#pragma shader_feature EFFECT_BUMP
			//endex
			
			//ifex _PostProcess==0
			#pragma shader_feature_local POSTPROCESS
			//endex
			
			//ifex _PoiInternalParallax==0
			#pragma shader_feature_local POI_INTERNALPARALLAX
			//endex
			
			//ifex _NormalCorrect==0
			#pragma shader_feature_local POI_NORMALCORRECT
			//endex
			
			//ifex _BacklightEnabled!=1
			#pragma shader_feature_local POI_BACKLIGHT
			//endex
			
			#pragma multi_compile_fwdadd_fullshadows
			#pragma multi_compile_instancing
			#pragma multi_compile_fog
			#define POI_PASS_ADD
			
			#define POI_WORLD
			
			// UNITY Includes
			#include "UnityCG.cginc"
			#include "UnityStandardUtils.cginc"
			#include "AutoLight.cginc"
			#include "UnityLightingCommon.cginc"
			#include "UnityPBSLighting.cginc"
			#ifdef POI_PASS_META
			#include "UnityMetaPass.cginc"
			#endif
			#pragma vertex vert
			
			#pragma fragment frag
			
			#define DielectricSpec float4(0.04, 0.04, 0.04, 1.0 - 0.04)
			#define PI float(3.14159265359)
			
			#define POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex,samplertex,coord,dx,dy) tex.SampleGrad (sampler##samplertex,coord,dx,dy)
			
			#define POI_PAN_UV(uv, pan) (uv + _Time.x * pan)
			#define POI2D_SAMPLER_PAN(tex, texSampler, uv, pan) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, POI_PAN_UV(uv, pan)))
			#define POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, POI_PAN_UV(uv, pan), dx, dy))
			#define POI2D_SAMPLER(tex, texSampler, uv) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_GRAD(tex, texSampler, uv, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, uv, dx, dy))
			#define POI2D_PAN(tex, uv, pan) (tex2D(tex, POI_PAN_UV(uv, pan)))
			#define POI2D(tex, uv) (tex2D(tex, uv))
			#define POI_SAMPLE_TEX2D(tex, uv) (UNITY_SAMPLE_TEX2D(tex, uv))
			#define POI_SAMPLE_TEX2D_PAN(tex, uv, pan) (UNITY_SAMPLE_TEX2D(tex, POI_PAN_UV(uv, pan)))
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_MAINTEX_SAMPLER_PAN_INLINED(tex, poiMesh) (POI2D_SAMPLER_PAN(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan))
			
			#define POI_SAFE_RGB0 float4(mainTexture.rgb * .0001, 0)
			#define POI_SAFE_RGB1 float4(mainTexture.rgb * .0001, 1)
			#define POI_SAFE_RGBA mainTexture
			
			#if defined(UNITY_COMPILER_HLSL)
			#define PoiInitStruct(type, name) name = (type)0;
			#else
			#define PoiInitStruct(type, name)
			#endif
			
			#define POI_ERROR(poiMesh, gridSize) lerp(float3(1, 0, 1), float3(0, 0, 0), fmod(floor((poiMesh.worldPos.x) * gridSize) + floor((poiMesh.worldPos.y) * gridSize) + floor((poiMesh.worldPos.z) * gridSize), 2) == 0)
			#define POI_NAN (asfloat(-1))
			
			#define POI_MODE_OPAQUE 0
			#define POI_MODE_CUTOUT 1
			#define POI_MODE_FADE 2
			#define POI_MODE_TRANSPARENT 3
			#define POI_MODE_ADDITIVE 4
			#define POI_MODE_SOFTADDITIVE 5
			#define POI_MODE_MULTIPLICATIVE 6
			#define POI_MODE_2XMULTIPLICATIVE 7
			#define POI_MODE_TRANSCLIPPING 9
			
			/*
			Texture2D ;
			float4 _ST;
			float2 Pan;
			float UV;
			float Stochastic;
			
			[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7 )]
			*/
			
			#define POI_DECLARETEX_ST_UV(tex) float4 tex##_ST; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN_STOCHASTIC(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV; float tex##Stochastic;
			//ifex _EnableAudioLink==0
			// Map of where features in AudioLink are.
			#define ALPASS_DFT                      uint2(0,4)   //Size: 128, 2
			#define ALPASS_WAVEFORM                 uint2(0,6)   //Size: 128, 16
			#define ALPASS_AUDIOLINK                uint2(0,0)   //Size: 128, 4
			#define ALPASS_AUDIOBASS                uint2(0,0)   //Size: 128, 1
			#define ALPASS_AUDIOLOWMIDS             uint2(0,1)   //Size: 128, 1
			#define ALPASS_AUDIOHIGHMIDS            uint2(0,2)   //Size: 128, 1
			#define ALPASS_AUDIOTREBLE              uint2(0,3)   //Size: 128, 1
			#define ALPASS_AUDIOLINKHISTORY         uint2(1,0)   //Size: 127, 4
			#define ALPASS_GENERALVU                uint2(0,22)  //Size: 12, 1
			#define ALPASS_CCINTERNAL               uint2(12,22) //Size: 12, 2
			#define ALPASS_CCCOLORS                 uint2(25,22) //Size: 11, 1
			#define ALPASS_CCSTRIP                  uint2(0,24)  //Size: 128, 1
			#define ALPASS_CCLIGHTS                 uint2(0,25)  //Size: 128, 2
			#define ALPASS_AUTOCORRELATOR           uint2(0,27)  //Size: 128, 1
			#define ALPASS_GENERALVU_INSTANCE_TIME  uint2(2,22)
			#define ALPASS_GENERALVU_LOCAL_TIME     uint2(3,22)
			#define ALPASS_GENERALVU_NETWORK_TIME   uint2(4,22)
			#define ALPASS_GENERALVU_PLAYERINFO     uint2(6,22)
			// Added in version 2.5
			#define ALPASS_FILTEREDAUDIOLINK        uint2(0,28)  //Size: 16, 4
			// Added in version 2.6
			#define ALPASS_CHRONOTENSITY            uint2(16,28) //Size: 8, 4
			#define ALPASS_THEME_COLOR0             uint2(0,23)
			#define ALPASS_THEME_COLOR1             uint2(1,23)
			#define ALPASS_THEME_COLOR2             uint2(2,23)
			#define ALPASS_THEME_COLOR3             uint2(3,23)
			#define ALPASS_FILTEREDVU               uint2(24,28) //Size: 4, 4
			#define ALPASS_FILTEREDVU_INTENSITY     uint2(24,28) //Size: 4, 1
			#define ALPASS_FILTEREDVU_MARKER        uint2(24,29) //Size: 4, 1
			
			// Some basic constants to use (Note, these should be compatible with
			// future version of AudioLink, but may change.
			#define AUDIOLINK_SAMPHIST              3069        // Internal use for algos, do not change.
			#define AUDIOLINK_SAMPLEDATA24          2046
			#define AUDIOLINK_EXPBINS               24
			#define AUDIOLINK_EXPOCT                10
			#define AUDIOLINK_ETOTALBINS (AUDIOLINK_EXPBINS * AUDIOLINK_EXPOCT)
			#define AUDIOLINK_WIDTH                 128
			#define AUDIOLINK_SPS                   48000       // Samples per second
			#define AUDIOLINK_ROOTNOTE              0
			#define AUDIOLINK_4BAND_FREQFLOOR       0.123
			#define AUDIOLINK_4BAND_FREQCEILING     1
			#define AUDIOLINK_BOTTOM_FREQUENCY      13.75
			#define AUDIOLINK_BASE_AMPLITUDE        2.5
			#define AUDIOLINK_DELAY_COEFFICIENT_MIN 0.3
			#define AUDIOLINK_DELAY_COEFFICIENT_MAX 0.9
			#define AUDIOLINK_DFT_Q                 4.0
			#define AUDIOLINK_TREBLE_CORRECTION     5.0
			
			// ColorChord constants
			#define COLORCHORD_EMAXBIN              192
			#define COLORCHORD_IIR_DECAY_1          0.90
			#define COLORCHORD_IIR_DECAY_2          0.85
			#define COLORCHORD_CONSTANT_DECAY_1     0.01
			#define COLORCHORD_CONSTANT_DECAY_2     0.0
			#define COLORCHORD_NOTE_CLOSEST         3.0
			#define COLORCHORD_NEW_NOTE_GAIN        8.0
			#define COLORCHORD_MAX_NOTES            10
			
			uniform float4               _AudioTexture_TexelSize;
			
			#ifdef SHADER_TARGET_SURFACE_ANALYSIS
			#define AUDIOLINK_STANDARD_INDEXING
			#endif
			
			// Mechanism to index into texture.
			#ifdef AUDIOLINK_STANDARD_INDEXING
			sampler2D _AudioTexture;
			#define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, float4(uint2(xycoord) * _AudioTexture_TexelSize.xy, 0, 0))
			#else
			uniform Texture2D<float4> _AudioTexture;
			SamplerState sampler_AudioTexture;
			#define AudioLinkData(xycoord) _AudioTexture[uint2(xycoord)]
			#endif
			uniform sampler2D _Stored;
			uniform float4 _Stored_TexelSize;
			#define LumaData(x,y) tex2Dlod(_Stored, float4(x, y, 0, 0))
			//endex
			
			float _Mode;
			
			float _StochasticDeliotHeitzDensity;
			float _StochasticHexGridDensity;
			float _StochasticHexRotationStrength;
			float _StochasticHexFallOffContrast;
			float _StochasticHexFallOffPower;
			
			#if defined(PROP_LIGHTINGAOMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _LightingAOMaps;
			#endif
			float4 _LightingAOMaps_ST;
			float2 _LightingAOMapsPan;
			float _LightingAOMapsUV;
			float _LightDataAOStrengthR;
			float _LightDataAOStrengthG;
			float _LightDataAOStrengthB;
			float _LightDataAOStrengthA;
			float _LightDataAOGlobalMaskR;
			float _LightDataAOGlobalMaskBlendTypeR;
			
			#if defined(PROP_LIGHTINGDETAILSHADOWMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _LightingDetailShadowMaps;
			#endif
			float4 _LightingDetailShadowMaps_ST;
			float2 _LightingDetailShadowMapsPan;
			float _LightingDetailShadowMapsUV;
			float _LightingDetailShadowStrengthR;
			float _LightingDetailShadowStrengthG;
			float _LightingDetailShadowStrengthB;
			float _LightingDetailShadowStrengthA;
			float _LightingAddDetailShadowStrengthR;
			float _LightingAddDetailShadowStrengthG;
			float _LightingAddDetailShadowStrengthB;
			float _LightingAddDetailShadowStrengthA;
			float _LightDataDetailShadowGlobalMaskR;
			float _LightDataDetailShadowGlobalMaskBlendTypeR;
			
			#if defined(PROP_LIGHTINGSHADOWMASKS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _LightingShadowMasks;
			#endif
			float4 _LightingShadowMasks_ST;
			float2 _LightingShadowMasksPan;
			float _LightingShadowMasksUV;
			float _LightingShadowMaskStrengthR;
			float _LightingShadowMaskStrengthG;
			float _LightingShadowMaskStrengthB;
			float _LightingShadowMaskStrengthA;
			float _LightDataShadowMaskGlobalMaskR;
			float _LightDataShadowMaskGlobalMaskBlendTypeR;
			
			// Lighting Data
			float _Unlit_Intensity;
			float _LightingColorMode;
			float _LightingMapMode;
			float _LightingDirectionMode;
			float3 _LightngForcedDirection;
			float _LightingIndirectUsesNormals;
			float _LightingCapEnabled;
			float _LightingCap;
			float _LightingForceColorEnabled;
			float3 _LightingForcedColor;
			float _LightingForcedColorThemeIndex;
			float _LightingCastedShadows;
			float _LightingMonochromatic;
			float _LightingMinLightBrightness;
			// Additive Lighting Data
			float _LightingAdditiveEnable;
			float _LightingAdditiveLimited;
			float _LightingAdditiveLimit;
			float _LightingAdditiveCastedShadows;
			float _LightingAdditiveMonochromatic;
			float _LightingAdditivePassthrough;
			float _DisableDirectionalInAdd;
			float _LightingVertexLightingEnabled;
			// Lighting Data Debug
			float _LightDataDebugEnabled;
			float _LightingDebugVisualize;
			
			float _IgnoreFog;
			float _RenderingReduceClipDistance;
			float _AddBlendOp;
			
			float4 _Color;
			float _ColorThemeIndex;
			UNITY_DECLARE_TEX2D(_MainTex);
			UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);
			float _MainPixelMode;
			float4 _MainTex_ST;
			float2 _MainTexPan;
			float _MainTexUV;
			float4 _MainTex_TexelSize;
			float _MainTexStochastic;
			#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BumpMap;
			#endif
			float4 _BumpMap_ST;
			float2 _BumpMapPan;
			float _BumpMapUV;
			float _BumpScale;
			float _BumpMapStochastic;
			Texture2D _ClippingMask;
			float4 _ClippingMask_ST;
			float2 _ClippingMaskPan;
			float _ClippingMaskUV;
			float _Inverse_Clipping;
			float _Cutoff;
			//ifex _MainColorAdjustToggle==0
			float _MainColorAdjustToggle;
			#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MainColorAdjustTexture;
			#endif
			float4 _MainColorAdjustTexture_ST;
			float2 _MainColorAdjustTexturePan;
			float _MainColorAdjustTextureUV;
			float _MainHueShiftToggle;
			float _MainHueShiftReplace;
			float _MainHueShift;
			float _MainHueShiftSpeed;
			float _Saturation;
			float _MainBrightness;
			
			float _MainHueALCTEnabled;
			float _MainALHueShiftBand;
			float _MainALHueShiftCTIndex;
			float _MainHueALMotionSpeed;
			
			float _MainHueGlobalMask;
			float _MainHueGlobalMaskBlendType;
			float _MainSaturationGlobalMask;
			float _MainSaturationGlobalMaskBlendType;
			float _MainBrightnessGlobalMask;
			float _MainBrightnessGlobalMaskBlendType;
			//endex
			
			SamplerState sampler_linear_clamp;
			SamplerState sampler_linear_repeat;
			
			float _AlphaForceOpaque;
			float _AlphaMod;
			float _AlphaPremultiply;
			float _AlphaBoostFA;
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			float _AlphaToCoverage;
			float _AlphaSharpenedA2C;
			float _AlphaMipScale;
			//endex
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			float _AlphaDithering;
			float _AlphaDitherGradient;
			float _AlphaDitherBias;
			//endex
			
			//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
			float _AlphaDistanceFade;
			float _AlphaDistanceFadeType;
			float _AlphaDistanceFadeMinAlpha;
			float _AlphaDistanceFadeMaxAlpha;
			float _AlphaDistanceFadeMin;
			float _AlphaDistanceFadeMax;
			float _AlphaDistanceFadeGlobalMask;
			float _AlphaDistanceFadeGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
			float _AlphaFresnel;
			float _AlphaFresnelAlpha;
			float _AlphaFresnelSharpness;
			float _AlphaFresnelWidth;
			float _AlphaFresnelInvert;
			float _AlphaFresnelGlobalMask;
			float _AlphaFresnelGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
			float _AlphaAngular;
			float _AngleType;
			float _AngleCompareTo;
			float3 _AngleForwardDirection;
			float _CameraAngleMin;
			float _CameraAngleMax;
			float _ModelAngleMin;
			float _ModelAngleMax;
			float _AngleMinAlpha;
			float _AlphaAngularGlobalMask;
			float _AlphaAngularGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
			float _AlphaAudioLinkEnabled;
			float2 _AlphaAudioLinkAddRange;
			float _AlphaAudioLinkAddBand;
			//endex
			
			float _AlphaGlobalMask;
			float _AlphaGlobalMaskBlendType;
			
			float4 _GlobalThemeColor0;
			float4 _GlobalThemeColor1;
			float4 _GlobalThemeColor2;
			float4 _GlobalThemeColor3;
			float _GlobalThemeHue0;
			float _GlobalThemeHue1;
			float _GlobalThemeHue2;
			float _GlobalThemeHue3;
			float _GlobalThemeHueSpeed0;
			float _GlobalThemeHueSpeed1;
			float _GlobalThemeHueSpeed2;
			float _GlobalThemeHueSpeed3;
			float _GlobalThemeSaturation0;
			float _GlobalThemeSaturation1;
			float _GlobalThemeSaturation2;
			float _GlobalThemeSaturation3;
			float _GlobalThemeValue0;
			float _GlobalThemeValue1;
			float _GlobalThemeValue2;
			float _GlobalThemeValue3;
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture0;
			#endif
			float4 _GlobalMaskTexture0_ST;
			float2 _GlobalMaskTexture0Pan;
			float _GlobalMaskTexture0UV;
			int _GlobalMaskTexture0Split;
			float4 _GlobalMaskTexture0SplitTilingOffset_G;
			float4 _GlobalMaskTexture0SplitPan_G;
			float4 _GlobalMaskTexture0SplitTilingOffset_B;
			float4 _GlobalMaskTexture0SplitPan_B;
			float4 _GlobalMaskTexture0SplitTilingOffset_A;
			float4 _GlobalMaskTexture0SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture1;
			#endif
			float4 _GlobalMaskTexture1_ST;
			float2 _GlobalMaskTexture1Pan;
			float _GlobalMaskTexture1UV;
			int _GlobalMaskTexture1Split;
			float4 _GlobalMaskTexture1SplitTilingOffset_G;
			float4 _GlobalMaskTexture1SplitPan_G;
			float4 _GlobalMaskTexture1SplitTilingOffset_B;
			float4 _GlobalMaskTexture1SplitPan_B;
			float4 _GlobalMaskTexture1SplitTilingOffset_A;
			float4 _GlobalMaskTexture1SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture2;
			#endif
			float4 _GlobalMaskTexture2_ST;
			float2 _GlobalMaskTexture2Pan;
			float _GlobalMaskTexture2UV;
			int _GlobalMaskTexture2Split;
			float4 _GlobalMaskTexture2SplitTilingOffset_G;
			float4 _GlobalMaskTexture2SplitPan_G;
			float4 _GlobalMaskTexture2SplitTilingOffset_B;
			float4 _GlobalMaskTexture2SplitPan_B;
			float4 _GlobalMaskTexture2SplitTilingOffset_A;
			float4 _GlobalMaskTexture2SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture3;
			#endif
			float4 _GlobalMaskTexture3_ST;
			float2 _GlobalMaskTexture3Pan;
			float _GlobalMaskTexture3UV;
			int _GlobalMaskTexture3Split;
			float4 _GlobalMaskTexture3SplitTilingOffset_G;
			float4 _GlobalMaskTexture3SplitPan_G;
			float4 _GlobalMaskTexture3SplitTilingOffset_B;
			float4 _GlobalMaskTexture3SplitPan_B;
			float4 _GlobalMaskTexture3SplitTilingOffset_A;
			float4 _GlobalMaskTexture3SplitPan_A;
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			float _GlobalMaskOptionsEnable;
			int _GlobalMaskOptionsType;
			
			//ifex _GlobalMaskOptionsType!=0
			float _GlobalMaskSlider_0;
			float _GlobalMaskSlider_1;
			float _GlobalMaskSlider_2;
			float _GlobalMaskSlider_3;
			float _GlobalMaskSlider_4;
			float _GlobalMaskSlider_5;
			float _GlobalMaskSlider_6;
			float _GlobalMaskSlider_7;
			float _GlobalMaskSlider_8;
			float _GlobalMaskSlider_9;
			float _GlobalMaskSlider_10;
			float _GlobalMaskSlider_11;
			float _GlobalMaskSlider_12;
			float _GlobalMaskSlider_13;
			float _GlobalMaskSlider_14;
			float _GlobalMaskSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=1
			float2 _GlobalMaskMinMaxSlider_0;
			float2 _GlobalMaskMinMaxSlider_1;
			float2 _GlobalMaskMinMaxSlider_2;
			float2 _GlobalMaskMinMaxSlider_3;
			float2 _GlobalMaskMinMaxSlider_4;
			float2 _GlobalMaskMinMaxSlider_5;
			float2 _GlobalMaskMinMaxSlider_6;
			float2 _GlobalMaskMinMaxSlider_7;
			float2 _GlobalMaskMinMaxSlider_8;
			float2 _GlobalMaskMinMaxSlider_9;
			float2 _GlobalMaskMinMaxSlider_10;
			float2 _GlobalMaskMinMaxSlider_11;
			float2 _GlobalMaskMinMaxSlider_12;
			float2 _GlobalMaskMinMaxSlider_13;
			float2 _GlobalMaskMinMaxSlider_14;
			float2 _GlobalMaskMinMaxSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=2
			int  _GlobalMaskToggleOn_0;
			int _GlobalMaskToggleOff_0;
			int  _GlobalMaskToggleOn_1;
			int _GlobalMaskToggleOff_1;
			int  _GlobalMaskToggleOn_2;
			int _GlobalMaskToggleOff_2;
			int  _GlobalMaskToggleOn_3;
			int _GlobalMaskToggleOff_3;
			int  _GlobalMaskToggleOn_4;
			int _GlobalMaskToggleOff_4;
			int  _GlobalMaskToggleOn_5;
			int _GlobalMaskToggleOff_5;
			int  _GlobalMaskToggleOn_6;
			int _GlobalMaskToggleOff_6;
			int  _GlobalMaskToggleOn_7;
			int _GlobalMaskToggleOff_7;
			int  _GlobalMaskToggleOn_8;
			int _GlobalMaskToggleOff_8;
			int  _GlobalMaskToggleOn_9;
			int _GlobalMaskToggleOff_9;
			int  _GlobalMaskToggleOn_10;
			int _GlobalMaskToggleOff_10;
			int  _GlobalMaskToggleOn_11;
			int _GlobalMaskToggleOff_11;
			int  _GlobalMaskToggleOn_12;
			int _GlobalMaskToggleOff_12;
			int  _GlobalMaskToggleOn_13;
			int _GlobalMaskToggleOff_13;
			int  _GlobalMaskToggleOn_14;
			int _GlobalMaskToggleOff_14;
			int  _GlobalMaskToggleOn_15;
			int _GlobalMaskToggleOff_15;
			//endex
			//endex
			//ifex _GlobalMaskModifiersBackfaceEnable==0
			float _GlobalMaskModifiersBackfaceEnable;
			float _GlobalMaskBackface_0;
			float _GlobalMaskBackface_1;
			float _GlobalMaskBackface_2;
			float _GlobalMaskBackface_3;
			float _GlobalMaskBackface_4;
			float _GlobalMaskBackface_5;
			float _GlobalMaskBackface_6;
			float _GlobalMaskBackface_7;
			float _GlobalMaskBackface_8;
			float _GlobalMaskBackface_9;
			float _GlobalMaskBackface_10;
			float _GlobalMaskBackface_11;
			float _GlobalMaskBackface_12;
			float _GlobalMaskBackface_13;
			float _GlobalMaskBackface_14;
			float _GlobalMaskBackface_15;
			//endex
			
			//ifex _GlobalMaskModifiersMirrorEnable==0
			float _GlobalMaskModifiersMirrorEnable;
			float _GlobalMaskMirrorVisibilityMode;
			float _GlobalMaskMirror_0;
			float _GlobalMaskMirror_1;
			float _GlobalMaskMirror_2;
			float _GlobalMaskMirror_3;
			float _GlobalMaskMirror_4;
			float _GlobalMaskMirror_5;
			float _GlobalMaskMirror_6;
			float _GlobalMaskMirror_7;
			float _GlobalMaskMirror_8;
			float _GlobalMaskMirror_9;
			float _GlobalMaskMirror_10;
			float _GlobalMaskMirror_11;
			float _GlobalMaskMirror_12;
			float _GlobalMaskMirror_13;
			float _GlobalMaskMirror_14;
			float _GlobalMaskMirror_15;
			//endex
			
			//ifex _GlobalMaskModifiersCameraEnable==0
			float _GlobalMaskModifiersCameraEnable;
			float _GlobalMaskCamera_0;
			float _GlobalMaskCamera_1;
			float _GlobalMaskCamera_2;
			float _GlobalMaskCamera_3;
			float _GlobalMaskCamera_4;
			float _GlobalMaskCamera_5;
			float _GlobalMaskCamera_6;
			float _GlobalMaskCamera_7;
			float _GlobalMaskCamera_8;
			float _GlobalMaskCamera_9;
			float _GlobalMaskCamera_10;
			float _GlobalMaskCamera_11;
			float _GlobalMaskCamera_12;
			float _GlobalMaskCamera_13;
			float _GlobalMaskCamera_14;
			float _GlobalMaskCamera_15;
			//endex
			
			//ifex _GlobalMaskModifiersDistanceEnable==0
			int _GlobalMaskModifiersDistanceEnable;
			
			//ifex _GlobalMaskDistanceEnable_0==0
			int _GlobalMaskDistanceEnable_0;
			int _GlobalMaskDistanceType_0;
			float _GlobalMaskDistanceMin_0;
			float _GlobalMaskDistanceMax_0;
			float _GlobalMaskDistanceMinAlpha_0;
			float _GlobalMaskDistanceMaxAlpha_0;
			int _GlobalMaskDistanceBlendType_0;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_1==0
			int _GlobalMaskDistanceEnable_1;
			int _GlobalMaskDistanceType_1;
			float _GlobalMaskDistanceMin_1;
			float _GlobalMaskDistanceMax_1;
			float _GlobalMaskDistanceMinAlpha_1;
			float _GlobalMaskDistanceMaxAlpha_1;
			int _GlobalMaskDistanceBlendType_1;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_2==0
			int _GlobalMaskDistanceEnable_2;
			int _GlobalMaskDistanceType_2;
			float _GlobalMaskDistanceMin_2;
			float _GlobalMaskDistanceMax_2;
			float _GlobalMaskDistanceMinAlpha_2;
			float _GlobalMaskDistanceMaxAlpha_2;
			int _GlobalMaskDistanceBlendType_2;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_3==0
			int _GlobalMaskDistanceEnable_3;
			int _GlobalMaskDistanceType_3;
			float _GlobalMaskDistanceMin_3;
			float _GlobalMaskDistanceMax_3;
			float _GlobalMaskDistanceMinAlpha_3;
			float _GlobalMaskDistanceMaxAlpha_3;
			int _GlobalMaskDistanceBlendType_3;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_4==0
			int _GlobalMaskDistanceEnable_4;
			int _GlobalMaskDistanceType_4;
			float _GlobalMaskDistanceMin_4;
			float _GlobalMaskDistanceMax_4;
			float _GlobalMaskDistanceMinAlpha_4;
			float _GlobalMaskDistanceMaxAlpha_4;
			int _GlobalMaskDistanceBlendType_4;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_5==0
			int _GlobalMaskDistanceEnable_5;
			int _GlobalMaskDistanceType_5;
			float _GlobalMaskDistanceMin_5;
			float _GlobalMaskDistanceMax_5;
			float _GlobalMaskDistanceMinAlpha_5;
			float _GlobalMaskDistanceMaxAlpha_5;
			int _GlobalMaskDistanceBlendType_5;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_6==0
			int _GlobalMaskDistanceEnable_6;
			int _GlobalMaskDistanceType_6;
			float _GlobalMaskDistanceMin_6;
			float _GlobalMaskDistanceMax_6;
			float _GlobalMaskDistanceMinAlpha_6;
			float _GlobalMaskDistanceMaxAlpha_6;
			int _GlobalMaskDistanceBlendType_6;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_7==0
			int _GlobalMaskDistanceEnable_7;
			int _GlobalMaskDistanceType_7;
			float _GlobalMaskDistanceMin_7;
			float _GlobalMaskDistanceMax_7;
			float _GlobalMaskDistanceMinAlpha_7;
			float _GlobalMaskDistanceMaxAlpha_7;
			int _GlobalMaskDistanceBlendType_7;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_8==0
			int _GlobalMaskDistanceEnable_8;
			int _GlobalMaskDistanceType_8;
			float _GlobalMaskDistanceMin_8;
			float _GlobalMaskDistanceMax_8;
			float _GlobalMaskDistanceMinAlpha_8;
			float _GlobalMaskDistanceMaxAlpha_8;
			int _GlobalMaskDistanceBlendType_8;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_9==0
			int _GlobalMaskDistanceEnable_9;
			int _GlobalMaskDistanceType_9;
			float _GlobalMaskDistanceMin_9;
			float _GlobalMaskDistanceMax_9;
			float _GlobalMaskDistanceMinAlpha_9;
			float _GlobalMaskDistanceMaxAlpha_9;
			int _GlobalMaskDistanceBlendType_9;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_10==0
			int _GlobalMaskDistanceEnable_10;
			int _GlobalMaskDistanceType_10;
			float _GlobalMaskDistanceMin_10;
			float _GlobalMaskDistanceMax_10;
			float _GlobalMaskDistanceMinAlpha_10;
			float _GlobalMaskDistanceMaxAlpha_10;
			int _GlobalMaskDistanceBlendType_10;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_11==0
			int _GlobalMaskDistanceEnable_11;
			int _GlobalMaskDistanceType_11;
			float _GlobalMaskDistanceMin_11;
			float _GlobalMaskDistanceMax_11;
			float _GlobalMaskDistanceMinAlpha_11;
			float _GlobalMaskDistanceMaxAlpha_11;
			int _GlobalMaskDistanceBlendType_11;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_12==0
			int _GlobalMaskDistanceEnable_12;
			int _GlobalMaskDistanceType_12;
			float _GlobalMaskDistanceMin_12;
			float _GlobalMaskDistanceMax_12;
			float _GlobalMaskDistanceMinAlpha_12;
			float _GlobalMaskDistanceMaxAlpha_12;
			int _GlobalMaskDistanceBlendType_12;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_13==0
			int _GlobalMaskDistanceEnable_13;
			int _GlobalMaskDistanceType_13;
			float _GlobalMaskDistanceMin_13;
			float _GlobalMaskDistanceMax_13;
			float _GlobalMaskDistanceMinAlpha_13;
			float _GlobalMaskDistanceMaxAlpha_13;
			int _GlobalMaskDistanceBlendType_13;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_14==0
			int _GlobalMaskDistanceEnable_14;
			int _GlobalMaskDistanceType_14;
			float _GlobalMaskDistanceMin_14;
			float _GlobalMaskDistanceMax_14;
			float _GlobalMaskDistanceMinAlpha_14;
			float _GlobalMaskDistanceMaxAlpha_14;
			int _GlobalMaskDistanceBlendType_14;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_15==0
			int _GlobalMaskDistanceEnable_15;
			int _GlobalMaskDistanceType_15;
			float _GlobalMaskDistanceMin_15;
			float _GlobalMaskDistanceMax_15;
			float _GlobalMaskDistanceMinAlpha_15;
			float _GlobalMaskDistanceMaxAlpha_15;
			int _GlobalMaskDistanceBlendType_15;
			//endex
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			float _UDIMDiscardMode;
			float _UDIMDiscardUV;
			float _UDIMDiscardRow3_0;
			float _UDIMDiscardRow3_1;
			float _UDIMDiscardRow3_2;
			float _UDIMDiscardRow3_3;
			float _UDIMDiscardRow2_0;
			float _UDIMDiscardRow2_1;
			float _UDIMDiscardRow2_2;
			float _UDIMDiscardRow2_3;
			float _UDIMDiscardRow1_0;
			float _UDIMDiscardRow1_1;
			float _UDIMDiscardRow1_2;
			float _UDIMDiscardRow1_3;
			float _UDIMDiscardRow0_0;
			float _UDIMDiscardRow0_1;
			float _UDIMDiscardRow0_2;
			float _UDIMDiscardRow0_3;
			#endif
			//endex
			
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture;
			float4 _DistortionFlowTexture_ST;
			float2 _DistortionFlowTexturePan;
			float _DistortionFlowTextureUV;
			#endif
			
			#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture1;
			float4 _DistortionFlowTexture1_ST;
			float2 _DistortionFlowTexture1Pan;
			float _DistortionFlowTexture1UV;
			#endif
			
			#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionMask;
			float4 _DistortionMask_ST;
			float2 _DistortionMaskPan;
			float _DistortionMaskUV;
			float _DistortionMaskChannel;
			#endif
			
			float _DistortionUvToDistort;
			float _DistortionStrength;
			float _DistortionStrength1;
			
			#ifdef POI_AUDIOLINK
			half _EnableDistortionAudioLink;
			half2 _DistortionStrengthAudioLink;
			half _DistortionStrengthAudioLinkBand;
			half2 _DistortionStrength1AudioLink;
			half _DistortionStrength1AudioLinkBand;
			#endif
			#endif
			//endex
			float _StereoEnabled;
			float _PolarUV;
			float2 _PolarCenter;
			float _PolarRadialScale;
			float _PolarLengthScale;
			float _PolarSpiralPower;
			float _PanoUseBothEyes;
			
			float _UVModWorldPos0;
			float _UVModWorldPos1;
			float _UVModLocalPos0;
			float _UVModLocalPos1;
			
			//ifex _PoiParallax==0
			#ifdef POI_PARALLAX
			
			sampler2D _HeightMap;
			float4 _HeightMap_ST;
			float2 _HeightMapPan;
			float _HeightMapUV;
			
			#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Heightmask;
			float4 _Heightmask_ST;
			float2 _HeightmaskPan;
			float _HeightmaskUV;
			float _HeightmaskChannel;
			float _HeightmaskInvert;
			SamplerState _linear_repeat;
			#endif
			
			float _ParallaxUV;
			float _HeightStrength;
			float _HeightOffset;
			float _HeightStepsMin;
			float _HeightStepsMax;
			
			float _CurvatureU;
			float _CurvatureV;
			float _CurvFix;
			#endif
			//endex
			
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			float _AudioLinkDelay;
			float _AudioLinkAnimToggle;
			
			float _AudioLinkSmoothingBass;
			float _AudioLinkSmoothingLowMid;
			float _AudioLinkSmoothingHighMid;
			float _AudioLinkSmoothingTreble;
			
			float _DebugWaveform;
			float _DebugDFT;
			float _DebugBass;
			float _DebugLowMids;
			float _DebugHighMids;
			float _DebugTreble;
			float _DebugCCColors;
			float _DebugCCStrip;
			float _DebugCCLights;
			float _DebugAutocorrelator;
			float _DebugChronotensity;
			float _AudioLinkCCStripY;
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			float _BlackLightMasking0Key;
			float2 _BlackLightMasking0Range;
			float _BlackLightMasking0GlobalMaskIndex;
			float _BlackLightMasking0GlobalMaskBlendType;
			
			float _BlackLightMasking1Key;
			float2 _BlackLightMasking1Range;
			float _BlackLightMasking1GlobalMaskIndex;
			float _BlackLightMasking1GlobalMaskBlendType;
			
			float _BlackLightMasking2Key;
			float2 _BlackLightMasking2Range;
			float _BlackLightMasking2GlobalMaskIndex;
			float _BlackLightMasking2GlobalMaskBlendType;
			
			float _BlackLightMasking3Key;
			float2 _BlackLightMasking3Range;
			float _BlackLightMasking3GlobalMaskIndex;
			float _BlackLightMasking3GlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _DetailEnabled==0
			#ifdef FINALPASS
			#if defined(PROP_DETAILMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailMask;
			#endif
			float4 _DetailMask_ST;
			float2 _DetailMaskPan;
			float _DetailMaskUV;
			float _DetailMaskStochastic;
			
			#if defined(PROP_DETAILNORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailNormalMap;
			#endif
			float4 _DetailNormalMap_ST;
			float2 _DetailNormalMapPan;
			float _DetailNormalMapUV;
			float _DetailNormalMapScale;
			float _DetailNormalMapStochastic;
			float _DetailNormalGlobalMask;
			float _DetailNormalGlobalMaskBlendType;
			
			#if defined(PROP_DETAILTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailTex;
			#endif
			float4 _DetailTex_ST;
			float2 _DetailTexPan;
			float _DetailTexUV;
			float _DetailTexStochastic;
			
			float3 _DetailTint;
			float _DetailTintThemeIndex;
			float _DetailTexIntensity;
			float _DetailBrightness;
			float _DetailTexGlobalMask;
			float _DetailTexGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#ifdef AUTO_EXPOSURE
			float4 _VertexManipulationLocalTranslation;
			float4 _VertexManipulationLocalRotation;
			float3 _VertexManipulationLocalRotationSpeed;
			float4 _VertexManipulationLocalScale;
			float4 _VertexManipulationWorldTranslation;
			float _VertexManipulationHeight;
			sampler2D _VertexManipulationHeightMask;
			float4 _VertexManipulationHeightMask_ST;
			float2 _VertexManipulationHeightMaskPan;
			float _VertexManipulationHeightMaskUV;
			float _VertexManipulationHeightMaskChannel;
			float _VertexManipulationHeightBias;
			float _VertexRoundingEnabled;
			int _VertexRoundingSpace;
			float _VertexRoundingDivision;
			
			//AL
			float _VertexAudioLinkEnabled;
			float3 _VertexLocalTranslationALMin;
			float3 _VertexLocalTranslationALMax;
			float _VertexLocalTranslationALBand;
			
			float3 _VertexLocalRotationAL;
			float _VertexLocalRotationALBand;
			
			float3 _VertexLocalRotationCTALSpeed;
			float _VertexLocalRotationCTALBandX;
			float _VertexLocalRotationCTALBandY;
			float _VertexLocalRotationCTALBandZ;
			float _VertexLocalRotationCTALTypeX;
			float _VertexLocalRotationCTALTypeY;
			float _VertexLocalRotationCTALTypeZ;
			
			float4 _VertexLocalScaleALMin;
			float4 _VertexLocalScaleALMax;
			float _VertexLocalScaleALBand;
			
			float3 _VertexWorldTranslationALMin;
			float3 _VertexWorldTranslationALMax;
			float _VertexWorldTranslationALBand;
			
			float2 _VertexManipulationHeightAL;
			float _VertexManipulationHeightBand;
			
			float2 _VertexRoundingRangeAL;
			float _VertexRoundingRangeBand;
			
			float _VertexBarrelMode;
			float _VertexBarrelWidth;
			float _VertexBarrelAlpha;
			float _VertexBarrelHeight;
			
			float _VertexSphereMode;
			float _VertexSphereRadius;
			float _VertexSphereHeight;
			float _VertexSphereAlpha;
			float4 _VertexSphereCenter;
			
			float _VertexSpectrumMotion;
			float3 _VertexSpectrumOffsetMin;
			float3 _VertexSpectrumOffsetMax;
			float _VertexSpectrumUV;
			float _VertexSpectrumUVDirection;
			#endif
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#ifdef POI_VERTEX_GLITCHING
			//Vertex Glitching
			#if defined(POI_VERTEX_GLITCHING_TEXTURE)
			float _VertexGlitchingUseTexture;
			sampler2D _VertexGlitchMap;
			float4 _VertexGlitchMap_ST;
			#endif
			float _VertexGlitchThreshold;
			float _VertexGlitchFrequency;
			float _VertexGlitchStrength;
			float _VertexGlitchDensity;
			
			float _VertexGlitchMirrorEnable;
			float _VertexGlitchMirror;
			
			float _VertexGlitchMapPanSpeed;
			float _VertexGlitchingAudioLinkEnabled;
			float _VertexGlitchingAudioLinkBand;
			float _VertexGlitchingAudiolinkOverride;
			#endif
			//endex
			
			//ifex _EnableDepthBulge==0
			#ifdef POI_DEPTHBULGE
			float _DepthBulgeFadeLength;
			float _DepthBulgeHeight;
			
			#if defined(PROP_DEPTHBULGEMASK) || !defined(OPTIMIZER_ENABLED)
			sampler2D _DepthBulgeMask;
			#endif
			float _DepthBulgeMaskUV;
			float4 _DepthBulgeMask_ST;
			float _DepthBulgeMaskChannel;
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			float _MainVertexColoringEnabled;
			float _MainVertexColoringLinearSpace;
			float _MainVertexColoring;
			float _MainUseVertexColorAlpha;
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			float _BackFaceEnabled;
			float _BackFaceDetailIntensity;
			float _BackFaceEmissionStrength;
			float2 _BackFacePanning;
			float4 _BackFaceColor;
			float _BackFaceColorThemeIndex;
			float _BackFaceReplaceAlpha;
			
			#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceTexture;
			#endif
			float4 _BackFaceTexture_ST;
			float2 _BackFaceTexturePan;
			float _BackFaceTextureUV;
			
			#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceMask;
			#endif
			float4 _BackFaceMask_ST;
			float2 _BackFaceMaskPan;
			float _BackFaceMaskUV;
			float _BackFaceMaskChannel;
			
			float _BackFaceHueShiftEnabled;
			float _BackFaceHueShift;
			float _BackFaceHueShiftSpeed;
			float _BackFaceEmissionLimiter;
			#endif
			
			//TODO detail strength stuff
			//endex
			
			//ifex _RGBMaskEnabled==0
			#ifdef VIGNETTE
			#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RGBMask;
			#endif
			float4 _RGBMask_ST;
			float2 _RGBMaskPan;
			float _RGBMaskUV;
			
			#if defined(PROP_REDTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RedTexture;
			#endif
			float4 _RedTexture_ST;
			float2 _RedTexturePan;
			float _RedTextureUV;
			float _RedAlphaAdd;
			float _RedTextureStochastic;
			float _RgbRedMaskChannel;
			float _RgbRedGlobalMaskChannel;
			float _RgbRedGlobalMaskBlendType;
			
			#if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GreenTexture;
			#endif
			float4 _GreenTexture_ST;
			float2 _GreenTexturePan;
			float _GreenTextureUV;
			float _GreenAlphaAdd;
			float _GreenTextureStochastic;
			float _RgbGreenMaskChannel;
			float _RgbGreenGlobalMaskChannel;
			float _RgbGreenGlobalMaskBlendType;
			
			#if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BlueTexture;
			#endif
			float4 _BlueTexture_ST;
			float2 _BlueTexturePan;
			float _BlueTextureUV;
			float _BlueAlphaAdd;
			float _BlueTextureStochastic;
			float _RgbBlueMaskChannel;
			float _RgbBlueGlobalMaskChannel;
			float _RgbBlueGlobalMaskBlendType;
			
			#if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AlphaTexture;
			#endif
			float4 _AlphaTexture_ST;
			float2 _AlphaTexturePan;
			float _AlphaTextureUV;
			float _AlphaAlphaAdd;
			float _AlphaTextureStochastic;
			float _RgbAlphaMaskChannel;
			float _RgbAlphaGlobalMaskChannel;
			float _RgbAlphaGlobalMaskBlendType;
			
			//ifex _RgbNormalsEnabled==0
			#ifdef GEOM_TYPE_MESH
			#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalR;
			#endif
			float4 _RgbNormalR_ST;
			float2 _RgbNormalRPan;
			float _RgbNormalRUV;
			float _RgbNormalRScale;
			float _RgbNormalRStochastic;
			float _RgbNormalRMaskChannel;
			float _RgbNormalRGlobalMaskChannel;
			float _RgbNormalRGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalG;
			#endif
			float4 _RgbNormalG_ST;
			float2 _RgbNormalGPan;
			float _RgbNormalGUV;
			float _RgbNormalGScale;
			float _RgbNormalGStochastic;
			float _RgbNormalGMaskChannel;
			float _RgbNormalGGlobalMaskChannel;
			float _RgbNormalGGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalB;
			#endif
			float4 _RgbNormalB_ST;
			float2 _RgbNormalBPan;
			float _RgbNormalBUV;
			float _RgbNormalBScale;
			float _RgbNormalBStochastic;
			float _RgbNormalBMaskChannel;
			float _RgbNormalBGlobalMaskChannel;
			float _RgbNormalBGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalA;
			#endif
			float4 _RgbNormalA_ST;
			float2 _RgbNormalAPan;
			float _RgbNormalAUV;
			float _RgbNormalAScale;
			float _RgbNormalAStochastic;
			float _RgbNormalAMaskChannel;
			float _RgbNormalAGlobalMaskChannel;
			float _RgbNormalAGlobalMaskBlendType;
			
			float _RgbNormalsEnabled;
			#endif
			//endex
			
			float4 _RedColor;
			float4 _GreenColor;
			float4 _BlueColor;
			float4 _AlphaColor;
			
			float _RedColorThemeIndex;
			float _GreenColorThemeIndex;
			float _BlueColorThemeIndex;
			float _AlphaColorThemeIndex;
			
			float _RGBBlendMultiplicative;
			float _RGBUseVertexColors;
			float _RGBNormalBlend;
			#endif
			//endex
			
			//ifex _DecalEnabled==0 && _DecalEnabled1==0 && _DecalEnabled2==0 && _DecalEnabled3==0
			#if defined(PROP_DECALMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DecalMask;
			float4 _DecalMask_ST;
			float2 _DecalMaskPan;
			float _DecalMaskUV;
			#endif
			float _DecalTPSDepthMaskEnabled;
			float _Decal0TPSMaskStrength;
			float _Decal1TPSMaskStrength;
			float _Decal2TPSMaskStrength;
			float _Decal3TPSMaskStrength;
			#ifdef POI_AUDIOLINK
			//ifex _DecalEnabled==0
			#ifdef GEOM_TYPE_BRANCH
			// Audio Link
			half _AudioLinkDecal0ScaleBand;
			float4 _AudioLinkDecal0Scale;
			half _AudioLinkDecal0RotationBand;
			float2 _AudioLinkDecal0Rotation;
			half _AudioLinkDecal0AlphaBand;
			float2 _AudioLinkDecal0Alpha;
			half _AudioLinkDecal0EmissionBand;
			float2 _AudioLinkDecal0Emission;
			float _DecalRotationCTALBand0;
			float _DecalRotationCTALSpeed0;
			float _DecalRotationCTALType0;
			float _AudioLinkDecalCC0;
			float _AudioLinkDecal0SideBand;
			float4 _AudioLinkDecal0SideMin;
			float4 _AudioLinkDecal0SideMax;
			float2 _AudioLinkDecal0ChannelSeparation;
			float _AudioLinkDecal0ChannelSeparationBand;
			#endif //GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#ifdef GEOM_TYPE_BRANCH_DETAIL
			half _AudioLinkDecal1ScaleBand;
			float4 _AudioLinkDecal1Scale;
			half _AudioLinkDecal1RotationBand;
			float2 _AudioLinkDecal1Rotation;
			half _AudioLinkDecal1AlphaBand;
			float2 _AudioLinkDecal1Alpha;
			half _AudioLinkDecal1EmissionBand;
			float2 _AudioLinkDecal1Emission;
			float _DecalRotationCTALBand1;
			float _DecalRotationCTALSpeed1;
			float _DecalRotationCTALType1;
			float _AudioLinkDecalCC1;
			float _AudioLinkDecal1SideBand;
			float4 _AudioLinkDecal1SideMin;
			float4 _AudioLinkDecal1SideMax;
			float2 _AudioLinkDecal1ChannelSeparation;
			float _AudioLinkDecal1ChannelSeparationBand;
			#endif //GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#ifdef GEOM_TYPE_FROND
			half _AudioLinkDecal2ScaleBand;
			float4 _AudioLinkDecal2Scale;
			half _AudioLinkDecal2RotationBand;
			float2 _AudioLinkDecal2Rotation;
			half _AudioLinkDecal2AlphaBand;
			float2 _AudioLinkDecal2Alpha;
			half _AudioLinkDecal2EmissionBand;
			float2 _AudioLinkDecal2Emission;
			float _DecalRotationCTALBand2;
			float _DecalRotationCTALSpeed2;
			float _DecalRotationCTALType2;
			float _AudioLinkDecalCC2;
			float _AudioLinkDecal2SideBand;
			float4 _AudioLinkDecal2SideMin;
			float4 _AudioLinkDecal2SideMax;
			float2 _AudioLinkDecal2ChannelSeparation;
			float _AudioLinkDecal2ChannelSeparationBand;
			#endif //GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#ifdef DEPTH_OF_FIELD_COC_VIEW
			half _AudioLinkDecal3ScaleBand;
			float4 _AudioLinkDecal3Scale;
			half _AudioLinkDecal3RotationBand;
			float2 _AudioLinkDecal3Rotation;
			half _AudioLinkDecal3AlphaBand;
			float2 _AudioLinkDecal3Alpha;
			half _AudioLinkDecal3EmissionBand;
			float2 _AudioLinkDecal3Emission;
			float _DecalRotationCTALBand3;
			float _DecalRotationCTALSpeed3;
			float _DecalRotationCTALType3;
			float _AudioLinkDecalCC3;
			float _AudioLinkDecal3SideBand;
			float4 _AudioLinkDecal3SideMin;
			float4 _AudioLinkDecal3SideMax;
			float2 _AudioLinkDecal3ChannelSeparation;
			float _AudioLinkDecal3ChannelSeparationBand;
			#endif //DEPTH_OF_FIELD_COC_VIEW
			//endex
			#endif
			//endex
			//ifex _DecalEnabled==0
			#ifdef GEOM_TYPE_BRANCH
			sampler2D _DecalTexture;
			
			float _Decal0MaskChannel;
			float _Decal0GlobalMask;
			float _Decal0GlobalMaskBlendType;
			float _Decal0ApplyGlobalMaskIndex;
			float _Decal0ApplyGlobalMaskBlendType;
			float4 _DecalTexture_ST;
			float2 _DecalTexturePan;
			float _DecalTextureUV;
			float4 _DecalColor;
			float _DecalColorThemeIndex;
			float _DecalTiled;
			float _DecalBlendType;
			half _DecalRotation;
			half2 _DecalScale;
			float4 _DecalSideOffset;
			half2 _DecalPosition;
			half _DecalRotationSpeed;
			float _DecalEmissionStrength;
			float _DecalBlendAlpha;
			float _DecalOverrideAlpha;
			float _DecalHueShiftEnabled;
			float _DecalHueShift;
			float _DecalHueShiftSpeed;
			float _Decal0Depth;
			float _Decal0HueAngleStrength;
			float _Decal0ChannelSeparationEnable;
			float _Decal0ChannelSeparation;
			float _Decal0ChannelSeparationPremultiply;
			float _Decal0ChannelSeparationHue;
			float _Decal0ChannelSeparationVertical;
			float _Decal0ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled1==0
			#ifdef GEOM_TYPE_BRANCH_DETAIL
			sampler2D _DecalTexture1;
			
			float _Decal1MaskChannel;
			float _Decal1GlobalMask;
			float _Decal1GlobalMaskBlendType;
			float _Decal1ApplyGlobalMaskIndex;
			float _Decal1ApplyGlobalMaskBlendType;
			float4 _DecalTexture1_ST;
			float2 _DecalTexture1Pan;
			float _DecalTexture1UV;
			float4 _DecalColor1;
			float _DecalColor1ThemeIndex;
			fixed _DecalTiled1;
			float _DecalBlendType1;
			half _DecalRotation1;
			half2 _DecalScale1;
			float4 _DecalSideOffset1;
			half2 _DecalPosition1;
			half _DecalRotationSpeed1;
			float _DecalEmissionStrength1;
			float _DecalBlendAlpha1;
			float _DecalOverrideAlpha1;
			float _DecalHueShiftEnabled1;
			float _DecalHueShift1;
			float _DecalHueShiftSpeed1;
			float _Decal1Depth;
			float _Decal1HueAngleStrength;
			float _Decal1ChannelSeparationEnable;
			float _Decal1ChannelSeparation;
			float _Decal1ChannelSeparationPremultiply;
			float _Decal1ChannelSeparationHue;
			float _Decal1ChannelSeparationVertical;
			float _Decal1ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled2==0
			#ifdef GEOM_TYPE_FROND
			sampler2D _DecalTexture2;
			
			float _Decal2MaskChannel;
			float _Decal2GlobalMask;
			float _Decal2GlobalMaskBlendType;
			float _Decal2ApplyGlobalMaskIndex;
			float _Decal2ApplyGlobalMaskBlendType;
			float4 _DecalTexture2_ST;
			float2 _DecalTexture2Pan;
			float _DecalTexture2UV;
			float4 _DecalColor2;
			float _DecalColor2ThemeIndex;
			fixed _DecalTiled2;
			float _DecalBlendType2;
			half _DecalRotation2;
			half2 _DecalScale2;
			float4 _DecalSideOffset2;
			half2 _DecalPosition2;
			half _DecalRotationSpeed2;
			float _DecalEmissionStrength2;
			float _DecalBlendAlpha2;
			float _DecalOverrideAlpha2;
			float _DecalHueShiftEnabled2;
			float _DecalHueShift2;
			float _DecalHueShiftSpeed2;
			float _Decal2Depth;
			float _Decal2HueAngleStrength;
			float _Decal2ChannelSeparationEnable;
			float _Decal2ChannelSeparation;
			float _Decal2ChannelSeparationPremultiply;
			float _Decal2ChannelSeparationHue;
			float _Decal2ChannelSeparationVertical;
			float _Decal2ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled3==0
			#ifdef DEPTH_OF_FIELD_COC_VIEW
			sampler2D _DecalTexture3;
			
			float _Decal3MaskChannel;
			float _Decal3GlobalMask;
			float _Decal3GlobalMaskBlendType;
			float _Decal3ApplyGlobalMaskIndex;
			float _Decal3ApplyGlobalMaskBlendType;
			float4 _DecalTexture3_ST;
			float2 _DecalTexture3Pan;
			float _DecalTexture3UV;
			float4 _DecalColor3;
			float _DecalColor3ThemeIndex;
			fixed _DecalTiled3;
			float _DecalBlendType3;
			half _DecalRotation3;
			half2 _DecalScale3;
			float4 _DecalSideOffset3;
			half2 _DecalPosition3;
			half _DecalRotationSpeed3;
			float _DecalEmissionStrength3;
			float _DecalBlendAlpha3;
			float _DecalOverrideAlpha3;
			float _DecalHueShiftEnabled3;
			float _DecalHueShift3;
			float _DecalHueShiftSpeed3;
			float _Decal3Depth;
			float _Decal3HueAngleStrength;
			float _Decal3ChannelSeparationEnable;
			float _Decal3ChannelSeparation;
			float _Decal3ChannelSeparationPremultiply;
			float _Decal3ChannelSeparationHue;
			float _Decal3ChannelSeparationVertical;
			float _Decal3ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			float _DissolveType;
			float _DissolveEdgeWidth;
			float4 _DissolveEdgeColor;
			sampler2D _DissolveEdgeGradient;
			float4 _DissolveEdgeGradient_ST;
			float2 _DissolveEdgeGradientPan;
			float _DissolveEdgeGradientUV;
			float _DissolveEdgeEmission;
			float4 _DissolveTextureColor;
			float _DissolveEdgeColorThemeIndex;
			float _DissolveTextureColorThemeIndex;
			
			#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveToTexture;
			#endif
			float4 _DissolveToTexture_ST;
			float2 _DissolveToTexturePan;
			float _DissolveToTextureUV;
			
			#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveNoiseTexture;
			#endif
			float4 _DissolveNoiseTexture_ST;
			float2 _DissolveNoiseTexturePan;
			float _DissolveNoiseTextureUV;
			
			#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveDetailNoise;
			#endif
			float4 _DissolveDetailNoise_ST;
			float2 _DissolveDetailNoisePan;
			float _DissolveDetailNoiseUV;
			
			#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveMask;
			#endif
			float4 _DissolveMask_ST;
			float2 _DissolveMaskPan;
			float _DissolveMaskUV;
			
			float _DissolveMaskGlobalMask;
			float _DissolveMaskGlobalMaskBlendType;
			float _DissolveMaskInvert;
			float _DissolveAlpha;
			float _ContinuousDissolve;
			float _DissolveDetailStrength;
			float _DissolveDetailEdgeSmoothing;
			float _DissolveEdgeHardness;
			float _DissolveInvertNoise;
			float _DissolveInvertDetailNoise;
			float _DissolveToEmissionStrength;
			
			// Point to Point
			float _DissolveP2PWorldLocal;
			float _DissolveP2PEdgeLength;
			float _DissolveP2PClamp;
			float4 _DissolveStartPoint;
			float4 _DissolveEndPoint;
			
			// Spherical
			float3 _SphericalDissolveCenter;
			float _SphericalDissolveRadius;
			float _SphericalDissolveInvert;
			float _SphericalDissolveClamp;
			
			// CenterOut
			float _CenterOutDissolveMode;
			float3 _CenterOutDissolveDirection;
			float _CenterOutDissolveInvert;
			float _CenterOutDissolveNormals;
			float _CenterOutDissolvePower;
			
			// World Dissolve
			float _DissolveWorldShape;
			float4 _DissolveShapePosition;
			float4 _DissolveShapeRotation;
			float _DissolveShapeScale;
			float _DissolveInvertShape;
			float _DissolveShapeEdgeLength;
			
			// UV Tile Dissolve
			float _UVTileDissolveEnabled;
			float _UVTileDissolveDiscardAtMax;
			float _UVTileDissolveUV;
			
			float _UVTileDissolveAlpha_Row3_0;
			float _UVTileDissolveAlpha_Row3_1;
			float _UVTileDissolveAlpha_Row3_2;
			float _UVTileDissolveAlpha_Row3_3;
			float _UVTileDissolveAlpha_Row2_0;
			float _UVTileDissolveAlpha_Row2_1;
			float _UVTileDissolveAlpha_Row2_2;
			float _UVTileDissolveAlpha_Row2_3;
			float _UVTileDissolveAlpha_Row1_0;
			float _UVTileDissolveAlpha_Row1_1;
			float _UVTileDissolveAlpha_Row1_2;
			float _UVTileDissolveAlpha_Row1_3;
			float _UVTileDissolveAlpha_Row0_0;
			float _UVTileDissolveAlpha_Row0_1;
			float _UVTileDissolveAlpha_Row0_2;
			float _UVTileDissolveAlpha_Row0_3;
			
			float _DissolveAlpha0;
			float _DissolveAlpha1;
			float _DissolveAlpha2;
			float _DissolveAlpha3;
			float _DissolveAlpha4;
			float _DissolveAlpha5;
			float _DissolveAlpha6;
			float _DissolveAlpha7;
			float _DissolveAlpha8;
			float _DissolveAlpha9;
			// Masking
			float _DissolveEmissionSide;
			float _DissolveEmission1Side;
			float _DissolveUseVertexColors;
			
			float4 edgeColor;
			float edgeAlpha;
			float dissolveAlpha;
			float4 dissolveToTexture;
			
			float _DissolveHueShiftEnabled;
			float _DissolveHueShiftSpeed;
			float _DissolveHueShift;
			float _DissolveEdgeHueShiftEnabled;
			float _DissolveEdgeHueShiftSpeed;
			float _DissolveEdgeHueShift;
			
			// Audio Link
			#ifdef POI_AUDIOLINK
			fixed _EnableDissolveAudioLink;
			half _AudioLinkDissolveAlphaBand;
			float2 _AudioLinkDissolveAlpha;
			half _AudioLinkDissolveDetailBand;
			float2 _AudioLinkDissolveDetail;
			#endif
			#endif
			//endex
			
			//ifex _ShadingEnabled==0
			float _ShadowStrength;
			float _LightingIgnoreAmbientColor;
			float3 _LightingShadowColor;
			
			// Toon Lighting
			#ifdef _LIGHTINGMODE_TEXTURERAMP
			UNITY_DECLARE_TEX2D(_ToonRamp);
			float _ShadowOffset;
			#endif
			
			#ifdef _LIGHTINGMODE_WRAPPED
			float _LightingWrappedWrap;
			float _LightingWrappedNormalization;
			float _LightingGradientStart;
			float _LightingGradientEnd;
			#endif
			
			#ifdef _LIGHTINGMODE_SHADEMAP
			float3 _1st_ShadeColor;
			#if defined(PROP_1ST_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _1st_ShadeMap;
			#endif
			float4 _1st_ShadeMap_ST;
			float2 _1st_ShadeMapPan;
			float _1st_ShadeMapUV;
			float _Use_1stShadeMapAlpha_As_ShadowMask;
			float _1stShadeMapMask_Inverse;
			float _Use_BaseAs1st;
			float3 _2nd_ShadeColor;
			#if defined(PROP_2ND_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _2nd_ShadeMap;
			#endif
			float4 _2nd_ShadeMap_ST;
			float2 _2nd_ShadeMapPan;
			float _2nd_ShadeMapUV;
			float _Use_2ndShadeMapAlpha_As_ShadowMask;
			float _2ndShadeMapMask_Inverse;
			float _Use_1stAs2nd;
			float _BaseColor_Step;
			float _BaseShade_Feather;
			float _ShadeColor_Step;
			float _1st2nd_Shades_Feather;
			float _ShadingShadeMapBlendType;
			#endif
			
			#ifdef _LIGHTINGMODE_SKIN
			sampler2D _SkinLUT;
			float _SssScale;
			#if defined(PROP_SKINTHICKNESS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _SkinThicknessMap;
			#endif
			float4 _SkinThicknessMap_ST;
			float2 _SkinThicknessMapPan;
			float _SkinThicknessMapUV;
			float _SkinThicknessMapInvert;
			float _SkinThicknessPower;
			float _SssBumpBlur;
			float3 _SssTransmissionAbsorption;
			float3 _SssColorBleedAoWeights;
			#endif
			
			#ifdef _LIGHTINGMODE_MULTILAYER_MATH
			float4 _ShadowColor;
			float _LightingMulitlayerNonLinear;
			#if defined(PROP_SHADOWCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ShadowColorTex;
			float4 _ShadowColorTex_ST;
			float2 _ShadowColorTexPan;
			float _ShadowColorTexUV;
			#endif
			#if defined(PROP_MULTILAYERMATHBLURMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MultilayerMathBlurMap;
			float4 _MultilayerMathBlurMap_ST;
			float2 _MultilayerMathBlurMapPan;
			float _MultilayerMathBlurMapUV;
			#endif
			float _ShadowBorder;
			float _ShadowBlur;
			float _ShadowReceive;
			float4 _Shadow2ndColor;
			#if defined(PROP_SHADOW2NDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Shadow2ndColorTex;
			float4 _Shadow2ndColorTex_ST;
			float2 _Shadow2ndColorTexPan;
			float _Shadow2ndColorTexUV;
			#endif
			float _Shadow2ndBorder;
			float _Shadow2ndBlur;
			float _Shadow2ndReceive;
			float4 _Shadow3rdColor;
			#if defined(PROP_SHADOW3RDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Shadow3rdColorTex;
			float4 _Shadow3rdColorTex_ST;
			float2 _Shadow3rdColorTexPan;
			float _Shadow3rdColorTexUV;
			#endif
			float _Shadow3rdBorder;
			float _Shadow3rdBlur;
			float _Shadow3rdReceive;
			float4 _ShadowBorderColor;
			float _ShadowBorderRange;
			float _ShadowMainStrength;
			#endif
			
			#ifdef _LIGHTINGMODE_CLOTH
			Texture2D_float _ClothDFG;
			SamplerState sampler_ClothDFG;
			
			#if defined(PROP_CLOTHMETALLICSMOOTHNESSMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ClothMetallicSmoothnessMap;
			#endif
			
			float4 _ClothMetallicSmoothnessMap_ST;
			float2 _ClothMetallicSmoothnessMapPan;
			float _ClothMetallicSmoothnessMapUV;
			float _ClothMetallicSmoothnessMapInvert;
			
			float _ClothLerp;
			float _ClothMetallic;
			float _ClothReflectance;
			float _ClothSmoothness;
			#endif
			
			#ifdef _LIGHTINGMODE_SDF
			#if defined(PROP_SDFSHADINGTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _SDFShadingTexture;
			float _SDFShadingTextureUV;
			float2 _SDFShadingTexturePan;
			float4 _SDFShadingTexture_ST;
			float _SDFBlur;
			float4 _SDFForward;
			float4 _SDFLeft;
			#endif
			#endif
			
			// Additive
			float _LightingAdditiveType;
			float _LightingAdditiveGradientStart;
			float _LightingAdditiveGradientEnd;
			float _LightingAdditiveDetailStrength;
			//endex
			
			//ifex _EnableAniso==0
			#ifdef POI_ANISOTROPICS
			
			#if defined(PROP_ANISOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AnisoColorMap;
			float4 _AnisoColorMap_ST;
			float2 _AnisoColorMapPan;
			float _AnisoColorMapUV;
			#endif
			/*
			#if defined(PROP_ANISONOISEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AnisoNoiseMap;
			float4 _AnisoNoiseMap_ST;
			float2 _AnisoNoiseMapPan;
			float _AnisoNoiseMapUV;
			#endif
			*/
			float _AnisoHideInShadow;
			float _AnisoReplace;
			float _AnisoAdd;
			float _AnisoUseBaseColor;
			float _AnisoUseLightColor;
			
			float _Aniso0Strength;
			float _Aniso0Power;
			float _Aniso0Offset;
			float _Aniso0SwitchDirection;
			float4 _Aniso0Tint;
			float _Aniso0TintIndex;
			float _Aniso0OffsetMapStrength;
			float _Aniso0ToonMode;
			float _Aniso0Edge;
			float _Aniso0Blur;
			
			float _Aniso1Strength;
			float _Aniso1Power;
			float _Aniso1Offset;
			float _Aniso1SwitchDirection;
			float4 _Aniso1Tint;
			float _Aniso1TintIndex;
			float _Aniso1OffsetMapStrength;
			float _Aniso1ToonMode;
			float _Aniso1Edge;
			float _Aniso1Blur;
			
			float _AnisoDebugToggle;
			float _AnisoDebugMode;
			#endif
			//endex
			
			//ifex _MatcapEnable==0
			#ifdef POI_MATCAP0
			#if defined(PROP_MATCAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap;
			float4 _Matcap_ST;
			float4 _Matcap_TexelSize;
			float2 _MatcapPan;
			float _MatcapUV;
			#endif
			#if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MatcapMask;
			float4 _MatcapMask_ST;
			float2 _MatcapMaskPan;
			float _MatcapMaskUV;
			float _MatcapMaskChannel;
			#endif
			#ifdef POI_MATCAP0_CUSTOM_NORMAL
			#if defined(PROP_MATCAP0NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap0NormalMap;
			#endif
			float4 _Matcap0NormalMap_ST;
			float2 _Matcap0NormalMapPan;
			float _Matcap0NormalMapUV;
			float _Matcap0NormalMapScale;
			#endif
			float _MatcapUVToBlend;
			float4 _MatCapBlendUV1;
			float _MatcapUVMode;
			float _MatcapMaskInvert;
			float _MatcapMaskGlobalMask;
			float _MatcapMaskGlobalMaskBlendType;
			float _MatcapBorder;
			float _MatcapRotation;
			float _MatcapSmoothnessEnabled;
			float _MatcapSmoothness;
			float _MatcapMaskSmoothnessChannel;
			float _MatcapMaskSmoothnessApply;
			float4 _MatcapColor;
			float _MatcapBaseColorMix;
			float _MatcapColorThemeIndex;
			float _MatcapIntensity;
			float _MatcapReplace;
			float _MatcapMultiply;
			float _MatcapAdd;
			float _MatcapAddToLight;
			float _MatcapMixed;
			float _MatcapScreen;
			float _MatcapAlphaOverride;
			float _MatcapEnable;
			float _MatcapLightMask;
			float _MatcapEmissionStrength;
			float _MatcapNormal;
			float _MatcapHueShiftEnabled;
			float _MatcapHueShiftSpeed;
			float _MatcapHueShift;
			float _MatcapTPSDepthEnabled;
			float _MatcapTPSMaskStrength;
			#endif
			//endex
			//ifex _Matcap2Enable==0
			#ifdef COLOR_GRADING_HDR_3D
			#if defined(PROP_MATCAP2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap2;
			float4 _Matcap2_ST;
			float4 _Matcap2_TexelSize;
			float2 _Matcap2Pan;
			float _Matcap2UV;
			#endif
			#if defined(PROP_MATCAP2MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap2Mask;
			float4 _Matcap2Mask_ST;
			float2 _Matcap2MaskPan;
			float _Matcap2MaskUV;
			float _Matcap2MaskChannel;
			#endif
			#ifdef POI_MATCAP1_CUSTOM_NORMAL
			#if defined(PROP_MATCAP1NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap1NormalMap;
			#endif
			float4 _Matcap1NormalMap_ST;
			float2 _Matcap1NormalMapPan;
			float _Matcap1NormalMapUV;
			float _Matcap1NormalMapScale;
			#endif
			float _Matcap2UVToBlend;
			float4 _MatCap2ndBlendUV1;
			float _Matcap2UVMode;
			float _Matcap2MaskInvert;
			float _Matcap2MaskGlobalMask;
			float _Matcap2MaskGlobalMaskBlendType;
			float _Matcap2Border;
			float _Matcap2Rotation;
			float _Matcap2SmoothnessEnabled;
			float _Matcap2Smoothness;
			float _Matcap2MaskSmoothnessChannel;
			float _Matcap2MaskSmoothnessApply;
			float4 _Matcap2Color;
			float _Matcap2BaseColorMix;
			float _Matcap2ColorThemeIndex;
			float _Matcap2Intensity;
			float _Matcap2Replace;
			float _Matcap2Multiply;
			float _Matcap2Add;
			float _Matcap2AddToLight;
			float _Matcap2Mixed;
			float _Matcap2Screen;
			float _Matcap2AlphaOverride;
			float _Matcap2Enable;
			float _Matcap2LightMask;
			float _Matcap2EmissionStrength;
			float _Matcap2Normal;
			float _Matcap2HueShiftEnabled;
			float _Matcap2HueShiftSpeed;
			float _Matcap2HueShift;
			float _Matcap2TPSDepthEnabled;
			float _Matcap2TPSMaskStrength;
			#endif
			//endex
			
			//ifex _Matcap3Enable==0
			#ifdef POI_MATCAP2
			#if defined(PROP_MATCAP3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap3;
			float4 _Matcap3_ST;
			float4 _Matcap3_TexelSize;
			float2 _Matcap3Pan;
			float _Matcap3UV;
			#endif
			#if defined(PROP_MATCAP3MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap3Mask;
			float4 _Matcap3Mask_ST;
			float2 _Matcap3MaskPan;
			float _Matcap3MaskUV;
			float _Matcap3MaskChannel;
			#endif
			#ifdef POI_MATCAP2_CUSTOM_NORMAL
			#if defined(PROP_MATCAP2NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap2NormalMap;
			#endif
			float4 _Matcap2NormalMap_ST;
			float2 _Matcap2NormalMapPan;
			float _Matcap2NormalMapUV;
			float _Matcap2NormalMapScale;
			#endif
			float _Matcap3UVToBlend;
			float4 _MatCap3rdBlendUV1;
			float _Matcap3UVMode;
			float _Matcap3MaskInvert;
			float _Matcap3MaskGlobalMask;
			float _Matcap3MaskGlobalMaskBlendType;
			float _Matcap3Border;
			float _Matcap3Rotation;
			float _Matcap3SmoothnessEnabled;
			float _Matcap3Smoothness;
			float _Matcap3MaskSmoothnessChannel;
			float _Matcap3MaskSmoothnessApply;
			float4 _Matcap3Color;
			float _Matcap3BaseColorMix;
			float _Matcap3ColorThemeIndex;
			float _Matcap3Intensity;
			float _Matcap3Replace;
			float _Matcap3Multiply;
			float _Matcap3Add;
			float _Matcap3AddToLight;
			float _Matcap3Mixed;
			float _Matcap3Screen;
			float _Matcap3AlphaOverride;
			float _Matcap3Enable;
			float _Matcap3LightMask;
			float _Matcap3EmissionStrength;
			float _Matcap3Normal;
			float _Matcap3HueShiftEnabled;
			float _Matcap3HueShiftSpeed;
			float _Matcap3HueShift;
			float _Matcap3TPSDepthEnabled;
			float _Matcap3TPSMaskStrength;
			#endif
			//endex
			
			//ifex _Matcap4Enable==0
			#ifdef POI_MATCAP3
			#if defined(PROP_MATCAP4) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap4;
			float4 _Matcap4_ST;
			float4 _Matcap4_TexelSize;
			float2 _Matcap4Pan;
			float _Matcap4UV;
			#endif
			#if defined(PROP_MATCAP4MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap4Mask;
			float4 _Matcap4Mask_ST;
			float2 _Matcap4MaskPan;
			float _Matcap4MaskUV;
			float _Matcap4MaskChannel;
			#endif
			#ifdef POI_MATCAP3_CUSTOM_NORMAL
			#if defined(PROP_MATCAP3NORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Matcap3NormalMap;
			#endif
			float4 _Matcap3NormalMap_ST;
			float2 _Matcap3NormalMapPan;
			float _Matcap3NormalMapUV;
			float _Matcap3NormalMapScale;
			#endif
			float _Matcap4UVToBlend;
			float4 _MatCap4thBlendUV1;
			float _Matcap4UVMode;
			float _Matcap4MaskInvert;
			float _Matcap4MaskGlobalMask;
			float _Matcap4MaskGlobalMaskBlendType;
			float _Matcap4Border;
			float _Matcap4Rotation;
			float _Matcap4SmoothnessEnabled;
			float _Matcap4Smoothness;
			float _Matcap4MaskSmoothnessChannel;
			float _Matcap4MaskSmoothnessApply;
			float4 _Matcap4Color;
			float _Matcap4BaseColorMix;
			float _Matcap4ColorThemeIndex;
			float _Matcap4Intensity;
			float _Matcap4Replace;
			float _Matcap4Multiply;
			float _Matcap4Add;
			float _Matcap4AddToLight;
			float _Matcap4Mixed;
			float _Matcap4Screen;
			float _Matcap4AlphaOverride;
			float _Matcap4Enable;
			float _Matcap4LightMask;
			float _Matcap4EmissionStrength;
			float _Matcap4Normal;
			float _Matcap4HueShiftEnabled;
			float _Matcap4HueShiftSpeed;
			float _Matcap4HueShift;
			float _Matcap4TPSDepthEnabled;
			float _Matcap4TPSMaskStrength;
			#endif
			//endex
			
			//ifex _CubeMapEnabled==0
			#ifdef _CUBEMAP
			#if defined(PROP_CUBEMAP) || !defined(OPTIMIZER_ENABLED)
			samplerCUBE _CubeMap;
			float3 _CubeMapRotation;
			float3 _CubeMapRotationPan;
			#endif
			#if defined(PROP_CUBEMAPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _CubeMapMask;
			float4 _CubeMapMask_ST;
			float2 _CubeMapMaskPan;
			float _CubeMapMaskUV;
			float _CubeMapMaskChannel;
			#endif
			float _CubeMapUVMode;
			float _CubeMapWorldNormalsStrength;
			float _CubeMapMaskInvert;
			float _CubeMapMaskGlobalMask;
			float _CubeMapMaskGlobalMaskBlendType;
			float4 _CubeMapColor;
			float _CubeMapColorThemeIndex;
			float _CubeMapIntensity;
			float _CubeMapReplace;
			float _CubeMapMultiply;
			float _CubeMapAdd;
			float _CubeMapEnable;
			float _CubeMapLightMask;
			float _CubeMapEmissionStrength;
			float _CubeMapNormal;
			float _CubeMapHueShiftEnabled;
			float _CubeMapHueShiftSpeed;
			float _CubeMapHueShift;
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			float _ALDecalUV;
			float4 _ALUVScale;
			float2 _ALUVPosition;
			float _ALUVRotation;
			float _ALUVRotationSpeed;
			float4 _ALDecaldCircleDimensions;
			
			float _ALDecalUVMode;
			
			float _ALDecalVolumeStep;
			float _ALDecalVolumeClipMin;
			float _ALDecalVolumeClipMax;
			
			float _ALDecalBandStep;
			float _ALDecalBandClipMin;
			float _ALDecalBandClipMax;
			
			float _ALDecalShapeClip;
			float _ALDecalShapeClipVolumeWidth;
			float _ALDecalShapeClipBandWidth;
			
			#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ALDecalColorMask;
			float4 _ALDecalColorMask_ST;
			float2 _ALDecalColorMaskPan;
			float _ALDecalColorMaskUV;
			#endif
			
			float _ALDecalVolume;
			float _ALDecalBaseBoost;
			float _ALDecalTrebleBoost;
			float _ALDecalLineWidth;
			float _ALDecalVolumeColorSource;
			float3 _ALDecalVolumeColorLow;
			float _ALDecalVolumeColorLowThemeIndex;
			float3 _ALDecalVolumeColorMid;
			float _ALDecalVolumeColorMidThemeIndex;
			float3 _ALDecalVolumeColorHigh;
			float _ALDecalVolumeColorHighThemeIndex;
			float _ALDecalLowEmission;
			float _ALDecalMidEmission;
			float _ALDecalHighEmission;
			float _ALDecalBlendType;
			float _ALDecalBlendAlpha;
			float _ALDecalControlsAlpha;
			#endif
			#endif
			//endex
			
			//ifex _EnableVolumeColor==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_VOLUMECOLOR
			float _ALVolumeColorUV;
			float _ALVolumeColorDirection;
			float _ALVolumeColorBlendType;
			float _ALVolumeColorBlendAlpha;
			float3 _ALVolumeColorLow;
			float _ALVolumeColorLowThemeIndex;
			float3 _ALVolumeColorMid;
			float _ALVolumeColorMidThemeIndex;
			float3 _ALVolumeColorHigh;
			float _ALVolumeColorHighThemeIndex;
			float _ALLowEmission;
			float _ALMidEmission;
			float _ALHighEmission;
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			UNITY_DECLARE_TEX2DARRAY(_FlipbookTexArray);
			float4 _FlipbookTexArray_ST;
			
			float4 _FlipbookColor;
			float _FlipbookColorThemeIndex;
			float _FlipbookFPS;
			// float _FlipbookTotalFrames;
			float4 _FlipbookScaleOffset;
			float4 _FlipbookSideOffset;
			float _FlipbookTiled;
			float _FlipbookManualFrameControl;
			float _FlipbookCurrentFrame;
			float _FlipbookStartAndEnd;
			float _FlipbookStartFrame;
			float _FlipbookEndFrame;
			float _FlipbookEmissionStrength;
			float _FlipbookRotation;
			float _EnableFlipbook;
			float _FlipbookTexArrayUV;
			float _FlipbookAlphaControlsFinalAlpha;
			float _FlipbookRotationSpeed;
			float _FlipbookIntensityControlsAlpha;
			float _FlipbookColorReplaces;
			float2 _FlipbookTexArrayPan;
			float _FlipbookFrameOffset;
			// blending
			float _FlipbookReplace;
			float _FlipbookMultiply;
			float _FlipbookAdd;
			
			#if defined(PROP_FLIPBOOKMASSK) || !defined(OPTIMIZED_ENABLED)
			Texture2D _FlipbookMask;
			#endif
			float4 _FlipbookMask_ST;
			float2 _FlipbookMaskPan;
			float _FlipbookMaskUV;
			float _FlipbookMaskChannel;
			float _FlipbookMaskGlobalMask;
			float _FlipbookMaskGlobalMaskBlendType;
			
			// anim
			float _FlipbookMovementType;
			float4 _FlipbookStartEndOffset;
			float _FlipbookMovementSpeed;
			
			// Crossfade
			float _FlipbookCrossfadeEnabled;
			float2 _FlipbookCrossfadeRange;
			
			// Hueshift
			float _FlipbookHueShiftEnabled;
			float _FlipbookHueShiftSpeed;
			float _FlipbookHueShift;
			
			#ifdef POI_AUDIOLINK
			float _FlipbookChronotensityEnabled;
			float _FlipbookChronotensityBand;
			float _FlipbookChronotensitySpeed;
			float _FlipbookChronoType;
			half _AudioLinkFlipbookScaleBand;
			half4 _AudioLinkFlipbookScale;
			half _AudioLinkFlipbookAlphaBand;
			half2 _AudioLinkFlipbookAlpha;
			half _AudioLinkFlipbookEmissionBand;
			half2 _AudioLinkFlipbookEmission;
			half _AudioLinkFlipbookFrameBand;
			half2 _AudioLinkFlipbookFrame;
			#endif
			#endif
			//endex
			
			//ifex _EnableRimLighting==0
			#ifdef _GLOSSYREFLECTIONS_OFF
			float _Is_NormalMapToRimLight;
			float4 _RimLightColor;
			float _RimLightColorThemeIndex;
			float _RimClamp;
			#ifdef _RIMSTYLE_POIYOMI
			float _RimLightingInvert;
			float _RimWidth;
			float _RimStrength;
			float _RimSharpness;
			float _RimBaseColorMix;
			float _EnableRimLighting;
			float _RimWidthNoiseStrength;
			float4 _RimShadowAlpha;
			float _RimShadowWidth;
			float _RimBlendStrength;
			float _RimBlendMode;
			float _RimShadowToggle;
			float _RimPower;
			float _RimShadowMaskStrength;
			float _RimShadowMaskRampType;
			float _RimShadowMaskInvert;
			float _RimBrightness;
			#if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimTex;
			#endif
			float4 _RimTex_ST;
			float2 _RimTexPan;
			float _RimTexUV;
			#if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimMask;
			#endif
			float4 _RimMask_ST;
			float2 _RimMaskPan;
			float _RimMaskUV;
			float _RimMaskChannel;
			float _RimMaskInvert;
			float _RimBiasIntensity;
			#ifdef POI_AUDIOLINK
			half _AudioLinkRimWidthBand;
			float2 _AudioLinkRimWidthAdd;
			half _AudioLinkRimEmissionBand;
			float2 _AudioLinkRimEmissionAdd;
			half _AudioLinkRimBrightnessBand;
			float2 _AudioLinkRimBrightnessAdd;
			#endif
			#endif
			
			#ifdef _RIMSTYLE_UTS2
			float _RimLight;
			float _Is_LightColor_RimLight;
			float _RimLight_Power;
			float _RimLight_InsideMask;
			float _RimLight_FeatherOff;
			float _LightDirection_MaskOn;
			float _Tweak_LightDirection_MaskLevel;
			float _Add_Antipodean_RimLight;
			float4 _Ap_RimLightColor;
			float _RimApColorThemeIndex;
			float _Is_LightColor_Ap_RimLight;
			float _Ap_RimLight_Power;
			float _Ap_RimLight_FeatherOff;
			#if defined(PROP_SET_RIMLIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_RimLightMask;
			float4 _Set_RimLightMask_ST;
			float2 _Set_RimLightMaskPan;
			float _Set_RimLightMaskUV;
			float _Set_RimLightMaskChannel;
			#endif
			float _Tweak_RimLightMaskLevel;
			#endif
			
			#ifdef _RIMSTYLE_LILTOON
			float4 _RimColor;
			#if defined(PROP_RIMCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimColorTex;
			float4 _RimColorTex_ST;
			float2 _RimColorTexPan;
			float _RimColorTexUV;
			#endif
			float _RimMainStrength;
			float _RimNormalStrength;
			float _RimBorder;
			float _RimBlur;
			float _RimFresnelPower;
			float _RimEnableLighting;
			float _RimShadowMask;
			int _RimBackfaceMask;
			float _RimVRParallaxStrength;
			float _RimDirStrength;
			float _RimDirRange;
			float _RimIndirRange;
			float4 _RimIndirColor;
			float _RimIndirBorder;
			float _RimIndirBlur;
			#endif
			
			float _RimGlobalMask;
			float _RimGlobalMaskBlendType;
			float _RimApplyGlobalMaskIndex;
			float _RimApplyGlobalMaskBlendType;
			
			float _RimHueShiftEnabled;
			float _RimHueShiftSpeed;
			float _RimHueShift;
			#endif
			//endex
			//ifex _EnableRim2Lighting==0
			#ifdef POI_RIM2
			float _Is_NormalMapToRim2Light;
			float4 _Rim2LightColor;
			float _Rim2LightColorThemeIndex;
			float _Rim2Clamp;
			
			#ifdef _RIM2STYLE_POIYOMI
			float _Rim2LightingInvert;
			float _Rim2Width;
			float _Rim2Strength;
			float _Rim2Sharpness;
			float _Rim2BaseColorMix;
			float _EnableRim2Lighting;
			float _Rim2WidthNoiseStrength;
			float4 _Rim2ShadowAlpha;
			float _Rim2ShadowWidth;
			float _Rim2BlendStrength;
			float _Rim2BlendMode;
			float _Rim2ShadowToggle;
			float _Rim2Power;
			float _Rim2ShadowMaskStrength;
			float _Rim2ShadowMaskRampType;
			float _Rim2ShadowMaskInvert;
			float _Rim2Brightness;
			#if defined(PROP_RIM2TEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2Tex;
			#endif
			float4 _Rim2Tex_ST;
			float2 _Rim2TexPan;
			float _Rim2TexUV;
			#if defined(PROP_RIM2MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2Mask;
			#endif
			float4 _Rim2Mask_ST;
			float2 _Rim2MaskPan;
			float _Rim2MaskUV;
			float _Rim2MaskChannel;
			float _Rim2MaskInvert;
			float _Rim2BiasIntensity;
			#if defined(PROP_RIM2WIDTHNOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2WidthNoiseTexture;
			#endif
			#ifdef POI_AUDIOLINK
			half _AudioLinkRim2WidthBand;
			float2 _AudioLinkRim2WidthAdd;
			half _AudioLinkRim2EmissionBand;
			float2 _AudioLinkRim2EmissionAdd;
			half _AudioLinkRim2BrightnessBand;
			float2 _AudioLinkRim2BrightnessAdd;
			#endif
			#endif
			
			#ifdef _RIM2STYLE_UTS2
			float _Rim2Light;
			float _Is_LightColor_Rim2Light;
			float _Rim2Light_Power;
			float _Rim2Light_InsideMask;
			float _Rim2Light_FeatherOff;
			float _LightDirection_MaskOn2;
			float _Tweak_LightDirection_MaskLevel2;
			float _Add_Antipodean_Rim2Light;
			float4 _Ap_Rim2LightColor;
			float _Rim2ApColorThemeIndex;
			float _Is_LightColor_Ap_Rim2Light;
			float _Ap_Rim2Light_Power;
			float _Ap_Rim2Light_FeatherOff;
			#if defined(PROP_SET_RIM2LIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_Rim2LightMask;
			float4 _Set_Rim2LightMask_ST;
			float2 _Set_Rim2LightMaskPan;
			float _Set_Rim2LightMaskUV;
			float _Set_Rim2LightMaskChannel;
			#endif
			float _Tweak_Rim2LightMaskLevel;
			#endif
			
			#ifdef _RIM2STYLE_LILTOON
			float4 _Rim2Color;
			#if defined(PROP_RIM2COLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2ColorTex;
			float4 _Rim2ColorTex_ST;
			float2 _Rim2ColorTexPan;
			float _Rim2ColorTexUV;
			#endif
			float _Rim2MainStrength;
			float _Rim2NormalStrength;
			float _Rim2Border;
			float _Rim2Blur;
			float _Rim2FresnelPower;
			float _Rim2EnableLighting;
			float _Rim2ShadowMask;
			int _Rim2BackfaceMask;
			float _Rim2VRParallaxStrength;
			// int _Rim2ApplyTransparency;
			float _Rim2DirStrength;
			float _Rim2DirRange;
			float _Rim2IndirRange;
			float4 _Rim2IndirColor;
			float _Rim2IndirBorder;
			float _Rim2IndirBlur;
			#endif
			
			float _Rim2GlobalMask;
			float _Rim2GlobalMaskBlendType;
			float _Rim2ApplyGlobalMaskIndex;
			float _Rim2ApplyGlobalMaskBlendType;
			
			float _Rim2HueShiftEnabled;
			float _Rim2HueShiftSpeed;
			float _Rim2HueShift;
			#endif
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#ifdef _POI_DEPTH_RIMLIGHT
			float _DepthRimNormalToUse;
			float _DepthRimWidth;
			float _DepthRimSharpness;
			float _DepthRimHideInShadow;
			float4 _DepthRimColor;
			float _DepthRimColorThemeIndex;
			float _DepthRimMixBaseColor;
			float _DepthRimEmission;
			float _DepthRimReplace;
			float _DepthRimAdd;
			float _DepthRimMultiply;
			float _DepthRimAdditiveLighting;
			float _DepthRimMixLightColor;
			float _DepthRimType;
			float _DepthRimBrightness;
			
			static float2 sobelSamplePoints[9] = {
				float2(-1, 1), float2(0, 1), float2(1, 1),
				float2(-1, 0), float2(0, 0), float2(1, 01),
				float2(-1, -1), float2(0, -1), float2(1, -1)
			};
			
			static float sobelXMatrix[9] = {
				1, 0, -1,
				2, 0, -2,
				1, 0, -1
			};
			static float sobelYMatrix[9] = {
				1, 2, 1,
				0, 0, 0,
				- 1, -2, -1
			};
			#endif
			//endex
			
			//ifex _GlitterEnable==0
			#ifdef _SUNDISK_SIMPLE
			float _GlitterUseNormals;
			float _GlitterUV;
			half3 _GlitterColor;
			float _GlitterColorThemeIndex;
			float2 _GlitterPan;
			half _GlitterSpeed;
			half _GlitterBrightness;
			float _GlitterFrequency;
			float _GlitterJitter;
			half _GlitterSize;
			half _GlitterContrast;
			half _GlitterAngleRange;
			half _GlitterMinBrightness;
			half _GlitterBias;
			fixed _GlitterUseSurfaceColor;
			float _GlitterBlendType;
			float _GlitterMode;
			float _GlitterShape;
			float _GlitterCenterSize;
			float _glitterFrequencyLinearEmissive;
			float _GlitterJaggyFix;
			float _GlitterTextureRotation;
			float2 _GlitterUVPanning;
			
			float _GlitterHueShiftEnabled;
			float _GlitterHueShiftSpeed;
			float _GlitterHueShift;
			float _GlitterHideInShadow;
			
			float _GlitterRandomColors;
			float2 _GlitterMinMaxSaturation;
			float2 _GlitterMinMaxBrightness;
			float _GlitterRandomSize;
			float4 _GlitterMinMaxSize;
			float _GlitterRandomRotation;
			
			#if defined(PROP_GLITTERMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterMask;
			#endif
			float4 _GlitterMask_ST;
			float2 _GlitterMaskPan;
			float _GlitterMaskUV;
			float _GlitterMaskChannel;
			float _GlitterMaskGlobalMask;
			float _GlitterMaskGlobalMaskBlendType;
			#if defined(PROP_GLITTERCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterColorMap;
			#endif
			float4 _GlitterColorMap_ST;
			float2 _GlitterColorMapPan;
			float _GlitterColorMapUV;
			#if defined(PROP_GLITTERTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterTexture;
			#endif
			float4 _GlitterTexture_ST;
			float2 _GlitterTexturePan;
			float _GlitterTextureUV;
			#endif
			//endex
			
			//ifex _SubsurfaceScattering==0
			#ifdef POI_SUBSURFACESCATTERING
			float4 _SSSColor;
			#if defined(PROP_SSSTHICKNESSMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _SSSThicknessMap;
			#endif
			float4 _SSSThicknessMap_ST;
			float2 _SSSThicknessMapPan;
			float _SSSThicknessMapUV;
			float _SSSThicknessMapChannel;
			
			float _SSSThicknessMod;
			float _SSSStrength;
			float _SSSSpread;
			float _SSSDistortion;
			#endif
			//endex
			
			//ifex _MochieBRDF==0
			#ifdef MOCHIE_PBR
			#if defined(PROP_MOCHIEMETALLICMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MochieMetallicMaps;
			float _PBRMapsStochastic;
			#endif
			POI_DECLARETEX_ST_UV_PAN_STOCHASTIC(_MochieMetallicMaps);
			float _MochieMetallicMapInvert;
			float _MochieRoughnessMapInvert;
			float _MochieReflectionMaskInvert;
			float _MochieSpecularMaskInvert;
			float _MochieMetallicMapsMetallicChannel;
			float _MochieMetallicMapsRoughnessChannel;
			float _MochieMetallicMapsReflectionMaskChannel;
			float _MochieMetallicMapsSpecularMaskChannel;
			float _PBRNormalSelect;
			
			float _MochieReflectionTintThemeIndex;
			float _MochieSpecularTintThemeIndex;
			
			float _MochieRoughnessMultiplier;
			float _MochieMetallicMultiplier;
			float _MochieReflectionStrength;
			float _MochieSpecularStrength;
			float4 _MochieSpecularTint;
			float4 _MochieReflectionTint;
			float _MochieLitFallback;
			float _IgnoreCastedShadows;
			float _PBRSplitMaskSample;
			float _PBRSplitMaskStochastic;
			float4 _PBRMaskScaleTiling;
			float _MochieMetallicMasksUV;
			float4 _MochieMetallicMasksPan;
			
			float _Specular2ndLayer;
			float _MochieSpecularStrength2;
			float _MochieRoughnessMultiplier2;
			float _RefSpecFresnel;
			samplerCUBE _MochieReflCube;
			float4 _MochieReflCube_HDR;
			float _MochieForceFallback;
			float _MochieGSAAEnabled;
			float _PoiGSAAVariance;
			float _PoiGSAAThreshold;
			float _BRDFTPSReflectionMaskStrength;
			float _BRDFTPSSpecularMaskStrength;
			float _BRDFTPSDepthEnabled;
			
			float _MochieMetallicGlobalMask;
			float _MochieMetallicGlobalMaskBlendType;
			float _MochieSmoothnessGlobalMask;
			float _MochieSmoothnessGlobalMaskBlendType;
			float _MochieReflectionStrengthGlobalMask;
			float _MochieReflectionStrengthGlobalMaskBlendType;
			float _MochieSpecularStrengthGlobalMask;
			float _MochieSpecularStrengthGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _ClearCoatBRDF==0
			#ifdef POI_CLEARCOAT
			#if defined(PROP_CLEARCOATMAPS) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ClearCoatMaps;
			float4 _ClearCoatMaps_ST;
			float2 _ClearCoatMapsPan;
			float _ClearCoatMapsUV;
			float _ClearCoatMapsStochastic;
			#endif
			float _ClearCoatMapsClearCoatMaskChannel;
			float _ClearCoatMapsRoughnessChannel;
			float _ClearCoatMapsReflectionMaskChannel;
			float _ClearCoatMapsSpecularMaskChannel;
			float _ClearCoatBRDF;
			float _ClearCoatReflectionStrength;
			float _ClearCoatSpecularStrength;
			float _ClearCoatStrength;
			float _ClearCoatSmoothness;
			float4 _ClearCoatReflectionTint;
			float _ClearCoatReflectionTintThemeIndex;
			float4 _ClearCoatSpecularTint;
			float _ClearCoatSpecularTintThemeIndex;
			float _ClearCoatSmoothnessMapInvert;
			float _ClearCoatMaskInvert;
			float _ClearCoatReflectionMaskInvert;
			float _ClearCoatSpecularMaskInvert;
			float _ClearCoatTPSMaskStrength;
			float _ClearCoatTPSDepthMaskEnabled;
			float _ClearCoatNormalSelect;
			
			samplerCUBE _ClearCoatFallback;
			float4 _ClearCoatFallback_HDR;
			float _ClearCoatForceFallback;
			float _ClearCoatLitFallback;
			float _CCIgnoreCastedShadows;
			float _ClearCoatGSAAEnabled;
			float _ClearCoatGSAAVariance;
			float _ClearCoatGSAAThreshold;
			float _ClearcoatFresnel;
			
			float _ClearCoatGlobalMask;
			float _ClearCoatGlobalMaskBlendType;
			float _ClearCoatSmoothnessGlobalMask;
			float _ClearCoatSmoothnessGlobalMaskBlendType;
			float _ClearCoatReflectionStrengthGlobalMask;
			float _ClearCoatReflectionStrengthGlobalMaskBlendType;
			float _ClearCoatSpecularStrengthGlobalMask;
			float _ClearCoatSpecularStrengthGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _StylizedSpecular==0
			#ifdef POI_STYLIZED_StylizedSpecular
			#if defined(PROP_HIGHCOLOR_TEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _HighColor_Tex;
			#endif
			float4 _HighColor_Tex_ST;
			float2 _HighColor_TexPan;
			float _HighColor_TexUV;
			
			#if defined(PROP_SET_HIGHCOLORMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_HighColorMask;
			#endif
			float4 _Set_HighColorMask_ST;
			float2 _Set_HighColorMaskPan;
			float _Set_HighColorMaskUV;
			float _Set_HighColorMaskChannel;
			float _Tweak_HighColorMaskLevel;
			
			/*
			#if defined(PROP_StylizedSpecularOPTMAP1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _StylizedSpecularOptMap1;
			#endif
			float4 _StylizedSpecularOptMap1_ST;
			float2 _StylizedSpecularOptMap1Pan;
			float _StylizedSpecularOptMap1UV;
			
			#if defined(PROP_StylizedSpecularOPTMAP2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _StylizedSpecularOptMap2;
			#endif
			float4 _StylizedSpecularOptMap2_ST;
			float2 _StylizedSpecularOptMap2Pan;
			float _StylizedSpecularOptMap2UV;
			*/
			
			float4 _HighColor;
			float _UseLightColor;
			
			float _HighColor_Power;
			float _StylizedSpecularFeather;
			float _Layer1Strength;
			
			float _StylizedSpecularIgnoreNormal;
			float _StylizedSpecularIgnoreShadow;
			
			float _Layer2Size;
			float _StylizedSpecular2Feather;
			float _Layer2Strength;
			float _SSIgnoreCastedShadows;
			float _StylizedSpecularStrength;
			float _UseSpecularOptMap2;
			float _HighColorThemeIndex;
			float _Is_BlendAddToHiColor;
			float _Is_SpecularToHighColor;
			#endif
			//endex
			
			//ifex _EnablePathing==0
			#ifdef POI_PATHING
			
			#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PathingMap;
			SamplerState SmpRepeatPoint;
			#endif
			float4 _PathingMap_ST;
			float2 _PathingMapPan;
			float _PathingMapUV;
			
			#if defined(PROP_PATHINGCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PathingColorMap;
			#endif
			float4 _PathingColorMap_ST;
			float2 _PathingColorMapPan;
			float _PathingColorMapUV;
			float _PathingOverrideAlpha;
			// Fill, 0, Path, 1, Loop, 2
			float _PathTypeR;
			float _PathTypeG;
			float _PathTypeB;
			float _PathTypeA;
			float _PathGradientType;
			half4 _PathWidth;
			float4 _PathTime;
			float4 _PathOffset;
			float4 _PathSpeed;
			float4 _PathColorR;
			float4 _PathColorG;
			float4 _PathColorB;
			float4 _PathColorA;
			float4 _PathEmissionStrength;
			float4 _PathSoftness;
			float4 _PathSegments;
			
			float _PathColorRThemeIndex;
			float _PathColorGThemeIndex;
			float _PathColorBThemeIndex;
			float _PathColorAThemeIndex;
			
			#ifdef POI_AUDIOLINK
			float _PathALAutoCorrelator;
			float _PathALAutoCorrelatorMode;
			float _PathALAutoCorrelatorR;
			float2 _PathALAutoCorrelatorRangeR;
			float _PathALAutoCorrelatorG;
			float2 _PathALAutoCorrelatorRangeG;
			float _PathALAutoCorrelatorB;
			float2 _PathALAutoCorrelatorRangeB;
			float _PathALAutoCorrelatorA;
			float2 _PathALAutoCorrelatorRangeA;
			
			float _PathALHistory;
			float _PathALHistoryMode;
			float _PathALHistoryBandR;
			float2 _PathALHistoryRangeR;
			float _PathALHistoryR;
			float _PathALHistoryBandG;
			float2 _PathALHistoryRangeG;
			float _PathALHistoryG;
			float _PathALHistoryBandB;
			float2 _PathALHistoryRangeB;
			float _PathALHistoryB;
			float _PathALHistoryBandA;
			float2 _PathALHistoryRangeA;
			float _PathALHistoryA;
			
			float _PathALColorChord;
			float _PathALCCR;
			float _PathALCCG;
			float _PathALCCB;
			float _PathALCCA;
			
			// Time Offset
			float _PathALTimeOffset;
			half _AudioLinkPathTimeOffsetBandR;
			half2 _AudioLinkPathTimeOffsetR;
			half _AudioLinkPathTimeOffsetBandG;
			half2 _AudioLinkPathTimeOffsetG;
			half _AudioLinkPathTimeOffsetBandB;
			half2 _AudioLinkPathTimeOffsetB;
			half _AudioLinkPathTimeOffsetBandA;
			half2 _AudioLinkPathTimeOffsetA;
			
			// Emission Offset
			float _PathALEmissionOffset;
			half _AudioLinkPathEmissionAddBandR;
			half2 _AudioLinkPathEmissionAddR;
			half _AudioLinkPathEmissionAddBandG;
			half2 _AudioLinkPathEmissionAddG;
			half _AudioLinkPathEmissionAddBandB;
			half2 _AudioLinkPathEmissionAddB;
			half _AudioLinkPathEmissionAddBandA;
			half2 _AudioLinkPathEmissionAddA;
			
			// Length Offset
			float _PathALWidthOffset;
			half _AudioLinkPathWidthOffsetBandR;
			half2 _AudioLinkPathWidthOffsetR;
			half _AudioLinkPathWidthOffsetBandG;
			half2 _AudioLinkPathWidthOffsetG;
			half _AudioLinkPathWidthOffsetBandB;
			half2 _AudioLinkPathWidthOffsetB;
			half _AudioLinkPathWidthOffsetBandA;
			half2 _AudioLinkPathWidthOffsetA;
			
			// Chrono Time
			float _PathALChrono;
			float _PathChronoBandR;
			float _PathChronoTypeR;
			float _PathChronoSpeedR;
			float _PathChronoBandG;
			float _PathChronoTypeG;
			float _PathChronoSpeedG;
			float _PathChronoBandB;
			float _PathChronoTypeB;
			float _PathChronoSpeedB;
			float _PathChronoBandA;
			float _PathChronoTypeA;
			float _PathChronoSpeedA;
			#endif
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			float _VisibilityMode;
			float _Mirror;
			#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MirrorTexture;
			#endif
			float4 _MirrorColor;
			float _MirrorColorThemeIndex;
			float _MirrorTextureBlendType;
			float4 _MirrorTexture_ST;
			float2 _MirrorTexturePan;
			float _MirrorTextureUV;
			
			float _VisibilityVRCRegular;
			float _VisibilityVRCMirrorVR;
			float _VisibilityVRCMirrorDesktop;
			float _VisibilityVRCCameraVR;
			float _VisibilityVRCCameraDesktop;
			float _VisibilityVRCCameraScreenshot;
			#endif
			//endex
			
			//ifex _EnableTouchGlow==0
			#if defined(PROP_DEPTHMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DepthMask;
			#endif
			float4 _DepthMask_ST;
			float2 _DepthMaskPan;
			float _DepthMaskUV;
			float _DepthMaskChannel;
			float _DepthMaskGlobalMask;
			float _DepthMaskGlobalMaskBlendType;
			
			// Color
			float _DepthColorToggle;
			float _DepthColorBlendMode;
			#if defined(PROP_DEPTHTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DepthTexture;
			#endif
			float4 _DepthTexture_ST;
			float2 _DepthTexturePan;
			float _DepthTextureUV;
			
			float3 _DepthColor;
			float _DepthColorThemeIndex;
			float _DepthColorMinDepth;
			float _DepthColorMaxDepth;
			float _DepthColorMinValue;
			float _DepthColorMaxValue;
			float _DepthEmissionStrength;
			
			// Emission
			
			// Alpha
			float _DepthAlphaToggle;
			float _DepthAlphaMinValue;
			float _DepthAlphaMaxValue;
			float _DepthAlphaMinDepth;
			float _DepthAlphaMaxDepth;
			//endex
			
			//ifex _EnableIridescence==0
			#ifdef POI_IRIDESCENCE
			#if defined(PROP_IRIDESCENCERAMP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _IridescenceRamp;
			#endif
			float4 _IridescenceRamp_ST;
			float2 _IridescenceRampPan;
			
			#if defined(PROP_IRIDESCENCEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _IridescenceMask;
			#endif
			float4 _IridescenceMask_ST;
			float2 _IridescenceMaskPan;
			float _IridescenceMaskUV;
			float _IridescenceMaskChannel;
			float _IridescenceMaskInvert;
			float _IridescenceMaskGlobalMask;
			float _IridescenceMaskGlobalMaskBlendType;
			
			#if defined(PROP_IRIDESCENCENORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _IridescenceNormalMap;
			#endif
			float4 _IridescenceNormalMap_ST;
			float2 _IridescenceNormalMapPan;
			float _IridescenceNormalMapUV;
			
			float _IridescenceIntensity;
			float _IridescenceHueShiftEnabled;
			float _IridescenceHueShiftSpeed;
			float _IridescenceHueShift;
			
			float _IridescenceNormalSelection;
			float _IridescenceNormalIntensity;
			float _IridescenceNormalToggle;
			float _IridescenceAddBlend;
			float _IridescenceReplaceBlend;
			float _IridescenceMultiplyBlend;
			float _IridescenceEmissionStrength;
			
			#ifdef POI_AUDIOLINK
			float _IridescenceAudioLinkEmissionAddBand;
			float2 _IridescenceAudioLinkEmissionAdd;
			float _IridescenceAudioLinkIntensityAddBand;
			float2 _IridescenceAudioLinkIntensityAdd;
			float _IridescenceAudioLinkChronoPanType;
			float _IridescenceAudioLinkChronoPanBand;
			float _IridescenceAudioLinkChronoPanSpeed;
			#endif
			#endif
			//endex
			
			//ifex _TextEnabled==0
			#ifdef EFFECT_BUMP
			sampler2D _TextGlyphs;
			float4 _TextGlyphs_ST;
			float4 _TextGlyphs_TexelSize;
			float _TextFPSUV;
			float _TextTimeUV;
			float _TextPositionUV;
			float _TextNumericUV;
			float _TextPixelRange;
			
			float _TextFPSEnabled;
			float _TextPositionEnabled;
			float _TextTimeEnabled;
			float _TextNumericEnabled;
			
			float4 _TextFPSColor;
			float _TextFPSEmissionStrength;
			fixed4 _TextFPSPadding;
			float2 _TextFPSOffset;
			float2 _TextFPSScale;
			float _TextFPSRotation;
			
			fixed _TextPositionVertical;
			float4 _TextPositionColor;
			float _TextPositionEmissionStrength;
			fixed4 _TextPositionPadding;
			float2 _TextPositionOffset;
			float2 _TextPositionScale;
			float _TextPositionRotation;
			
			float4 _TextTimeColor;
			float _TextTimeEmissionStrength;
			fixed4 _TextTimePadding;
			float2 _TextTimeOffset;
			float2 _TextTimeScale;
			float _TextTimeRotation;
			
			float4 _TextNumericColor;
			float _TextNumericEmissionStrength;
			fixed4 _TextNumericPadding;
			float2 _TextNumericOffset;
			float2 _TextNumericScale;
			float _TextNumericRotation;
			float _TextNumericValue;
			float _TextNumericWholeDigits;
			float _TextNumericDecimalDigits;
			float _TextNumericTrimZeroes;
			
			float _TextFPSColorThemeIndex;
			float _TextPositionColorThemeIndex;
			float _TextTimeColorThemeIndex;
			float _TextNumericColorThemeIndex;
			
			float3 globalTextEmission;
			
			#define ASCII_SPACE 32
			#define ASCII_LEFT_PARENTHESIS 40
			#define ASCII_RIGHT_PARENTHESIS 41
			#define ASCII_POSITIVE 43
			#define ASCII_PERIOD 46
			#define ASCII_NEGATIVE 45
			#define ASCII_COMMA 44
			#define ASCII_E 69
			#define ASCII_F 70
			#define ASCII_I 73
			#define ASCII_M 77
			#define ASCII_O 79
			#define ASCII_P 80
			#define ASCII_R 82
			#define ASCII_S 83
			#define ASCII_T 84
			#define ASCII_SEMICOLON 58
			#define glyphWidth 0.0625
			
			#endif
			//endex
			
			//ifex _FXProximityColor==0
			float _FXProximityColor;
			float _FXProximityColorType;
			float3 _FXProximityColorMinColor;
			float3 _FXProximityColorMaxColor;
			float _FXProximityColorMinColorThemeIndex;
			float _FXProximityColorMaxColorThemeIndex;
			float _FXProximityColorMinDistance;
			float _FXProximityColorMaxDistance;
			float _FXProximityColorBackFace;
			//endex
			
			//ifex _PostProcess==0
			#ifdef POSTPROCESS
			#if defined(PROP_PPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PPMask;
			#endif
			float4 _PPMask_ST;
			float2 _PPMaskPan;
			float _PPMaskUV;
			float _PPMaskChannel;
			float _PPMaskInvert;
			
			float3 _PPTint;
			float3 _PPRGB;
			float _PPHue;
			float _PPContrast;
			float _PPSaturation;
			float _PPBrightness;
			float _PPLightness;
			float _PPHDR;
			
			float _PPPosterization;
			float _PPPosterizationAmount;
			const static float COLORS = 32;
			
			#endif
			//endex
			
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			float _NormalCorrectAmount;
			float3 _NormalCorrectOrigin;
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float _VideoEffectsEnable;
			#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
			sampler2D _VideoPixelTexture;
			float4 _VideoPixelTexture_ST;
			float _VideoPixelTextureUV;
			#endif
			#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _VideoMaskTexture;
			float4 _VideoMaskTexture_ST;
			float2 _VideoMaskTexturePan;
			float _VideoMaskTextureUV;
			float _VideoMaskTextureChannel;
			#endif
			
			float _VideoType;
			float2 _VideoResolution;
			sampler2D _VideoGameboyRamp;
			float _VideoBacklight;
			float _VideoCRTRefreshRate;
			float _VideoCRTPixelEnergizedTime;
			float _VideoRepeatVideoTexture;
			float _VideoPixelateToResolution;
			float2 _VideoMaskPanning;
			
			float _VideoSaturation;
			float _VideoContrast;
			float _VideoEmissionEnabled;
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			float4 _BacklightColor;
			#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BacklightColorTex;
			float4 _BacklightColorTex_ST;
			float2 _BacklightColorTexPan;
			float _BacklightColorTexUV;
			#endif
			float _BacklightMainStrength;
			float _BacklightNormalStrength;
			float _BacklightBorder;
			float _BacklightBlur;
			float _BacklightDirectivity;
			float _BacklightViewStrength;
			int _BacklightReceiveShadow;
			int _BacklightBackfaceMask;
			#endif
			//endex
			
			struct appdata
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
				float4 color : COLOR;
				float2 uv0 : TEXCOORD0;
				float2 uv1 : TEXCOORD1;
				float2 uv2 : TEXCOORD2;
				float2 uv3 : TEXCOORD3;
				uint vertexId : SV_VertexID;
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};
			
			struct VertexOut
			{
				float4 pos : SV_POSITION;
				float2 uv[4] : TEXCOORD0;
				float3 objNormal : TEXCOORD4;
				float3 normal : TEXCOORD5;
				float3 tangent : TEXCOORD6;
				float3 binormal : TEXCOORD7;
				float4 worldPos : TEXCOORD8;
				float4 localPos : TEXCOORD9;
				float3 objectPos : TEXCOORD10;
				float4 vertexColor : TEXCOORD11;
				float4 lightmapUV : TEXCOORD12;
				float4 grabPos: TEXCOORD13;
				float4 worldDirection: TEXCOORD14;
				float4 extra: TEXCOORD15;
				UNITY_SHADOW_COORDS(16)
				UNITY_FOG_COORDS(17)
				
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};
			
			struct PoiMesh
			{
				
				// 0 Vertex normal
				// 1 Fragment normal
				float3 normals[2];
				float3 objNormal;
				float3 tangentSpaceNormal;
				float3 binormal[2];
				float3 tangent[2];
				float3 worldPos;
				float3 localPos;
				float3 objectPosition;
				float isFrontFace;
				float4 vertexColor;
				float4 lightmapUV;
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 7 Distorted UV
				float2 uv[9];
				float2 parallaxUV;
			};
			
			struct PoiCam
			{
				float3 viewDir;
				float3 forwardDir;
				float3 worldPos;
				float distanceToVert;
				float4 clipPos;
				float3 reflectionDir;
				float3 vertexReflectionDir;
				float3 tangentViewDir;
				float4 grabPos;
				float2 screenUV;
				float vDotN;
				float4 worldDirection;
				
			};
			
			struct PoiMods
			{
				float4 PBR; // smoothness, metallic, smoothness mask, metallic mask
				float4 Mask;
				float4 audioLink;
				float audioLinkAvailable;
				float audioLinkVersion;
				float4 audioLinkTexture;
				float audioLinkViaLuma;
				float2 detailMask;
				float2 backFaceDetailIntensity;
				float globalEmission;
				float4 globalColorTheme[12];
				float globalMask[16];
				float ALTime[8];
			};
			
			struct PoiLight
			{
				
				float3 direction;
				float attenuation;
				float attenuationStrength;
				float3 directColor;
				float3 indirectColor;
				float occlusion;
				float shadowMask;
				float detailShadow;
				float3 halfDir;
				float lightMap;
				float lightMapNoAttenuation;
				float3 rampedLightMap;
				float vertexNDotL;
				float nDotL;
				float nDotV;
				float vertexNDotV;
				float nDotH;
				float vertexNDotH;
				float lDotv;
				float lDotH;
				float nDotLSaturated;
				float nDotLNormalized;
				#ifdef POI_PASS_ADD
				float additiveShadow;
				#endif
				float3 finalLighting;
				float3 finalLightAdd;
				
				#if defined(VERTEXLIGHT_ON)
				// Non Important Lights
				float4 vDotNL;
				float4 vertexVDotNL;
				float3 vColor[4];
				float4 vCorrectedDotNL;
				float4 vAttenuation;
				float4 vAttenuationDotNL;
				float3 vPosition[4];
				float3 vDirection[4];
				float3 vFinalLighting;
				float3 vHalfDir[4];
				half4 vDotNH;
				half4 vertexVDotNH;
				half4 vDotLH;
				#endif
				
			};
			
			struct PoiVertexLights
			{
				
				float3 direction;
				float3 color;
				float attenuation;
			};
			
			struct PoiFragData
			{
				float3 baseColor;
				float3 finalColor;
				float alpha;
				float3 emission;
			};
			
			// glsl_mod behaves better on negative numbers, and
			// in some situations actually outperforms HLSL's fmod()
			#ifndef glsl_mod
			#define glsl_mod(x, y) (((x) - (y) * floor((x) / (y))))
			#endif
			
			uniform float random_uniform_float_only_used_to_stop_compiler_warnings = 0.0f;
			
			float2 poiUV(float2 uv, float4 tex_st)
			{
				return uv * tex_st.xy + tex_st.zw;
			}
			
			float2 vertexUV(in VertexOut o, int index)
			{
				switch(index)
				{
					case 0:
					return o.uv[0];
					case 1:
					return o.uv[1];
					case 2:
					return o.uv[2];
					case 3:
					return o.uv[3];
					default:
					return o.uv[0];
				}
			}
			
			float2 vertexUV(in appdata v, int index)
			{
				switch(index)
				{
					case 0:
					return v.uv0;
					case 1:
					return v.uv1;
					case 2:
					return v.uv2;
					case 3:
					return v.uv3;
					default:
					return v.uv0;
				}
			}
			
			//Lighting Helpers
			float calculateluminance(float3 color)
			{
				return color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
			}
			
			// Set by VRChat (as of open beta 1245)
			// _VRChatCameraMode: 0 => Normal, 1 => VR HandCam, 2 => Desktop Handcam, 3 => Screenshot/Photo
			// _VRChatMirrorMode: 0 => Normal, 1 => Mirror (VR), 2 => Mirror (Deskie)
			float _VRChatCameraMode;
			float _VRChatMirrorMode;
			
			float VRCCameraMode()
			{
				return _VRChatCameraMode;
			}
			
			float VRCMirrorMode()
			{
				return _VRChatMirrorMode;
			}
			
			bool IsInMirror()
			{
				return unity_CameraProjection[2][0] != 0.f || unity_CameraProjection[2][1] != 0.f;
			}
			
			bool IsOrthographicCamera()
			{
				return unity_OrthoParams.w == 1 || UNITY_MATRIX_P[3][3] == 1;
			}
			
			float shEvaluateDiffuseL1Geomerics_local(float L0, float3 L1, float3 n)
			{
				// average energy
				float R0 = max(0, L0);
				
				// avg direction of incoming light
				float3 R1 = 0.5f * L1;
				
				// directional brightness
				float lenR1 = length(R1);
				
				// linear angle between normal and direction 0-1
				//float q = 0.5f * (1.0f + dot(R1 / lenR1, n));
				//float q = dot(R1 / lenR1, n) * 0.5 + 0.5;
				float q = dot(normalize(R1), n) * 0.5 + 0.5;
				q = saturate(q); // Thanks to ScruffyRuffles for the bug identity.
				
				// power for q
				// lerps from 1 (linear) to 3 (cubic) based on directionality
				float p = 1.0f + 2.0f * lenR1 / R0;
				
				// dynamic range constant
				// should vary between 4 (highly directional) and 0 (ambient)
				float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);
				
				return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));
			}
			
			half3 BetterSH9(half4 normal)
			{
				float3 indirect;
				float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;
				indirect.r = shEvaluateDiffuseL1Geomerics_local(L0.r, unity_SHAr.xyz, normal.xyz);
				indirect.g = shEvaluateDiffuseL1Geomerics_local(L0.g, unity_SHAg.xyz, normal.xyz);
				indirect.b = shEvaluateDiffuseL1Geomerics_local(L0.b, unity_SHAb.xyz, normal.xyz);
				indirect = max(0, indirect);
				indirect += SHEvalLinearL2(normal);
				return indirect;
			}
			
			// Silent's code ends here
			
			float3 getCameraForward()
			{
				#if UNITY_SINGLE_PASS_STEREO
				float3 p1 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 1, 1));
				float3 p2 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 0, 1));
				#else
				float3 p1 = mul(unity_CameraToWorld, float4(0, 0, 1, 1)).xyz;
				float3 p2 = mul(unity_CameraToWorld, float4(0, 0, 0, 1)).xyz;
				#endif
				return normalize(p2 - p1);
			}
			
			half3 GetSHLength()
			{
				half3 x, x1;
				x.r = length(unity_SHAr);
				x.g = length(unity_SHAg);
				x.b = length(unity_SHAb);
				x1.r = length(unity_SHBr);
				x1.g = length(unity_SHBg);
				x1.b = length(unity_SHBb);
				return x + x1;
			}
			
			float3 BoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
			{
				#if UNITY_SPECCUBE_BOX_PROJECTION
				//UNITY_BRANCH
				if (cubemapPosition.w > 0)
				{
					float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
					float scalar = min(min(factors.x, factors.y), factors.z);
					direction = direction * scalar + (position - cubemapPosition.xyz);
				}
				#endif
				return direction;
			}
			
			float poiMax(float2 i)
			{
				return max(i.x, i.y);
			}
			
			float poiMax(float3 i)
			{
				return max(max(i.x, i.y), i.z);
			}
			
			float poiMax(float4 i)
			{
				return max(max(max(i.x, i.y), i.z), i.w);
			}
			
			float3 calculateNormal(in float3 baseNormal, in PoiMesh poiMesh, in Texture2D normalTexture, in float4 normal_ST, in float2 normalPan, in float normalUV, in float normalIntensity)
			{
				float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
				return normalize(
				normal.x * poiMesh.tangent[0] +
				normal.y * poiMesh.binormal[0] +
				normal.z * baseNormal
				);
			}
			
			float remap(float x, float minOld, float maxOld, float minNew = 0, float maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float2 remap(float2 x, float2 minOld, float2 maxOld, float2 minNew = 0, float2 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float3 remap(float3 x, float3 minOld, float3 maxOld, float3 minNew = 0, float3 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float4 remap(float4 x, float4 minOld, float4 maxOld, float4 minNew = 0, float4 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float remapClamped(float minOld, float maxOld, float x, float minNew = 0, float maxNew = 1)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float2 remapClamped(float2 minOld, float2 maxOld, float2 x, float2 minNew, float2 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float3 remapClamped(float3 minOld, float3 maxOld, float3 x, float3 minNew, float3 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float4 remapClamped(float4 minOld, float4 maxOld, float4 x, float4 minNew, float4 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			float2 calcParallax(in float height, in PoiCam poiCam)
			{
				return ((height * - 1) + 1) * (poiCam.tangentViewDir.xy / poiCam.tangentViewDir.z);
			}
			
			/*
			0: Zero	                float4(0.0, 0.0, 0.0, 0.0),
			1: One	                float4(1.0, 1.0, 1.0, 1.0),
			2: DstColor	            destinationColor,
			3: SrcColor	            sourceColor,
			4: OneMinusDstColor	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
			5: SrcAlpha	            sourceColor.aaaa,
			6: OneMinusSrcColor	    float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
			7: DstAlpha	            destinationColor.aaaa,
			8: OneMinusDstAlpha	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor.,
			9: SrcAlphaSaturate     saturate(sourceColor.aaaa),
			10: OneMinusSrcAlpha	float4(1.0, 1.0, 1.0, 1.0) - sourceColor.aaaa,
			*/
			
			float4 poiBlend(const float sourceFactor, const  float4 sourceColor, const  float destinationFactor, const  float4 destinationColor, const float4 blendFactor)
			{
				float4 sA = 1 - blendFactor;
				const float4 blendData[11] = {
					float4(0.0, 0.0, 0.0, 0.0),
					float4(1.0, 1.0, 1.0, 1.0),
					destinationColor,
					sourceColor,
					float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sA,
					saturate(sourceColor.aaaa),
					1 - sA,
				};
				
				return lerp(blendData[sourceFactor] * sourceColor + blendData[destinationFactor] * destinationColor, sourceColor, sA);
			}
			
			// Average
			float blendAverage(float base, float blend)
			{
				return (base + blend) / 2.0;
			}
			float3 blendAverage(float3 base, float3 blend)
			{
				return (base + blend) / 2.0;
			}
			
			// Color burn
			float blendColorBurn(float base, float blend)
			{
				return (blend == 0.0) ? blend : max((1.0 - ((1.0 - base) * rcp(random_uniform_float_only_used_to_stop_compiler_warnings + blend))), 0.0);
			}
			
			float3 blendColorBurn(float3 base, float3 blend)
			{
				return float3(blendColorBurn(base.r, blend.r), blendColorBurn(base.g, blend.g), blendColorBurn(base.b, blend.b));
			}
			
			// Color Dodge
			float blendColorDodge(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0);
			}
			
			float3 blendColorDodge(float3 base, float3 blend)
			{
				return float3(blendColorDodge(base.r, blend.r), blendColorDodge(base.g, blend.g), blendColorDodge(base.b, blend.b));
			}
			
			// Darken
			float blendDarken(float base, float blend)
			{
				return min(blend, base);
			}
			
			float3 blendDarken(float3 base, float3 blend)
			{
				return float3(blendDarken(base.r, blend.r), blendDarken(base.g, blend.g), blendDarken(base.b, blend.b));
			}
			
			// Exclusion
			float blendExclusion(float base, float blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			float3 blendExclusion(float3 base, float3 blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			
			// Reflect
			float blendReflect(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0);
			}
			
			float3 blendReflect(float3 base, float3 blend)
			{
				return float3(blendReflect(base.r, blend.r), blendReflect(base.g, blend.g), blendReflect(base.b, blend.b));
			}
			
			// Glow
			float blendGlow(float base, float blend)
			{
				return blendReflect(blend, base);
			}
			float3 blendGlow(float3 base, float3 blend)
			{
				return blendReflect(blend, base);
			}
			
			// Overlay
			float blendOverlay(float base, float blend)
			{
				return base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend));
			}
			
			float3 blendOverlay(float3 base, float3 blend)
			{
				return float3(blendOverlay(base.r, blend.r), blendOverlay(base.g, blend.g), blendOverlay(base.b, blend.b));
			}
			
			// Hard Light
			float blendHardLight(float base, float blend)
			{
				return blendOverlay(blend, base);
			}
			float3 blendHardLight(float3 base, float3 blend)
			{
				return blendOverlay(blend, base);
			}
			
			// Vivid light
			float blendVividLight(float base, float blend)
			{
				return (blend < 0.5) ? blendColorBurn(base, (2.0 * blend)) : blendColorDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendVividLight(float3 base, float3 blend)
			{
				return float3(blendVividLight(base.r, blend.r), blendVividLight(base.g, blend.g), blendVividLight(base.b, blend.b));
			}
			
			// Hard mix
			float blendHardMix(float base, float blend)
			{
				return (blendVividLight(base, blend) < 0.5) ? 0.0 : 1.0;
			}
			
			float3 blendHardMix(float3 base, float3 blend)
			{
				return float3(blendHardMix(base.r, blend.r), blendHardMix(base.g, blend.g), blendHardMix(base.b, blend.b));
			}
			
			// Lighten
			float blendLighten(float base, float blend)
			{
				return max(blend, base);
			}
			
			float3 blendLighten(float3 base, float3 blend)
			{
				return float3(blendLighten(base.r, blend.r), blendLighten(base.g, blend.g), blendLighten(base.b, blend.b));
			}
			
			// Linear Burn
			float blendLinearBurn(float base, float blend)
			{
				// Note : Same implementation as BlendSubtractf
				return max(base + blend - 1.0, 0.0);
			}
			
			float3 blendLinearBurn(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendSubtract
				return max(base + blend - float3(1.0, 1.0, 1.0), float3(0.0, 0.0, 0.0));
			}
			
			// Linear Dodge
			float blendLinearDodge(float base, float blend)
			{
				// Note : Same implementation as BlendAddf
				return min(base + blend, 1.0);
			}
			
			float3 blendLinearDodge(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendAdd
				return min(base + blend, float3(1.0, 1.0, 1.0));
			}
			
			// Linear light
			float blendLinearLight(float base, float blend)
			{
				return blend < 0.5 ? blendLinearBurn(base, (2.0 * blend)) : blendLinearDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendLinearLight(float3 base, float3 blend)
			{
				return float3(blendLinearLight(base.r, blend.r), blendLinearLight(base.g, blend.g), blendLinearLight(base.b, blend.b));
			}
			
			// Multiply
			float blendMultiply(float base, float blend)
			{
				return base * blend;
			}
			float3 blendMultiply(float3 base, float3 blend)
			{
				return base * blend;
			}
			
			// Negation
			float blendNegation(float base, float blend)
			{
				return 1.0 - abs(1.0 - base - blend);
			}
			float3 blendNegation(float3 base, float3 blend)
			{
				return float3(1.0, 1.0, 1.0) - abs(float3(1.0, 1.0, 1.0) - base - blend);
			}
			
			// Normal
			float blendNormal(float base, float blend)
			{
				return blend;
			}
			float3 blendNormal(float3 base, float3 blend)
			{
				return blend;
			}
			
			// Phoenix
			float blendPhoenix(float base, float blend)
			{
				return min(base, blend) - max(base, blend) + 1.0;
			}
			float3 blendPhoenix(float3 base, float3 blend)
			{
				return min(base, blend) - max(base, blend) + float3(1.0, 1.0, 1.0);
			}
			
			// Pin light
			float blendPinLight(float base, float blend)
			{
				return (blend < 0.5) ? blendDarken(base, (2.0 * blend)) : blendLighten(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendPinLight(float3 base, float3 blend)
			{
				return float3(blendPinLight(base.r, blend.r), blendPinLight(base.g, blend.g), blendPinLight(base.b, blend.b));
			}
			
			// Screen
			float blendScreen(float base, float blend)
			{
				return 1.0 - ((1.0 - base) * (1.0 - blend));
			}
			
			float3 blendScreen(float3 base, float3 blend)
			{
				return float3(blendScreen(base.r, blend.r), blendScreen(base.g, blend.g), blendScreen(base.b, blend.b));
			}
			
			// Soft Light
			float blendSoftLight(float base, float blend)
			{
				return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
			}
			
			float3 blendSoftLight(float3 base, float3 blend)
			{
				return float3(blendSoftLight(base.r, blend.r), blendSoftLight(base.g, blend.g), blendSoftLight(base.b, blend.b));
			}
			
			// Subtract
			float blendSubtract(float base, float blend)
			{
				return max(base - blend, 0.0);
			}
			
			float3 blendSubtract(float3 base, float3 blend)
			{
				return max(base - blend, 0.0);
			}
			
			// Difference
			float blendDifference(float base, float blend)
			{
				return abs(base - blend);
			}
			
			float3 blendDifference(float3 base, float3 blend)
			{
				return abs(base - blend);
			}
			
			// Divide
			float blendDivide(float base, float blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float3 blendDivide(float3 base, float3 blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float blendMixed(float base, float blend)
			{
				return base + base * blend;
			}
			
			float3 blendMixed(float3 base, float3 blend)
			{
				return base + base * blend;
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float customBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType, float alpha)
			{
				float3 output = base;
				switch(blendType)
				{
					case 0: output = lerp(base, blend, alpha); break;
					case 2: output = base * lerp(1, blend, alpha); break;
					case 6: output = lerp(base, blendScreen(base, blend), alpha); break;
					case 8: output = lerp(base, blendLinearDodge(base, blend), alpha); break;
					case 9: output = lerp(base, blendOverlay(base, blend), alpha); break;
					case 20: output = lerp(base, blendMixed(base, blend), alpha); break;
					default: output = 0; break;
				}
				return output;
			}
			
			#define REPLACE 0
			#define SUBSTRACT 1
			#define MULTIPLY 2
			#define DIVIDE 3
			#define MIN 4
			#define MAX 5
			#define AVERAGE 6
			#define ADD 7
			
			float maskBlend(float baseMask, float blendMask, float blendType)
			{
				float output = 0;
				switch(blendType)
				{
					case REPLACE: output = blendMask; break;
					case SUBSTRACT: output = baseMask - blendMask; break;
					case MULTIPLY: output = baseMask * blendMask; break;
					case DIVIDE: output = baseMask / blendMask; break;
					case MIN: output = min(baseMask, blendMask); break;
					case MAX: output = max(baseMask, blendMask); break;
					case AVERAGE: output = (baseMask + blendMask) * 0.5; break;
					case ADD: output = baseMask + blendMask; break;
				}
				return saturate(output);
			}
			
			float random(float2 p)
			{
				return frac(sin(dot(p, float2(12.9898, 78.2383))) * 43758.5453123);
			}
			
			float2 random2(float2 p)
			{
				return frac(sin(float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)))) * 43758.5453);
			}
			
			float3 random3(float2 p)
			{
				return frac(sin(float3(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)), dot(p, float2(248.3, 315.9)))) * 43758.5453);
			}
			
			float3 random3(float3 p)
			{
				return frac(sin(float3(dot(p, float3(127.1, 311.7, 248.6)), dot(p, float3(269.5, 183.3, 423.3)), dot(p, float3(248.3, 315.9, 184.2)))) * 43758.5453);
			}
			
			float3 randomFloat3(float2 Seed, float maximum)
			{
				return (.5 + float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed), float2(12.9898, 78.233))) * 43758.5453)
				) * .5) * (maximum);
			}
			
			float3 randomFloat3Range(float2 Seed, float Range)
			{
				return (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1) * Range;
			}
			
			float3 randomFloat3WiggleRange(float2 Seed, float Range, float wiggleSpeed)
			{
				float3 rando = (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1);
				float speed = 1 + wiggleSpeed;
				return float3(sin((_Time.x + rando.x * PI) * speed), sin((_Time.x + rando.y * PI) * speed), sin((_Time.x + rando.z * PI) * speed)) * Range;
			}
			
			void poiDither(float4 In, float4 ScreenPosition, out float4 Out)
			{
				float2 uv = ScreenPosition.xy * _ScreenParams.xy;
				float DITHER_THRESHOLDS[16] = {
					1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0,
					13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0,
					4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0,
					16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0
				};
				uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
				Out = In - DITHER_THRESHOLDS[index];
			}
			
			static const float Epsilon = 1e-10;
			// The weights of RGB contributions to luminance.
			// Should sum to unity.
			static const float3 HCYwts = float3(0.299, 0.587, 0.114);
			static const float HCLgamma = 3;
			static const float HCLy0 = 100;
			static const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
			static const float3 wref = float3(1.0, 1.0, 1.0);
			#define TAU 6.28318531
			
			float3 HUEtoRGB(in float H)
			{
				float R = abs(H * 6 - 3) - 1;
				float G = 2 - abs(H * 6 - 2);
				float B = 2 - abs(H * 6 - 4);
				return saturate(float3(R, G, B));
			}
			
			float3 RGBtoHCV(in float3 RGB)
			{
				// Based on work by Sam Hocevar and Emil Persson
				float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
				float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
				float C = Q.x - min(Q.w, Q.y);
				float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
				return float3(H, C, Q.x);
			}
			
			float3 HSVtoRGB(in float3 HSV)
			{
				float3 RGB = HUEtoRGB(HSV.x);
				return ((RGB - 1) * HSV.y + 1) * HSV.z;
			}
			
			float3 RGBtoHSV(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float S = HCV.y / (HCV.z + Epsilon);
				return float3(HCV.x, S, HCV.z);
			}
			
			float3 HSLtoRGB(in float3 HSL)
			{
				float3 RGB = HUEtoRGB(HSL.x);
				float C = (1 - abs(2 * HSL.z - 1)) * HSL.y;
				return (RGB - 0.5) * C + HSL.z;
			}
			
			float3 RGBtoHSL(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float L = HCV.z - HCV.y * 0.5;
				float S = HCV.y / (1 - abs(L * 2 - 1) + Epsilon);
				return float3(HCV.x, S, L);
			}
			
			void DecomposeHDRColor(in float3 linearColorHDR, out float3 baseLinearColor, out float exposure)
			{
				// Optimization/adaptation of https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/GUI/ColorMutator.cs#L23 but skips weird photoshop stuff
				float maxColorComponent = max(linearColorHDR.r, max(linearColorHDR.g, linearColorHDR.b));
				bool isSDR = maxColorComponent <= 1.0;
				
				float scaleFactor = isSDR ? 1.0 : (1.0 / maxColorComponent);
				exposure = isSDR ? 0.0 : log(maxColorComponent) * 1.44269504089; // ln(2)
				
				baseLinearColor = scaleFactor * linearColorHDR;
			}
			
			float3 ApplyHDRExposure(float3 linearColor, float exposure)
			{
				return linearColor * pow(2, exposure);
			}
			
			// Transforms an RGB color using a matrix. Note that S and V are absolute values here
			float3 ModifyViaHSV(float3 color, float h, float s, float v)
			{
				float3 colorHSV = RGBtoHSV(color);
				colorHSV.x = frac(colorHSV.x + h);
				colorHSV.y = saturate(colorHSV.y + s);
				colorHSV.z = saturate(colorHSV.z + v);
				return HSVtoRGB(colorHSV);
			}
			
			float3 ModifyViaHSV(float3 color, float3 HSVMod)
			{
				return ModifyViaHSV(color, HSVMod.x, HSVMod.y, HSVMod.z);
			}
			
			float3 hueShift(float3 color, float hueOffset)
			{
				color = RGBtoHSV(color);
				color.x = frac(hueOffset +color.x);
				return HSVtoRGB(color);
			}
			
			// LCH
			float xyzF(float t)
			{
				return lerp(pow(t, 1. / 3.), 7.787037 * t + 0.139731, step(t, 0.00885645));
			}
			float xyzR(float t)
			{
				return lerp(t * t * t, 0.1284185 * (t - 0.139731), step(t, 0.20689655));
			}
			
			float4x4 poiRotationMatrixFromAngles(float x, float y, float z)
			{
				float angleX = radians(x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float4x4 poiRotationMatrixFromAngles(float3 angles)
			{
				float angleX = radians(angles.x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(angles.y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(angles.z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float3 getCameraPosition()
			{
				#ifdef USING_STEREO_MATRICES
				return lerp(unity_StereoWorldSpaceCameraPos[0], unity_StereoWorldSpaceCameraPos[1], 0.5);
				#endif
				return _WorldSpaceCameraPos;
			}
			
			half2 calcScreenUVs(half4 grabPos)
			{
				half2 uv = grabPos.xy / (grabPos.w + 0.0000000001);
				#if UNITY_SINGLE_PASS_STEREO
				uv.xy *= half2(_ScreenParams.x * 2, _ScreenParams.y);
				#else
				uv.xy *= _ScreenParams.xy;
				#endif
				
				return uv;
			}
			
			float CalcMipLevel(float2 texture_coord)
			{
				float2 dx = ddx(texture_coord);
				float2 dy = ddy(texture_coord);
				float delta_max_sqr = max(dot(dx, dx), dot(dy, dy));
				
				return 0.5 * log2(delta_max_sqr);
			}
			
			float inverseLerp(float A, float B, float T)
			{
				return (T - A) / (B - A);
			}
			
			float inverseLerp2(float2 a, float2 b, float2 value)
			{
				float2 AB = b - a;
				float2 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp3(float3 a, float3 b, float3 value)
			{
				float3 AB = b - a;
				float3 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp4(float4 a, float4 b, float4 value)
			{
				float4 AB = b - a;
				float4 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			/*
			MIT License
			
			Copyright (c) 2019 wraikny
			
			Permission is hereby granted, free of charge, to any person obtaining a copy
			of this software and associated documentation files (the "Software"), to deal
			in the Software without restriction, including without limitation the rights
			to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			copies of the Software, and to permit persons to whom the Software is
			furnished to do so, subject to the following conditions:
			
			The above copyright notice and this permission notice shall be included in all
			copies or substantial portions of the Software.
			
			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			SOFTWARE.
			
			VertexTransformShader is dependent on:
			*/
			
			float4 quaternion_conjugate(float4 v)
			{
				return float4(
				v.x, -v.yzw
				);
			}
			
			float4 quaternion_mul(float4 v1, float4 v2)
			{
				float4 result1 = (v1.x * v2 + v1 * v2.x);
				
				float4 result2 = float4(
				- dot(v1.yzw, v2.yzw),
				cross(v1.yzw, v2.yzw)
				);
				
				return float4(result1 + result2);
			}
			
			// angle : radians
			float4 get_quaternion_from_angle(float3 axis, float angle)
			{
				float sn = sin(angle * 0.5);
				float cs = cos(angle * 0.5);
				return float4(axis * sn, cs);
			}
			
			float4 quaternion_from_vector(float3 inVec)
			{
				return float4(0.0, inVec);
			}
			
			float degree_to_radius(float degree)
			{
				return (
				degree / 180.0 * PI
				);
			}
			
			float3 rotate_with_quaternion(float3 inVec, float3 rotation)
			{
				float4 qx = get_quaternion_from_angle(float3(1, 0, 0), radians(rotation.x));
				float4 qy = get_quaternion_from_angle(float3(0, 1, 0), radians(rotation.y));
				float4 qz = get_quaternion_from_angle(float3(0, 0, 1), radians(rotation.z));
				
				#define MUL3(A, B, C) quaternion_mul(quaternion_mul((A), (B)), (C))
				float4 quaternion = normalize(MUL3(qx, qy, qz));
				float4 conjugate = quaternion_conjugate(quaternion);
				
				float4 inVecQ = quaternion_from_vector(inVec);
				
				float3 rotated = (
				MUL3(quaternion, inVecQ, conjugate)
				).yzw;
				
				return rotated;
			}
			
			float4 transform(float4 input, float4 pos, float4 rotation, float4 scale)
			{
				input.rgb *= (scale.xyz * scale.w);
				input = float4(rotate_with_quaternion(input.xyz, rotation.xyz * rotation.w) + (pos.xyz * pos.w), input.w);
				return input;
			}
			
			float2 RotateUV(float2 _uv, float _radian, float2 _piv, float _time)
			{
				float RotateUV_ang = _radian;
				float RotateUV_cos = cos(_time * RotateUV_ang);
				float RotateUV_sin = sin(_time * RotateUV_ang);
				return (mul(_uv - _piv, float2x2(RotateUV_cos, -RotateUV_sin, RotateUV_sin, RotateUV_cos)) + _piv);
			}
			
			/*
			MIT END
			*/
			
			float3 poiThemeColor(in PoiMods poiMods, in float3 srcColor, in float themeIndex)
			{
				if (themeIndex == 0) return srcColor;
				themeIndex -= 1;
				
				if (themeIndex <= 3)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				#endif
				
				return srcColor;
			}
			
			float3 lilToneCorrection(float3 c, float4 hsvg)
			{
				// gamma
				c = pow(abs(c), hsvg.w);
				// rgb -> hsv
				float4 p = (c.b > c.g) ? float4(c.bg, -1.0, 2.0 / 3.0) : float4(c.gb, 0.0, -1.0 / 3.0);
				float4 q = (p.x > c.r) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
				float d = q.x - min(q.w, q.y);
				float e = 1.0e-10;
				float3 hsv = float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
				// shift
				hsv = float3(hsv.x + hsvg.x, saturate(hsv.y * hsvg.y), saturate(hsv.z * hsvg.z));
				// hsv -> rgb
				return hsv.z - hsv.z * hsv.y + hsv.z * hsv.y * saturate(abs(frac(hsv.x + float3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 1.0);
			}
			
			float lilIsIn0to1(float f)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, 1.0));
			}
			
			float lilIsIn0to1(float f, float nv)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, nv));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border)
			{
				return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
			}
			
			float3 poiEdgeLinearNoSaturate(float value, float3 border)
			{
				return float3(
				(value - border.x) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.y) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.z) / clamp(fwidth(value), 0.0001, 1.0)
				);
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur)
			{
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border)
			{
				//return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
				
				float fwidthValue = fwidth(value);
				return smoothstep(border - fwidthValue, border + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinear(float value, float border)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur, borderRange));
			}
			
			float poiEdgeLinear(float value, float border)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border));
			}
			
			float poiEdgeLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur, borderRange));
			}
			// From https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl
			float3 OpenLitLinearToSRGB(float3 col)
			{
				return LinearToGammaSpace(col);
			}
			
			float3 OpenLitSRGBToLinear(float3 col)
			{
				return GammaToLinearSpace(col);
			}
			
			float OpenLitLuminance(float3 rgb)
			{
				#if defined(UNITY_COLORSPACE_GAMMA)
				return dot(rgb, float3(0.22, 0.707, 0.071));
				#else
				return dot(rgb, float3(0.0396819152, 0.458021790, 0.00609653955));
				#endif
			}
			
			float OpenLitGray(float3 rgb)
			{
				return dot(rgb, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
			}
			
			void OpenLitShadeSH9ToonDouble(float3 lightDirection, out float3 shMax, out float3 shMin)
			{
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 N = lightDirection * 0.666666;
				float4 vB = N.xyzz * N.yzzx;
				// L0 L2
				float3 res = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				res.r += dot(unity_SHBr, vB);
				res.g += dot(unity_SHBg, vB);
				res.b += dot(unity_SHBb, vB);
				res += unity_SHC.rgb * (N.x * N.x - N.y * N.y);
				// L1
				float3 l1;
				l1.r = dot(unity_SHAr.rgb, N);
				l1.g = dot(unity_SHAg.rgb, N);
				l1.b = dot(unity_SHAb.rgb, N);
				shMax = res + l1;
				shMin = res - l1;
				#if defined(UNITY_COLORSPACE_GAMMA)
				shMax = OpenLitLinearToSRGB(shMax);
				shMin = OpenLitLinearToSRGB(shMin);
				#endif
				#else
				shMax = 0.0;
				shMin = 0.0;
				#endif
			}
			
			float3 OpenLitComputeCustomLightDirection(float4 lightDirectionOverride)
			{
				float3 customDir = length(lightDirectionOverride.xyz) * normalize(mul((float3x3)unity_ObjectToWorld, lightDirectionOverride.xyz));
				return lightDirectionOverride.w ? customDir : lightDirectionOverride.xyz; // .w isn't doc'd anywhere and is always 0 unless end user changes it
				
			}
			
			float3 OpenLitLightingDirectionForSH9()
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				
				float3 lightDirectionForSH9 = sh9Dir + mainDir;
				lightDirectionForSH9 = dot(lightDirectionForSH9, lightDirectionForSH9) < 0.000001 ? 0 : normalize(lightDirectionForSH9);
				return lightDirectionForSH9;
			}
			
			float3 OpenLitLightingDirection(float4 lightDirectionOverride)
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				float3 customDir = OpenLitComputeCustomLightDirection(lightDirectionOverride);
				
				return normalize(sh9DirAbs + mainDir + customDir);
			}
			
			float3 OpenLitLightingDirection()
			{
				float4 customDir = float4(0.001, 0.002, 0.001, 0.0);
				return OpenLitLightingDirection(customDir);
			}
			
			inline float4 CalculateFrustumCorrection()
			{
				float x1 = -UNITY_MATRIX_P._31 / (UNITY_MATRIX_P._11 * UNITY_MATRIX_P._34);
				float x2 = -UNITY_MATRIX_P._32 / (UNITY_MATRIX_P._22 * UNITY_MATRIX_P._34);
				return float4(x1, x2, 0, UNITY_MATRIX_P._33 / UNITY_MATRIX_P._34 + x1 * UNITY_MATRIX_P._13 + x2 * UNITY_MATRIX_P._23);
			}
			
			inline float CorrectedLinearEyeDepth(float z, float B)
			{
				return 1.0 / (z / UNITY_MATRIX_P._34 + B);
			}
			
			//Silent's code
			float2 sharpSample(float4 texelSize, float2 p)
			{
				p = p * texelSize.zw;
				float2 c = max(0.0, fwidth(p));
				p = floor(p) + saturate(frac(p) / c);
				p = (p - 0.5) * texelSize.xy;
				return p;
			}
			
			void applyToGlobalMask(inout PoiMods poiMods, int index, int blendType, float val)
			{
				float valBlended = saturate(maskBlend(poiMods.globalMask[index], val, blendType));
				switch(index)
				{
					case 0: poiMods.globalMask[0] = valBlended; break;
					case 1: poiMods.globalMask[1] = valBlended; break;
					case 2: poiMods.globalMask[2] = valBlended; break;
					case 3: poiMods.globalMask[3] = valBlended; break;
					case 4: poiMods.globalMask[4] = valBlended; break;
					case 5: poiMods.globalMask[5] = valBlended; break;
					case 6: poiMods.globalMask[6] = valBlended; break;
					case 7: poiMods.globalMask[7] = valBlended; break;
					case 8: poiMods.globalMask[8] = valBlended; break;
					case 9: poiMods.globalMask[9] = valBlended; break;
					case 10: poiMods.globalMask[10] = valBlended; break;
					case 11: poiMods.globalMask[11] = valBlended; break;
					case 12: poiMods.globalMask[12] = valBlended; break;
					case 13: poiMods.globalMask[13] = valBlended; break;
					case 14: poiMods.globalMask[14] = valBlended; break;
					case 15: poiMods.globalMask[15] = valBlended; break;
				}
			}
			
			void assignValueToVectorFromIndex(inout float4 vec, int index, float value)
			{
				switch(index)
				{
					case 0: vec[0] = value; break;
					case 1: vec[1] = value; break;
					case 2: vec[2] = value; break;
					case 3: vec[3] = value; break;
				}
			}
			
			// SNose
			float3 mod289(float3 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float2 mod289(float2 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float3 permute(float3 x)
			{
				return mod289(((x * 34.0) + 1.0) * x);
			}
			
			float snoise(float2 v)
			{
				const float4 C = float4(0.211324865405187, // (3.0-sqrt(3.0))/6.0
				0.366025403784439, // 0.5*(sqrt(3.0)-1.0)
				- 0.577350269189626, // -1.0 + 2.0 * C.x
				0.024390243902439); // 1.0 / 41.0
				float2 i = floor(v + dot(v, C.yy));
				float2 x0 = v - i + dot(i, C.xx);
				float2 i1;
				i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
				float4 x12 = x0.xyxy + C.xxzz;
				x12.xy -= i1;
				i = mod289(i); // Avoid truncation effects in permutation
				float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0))
				+ i.x + float3(0.0, i1.x, 1.0));
				
				float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
				m = m * m ;
				m = m * m ;
				float3 x = 2.0 * frac(p * C.www) - 1.0;
				float3 h = abs(x) - 0.5;
				float3 ox = floor(x + 0.5);
				float3 a0 = x - ox;
				m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
				float3 g;
				g.x = a0.x * x0.x + h.x * x0.y;
				g.yz = a0.yz * x12.xz + h.yz * x12.yw;
				return 130.0 * dot(m, g);
			}
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			
			// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.
			float4 AudioLinkDataMultiline(uint2 xycoord) { return AudioLinkData(uint2(xycoord.x % AUDIOLINK_WIDTH, xycoord.y + xycoord.x/AUDIOLINK_WIDTH)); }
			
			// Mechanism to sample between two adjacent pixels and lerp between them, like "linear" supesampling
			float4 AudioLinkLerp(float2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(xy+int2(1,0)), frac( xy.x ) ); }
			
			// Same as AudioLinkLerp but properly handles multiline reading.
			float4 AudioLinkLerpMultiline(float2 xy) { return lerp(AudioLinkDataMultiline(xy), AudioLinkDataMultiline(xy+float2(1,0)), frac(xy.x)); }
			
			//Tests to see if Audio Link texture is available
			bool AudioLinkIsAvailable()
			{
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				int width, height;
				_AudioTexture.GetDimensions(width, height);
				return width > 16;
				#else
				return _AudioTexture_TexelSize.z > 16;
				#endif
			}
			
			//Get version of audiolink present in the world, 0 if no audiolink is present
			float AudioLinkGetVersion()
			{
				int2 dims;
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				_AudioTexture.GetDimensions(dims.x, dims.y);
				#else
				dims = _AudioTexture_TexelSize.zw;
				#endif
				
				if (dims.x >= 128)
				return AudioLinkData(ALPASS_GENERALVU).x;
				else if (dims.x > 16)
				return 1;
				else
				return 0;
			}
			
			// This pulls data from this texture.
			#define AudioLinkGetSelfPixelData(xy) _SelfTexture2D[xy]
			
			// Extra utility functions for time.
			uint AudioLinkDecodeDataAsUInt(uint2 indexloc)
			{
				uint4 rpx = AudioLinkData(indexloc);
				return rpx.r + rpx.g*1024 + rpx.b * 1048576 + rpx.a * 1073741824;
			}
			
			//Note: This will truncate time to every 134,217.728 seconds (~1.5 days of an instance being up) to prevent floating point aliasing.
			// if your code will alias sooner, you will need to use a different function.  It should be safe to use this on all times.
			float AudioLinkDecodeDataAsSeconds(uint2 indexloc)
			{
				uint time = AudioLinkDecodeDataAsUInt(indexloc) & 0x7ffffff;
				//Can't just divide by float.  Bug in Unity's HLSL compiler.
				return float(time / 1000) + float( time % 1000 ) / 1000.;
			}
			
			#define ALDecodeDataAsSeconds( x ) AudioLinkDecodeDataAsSeconds( x )
			#define ALDecodeDataAsUInt( x ) AudioLinkDecodeDataAsUInt( x )
			
			float AudioLinkRemap(float t, float a, float b, float u, float v) { return ((t-a) / (b-a)) * (v-u) + u; }
			
			float3 AudioLinkHSVtoRGB(float3 HSV)
			{
				float3 RGB = 0;
				float C = HSV.z * HSV.y;
				float H = HSV.x * 6;
				float X = C * (1 - abs(fmod(H, 2) - 1));
				if (HSV.y != 0)
				{
					float I = floor(H);
					if (I == 0) { RGB = float3(C, X, 0); }
					else if (I == 1) { RGB = float3(X, C, 0); }
					else if (I == 2) { RGB = float3(0, C, X); }
					else if (I == 3) { RGB = float3(0, X, C); }
					else if (I == 4) { RGB = float3(X, 0, C); }
					else { RGB = float3(C, 0, X); }
				}
				float M = HSV.z - C;
				return RGB + M;
			}
			
			float3 AudioLinkCCtoRGB(float bin, float intensity, int rootNote)
			{
				float note = bin / AUDIOLINK_EXPBINS;
				
				float hue = 0.0;
				note *= 12.0;
				note = glsl_mod(4. - note + rootNote, 12.0);
				{
					if(note < 4.0)
					{
						//Needs to be YELLOW->RED
						hue = (note) / 24.0;
					}
					else if(note < 8.0)
					{
						//            [4]  [8]
						//Needs to be RED->BLUE
						hue = (note-2.0) / 12.0;
					}
					else
					{
						//             [8] [12]
						//Needs to be BLUE->YELLOW
						hue = (note - 4.0) / 8.0;
					}
				}
				float val = intensity - 0.1;
				return AudioLinkHSVtoRGB(float3(fmod(hue, 1.0), 1.0, clamp(val, 0.0, 1.0)));
			}
			
			// Sample the amplitude of a given frequency in the DFT, supports frequencies in [13.75; 14080].
			float4 AudioLinkGetAmplitudeAtFrequency(float hertz)
			{
				float note = AUDIOLINK_EXPBINS * log2(hertz / AUDIOLINK_BOTTOM_FREQUENCY);
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(note, 0));
			}
			
			// Sample the amplitude of a given semitone in an octave. Octave is in [0; 9] while note is [0; 11].
			float AudioLinkGetAmplitudeAtNote(float octave, float note)
			{
				float quarter = note * 2.0;
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(octave * AUDIOLINK_EXPBINS + quarter, 0));
			}
			
			// Get a reasonable drop-in replacement time value for _Time.y with the
			// given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTime(uint index, uint band)
			{
				return (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY + uint2(index, band))) / 100000.0;
			}
			
			// Get a chronotensity value in the interval [0; 1], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeNormalized(uint index, uint band, float speed)
			{
				return frac(AudioLinkGetChronoTime(index, band) * speed);
			}
			
			// Get a chronotensity value in the interval [0; interval], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeInterval(uint index, uint band, float speed, float interval)
			{
				return AudioLinkGetChronoTimeNormalized(index, band, speed) * interval;
			}
			
			float getBandAtTime(float band, float time, float size = 1.0f)
			{
				//return remap(UNITY_SAMPLE_TEX2D(_AudioTexture, float2(time * width, band/128.0)).r, min(size,.9999), 1);
				return remapClamped(min(size,.9999), 1, AudioLinkData(ALPASS_AUDIOBASS + uint2(time * AUDIOLINK_WIDTH,band)).r);
			}
			
			fixed3 maximize(fixed3 c) {
				if (c.x == 0 && c.y == 0 && c.z == 0)
				return fixed3(1.0, 1.0, 1.0);
				else
				return c / max(c.r, max(c.g, c.b));
			}
			
			bool LumaIsAvailable()
			{
				return LumaData(0.629, 0.511).r > 0.9;
			}
			
			float3 getLumaGradient(uint index, float offset) {
				return LumaData(0.57 + (index * 0.11) + lerp(0, 0.107, offset), 0.493);
			}
			
			void initPoiAudioLink(inout PoiMods poiMods)
			{
				if (!_AudioLinkAnimToggle) return;
				
				if (AudioLinkIsAvailable())
				{
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkVersion = AudioLinkGetVersion();
					poiMods.audioLink[0] = _AudioLinkSmoothingBass    == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 0))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingBass   ) * 15.95, 0))[0];
					poiMods.audioLink[1] = _AudioLinkSmoothingLowMid  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 1))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingLowMid ) * 15.95, 1))[0];
					poiMods.audioLink[2] = _AudioLinkSmoothingHighMid == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 2))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingHighMid) * 15.95, 2))[0];
					poiMods.audioLink[3] = _AudioLinkSmoothingTreble  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 3))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingTreble ) * 15.95, 3))[0];
					/*
					poiMods.globalColorTheme[4] = AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) );
					poiMods.globalColorTheme[5] = AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) );
					poiMods.globalColorTheme[6] = AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) );
					poiMods.globalColorTheme[7] = AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) );
					
					poiMods.globalColorTheme[4] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) )),1.0);
					poiMods.globalColorTheme[5] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) )),1.0);
					poiMods.globalColorTheme[6] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) )),1.0);
					poiMods.globalColorTheme[7] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) )),1.0);
					*/
					
					poiMods.globalColorTheme[4] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(2, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[5] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(3, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[6] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(4, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[7] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(5, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					
					poiMods.globalColorTheme[8] = AudioLinkData(ALPASS_THEME_COLOR0);
					poiMods.globalColorTheme[9] = AudioLinkData(ALPASS_THEME_COLOR1);
					poiMods.globalColorTheme[10] = AudioLinkData(ALPASS_THEME_COLOR2);
					poiMods.globalColorTheme[11] = AudioLinkData(ALPASS_THEME_COLOR3);
					return;
				}
				
				if (LumaIsAvailable())
				{
					// Gradients:
					// 0.570 - 0.677, 0.493
					// 0.680 - 0.788, 0.493
					// 0.791 - 0.898, 0.493
					float4 audioPixel = LumaData(0.578, 0.515);
					float audioLows = audioPixel.r;
					float audioHighs = audioPixel.g;
					float4 zone1 = LumaData(0.856, 0.522);
					float4 zone2 = LumaData(0.856, 0.507);
					float4 zone3 = LumaData(0.864, 0.522);
					float4 zone4 = LumaData(0.864, 0.507);
					// float4 lumaEnabledPixel = LumaData(0.629, 0.511);
					// float fakeLight = (lumaEnabledPixel.g > 0) ? 1 : (1 - lumaEnabledPixel.r);
					
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkViaLuma = true;
					poiMods.audioLink.xy = audioLows;
					poiMods.audioLink.zw = audioHighs;
					
					poiMods.globalColorTheme[8] = zone1;
					poiMods.globalColorTheme[9] = zone2;
					poiMods.globalColorTheme[10] = zone3;
					poiMods.globalColorTheme[11] = zone4;
				}
			}
			
			void DebugVisualizer(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods){
				if (_DebugWaveform){
					float waveform = AudioLinkLerpMultiline(ALPASS_WAVEFORM + float2( 500. * poiMesh.uv[0].x, 0)).r;
					poiFragData.emission += clamp(1 - 50 * abs(waveform - poiMesh.uv[0].y * 2. + 1), 0, 1);
				}
				if (_DebugDFT){
					poiFragData.emission += AudioLinkLerpMultiline(ALPASS_DFT + uint2(poiMesh.uv[0].x * AUDIOLINK_ETOTALBINS, 0)).rrr;
				}
				if (_DebugBass){
					poiFragData.emission += poiMods.audioLink.x;
				}
				if (_DebugLowMids){
					poiFragData.emission += poiMods.audioLink.y;
				}
				if (_DebugHighMids){
					poiFragData.emission += poiMods.audioLink.z;
				}
				if (_DebugTreble){
					poiFragData.emission += poiMods.audioLink.w;
				}
				if (_DebugCCColors){
					poiFragData.emission += AudioLinkData(ALPASS_CCCOLORS + uint2(3 + 1, 0));
				}
				if (_DebugCCStrip){
					poiFragData.emission += AudioLinkLerp(ALPASS_CCSTRIP + float2(poiMesh.uv[0].x * AUDIOLINK_WIDTH, 0));
				}
				if (_DebugCCLights){
					poiFragData.emission += AudioLinkData(ALPASS_CCLIGHTS + uint2(uint(poiMesh.uv[0].x * 8) + uint(poiMesh.uv[0].y * 16) * 8, 0));
				}
				if (_DebugAutocorrelator){
					poiFragData.emission += saturate(AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2((abs(1. - poiMesh.uv[0].x * 2.)) * AUDIOLINK_WIDTH, 0)).rrr);
				}
				if (_DebugChronotensity){
					poiFragData.emission += (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY  + uint2(1, 0)) % 1000000) / 1000000.0;
				}
			}
			
			void SetupAudioLink(inout PoiFragData poiFragData, inout PoiMods poiMods, in PoiMesh poiMesh){
				initPoiAudioLink(poiMods);
				DebugVisualizer(poiFragData, poiMesh, poiMods);
				
				if(_AudioLinkCCStripY)
				{
					poiFragData.emission += AudioLinkLerp( ALPASS_CCSTRIP + float2( poiMesh.uv[0].y * AUDIOLINK_WIDTH, 0 ) ).rgb * .5;
				}
			}
			
			#endif
			//endex
			
			//ifex _EnableDepthBulge==0
			#if defined(POI_DEPTHBULGE)
			void applyDepthBulgeFX(inout VertexOut o)
			{
				float4 pos = UnityObjectToClipPos(o.localPos);
				float4 grabPos = ComputeGrabScreenPos(pos);
				float depth = SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, float4(grabPos.xy / grabPos.w, 0, 0));
				
				#if defined(PROP_DEPTHBULGEMASK) || !defined(OPTIMIZER_ENABLED)
				float depthBulgeMask = tex2Dlod(_DepthBulgeMask, float4(poiUV(vertexUV(o, _DepthBulgeMaskUV), _DepthBulgeMask_ST), 0, 0))[_DepthBulgeMaskChannel];
				#else
				float depthBulgeMask = 1.0;
				#endif
				
				depth = Linear01Depth(depth);
				
				float intersect = 0;
				if (depth != 1)
				{
					float diff = distance(depth, Linear01Depth(pos.z / pos.w));
					if (diff > 0)
					{
						intersect = 1 - smoothstep(0, _ProjectionParams.w * _DepthBulgeFadeLength, diff);
					}
				}
				float4 offset = intersect * _DepthBulgeHeight * float4(o.normal, 0);
				
				offset = IsInMirror() ? 0 : offset;
				offset *= depthBulgeMask;
				
				o.worldPos.xyz += offset.xyz;
				o.localPos.xyz += mul(unity_WorldToObject, float4(offset.xyz, 0)).xyz;
			}
			#endif
			//endex
			
			VertexOut vert(
			#ifndef POI_TESSELLATED
			appdata v
			#else
			tessAppData v
			#endif
			)
			{
				UNITY_SETUP_INSTANCE_ID(v);
				VertexOut o;
				PoiInitStruct(VertexOut, o);
				UNITY_TRANSFER_INSTANCE_ID(v, o);
				#ifdef POI_TESSELLATED
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v);
				#endif
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
				
				//ifex _EnableUDIMDiscardOptions==0
				#ifdef POI_UDIMDISCARD
				UNITY_BRANCH
				if(_UDIMDiscardMode == 0) // Discard Vertices instead of just pixels
				{
					// Branchless (inspired by s-ilent)
					float2 udim = 0;
					// Select UV
					udim += (v.uv0.xy * (_UDIMDiscardUV == 0));
					udim += (v.uv1.xy * (_UDIMDiscardUV == 1));
					udim += (v.uv2.xy * (_UDIMDiscardUV == 2));
					udim += (v.uv3.xy * (_UDIMDiscardUV == 3));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 0, but not exactly 0
					const float threshold = 0.001;
					if(isDiscarded > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _VertexManipulationsEnabled==0
				#ifdef AUTO_EXPOSURE
				float4 audioLinkBands = 0;
				float3 ALrotation = 0;
				float3 ALLocalTranslation = 0;
				float3 CTALRotation = 0;
				float3 ALScale = 0;
				float3 ALWorldTranslation = 0;
				float ALHeight = 0;
				float ALRoundingAmount = 0;
				float4 ALSpectrumLocalOffset = float4(0, 0, 0, 0);
				#ifdef POI_AUDIOLINK
				if (AudioLinkIsAvailable() && _VertexAudioLinkEnabled && _AudioLinkAnimToggle)
				{
					audioLinkBands.x = AudioLinkData(ALPASS_AUDIOBASS).r;
					audioLinkBands.y = AudioLinkData(ALPASS_AUDIOLOWMIDS).r;
					audioLinkBands.z = AudioLinkData(ALPASS_AUDIOHIGHMIDS).r;
					audioLinkBands.w = AudioLinkData(ALPASS_AUDIOTREBLE).r;
					
					if (any(_VertexLocalTranslationALMin) || any(_VertexLocalTranslationALMax))
					{
						ALLocalTranslation = lerp(_VertexLocalTranslationALMin, _VertexLocalTranslationALMax, audioLinkBands[_VertexLocalTranslationALBand]);
					}
					if (any(_VertexLocalRotationAL))
					{
						ALrotation = audioLinkBands[_VertexLocalRotationALBand] * _VertexLocalRotationAL;
					}
					if (any(_VertexLocalRotationCTALSpeed))
					{
						CTALRotation.x = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeX, _VertexLocalRotationCTALBandX) * _VertexLocalRotationCTALSpeed.x * 360;
						CTALRotation.y = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeY, _VertexLocalRotationCTALBandY) * _VertexLocalRotationCTALSpeed.y * 360;
						CTALRotation.z = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeZ, _VertexLocalRotationCTALBandZ) * _VertexLocalRotationCTALSpeed.z * 360;
					}
					if (any(_VertexLocalScaleALMin) || any(_VertexLocalScaleALMax))
					{
						ALScale = lerp(_VertexLocalScaleALMin.xyz + _VertexLocalScaleALMin.w, _VertexLocalScaleALMax.xyz + _VertexLocalScaleALMax.w, audioLinkBands[_VertexLocalScaleALBand]);
					}
					if (any(_VertexWorldTranslationALMin) || any(_VertexWorldTranslationALMax))
					{
						ALWorldTranslation = lerp(_VertexWorldTranslationALMin, _VertexWorldTranslationALMax, audioLinkBands[_VertexWorldTranslationALBand]);
					}
					if (any(_VertexManipulationHeightAL))
					{
						ALHeight = lerp(_VertexManipulationHeightAL.x, _VertexManipulationHeightAL.y, audioLinkBands[_VertexManipulationHeightBand]);
					}
					if (any(_VertexRoundingRangeAL))
					{
						ALRoundingAmount = lerp(_VertexRoundingRangeAL.x, _VertexRoundingRangeAL.y, audioLinkBands[_VertexRoundingRangeBand]);
					}
					if (_VertexSpectrumMotion)
					{
						ALSpectrumLocalOffset.xyz = lerp(_VertexSpectrumOffsetMin.xyz, _VertexSpectrumOffsetMax.xyz, AudioLinkLerpMultiline(ALPASS_DFT + float2(vertexUV(v, _VertexSpectrumUV)[_VertexSpectrumUVDirection] * AUDIOLINK_ETOTALBINS, 0.)));
					}
				}
				#endif
				
				// Local Transformation
				float4 rotation = float4(_VertexManipulationLocalRotation.xyz + float3(180, 0, 0) + _VertexManipulationLocalRotationSpeed * _Time.x + ALrotation + CTALRotation, _VertexManipulationLocalRotation.w);
				v.normal = rotate_with_quaternion(v.normal, rotation.xyz);
				v.tangent.xyz = rotate_with_quaternion(v.tangent.xyz, rotation.xyz);
				v.vertex = transform(v.vertex, _VertexManipulationLocalTranslation + float4(ALLocalTranslation, 0) + ALSpectrumLocalOffset, rotation, _VertexManipulationLocalScale + float4(ALScale, 0));
				o.normal = UnityObjectToWorldNormal(v.normal);
				
				#if defined(PROP_VERTEXMANIPULATIONHEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float3 heightOffset = (tex2Dlod(_VertexManipulationHeightMask, float4(poiUV(vertexUV(v, _VertexManipulationHeightMaskUV), _VertexManipulationHeightMask_ST) + _VertexManipulationHeightMaskPan * _Time.x, 0, 0))[_VertexManipulationHeightMaskChannel] - _VertexManipulationHeightBias) * (_VertexManipulationHeight + ALHeight) * o.normal;
				#else
				float3 heightOffset = (_VertexManipulationHeight + ALHeight) * o.normal;
				#endif
				
				if (_VertexBarrelMode)
				{
					v.vertex.xz = lerp(v.vertex.xz, normalize(v.vertex.xz) * _VertexBarrelWidth + v.vertex.xz * _VertexBarrelHeight, _VertexBarrelAlpha);
				}
				
				if (_VertexSphereMode)
				{
					v.vertex.xyz = lerp(v.vertex.xyz, normalize(v.vertex.xyz + _VertexSphereCenter.xyz) * _VertexSphereRadius + v.vertex.xyz * _VertexSphereHeight, _VertexSphereAlpha);
				}
				
				v.vertex.xyz += mul(unity_WorldToObject, _VertexManipulationWorldTranslation.xyz + ALWorldTranslation + heightOffset).xyz;
				
				// rounding
				UNITY_BRANCH
				if (_VertexRoundingEnabled)
				{
					float divisionAmount = max(_VertexRoundingDivision + ALRoundingAmount, 0.0000001);
					float3 vertexPos = v.vertex.xyz;
					if (_VertexRoundingSpace == 0)
					{
						vertexPos = mul(unity_ObjectToWorld, v.vertex.xyz);
					}
					float3 worldRoundPosition = (ceil(vertexPos / divisionAmount) * divisionAmount) - divisionAmount * .5;
					v.vertex.xyz = worldRoundPosition;
					if (_VertexRoundingSpace == 0)
					{
						v.vertex.xyz = mul(unity_WorldToObject, worldRoundPosition);
					}
				}
				#endif
				//endex
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				UNITY_BRANCH
				if(_UVTileDissolveEnabled && _UVTileDissolveDiscardAtMax)
				{
					// Branchless (inspired by s-ilent)
					float2 dissolveUdim = 0;
					// Select UV
					dissolveUdim += (v.uv0.xy * (_UVTileDissolveUV == 0));
					dissolveUdim += (v.uv1.xy * (_UVTileDissolveUV == 1));
					dissolveUdim += (v.uv2.xy * (_UVTileDissolveUV == 2));
					dissolveUdim += (v.uv3.xy * (_UVTileDissolveUV == 3));
					
					float isDiscardedFromDissolve = 0;
					float4 xMaskDissolve = float4(  (dissolveUdim.x >= 0 && dissolveUdim.x < 1),
					(dissolveUdim.x >= 1 && dissolveUdim.x < 2),
					(dissolveUdim.x >= 2 && dissolveUdim.x < 3),
					(dissolveUdim.x >= 3 && dissolveUdim.x < 4));
					
					isDiscardedFromDissolve += (dissolveUdim.y >= 0 && dissolveUdim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 1 && dissolveUdim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 2 && dissolveUdim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 3 && dissolveUdim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMaskDissolve);
					
					isDiscardedFromDissolve *= any(float4(dissolveUdim.y >= 0, dissolveUdim.y < 4, dissolveUdim.x >= 0, dissolveUdim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 1, but not exactly 1
					const float threshold = 0.999;
					if(isDiscardedFromDissolve > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				float notVisible = 0;
				
				if (_VisibilityMode == 1) // VRC
				{
					float mirrorMode = VRCMirrorMode();
					float cameraMode = VRCCameraMode();
					
					notVisible += (!_VisibilityVRCRegular 		&& ((mirrorMode == 0) && (cameraMode == 0)));
					notVisible += (!_VisibilityVRCMirrorVR 		&&  (mirrorMode == 1));
					notVisible += (!_VisibilityVRCMirrorDesktop &&  (mirrorMode == 2));
					notVisible += (!_VisibilityVRCCameraVR			&& (cameraMode == 1));
					notVisible += (!_VisibilityVRCCameraDesktop 	&& (cameraMode == 2));
					notVisible += (!_VisibilityVRCCameraScreenshot 	&& (cameraMode == 3));
				}
				else if (_Mirror != 0) // Generic (CVR, etc)
				{
					notVisible += (_Mirror == 1) ^ IsInMirror();
				}
				
				if(notVisible) // Early Return skips rest of vertex shader
				{
					return (VertexOut)POI_NAN;
				}
				#endif
				//endex
				
				o.objectPos = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
				o.objNormal = v.normal;
				o.normal = UnityObjectToWorldNormal(v.normal);
				o.tangent = UnityObjectToWorldDir(v.tangent);
				
				o.binormal = cross(o.normal, o.tangent) * (v.tangent.w * unity_WorldTransformParams.w);
				o.vertexColor = v.color;
				
				o.uv[0] = v.uv0;
				o.uv[1] = v.uv1;
				o.uv[2] = v.uv2;
				o.uv[3] = v.uv3;
				
				#if defined(LIGHTMAP_ON)
				o.lightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
				#endif
				#ifdef DYNAMICLIGHTMAP_ON
				o.lightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
				#endif
				
				o.localPos = v.vertex;
				o.worldPos = mul(unity_ObjectToWorld, o.localPos);
				
				float3 localOffset = float3(0, 0, 0);
				float3 worldOffset = float3(0, 0, 0);
				
				//ifex _VertexGlitchingEnabled==0
				#if defined(POI_VERTEX_GLITCHING)
				
				bool canGlitch = true;
				if (_VertexGlitchMirrorEnable && _VertexGlitchMirror > 0)
				{
					bool inMirror = IsInMirror();
					if (_VertexGlitchMirror == 1 && !inMirror)	canGlitch = false;
					if (_VertexGlitchMirror == 2 && inMirror)	canGlitch = false;
				}
				if (canGlitch)
				{
					float3 forward = getCameraPosition() - mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
					forward.y = 0;
					forward = normalize(forward);
					float3 glitchDirection = normalize(cross(float3(0, 1, 0), forward));
					
					float glitchAmount = 0;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE)
					// if(_VertexGlitchingUseTexture)
					// {
					float uvl = o.worldPos.y * _VertexGlitchDensity + _Time.x * _VertexGlitchMapPanSpeed;
					float uvr = o.worldPos.y * _VertexGlitchDensity - _Time.x * _VertexGlitchMapPanSpeed;
					
					float3 glitchTextureL = 1;
					float3 glitchTextureR = 1;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE) || !defined(OPTIMIZER_ENABLED)
					glitchTextureL = tex2Dlod(_VertexGlitchMap, float4(uvl, uvl, 0, 0)).rgb;
					glitchTextureR = tex2Dlod(_VertexGlitchMap, float4(uvr, uvr, 0, 0)).rgb;
					#endif
					
					glitchAmount += (glitchTextureL.r - 0.5) * 2;
					glitchAmount += - (glitchTextureR.r - 0.5) * 2;
					
					glitchAmount += (glitchTextureL.g - 0.5) * 2;
					glitchAmount += - (glitchTextureR.b - 0.5) * 2;
					// } else {
					#else
					glitchAmount += frac(sin(dot(_Time.xy + o.worldPos.y, float2(12.9898, 78.233))) * 43758.5453123) * 2 - 1;
					// }
					#endif
					
					float time = _Time.y * _VertexGlitchFrequency;
					
					float randomGlitch = (sin(time) + sin(2.2 * time + 5.52) + sin(2.9 * time + 0.93) + sin(4.6 * time + 8.94)) / 4;
					float3 glitchOffset = 0;
					
					#ifdef POI_AUDIOLINK
					if (AudioLinkIsAvailable() && _VertexGlitchingAudioLinkEnabled)
					{
						// float4 audioLinkData = AudioLinkData(ALPASS_AUDIOBASS);
						
						float audioIntensity =
						AudioLinkData(ALPASS_AUDIOBASS).r 		* (_VertexGlitchingAudioLinkBand == 0) +
						AudioLinkData(ALPASS_AUDIOLOWMIDS).r 	* (_VertexGlitchingAudioLinkBand == 1) +
						AudioLinkData(ALPASS_AUDIOHIGHMIDS).r	* (_VertexGlitchingAudioLinkBand == 2) +
						AudioLinkData(ALPASS_AUDIOTREBLE).r 	* (_VertexGlitchingAudioLinkBand == 3) +
						AudioLinkData(ALPASS_FILTEREDVU_INTENSITY).r * (_VertexGlitchingAudioLinkBand == 4);
						
						if(_VertexGlitchingAudiolinkOverride)
						{
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
							// glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						} else {
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
							glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						}
					} else {
						glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					}
					#else
					glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					#endif
					
					localOffset += glitchOffset;
					worldOffset += mul(unity_ObjectToWorld, glitchOffset);
				}
				#endif
				//endex
				
				o.localPos.rgb += localOffset;
				o.worldPos.rgb += worldOffset;
				
				//ifex _EnableDepthBulge==0
				#if defined(POI_DEPTHBULGE) && (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				applyDepthBulgeFX(o);
				#endif
				//endex
				
				o.pos = UnityObjectToClipPos(o.localPos);
				
				#ifdef POI_PASS_OUTLINE
				#if defined(UNITY_REVERSED_Z)
				//DX
				o.pos.z += _Offset_Z * - 0.01;
				#else
				//OpenGL
				o.pos.z += _Offset_Z * 0.01;
				#endif
				#endif
				o.grabPos = ComputeGrabScreenPos(o.pos);
				
				#ifndef FORWARD_META_PASS
				#if !defined(UNITY_PASS_SHADOWCASTER)
				UNITY_TRANSFER_SHADOW(o, o.uv[0].xy);
				#else
				v.vertex.xyz = o.localPos.xyz;
				TRANSFER_SHADOW_CASTER_NOPOS(o, o.pos);
				#endif
				#endif
				
				UNITY_TRANSFER_FOG(o, o.pos);
				
				if (_RenderingReduceClipDistance)
				{
					if (o.pos.w < _ProjectionParams.y * 1.01 && o.pos.w > 0)
					{
						o.pos.z = o.pos.z * 0.0001 + o.pos.w * 0.999;
					}
				}
				
				#ifdef POI_PASS_META
				o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
				#endif
				
				#if defined(GRAIN)
				float4 worldDirection;
				
				worldDirection.xyz = o.worldPos.xyz - _WorldSpaceCameraPos;
				worldDirection.w = dot(o.pos, CalculateFrustumCorrection());
				o.worldDirection = worldDirection;
				#endif
				return o;
			}
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, uv) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan)) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			#if defined(_STOCHASTICMODE_HEXTILE)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, uv, false) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false, dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			#ifndef POI2D_SAMPLER_STOCHASTIC
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (POI2D_SAMPLER(tex, texSampler, uv))
			#endif
			#ifndef POI2D_SAMPLER_PAN_STOCHASTIC
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#endif
			#ifndef POI2D_SAMPLER_PANGRAD_STOCHASTIC
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_SAMPLER_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_SAMPLER_PAN_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// #define POI2D_MAINTEX_SAMPLER_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_MAINTEX_SAMPLER_PAN_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// Deliot, Heitz 2019 - Fast, but non-histogram-preserving (ends up looking a bit blurry and lower contrast)
			// https://eheitzresearch.wordpress.com/738-2/
			
			// Classic Magic Numbers fracsin
			#if !defined(_STOCHASTICMODE_NONE)
			float2 StochasticHash2D2D (float2 s)
			{
				return frac(sin(glsl_mod(float2(dot(s, float2(127.1,311.7)), dot(s, float2(269.5,183.3))), 3.14159)) * 43758.5453);
			}
			#endif
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			// UV Offsets and blend weights
			// UVBW[0...2].xy = UV Offsets
			// UVBW[0...2].z = Blend Weights
			float3x3 DeliotHeitzStochasticUVBW(float2 uv)
			{
				// UV transformed into triangular grid space with UV scaled by approximation of 2*sqrt(3)
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewUV = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticDeliotHeitzDensity);
				
				// Vertex IDs and barycentric coords
				float2 vxID = floor(skewUV);
				float3 bary = float3(frac(skewUV), 0);
				bary.z = 1.0 - bary.x - bary.y;
				
				float3x3 pos = float3x3(
				float3(vxID, 				bary.z),
				float3(vxID + float2(0, 1), bary.y),
				float3(vxID + float2(1, 0), bary.x)
				);
				
				float3x3 neg = float3x3(
				float3(vxID + float2(1, 1), 	 -bary.z),
				float3(vxID + float2(1, 0), 1.0 - bary.y),
				float3(vxID + float2(0, 1), 1.0 - bary.x)
				);
				
				return (bary.z > 0) ? pos : neg;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, float2 dx, float2 dy)
			{
				// UVBW[0...2].xy = UV Offsets
				// UVBW[0...2].z = Blend Weights
				float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
				
				//blend samples with calculated weights
				return 	mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv)
			{
				float2 dx = ddx(uv), dy = ddy(uv);
				return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
			}
			#endif // defined(_STOCHASTICMODE_DELIOT_HEITZ)
			
			#if defined(_STOCHASTICMODE_HEXTILE)
			// HexTiling: Slower, but histogram-preserving
			// SPDX-License-Idenfitier: MIT
			// Copyright (c) 2022 mmikk
			// https://github.com/mmikk/hextile-demo
			float2 HextileMakeCenUV(float2 vertex)
			{
				// 0.288675 ~= 1/(2*sqrt(3))
				const float2x2 stochasticInverseSkewedGrid = float2x2(1.0, 0.5, 0.0, 1.0/1.15470054);
				return mul(stochasticInverseSkewedGrid, vertex) * 0.288675;
			}
			
			float2x2 HextileLoadRot2x2(float2 idx, float rotStrength)
			{
				float angle = abs(idx.x * idx.y) + abs(idx.x + idx.y) + PI;
				
				// remap to +/-pi
				angle = glsl_mod(angle, 2 * PI);
				if(angle < 0)  angle += 2 * PI;
				if(angle > PI) angle -= 2 * PI;
				
				angle *= rotStrength;
				
				float cs = cos(angle), si = sin(angle);
				return float2x2(cs, -si, si, cs);
			}
			
			// UV Offsets and base blend weights
			// UVBWR[0...2].xy = UV Offsets
			// UVBWR[0...2].zw = rotation costh/sinth -> reconstruct rotation matrix with float2x2(UVBWR[n].z, -UVBWR[n].w, UVBWR[n].w, UVBWR[n].z)
			// UVBWR[3].xyz = Blend Weights (w unused) - needs luminance weighting
			float4x4 HextileUVBWR(float2 uv)
			{
				// Create Triangle Grid
				// Skew input space into simplex triangle grid (3.4641 ~= 2*sqrt(3))
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewedCoord = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticHexGridDensity);
				
				float2 baseId = float2(floor(skewedCoord));
				float3 temp = float3(frac(skewedCoord), 0);
				temp.z = 1 - temp.x - temp.y;
				
				float s = step(0.0, -temp.z);
				float s2 = 2 * s - 1;
				
				float3 weights = float3(-temp.z * s2, s - temp.y * s2, s - temp.x * s2);
				
				float2 vertex0 = baseId + float2(s, s);
				float2 vertex1 = baseId + float2(s, 1 - s);
				float2 vertex2 = baseId + float2(1 - s, s);
				
				float2 cen0 = HextileMakeCenUV(vertex0), cen1 = HextileMakeCenUV(vertex1), cen2 = HextileMakeCenUV(vertex2);
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = HextileLoadRot2x2(vertex0, _StochasticHexRotationStrength);
					rot1 = HextileLoadRot2x2(vertex1, _StochasticHexRotationStrength);
					rot2 = HextileLoadRot2x2(vertex2, _StochasticHexRotationStrength);
				}
				
				return float4x4(
				float4(mul(uv - cen0, rot0) + cen0 + StochasticHash2D2D(vertex0), rot0[0].x, -rot0[0].y),
				float4(mul(uv - cen1, rot1) + cen1 + StochasticHash2D2D(vertex1), rot1[0].x, -rot1[0].y),
				float4(mul(uv - cen2, rot2) + cen2 + StochasticHash2D2D(vertex2), rot2[0].x, -rot2[0].y),
				float4(weights, 0)
				);
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap, float2 dUVdx, float2 dUVdy)
			{
				// For some reason doing this instead of just calculating it directly prevents it from \
				// breaking after a certain number of textures use it. I don't understand why yet
				float4x4 UVBWR = HextileUVBWR(uv);
				
				// 2D Rotation Matrices for dUVdx/dy
				// Not sure if this constant folds during compiling when rot is locked at 0, so force it
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = float2x2(UVBWR[0].z, -UVBWR[0].w, UVBWR[0].w, UVBWR[0].z);
					rot1 = float2x2(UVBWR[1].z, -UVBWR[1].w, UVBWR[1].w, UVBWR[1].z);
					rot2 = float2x2(UVBWR[2].z, -UVBWR[2].w, UVBWR[2].w, UVBWR[2].z);
				}
				
				// Weights
				float3 W = UVBWR[3].xyz;
				
				// Sample texture
				// float3x4 c = float3x4(
				// 	tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0)),
				// 	tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1)),
				// 	tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2))
				// );
				
				float4 c0 = tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0));
				float4 c1 = tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1));
				float4 c2 = tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2));
				
				// Blend samples using luminance
				// This is technically incorrect for normal maps, but produces very similar
				// results to blending using normal map gradients (steepness)
				const float3 Lw = float3(0.299, 0.587, 0.114);
				float3 Dw = float3(dot(c0.xyz, Lw), dot(c1.xyz, Lw), dot(c2.xyz, Lw));
				
				Dw = lerp(1.0, Dw, _StochasticHexFallOffContrast);
				W = Dw * pow(W, _StochasticHexFallOffPower);
				// In the original hextiling there's a Gain3 step here, but it seems to slow things down \
				// and cause the UVs to break, so I've omitted it. Looks fine without
				
				W /= (W.x + W.y + W.z);
				return W.x * c0 + W.y * c1 + W.z * c2;
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap)
			{
				return HextileSampleTexture(tex, texSampler, uv, isNormalMap, ddx(uv), ddy(uv));
			}
			#endif // defined(_STOCHASTICMODE_HEXTILE)
			
			void applyAlphaOptions(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiMods poiMods)
			{
				poiFragData.alpha = saturate(poiFragData.alpha + _AlphaMod);
				
				if (_AlphaGlobalMask > 0)
				{
					poiFragData.alpha = maskBlend(poiFragData.alpha, poiMods.globalMask[_AlphaGlobalMask-1], _AlphaGlobalMaskBlendType);
				}
				
				//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
				if (_AlphaDistanceFade)
				{
					float3 position = _AlphaDistanceFadeType ? poiMesh.worldPos : poiMesh.objectPosition;
					float distanceFadeMultiplier = lerp(_AlphaDistanceFadeMinAlpha, _AlphaDistanceFadeMaxAlpha, smoothstep(_AlphaDistanceFadeMin, _AlphaDistanceFadeMax, distance(position, poiCam.worldPos)));
					if(_AlphaDistanceFadeGlobalMask > 0)
					{
						distanceFadeMultiplier = lerp(1, distanceFadeMultiplier, poiMods.globalMask[_AlphaDistanceFadeGlobalMask-1]);
					}
					poiFragData.alpha *= distanceFadeMultiplier;
				}
				//endex
				
				//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
				if (_AlphaFresnel)
				{
					float holoRim = saturate(1 - smoothstep(min(_AlphaFresnelSharpness, _AlphaFresnelWidth), _AlphaFresnelWidth, (poiCam.vDotN)));
					holoRim = abs(lerp(1, holoRim, _AlphaFresnelAlpha));
					holoRim = _AlphaFresnelInvert ? 1 - holoRim : holoRim;
					if(_AlphaFresnelGlobalMask > 0)
					{
						holoRim = lerp(1, holoRim, poiMods.globalMask[_AlphaFresnelGlobalMask-1]);
					}
					poiFragData.alpha *= holoRim;
				}
				//endex
				
				//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
				if (_AlphaAngular)
				{
					half cameraAngleMin = _CameraAngleMin / 180;
					half cameraAngleMax = _CameraAngleMax / 180;
					half modelAngleMin = _ModelAngleMin / 180;
					half modelAngleMax = _ModelAngleMax / 180;
					float3 pos = _AngleCompareTo == 0 ? poiMesh.objectPosition : poiMesh.worldPos;
					half3 cameraToModelDirection = normalize(pos - getCameraPosition());
					half3 modelForwardDirection = normalize(mul(unity_ObjectToWorld, normalize(_AngleForwardDirection.rgb)));
					half cameraLookAtModel = remapClamped(cameraAngleMax, cameraAngleMin, .5 * dot(cameraToModelDirection, getCameraForward()) + .5);
					half modelLookAtCamera = remapClamped(modelAngleMax, modelAngleMin, .5 * dot(-cameraToModelDirection, modelForwardDirection) + .5);
					float angularAlphaMod = 1;
					if (_AngleType == 0)
					{
						angularAlphaMod = max(cameraLookAtModel, _AngleMinAlpha);
					}
					else if (_AngleType == 1)
					{
						angularAlphaMod = max(modelLookAtCamera, _AngleMinAlpha);
					}
					else if (_AngleType == 2)
					{
						angularAlphaMod = max(cameraLookAtModel * modelLookAtCamera, _AngleMinAlpha);
					}
					if(_AlphaAngularGlobalMask > 0)
					{
						angularAlphaMod = lerp(1, angularAlphaMod, poiMods.globalMask[_AlphaAngularGlobalMask-1]);
					}
					poiFragData.alpha *= angularAlphaMod;
				}
				//endex
				
				//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && _AlphaAudioLinkEnabled)
				{
					poiFragData.alpha = saturate(poiFragData.alpha + lerp(_AlphaAudioLinkAddRange.x, _AlphaAudioLinkAddRange.y, poiMods.audioLink[_AlphaAudioLinkAddBand]));
				}
				#endif
				//endex
				
			}
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			inline half Dither8x8Bayer(int x, int y)
			{
				// Premultiplied by 1/64
				const half dither[ 64 ] = {
					0.015625, 0.765625, 0.203125, 0.953125, 0.06250, 0.81250, 0.25000, 1.00000,
					0.515625, 0.265625, 0.703125, 0.453125, 0.56250, 0.31250, 0.75000, 0.50000,
					0.140625, 0.890625, 0.078125, 0.828125, 0.18750, 0.93750, 0.12500, 0.87500,
					0.640625, 0.390625, 0.578125, 0.328125, 0.68750, 0.43750, 0.62500, 0.37500,
					0.046875, 0.796875, 0.234375, 0.984375, 0.03125, 0.78125, 0.21875, 0.96875,
					0.546875, 0.296875, 0.734375, 0.484375, 0.53125, 0.28125, 0.71875, 0.46875,
					0.171875, 0.921875, 0.109375, 0.859375, 0.15625, 0.90625, 0.09375, 0.84375,
					0.671875, 0.421875, 0.609375, 0.359375, 0.65625, 0.40625, 0.59375, 0.34375
				};
				int r = y * 8 + x;
				return dither[r];
			}
			
			half calcDither(half2 grabPos)
			{
				return Dither8x8Bayer(glsl_mod(grabPos.x, 8), glsl_mod(grabPos.y, 8));
			}
			
			void applyDithering(inout PoiFragData poiFragData, in PoiCam poiCam)
			{
				if (_AlphaDithering)
				{
					float dither = calcDither(poiCam.screenUV.xy) - _AlphaDitherBias;
					poiFragData.alpha = saturate(poiFragData.alpha - (dither * (1 - poiFragData.alpha) * _AlphaDitherGradient));
				}
			}
			//endex
			
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			void ApplyAlphaToCoverage(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				// Force Model Opacity to 1 if desired
				UNITY_BRANCH
				if (_Mode == 1)
				{
					UNITY_BRANCH
					if (_AlphaSharpenedA2C && _AlphaToCoverage)
					{
						// rescale alpha by mip level
						poiFragData.alpha *= 1 + max(0, CalcMipLevel(poiMesh.uv[0] * _MainTex_TexelSize.zw)) * _AlphaMipScale;
						// rescale alpha by partial derivative
						poiFragData.alpha = (poiFragData.alpha - _Cutoff) / max(fwidth(poiFragData.alpha), 0.0001) + _Cutoff;
						poiFragData.alpha = saturate(poiFragData.alpha);
					}
				}
			}
			//endex
			
			void calculateGlobalThemes(inout PoiMods poiMods)
			{
				// Theme colors are defined as HDR; convert to SDR and do the HSV adjustment, then re-apply exposure
				float4 themeColorExposures = 0;
				float4 themeColor0, themeColor1, themeColor2, themeColor3 = 0;
				
				DecomposeHDRColor(_GlobalThemeColor0.rgb, themeColor0.rgb, themeColorExposures.x);
				DecomposeHDRColor(_GlobalThemeColor1.rgb, themeColor1.rgb, themeColorExposures.y);
				DecomposeHDRColor(_GlobalThemeColor2.rgb, themeColor2.rgb, themeColorExposures.z);
				DecomposeHDRColor(_GlobalThemeColor3.rgb, themeColor3.rgb, themeColorExposures.w);
				
				poiMods.globalColorTheme[0] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor0.rgb, frac(_GlobalThemeHue0 + _GlobalThemeHueSpeed0 * _Time.x), _GlobalThemeSaturation0, _GlobalThemeValue0), themeColorExposures.x), _GlobalThemeColor0.a);
				poiMods.globalColorTheme[1] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor1.rgb, frac(_GlobalThemeHue1 + _GlobalThemeHueSpeed1 * _Time.x), _GlobalThemeSaturation1, _GlobalThemeValue1), themeColorExposures.y), _GlobalThemeColor1.a);
				poiMods.globalColorTheme[2] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor2.rgb, frac(_GlobalThemeHue2 + _GlobalThemeHueSpeed2 * _Time.x), _GlobalThemeSaturation2, _GlobalThemeValue2), themeColorExposures.z), _GlobalThemeColor2.a);
				poiMods.globalColorTheme[3] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor3.rgb, frac(_GlobalThemeHue3 + _GlobalThemeHueSpeed3 * _Time.x), _GlobalThemeSaturation3, _GlobalThemeValue3), themeColorExposures.w), _GlobalThemeColor3.a);
			}
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			void ApplyGlobalMaskTextures(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol0 = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0_ST), _GlobalMaskTexture0Pan);
				if (_GlobalMaskTexture0Split)
				{
					poiMods.globalMask[0] = gmcol0.r;
					poiMods.globalMask[1] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_G), _GlobalMaskTexture0SplitPan_G).g;
					poiMods.globalMask[2] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_B), _GlobalMaskTexture0SplitPan_B).b;
					poiMods.globalMask[3] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_A), _GlobalMaskTexture0SplitPan_A).a;
				} else {
					poiMods.globalMask[0] = gmcol0[0];
					poiMods.globalMask[1] = gmcol0[1];
					poiMods.globalMask[2] = gmcol0[2];
					poiMods.globalMask[3] = gmcol0[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol1 = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1_ST), _GlobalMaskTexture1Pan);
				if (_GlobalMaskTexture1Split)
				{
					poiMods.globalMask[4] = gmcol1.r;
					poiMods.globalMask[5] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_G), _GlobalMaskTexture1SplitPan_G).g;
					poiMods.globalMask[6] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_B), _GlobalMaskTexture1SplitPan_B).b;
					poiMods.globalMask[7] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_A), _GlobalMaskTexture1SplitPan_A).a;
				} else {
					poiMods.globalMask[4] = gmcol1[0];
					poiMods.globalMask[5] = gmcol1[1];
					poiMods.globalMask[6] = gmcol1[2];
					poiMods.globalMask[7] = gmcol1[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol2 = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2_ST), _GlobalMaskTexture2Pan);
				if (_GlobalMaskTexture2Split)
				{
					poiMods.globalMask[8] = gmcol2.r;
					poiMods.globalMask[9] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_G), _GlobalMaskTexture2SplitPan_G).g;
					poiMods.globalMask[10] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_B), _GlobalMaskTexture2SplitPan_B).b;
					poiMods.globalMask[11] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_A), _GlobalMaskTexture2SplitPan_A).a;
				} else {
					poiMods.globalMask[8] = gmcol2[0];
					poiMods.globalMask[9] = gmcol2[1];
					poiMods.globalMask[10] = gmcol2[2];
					poiMods.globalMask[11] = gmcol2[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol3 = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3_ST), _GlobalMaskTexture3Pan);
				if (_GlobalMaskTexture3Split)
				{
					poiMods.globalMask[12] = gmcol3.r;
					poiMods.globalMask[13] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_G), _GlobalMaskTexture3SplitPan_G).g;
					poiMods.globalMask[14] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_B), _GlobalMaskTexture3SplitPan_B).b;
					poiMods.globalMask[15] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_A), _GlobalMaskTexture3SplitPan_A).a;
				} else {
					poiMods.globalMask[12] = gmcol3[0];
					poiMods.globalMask[13] = gmcol3[1];
					poiMods.globalMask[14] = gmcol3[2];
					poiMods.globalMask[15] = gmcol3[3];
				}
				#endif
			}
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			void ApplyGlobalMaskOptions(inout PoiMods poiMods)
			{
				//ifex _GlobalMaskOptionsType!=0
				if (_GlobalMaskOptionsType == 0)
				{
					poiMods.globalMask[0]  = saturate(poiMods.globalMask[0]  + _GlobalMaskSlider_0);
					poiMods.globalMask[1]  = saturate(poiMods.globalMask[1]  + _GlobalMaskSlider_1);
					poiMods.globalMask[2]  = saturate(poiMods.globalMask[2]  + _GlobalMaskSlider_2);
					poiMods.globalMask[3]  = saturate(poiMods.globalMask[3]  + _GlobalMaskSlider_3);
					poiMods.globalMask[4]  = saturate(poiMods.globalMask[4]  + _GlobalMaskSlider_4);
					poiMods.globalMask[5]  = saturate(poiMods.globalMask[5]  + _GlobalMaskSlider_5);
					poiMods.globalMask[6]  = saturate(poiMods.globalMask[6]  + _GlobalMaskSlider_6);
					poiMods.globalMask[7]  = saturate(poiMods.globalMask[7]  + _GlobalMaskSlider_7);
					poiMods.globalMask[8]  = saturate(poiMods.globalMask[8]  + _GlobalMaskSlider_8);
					poiMods.globalMask[9]  = saturate(poiMods.globalMask[9]  + _GlobalMaskSlider_9);
					poiMods.globalMask[10] = saturate(poiMods.globalMask[10] + _GlobalMaskSlider_10);
					poiMods.globalMask[11] = saturate(poiMods.globalMask[11] + _GlobalMaskSlider_11);
					poiMods.globalMask[12] = saturate(poiMods.globalMask[12] + _GlobalMaskSlider_12);
					poiMods.globalMask[13] = saturate(poiMods.globalMask[13] + _GlobalMaskSlider_13);
					poiMods.globalMask[14] = saturate(poiMods.globalMask[14] + _GlobalMaskSlider_14);
					poiMods.globalMask[15] = saturate(poiMods.globalMask[15] + _GlobalMaskSlider_15);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=1
				if (_GlobalMaskOptionsType == 1)
				{
					poiMods.globalMask[0]  = lerp(_GlobalMaskMinMaxSlider_0.x,  _GlobalMaskMinMaxSlider_0.y,  poiMods.globalMask[0]);
					poiMods.globalMask[1]  = lerp(_GlobalMaskMinMaxSlider_1.x,  _GlobalMaskMinMaxSlider_1.y,  poiMods.globalMask[1]);
					poiMods.globalMask[2]  = lerp(_GlobalMaskMinMaxSlider_2.x,  _GlobalMaskMinMaxSlider_2.y,  poiMods.globalMask[2]);
					poiMods.globalMask[3]  = lerp(_GlobalMaskMinMaxSlider_3.x,  _GlobalMaskMinMaxSlider_3.y,  poiMods.globalMask[3]);
					poiMods.globalMask[4]  = lerp(_GlobalMaskMinMaxSlider_4.x,  _GlobalMaskMinMaxSlider_4.y,  poiMods.globalMask[4]);
					poiMods.globalMask[5]  = lerp(_GlobalMaskMinMaxSlider_5.x,  _GlobalMaskMinMaxSlider_5.y,  poiMods.globalMask[5]);
					poiMods.globalMask[6]  = lerp(_GlobalMaskMinMaxSlider_6.x,  _GlobalMaskMinMaxSlider_6.y,  poiMods.globalMask[6]);
					poiMods.globalMask[7]  = lerp(_GlobalMaskMinMaxSlider_7.x,  _GlobalMaskMinMaxSlider_7.y,  poiMods.globalMask[7]);
					poiMods.globalMask[8]  = lerp(_GlobalMaskMinMaxSlider_8.x,  _GlobalMaskMinMaxSlider_8.y,  poiMods.globalMask[8]);
					poiMods.globalMask[9]  = lerp(_GlobalMaskMinMaxSlider_9.x,  _GlobalMaskMinMaxSlider_9.y,  poiMods.globalMask[9]);
					poiMods.globalMask[10] = lerp(_GlobalMaskMinMaxSlider_10.x, _GlobalMaskMinMaxSlider_10.y, poiMods.globalMask[10]);
					poiMods.globalMask[11] = lerp(_GlobalMaskMinMaxSlider_11.x, _GlobalMaskMinMaxSlider_11.y, poiMods.globalMask[11]);
					poiMods.globalMask[12] = lerp(_GlobalMaskMinMaxSlider_12.x, _GlobalMaskMinMaxSlider_12.y, poiMods.globalMask[12]);
					poiMods.globalMask[13] = lerp(_GlobalMaskMinMaxSlider_13.x, _GlobalMaskMinMaxSlider_13.y, poiMods.globalMask[13]);
					poiMods.globalMask[14] = lerp(_GlobalMaskMinMaxSlider_14.x, _GlobalMaskMinMaxSlider_14.y, poiMods.globalMask[14]);
					poiMods.globalMask[15] = lerp(_GlobalMaskMinMaxSlider_15.x, _GlobalMaskMinMaxSlider_15.y, poiMods.globalMask[15]);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=2
				if (_GlobalMaskOptionsType == 2)
				{
					if (_GlobalMaskToggleOn_0)  poiMods.globalMask[0]  = 1;
					if (_GlobalMaskToggleOn_1)  poiMods.globalMask[1]  = 1;
					if (_GlobalMaskToggleOn_2)  poiMods.globalMask[2]  = 1;
					if (_GlobalMaskToggleOn_3)  poiMods.globalMask[3]  = 1;
					if (_GlobalMaskToggleOn_4)  poiMods.globalMask[4]  = 1;
					if (_GlobalMaskToggleOn_5)  poiMods.globalMask[5]  = 1;
					if (_GlobalMaskToggleOn_6)  poiMods.globalMask[6]  = 1;
					if (_GlobalMaskToggleOn_7)  poiMods.globalMask[7]  = 1;
					if (_GlobalMaskToggleOn_8)  poiMods.globalMask[8]  = 1;
					if (_GlobalMaskToggleOn_9)  poiMods.globalMask[9]  = 1;
					if (_GlobalMaskToggleOn_10) poiMods.globalMask[10] = 1;
					if (_GlobalMaskToggleOn_11) poiMods.globalMask[11] = 1;
					if (_GlobalMaskToggleOn_12) poiMods.globalMask[12] = 1;
					if (_GlobalMaskToggleOn_13) poiMods.globalMask[13] = 1;
					if (_GlobalMaskToggleOn_14) poiMods.globalMask[14] = 1;
					if (_GlobalMaskToggleOn_15) poiMods.globalMask[15] = 1;
					
					poiMods.globalMask[0]  *= (1-_GlobalMaskToggleOff_0);
					poiMods.globalMask[1]  *= (1-_GlobalMaskToggleOff_1);
					poiMods.globalMask[2]  *= (1-_GlobalMaskToggleOff_2);
					poiMods.globalMask[3]  *= (1-_GlobalMaskToggleOff_3);
					poiMods.globalMask[4]  *= (1-_GlobalMaskToggleOff_4);
					poiMods.globalMask[5]  *= (1-_GlobalMaskToggleOff_5);
					poiMods.globalMask[6]  *= (1-_GlobalMaskToggleOff_6);
					poiMods.globalMask[7]  *= (1-_GlobalMaskToggleOff_7);
					poiMods.globalMask[8]  *= (1-_GlobalMaskToggleOff_8);
					poiMods.globalMask[9]  *= (1-_GlobalMaskToggleOff_9);
					poiMods.globalMask[10] *= (1-_GlobalMaskToggleOff_10);
					poiMods.globalMask[11] *= (1-_GlobalMaskToggleOff_11);
					poiMods.globalMask[12] *= (1-_GlobalMaskToggleOff_12);
					poiMods.globalMask[13] *= (1-_GlobalMaskToggleOff_13);
					poiMods.globalMask[14] *= (1-_GlobalMaskToggleOff_14);
					poiMods.globalMask[15] *= (1-_GlobalMaskToggleOff_15);
				}
				//endex
			}
			//endex
			
			float customDistanceBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					default: return 0; break;
				}
			}
			
			void ApplyGlobalMaskModifiers(in PoiMesh poiMesh, inout PoiMods poiMods, in PoiCam poiCam)
			{
				//ifex _GlobalMaskModifiersBackfaceEnable==0
				if(_GlobalMaskModifiersBackfaceEnable)
				{
					float facingMode = saturate(poiMesh.isFrontFace) + 1;
					// _GlobalMaskBackface is 0 for ignore, 1 for back only, 2 for front only
					poiMods.globalMask[0]  *= _GlobalMaskBackface_0  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskBackface_1  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskBackface_2  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskBackface_3  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskBackface_4  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskBackface_5  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskBackface_6  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskBackface_7  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskBackface_8  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskBackface_9  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_9 ));
					poiMods.globalMask[10] *= _GlobalMaskBackface_10 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_10));
					poiMods.globalMask[11] *= _GlobalMaskBackface_11 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_11));
					poiMods.globalMask[12] *= _GlobalMaskBackface_12 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_12));
					poiMods.globalMask[13] *= _GlobalMaskBackface_13 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_13));
					poiMods.globalMask[14] *= _GlobalMaskBackface_14 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_14));
					poiMods.globalMask[15] *= _GlobalMaskBackface_15 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersMirrorEnable==0
				if(_GlobalMaskModifiersMirrorEnable)
				{
					float mirrorMode = 0;
					if (_GlobalMaskMirrorVisibilityMode == 1) // VRC
					mirrorMode = VRCMirrorMode() > 0;
					else // Generic (CVR, etc)
					mirrorMode = IsInMirror();
					
					mirrorMode += 1;
					// _GlobalMaskMirror is 0 for ignore, 1 for outside mirror only, 2 for in mirror only
					poiMods.globalMask[0]  *= _GlobalMaskMirror_0  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskMirror_1  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskMirror_2  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskMirror_3  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskMirror_4  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskMirror_5  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskMirror_6  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskMirror_7  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskMirror_8  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskMirror_9  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_9 ));
					poiMods.globalMask[10] *= _GlobalMaskMirror_10 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_10));
					poiMods.globalMask[11] *= _GlobalMaskMirror_11 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_11));
					poiMods.globalMask[12] *= _GlobalMaskMirror_12 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_12));
					poiMods.globalMask[13] *= _GlobalMaskMirror_13 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_13));
					poiMods.globalMask[14] *= _GlobalMaskMirror_14 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_14));
					poiMods.globalMask[15] *= _GlobalMaskMirror_15 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersCameraEnable==0
				if(_GlobalMaskModifiersCameraEnable)
				{
					float isCamera = VRCCameraMode() > 0;
					isCamera += 1;
					// _GlobalMaskCamera is 0 for ignore, 1 for outside camera only, 2 for in camera only
					poiMods.globalMask[0]  *= _GlobalMaskCamera_0  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskCamera_1  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskCamera_2  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskCamera_3  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskCamera_4  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskCamera_5  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskCamera_6  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskCamera_7  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskCamera_8  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskCamera_9  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_9 ));
					poiMods.globalMask[10] *= _GlobalMaskCamera_10 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_10));
					poiMods.globalMask[11] *= _GlobalMaskCamera_11 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_11));
					poiMods.globalMask[12] *= _GlobalMaskCamera_12 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_12));
					poiMods.globalMask[13] *= _GlobalMaskCamera_13 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_13));
					poiMods.globalMask[14] *= _GlobalMaskCamera_14 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_14));
					poiMods.globalMask[15] *= _GlobalMaskCamera_15 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_15));
				}
				//endex
				//ifex _GlobalMaskModifiersDistanceEnable==0
				if (_GlobalMaskModifiersDistanceEnable)
				{
					//ifex _GlobalMaskDistanceEnable_0==0
					if (_GlobalMaskDistanceEnable_0)
					{
						float3 position = _GlobalMaskDistanceType_0 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_0, _GlobalMaskDistanceMaxAlpha_0, smoothstep(_GlobalMaskDistanceMin_0, _GlobalMaskDistanceMax_0, distance(position, poiCam.worldPos)));
						poiMods.globalMask[0] = saturate(customDistanceBlend(poiMods.globalMask[0], val, _GlobalMaskDistanceBlendType_0));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_1==0
					if (_GlobalMaskDistanceEnable_1)
					{
						float3 position = _GlobalMaskDistanceType_1 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_1, _GlobalMaskDistanceMaxAlpha_1, smoothstep(_GlobalMaskDistanceMin_1, _GlobalMaskDistanceMax_1, distance(position, poiCam.worldPos)));
						poiMods.globalMask[1] = saturate(customDistanceBlend(poiMods.globalMask[1], val, _GlobalMaskDistanceBlendType_1));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_2==0
					if (_GlobalMaskDistanceEnable_2)
					{
						float3 position = _GlobalMaskDistanceType_2 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_2, _GlobalMaskDistanceMaxAlpha_2, smoothstep(_GlobalMaskDistanceMin_2, _GlobalMaskDistanceMax_2, distance(position, poiCam.worldPos)));
						poiMods.globalMask[2] = saturate(customDistanceBlend(poiMods.globalMask[2], val, _GlobalMaskDistanceBlendType_2));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_3==0
					if (_GlobalMaskDistanceEnable_3)
					{
						float3 position = _GlobalMaskDistanceType_3 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_3, _GlobalMaskDistanceMaxAlpha_3, smoothstep(_GlobalMaskDistanceMin_3, _GlobalMaskDistanceMax_3, distance(position, poiCam.worldPos)));
						poiMods.globalMask[3] = saturate(customDistanceBlend(poiMods.globalMask[3], val, _GlobalMaskDistanceBlendType_3));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_4==0
					if (_GlobalMaskDistanceEnable_4)
					{
						float3 position = _GlobalMaskDistanceType_4 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_4, _GlobalMaskDistanceMaxAlpha_4, smoothstep(_GlobalMaskDistanceMin_4, _GlobalMaskDistanceMax_4, distance(position, poiCam.worldPos)));
						poiMods.globalMask[4] = saturate(customDistanceBlend(poiMods.globalMask[4], val, _GlobalMaskDistanceBlendType_4));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_5==0
					if (_GlobalMaskDistanceEnable_5)
					{
						float3 position = _GlobalMaskDistanceType_5 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_5, _GlobalMaskDistanceMaxAlpha_5, smoothstep(_GlobalMaskDistanceMin_5, _GlobalMaskDistanceMax_5, distance(position, poiCam.worldPos)));
						poiMods.globalMask[5] = saturate(customDistanceBlend(poiMods.globalMask[5], val, _GlobalMaskDistanceBlendType_5));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_6==0
					if (_GlobalMaskDistanceEnable_6)
					{
						float3 position = _GlobalMaskDistanceType_6 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_6, _GlobalMaskDistanceMaxAlpha_6, smoothstep(_GlobalMaskDistanceMin_6, _GlobalMaskDistanceMax_6, distance(position, poiCam.worldPos)));
						poiMods.globalMask[6] = saturate(customDistanceBlend(poiMods.globalMask[6], val, _GlobalMaskDistanceBlendType_6));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_7==0
					if (_GlobalMaskDistanceEnable_7)
					{
						float3 position = _GlobalMaskDistanceType_7 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_7, _GlobalMaskDistanceMaxAlpha_7, smoothstep(_GlobalMaskDistanceMin_7, _GlobalMaskDistanceMax_7, distance(position, poiCam.worldPos)));
						poiMods.globalMask[7] = saturate(customDistanceBlend(poiMods.globalMask[7], val, _GlobalMaskDistanceBlendType_7));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_8==0
					if (_GlobalMaskDistanceEnable_8)
					{
						float3 position = _GlobalMaskDistanceType_8 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_8, _GlobalMaskDistanceMaxAlpha_8, smoothstep(_GlobalMaskDistanceMin_8, _GlobalMaskDistanceMax_8, distance(position, poiCam.worldPos)));
						poiMods.globalMask[8] = saturate(customDistanceBlend(poiMods.globalMask[8], val, _GlobalMaskDistanceBlendType_8));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_9==0
					if (_GlobalMaskDistanceEnable_9)
					{
						float3 position = _GlobalMaskDistanceType_9 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_9, _GlobalMaskDistanceMaxAlpha_9, smoothstep(_GlobalMaskDistanceMin_9, _GlobalMaskDistanceMax_9, distance(position, poiCam.worldPos)));
						poiMods.globalMask[9] = saturate(customDistanceBlend(poiMods.globalMask[9], val, _GlobalMaskDistanceBlendType_9));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_10==0
					if (_GlobalMaskDistanceEnable_10)
					{
						float3 position = _GlobalMaskDistanceType_10 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_10, _GlobalMaskDistanceMaxAlpha_10, smoothstep(_GlobalMaskDistanceMin_10, _GlobalMaskDistanceMax_10, distance(position, poiCam.worldPos)));
						poiMods.globalMask[10] = saturate(customDistanceBlend(poiMods.globalMask[10], val, _GlobalMaskDistanceBlendType_10));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_11==0
					if (_GlobalMaskDistanceEnable_11)
					{
						float3 position = _GlobalMaskDistanceType_11 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_11, _GlobalMaskDistanceMaxAlpha_11, smoothstep(_GlobalMaskDistanceMin_11, _GlobalMaskDistanceMax_11, distance(position, poiCam.worldPos)));
						poiMods.globalMask[11] = saturate(customDistanceBlend(poiMods.globalMask[11], val, _GlobalMaskDistanceBlendType_11));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_12==0
					if (_GlobalMaskDistanceEnable_12)
					{
						float3 position = _GlobalMaskDistanceType_12 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_12, _GlobalMaskDistanceMaxAlpha_12, smoothstep(_GlobalMaskDistanceMin_12, _GlobalMaskDistanceMax_12, distance(position, poiCam.worldPos)));
						poiMods.globalMask[12] = saturate(customDistanceBlend(poiMods.globalMask[12], val, _GlobalMaskDistanceBlendType_12));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_13==0
					if (_GlobalMaskDistanceEnable_13)
					{
						float3 position = _GlobalMaskDistanceType_13 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_13, _GlobalMaskDistanceMaxAlpha_13, smoothstep(_GlobalMaskDistanceMin_13, _GlobalMaskDistanceMax_13, distance(position, poiCam.worldPos)));
						poiMods.globalMask[13] = saturate(customDistanceBlend(poiMods.globalMask[13], val, _GlobalMaskDistanceBlendType_13));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_14==0
					if (_GlobalMaskDistanceEnable_14)
					{
						float3 position = _GlobalMaskDistanceType_14 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_14, _GlobalMaskDistanceMaxAlpha_14, smoothstep(_GlobalMaskDistanceMin_14, _GlobalMaskDistanceMax_14, distance(position, poiCam.worldPos)));
						poiMods.globalMask[14] = saturate(customDistanceBlend(poiMods.globalMask[14], val, _GlobalMaskDistanceBlendType_14));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_15==0
					if (_GlobalMaskDistanceEnable_15)
					{
						float3 position = _GlobalMaskDistanceType_15 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_15, _GlobalMaskDistanceMaxAlpha_15, smoothstep(_GlobalMaskDistanceMin_15, _GlobalMaskDistanceMax_15, distance(position, poiCam.worldPos)));
						poiMods.globalMask[15] = saturate(customDistanceBlend(poiMods.globalMask[15], val, _GlobalMaskDistanceBlendType_15));
					}
					//endex
				}
				//endex
			}
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			void applyUDIMDiscard(in VertexOut i)
			{
				if(_UDIMDiscardMode == 1) // Don't run if in vertex mode
				{
					float2 udim = floor(vertexUV(i, _UDIMDiscardUV));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					const float threshold = 0.001;
					clip(threshold - isDiscarded); // Clip if discarded
				}
				
				return;
			}
			#endif
			//endex
			
			float2 calculatePolarCoordinate(in PoiMesh poiMesh)
			{
				float2 delta = poiMesh.uv[_PolarUV] - _PolarCenter;
				float radius = length(delta) * 2 * _PolarRadialScale;
				float angle = atan2(delta.x, delta.y);
				float phi = angle / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				angle = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				angle *= _PolarLengthScale;
				
				return float2(radius, angle + distance(poiMesh.uv[_PolarUV], _PolarCenter) * _PolarSpiralPower);
			}
			
			float2 MonoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(1.0, 1.0 / UNITY_PI);
				sphereCoords = float2(1.0, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).zw;
			}
			
			float2 StereoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(0.5, 1.0 / UNITY_PI);
				sphereCoords = float2(0.5, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).zw;
			}
			
			float2 calculateWorldUV(in PoiMesh poiMesh)
			{
				return float2(_UVModWorldPos0 != 3 ? poiMesh.worldPos[ _UVModWorldPos0] : 0.0f, _UVModWorldPos1 != 3 ? poiMesh.worldPos[_UVModWorldPos1] : 0.0f);
			}
			
			float2 calculatelocalUV(in PoiMesh poiMesh)
			{
				float localUVs[8];
				localUVs[0] = poiMesh.localPos.x;
				localUVs[1] = poiMesh.localPos.y;
				localUVs[2] = poiMesh.localPos.z;
				localUVs[3] = 0;
				localUVs[4] = poiMesh.vertexColor.r;
				localUVs[5] = poiMesh.vertexColor.g;
				localUVs[6] = poiMesh.vertexColor.b;
				localUVs[7] = poiMesh.vertexColor.a;
				
				return float2(localUVs[_UVModLocalPos0],localUVs[_UVModLocalPos1]);
			}
			
			float2 calculatePanosphereUV(in PoiMesh poiMesh)
			{
				float3 viewDirection = normalize(lerp(getCameraPosition().xyz, _WorldSpaceCameraPos.xyz, _PanoUseBothEyes) - poiMesh.worldPos.xyz) * - 1;
				return lerp(MonoPanoProjection(viewDirection), StereoPanoProjection(viewDirection), _StereoEnabled);
			}
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			float2 distortedUV(in PoiMesh poiMesh)
			{
				#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector = POI2D_SAMPLER_PAN(_DistortionFlowTexture, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTextureUV], _DistortionFlowTexture_ST), _DistortionFlowTexturePan) * 2 - 1;
				#else
				float4 flowVector = -1;
				#endif
				
				#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector1 = POI2D_SAMPLER_PAN(_DistortionFlowTexture1, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTexture1UV], _DistortionFlowTexture1_ST), _DistortionFlowTexture1Pan) * 2 - 1;
				#else
				float4 flowVector1 = -1;
				#endif
				
				#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
				half distortionMask = POI2D_SAMPLER_PAN(_DistortionMask, _MainTex, poiMesh.uv[_DistortionMaskUV], _DistortionMaskPan)[_DistortionMaskChannel];
				#else
				half distortionMask = 1;
				#endif
				
				half distortionStrength = _DistortionStrength;
				half distortionStrength1 = _DistortionStrength1;
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (AudioLinkIsAvailable() && _EnableDistortionAudioLink && _AudioLinkAnimToggle)
				{
					distortionStrength += lerp(_DistortionStrengthAudioLink.x, _DistortionStrengthAudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrengthAudioLinkBand))).r);
					distortionStrength1 += lerp(_DistortionStrength1AudioLink.x, _DistortionStrength1AudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrength1AudioLinkBand))).r);
				}
				#endif
				
				flowVector *= distortionStrength;
				flowVector1 *= distortionStrength1;
				return poiMesh.uv[_DistortionUvToDistort] + ((flowVector.xy + flowVector1.xy) / 2) * distortionMask;
			}
			#endif
			//endex
			
			//ifex _PoiParallax==0
			#ifdef POI_PARALLAX
			inline float2 POM(in PoiLight poiLight, sampler2D heightMap, in PoiMesh poiMesh, float3 worldViewDir, float3 viewDirTan, int minSamples, int maxSamples, float parallax, float refPlane, float2 tilling, float2 curv)
			{
				#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float heightMask = POI2D_SAMPLER_PAN(_Heightmask, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmask_ST), _HeightmaskPan)[_HeightmaskChannel];
				if (_HeightmaskInvert)
				{
					heightMask = 1 - heightMask;
				}
				#else
				float heightMask = 1;
				#endif
				
				float2 uvs = poiUV(poiMesh.uv[_HeightMapUV], _HeightMap_ST);
				float2 dx = ddx(uvs);
				float2 dy = ddy(uvs);
				float3 result = 0;
				int stepIndex = 0;
				int numSteps = (int)lerp(maxSamples, minSamples, saturate(dot(poiMesh.normals[0], worldViewDir)));
				float layerHeight = 1.0 / numSteps;
				float2 plane = parallax * heightMask * (viewDirTan.xy / viewDirTan.z);
				uvs += refPlane * plane;
				float2 deltaTex = -plane * layerHeight;
				float2 prevTexOffset = 0;
				float prevRayZ = 1.0f;
				float prevHeight = 0.0f;
				float2 currTexOffset = deltaTex;
				float currRayZ = 1.0f - layerHeight;
				float currHeight = 0.0f;
				float intersection = 0;
				float2 finalTexOffset = 0;
				while (stepIndex < numSteps + 1)
				{
					result.z = dot(curv, currTexOffset * currTexOffset);
					currHeight = tex2Dgrad(heightMap, uvs + currTexOffset, dx, dy).r * (1 - result.z);
					if (currHeight > currRayZ)
					{
						stepIndex = numSteps + 1;
					}
					else
					{
						stepIndex++;
						prevTexOffset = currTexOffset;
						prevRayZ = currRayZ;
						prevHeight = currHeight;
						currTexOffset += deltaTex;
						currRayZ -= layerHeight * (1 - result.z) * (1 + _CurvFix);
					}
				}
				int sectionSteps = 10;
				int sectionIndex = 0;
				float newZ = 0;
				float newHeight = 0;
				while (sectionIndex < sectionSteps)
				{
					intersection = (prevHeight - prevRayZ) / (prevHeight - currHeight + currRayZ - prevRayZ);
					finalTexOffset = prevTexOffset +intersection * deltaTex;
					newZ = prevRayZ - intersection * layerHeight;
					newHeight = tex2Dgrad(heightMap, uvs + finalTexOffset, dx, dy).r;
					if (newHeight > newZ)
					{
						currTexOffset = finalTexOffset;
						currHeight = newHeight;
						currRayZ = newZ;
						deltaTex = intersection * deltaTex;
						layerHeight = intersection * layerHeight;
					}
					else
					{
						prevTexOffset = finalTexOffset;
						prevHeight = newHeight;
						prevRayZ = newZ;
						deltaTex = (1 - intersection) * deltaTex;
						layerHeight = (1 - intersection) * layerHeight;
					}
					sectionIndex++;
				}
				#ifdef UNITY_PASS_SHADOWCASTER
				if (unity_LightShadowBias.z == 0.0)
				{
					#endif
					if (result.z > 1)
					clip(-1);
					#ifdef UNITY_PASS_SHADOWCASTER
				}
				#endif
				
				return uvs + finalTexOffset;
			}
			/*
			float2 ParallaxOffsetMultiStep(float surfaceHeight, float strength, float2 uv, float3 tangentViewDir)
			{
				float2 uvOffset = 0;
				float2 prevUVOffset = 0;
				float stepSize = 1.0 / _HeightSteps;
				float stepHeight = 1;
				float2 uvDelta = tangentViewDir.xy * (stepSize * strength);
				float prevStepHeight = stepHeight;
				float prevSurfaceHeight = surfaceHeight;
				
				[unroll(20)]
				for (int j = 1; j <= _HeightSteps && stepHeight > surfaceHeight; j++)
				{
					prevUVOffset = uvOffset;
					prevStepHeight = stepHeight;
					prevSurfaceHeight = surfaceHeight;
					uvOffset -= uvDelta;
					stepHeight -= stepSize;
					surfaceHeight = POI2D_SAMPLER_PAN(_Heightmap, _MainTex, poiUV(uv + uvOffset, _Heightmap_ST), _HeightmapPan) + _HeightOffset;
				}
				
				[unroll(3)]
				for (int k = 0; k < 3; k++)
				{
					uvDelta *= 0.5;
					stepSize *= 0.5;
					
					if (stepHeight < surfaceHeight)
					{
						uvOffset += uvDelta;
						stepHeight += stepSize;
					}
					else
					{
						uvOffset -= uvDelta;
						stepHeight -= stepSize;
					}
					surfaceHeight = POI2D_SAMPLER_PAN(_Heightmap, _MainTex, poiUV(uv + uvOffset, _Heightmap_ST), _HeightmapPan) + _HeightOffset;
				}
				return uvOffset;
			}
			*/
			void applyParallax(inout PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam)
			{
				/*
				half h = POI2D_SAMPLER_PAN(_Heightmap, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmap_ST), _HeightmapPan).r + _HeightOffset;
				#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				half m = POI2D_SAMPLER_PAN(_Heightmask, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmask_ST), _HeightmaskPan).r + _HeightOffset;
				#else
				half m = 1 + _HeightOffset;
				#endif
				h = clamp(h, 0, 0.999);
				m = lerp(m, 1 - m, _HeightmaskInvert);
				#if defined(OPTIMIZER_ENABLED)das
				poiMesh.uv[_ParallaxUV] += ParallaxOffsetMultiStep(h, _HeightStrength * m, poiMesh.uv[_HeightmapUV], tangentViewDir / tangentViewDir.z);
				#else
				float2 offset = ParallaxOffsetMultiStep(h, _HeightStrength * m, poiMesh.uv[_HeightmapUV], tangentViewDir / tangentViewDir.z);
				if (_ParallaxUV == 0)       poiMesh.uv[0] += offset;
				if (_ParallaxUV == 1)       poiMesh.uv[1] += offset;
				if (_ParallaxUV == 2)       poiMesh.uv[2] += offset;
				if (_ParallaxUV == 3)       poiMesh.uv[3] += offset;
				if (_ParallaxUV == 4)       poiMesh.uv[4] += offset;
				if (_ParallaxUV == 5)       poiMesh.uv[5] += offset;
				if (_ParallaxUV == 6)       poiMesh.uv[6] += offset;
				if (_ParallaxUV == 7)       poiMesh.uv[7] += offset;
				#endif
				*/
				
				#if defined(OPTIMIZER_ENABLED)
				poiMesh.uv[_ParallaxUV] = POM(poiLight, _HeightMap, poiMesh, poiCam.viewDir, poiCam.tangentViewDir, _HeightStepsMin, _HeightStepsMax, _HeightStrength, 0, _HeightMap_ST.xy, float2(_CurvatureU, _CurvatureV));
				#else
				float2 offset = POM(poiLight, _HeightMap, poiMesh, poiCam.viewDir, poiCam.tangentViewDir, _HeightStepsMin, _HeightStepsMax, _HeightStrength, 0, _HeightMap_ST.xy, float2(_CurvatureU, _CurvatureV));
				if (_ParallaxUV == 0)       poiMesh.uv[0] = offset;
				if (_ParallaxUV == 1)       poiMesh.uv[1] = offset;
				if (_ParallaxUV == 2)       poiMesh.uv[2] = offset;
				if (_ParallaxUV == 3)       poiMesh.uv[3] = offset;
				if (_ParallaxUV == 4)       poiMesh.uv[4] = offset;
				if (_ParallaxUV == 5)       poiMesh.uv[5] = offset;
				if (_ParallaxUV == 6)       poiMesh.uv[6] = offset;
				if (_ParallaxUV == 7)       poiMesh.uv[7] = offset;
				#endif
			}
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			void calculateBlackLightMasks(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#ifdef VERTEXLIGHT_ON
				for (int lightIndex = 0; lightIndex < 4; lightIndex ++)
				{
					float3 lightPos = float3(unity_4LightPosX0[lightIndex], unity_4LightPosY0[lightIndex], unity_4LightPosZ0[lightIndex]);
					if (!distance(unity_LightColor[lightIndex].rgb, float3(0, 0, 0)))
					{
						if (_BlackLightMasking0GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking0Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking0GlobalMaskIndex-1, _BlackLightMasking0GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking1GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking1Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking1GlobalMaskIndex-1, _BlackLightMasking1GlobalMaskBlendType, smoothstep(_BlackLightMasking1Range.y, _BlackLightMasking1Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking2GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking2Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking2GlobalMaskIndex-1, _BlackLightMasking2GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking3GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking3Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking3GlobalMaskIndex-1, _BlackLightMasking3GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
					}
				}
				#endif
			}
			#endif
			//endex
			
			//ifex _DetailEnabled==0
			#ifdef FINALPASS
			void ApplyDetailColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_DETAILTEX) || !defined(OPTIMIZER_ENABLED)
				half3 detailTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_DetailTex, _MainTex, poiUV(poiMesh.uv[_DetailTexUV], _DetailTex_ST), _DetailTexPan, _DetailTexStochastic).rgb * poiThemeColor(poiMods, _DetailTint, _DetailTintThemeIndex);
				#else
				half3 detailTexture = 0.21763764082 * poiThemeColor(poiMods, _DetailTint, _DetailTintThemeIndex);
				#endif
				
				poiFragData.baseColor.rgb *= LerpWhiteTo(detailTexture * _DetailBrightness * unity_ColorSpaceDouble.rgb, poiMods.detailMask.r * _DetailTexIntensity);
			}
			
			void ApplyDetailNormal(inout PoiMods poiMods, inout PoiMesh poiMesh)
			{
				#if defined(PROP_DETAILMASK) || !defined(OPTIMIZER_ENABLED)
				poiMods.detailMask = POI2D_SAMPLER_PAN_STOCHASTIC(_DetailMask, _MainTex, poiUV(poiMesh.uv[_DetailMaskUV], _DetailMask_ST), _DetailMaskPan, _DetailMaskStochastic).rg;
				#else
				poiMods.detailMask = 1;
				#endif
				
				#ifdef POI_BACKFACE
				if (!poiMesh.isFrontFace)
				{
					poiMods.detailMask.rg *= _BackFaceDetailIntensity;
				}
				#endif
				
				if (_DetailTexGlobalMask > 0)
				{
					poiMods.detailMask.r = maskBlend(poiMods.detailMask.r, poiMods.globalMask[_DetailTexGlobalMask-1], _DetailTexGlobalMaskBlendType);
				}
				if (_DetailNormalGlobalMask > 0)
				{
					poiMods.detailMask.g = maskBlend(poiMods.detailMask.g, poiMods.globalMask[_DetailNormalGlobalMask-1], _DetailNormalGlobalMaskBlendType);
				}
				
				#if defined(PROP_DETAILNORMALMAP) || !defined(OPTIMIZER_ENABLED)
				half3 detailNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_DetailNormalMap, _MainTex, poiUV(poiMesh.uv[_DetailNormalMapUV], _DetailNormalMap_ST), _DetailNormalMapPan, _DetailNormalMapStochastic), _DetailNormalMapScale * poiMods.detailMask.g);
				poiMesh.tangentSpaceNormal = BlendNormals(detailNormal, poiMesh.tangentSpaceNormal);
				#endif
			}
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			void applyVertexColor(inout PoiFragData poiFragData, PoiMesh poiMesh)
			{
				if (_MainVertexColoringEnabled)
				{
					#ifndef POI_PASS_OUTLINE
					float3 vertCol = lerp(poiMesh.vertexColor.rgb, GammaToLinearSpace(poiMesh.vertexColor.rgb), _MainVertexColoringLinearSpace);
					poiFragData.baseColor *= lerp(1, vertCol, _MainVertexColoring);
					#endif
					poiFragData.alpha *= lerp(1, poiMesh.vertexColor.a, _MainUseVertexColorAlpha);
				}
			}
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			void ApplyBackFaceColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				if (!poiMesh.isFrontFace)
				{
					float4 backFaceColor = _BackFaceColor;
					backFaceColor.rgb = poiThemeColor(poiMods, backFaceColor.rgb, _BackFaceColorThemeIndex);
					#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
					backFaceColor *= POI2D_SAMPLER_PAN(_BackFaceTexture, _MainTex, poiUV(poiMesh.uv[_BackFaceTextureUV], _BackFaceTexture_ST), _BackFaceTexturePan);
					#endif
					backFaceColor.rgb = hueShift(backFaceColor.rgb, frac(_BackFaceHueShift + _BackFaceHueShiftSpeed * _Time.x) * _BackFaceHueShiftEnabled);
					
					float backFaceMask = 1;
					#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
					backFaceMask *= POI2D_SAMPLER_PAN(_BackFaceMask, _MainTex, poiUV(poiMesh.uv[_BackFaceMaskUV], _BackFaceMask_ST), _BackFaceMaskPan)[_BackFaceMaskChannel];
					#endif
					if (!_BackFaceReplaceAlpha)
					{
						backFaceMask *= backFaceColor.a;
					}
					
					poiFragData.baseColor = lerp(poiFragData.baseColor, backFaceColor.rgb, backFaceMask);
					
					UNITY_BRANCH
					if (_BackFaceReplaceAlpha)
					{
						poiFragData.alpha = backFaceColor.a;
					}
					
					poiFragData.emission += backFaceColor.rgb * _BackFaceEmissionStrength * backFaceMask;
					poiMods.globalEmission = min(poiMods.globalEmission, _BackFaceEmissionLimiter);
				}
			}
			#endif
			//endex
			
			//ifex _RGBMaskEnabled==0
			#ifdef VIGNETTE
			//ifex _RgbNormalsEnabled==0
			#if defined(GEOM_TYPE_MESH) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
			void calculateRGBNormals(inout PoiMesh poiMesh, inout PoiMods poiMods)
			{
				// Only define this if we actually have any normal map textures. Can't do the same in color textures because users can tint
				#if defined(PROP_RGBNORMALR) || defined(PROP_RGBNORMALG) || defined(PROP_RGBNORMALB) || defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
				float4 rgbMask;
				
				if (_RGBUseVertexColors)
				{
					rgbMask = poiMesh.vertexColor;
				}
				else
				{
					#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
					rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
					#else
					rgbMask = 1;
					#endif
				}
				
				float4 maskFinal = 1;
				maskFinal.r = rgbMask[_RgbNormalRMaskChannel];
				maskFinal.g = rgbMask[_RgbNormalGMaskChannel];
				maskFinal.b = rgbMask[_RgbNormalBMaskChannel];
				maskFinal.a = rgbMask[_RgbNormalAMaskChannel];
				
				if (_RgbNormalRGlobalMaskChannel > 0) maskFinal.r = customBlend(maskFinal.r, poiMods.globalMask[_RgbNormalRGlobalMaskChannel-1], _RgbNormalRGlobalMaskBlendType);
				if (_RgbNormalGGlobalMaskChannel > 0) maskFinal.g = customBlend(maskFinal.g, poiMods.globalMask[_RgbNormalGGlobalMaskChannel-1], _RgbNormalGGlobalMaskBlendType);
				if (_RgbNormalBGlobalMaskChannel > 0) maskFinal.b = customBlend(maskFinal.b, poiMods.globalMask[_RgbNormalBGlobalMaskChannel-1], _RgbNormalBGlobalMaskBlendType);
				if (_RgbNormalAGlobalMaskChannel > 0) maskFinal.a = customBlend(maskFinal.a, poiMods.globalMask[_RgbNormalAGlobalMaskChannel-1], _RgbNormalAGlobalMaskBlendType);
				
				if (_RGBNormalBlend == 0)
				{
					#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalRScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan, _RgbNormalRStochastic), _RgbNormalRScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.r);
					}
					#endif
					#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalGScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan, _RgbNormalGStochastic), _RgbNormalGScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.g);
					}
					#endif
					#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalBScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan, _RgbNormalBStochastic), _RgbNormalBScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.b);
					}
					#endif
					#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalAScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan, _RgbNormalAStochastic), _RgbNormalAScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.a);
					}
					#endif
				}
				else
				{
					half3 newNormal = half3(0, 0, 1);
					half3 normalToBlendWith = half3(0, 0, 1);
					#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan, _RgbNormalRStochastic), _RgbNormalRScale * maskFinal.r);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan, _RgbNormalGStochastic), _RgbNormalGScale * maskFinal.g);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan, _RgbNormalBStochastic), _RgbNormalBScale * maskFinal.b);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan, _RgbNormalAStochastic), _RgbNormalAScale * maskFinal.a);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					poiMesh.tangentSpaceNormal = BlendNormals(newNormal, poiMesh.tangentSpaceNormal);
				}
				#endif
			}
			#endif
			//endex
			void calculateRGBMask(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				//If RGB normals are in use this data will already exist
				float4 rgbMask = float4(1, 1, 1, 1);
				//UNITY_BRANCH
				if (_RGBUseVertexColors)
				{
					rgbMask = poiMesh.vertexColor;
				}
				else
				{
					#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
					rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
					#else
					rgbMask = 1;
					#endif
				}
				
				#if defined(PROP_REDTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 red = POI2D_SAMPLER_PAN_STOCHASTIC(_RedTexture, _MainTex, poiUV(poiMesh.uv[_RedTextureUV], _RedTexture_ST), _RedTexturePan, _RedTextureStochastic);
				#else
				float4 red = 1;
				#endif
				#if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 green = POI2D_SAMPLER_PAN_STOCHASTIC(_GreenTexture, _MainTex, poiUV(poiMesh.uv[_GreenTextureUV], _GreenTexture_ST), _GreenTexturePan, _GreenTextureStochastic);
				#else
				float4 green = 1;
				#endif
				#if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 blue = POI2D_SAMPLER_PAN_STOCHASTIC(_BlueTexture, _MainTex, poiUV(poiMesh.uv[_BlueTextureUV], _BlueTexture_ST), _BlueTexturePan, _BlueTextureStochastic);
				#else
				float4 blue = 1;
				#endif
				#if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 alpha = POI2D_SAMPLER_PAN_STOCHASTIC(_AlphaTexture, _MainTex, poiUV(poiMesh.uv[_AlphaTextureUV], _AlphaTexture_ST), _AlphaTexturePan, _AlphaTextureStochastic);
				#else
				float4 alpha = 1;
				#endif
				
				float4 maskFinal = 1;
				maskFinal.r = red.a   * saturate((rgbMask[_RgbRedMaskChannel  ] * _RedColor.a  ) + _RedAlphaAdd  );
				maskFinal.g = green.a * saturate((rgbMask[_RgbGreenMaskChannel] * _GreenColor.a) + _GreenAlphaAdd);
				maskFinal.b = blue.a  * saturate((rgbMask[_RgbBlueMaskChannel ] * _BlueColor.a ) + _BlueAlphaAdd );
				maskFinal.a = alpha.a * saturate((rgbMask[_RgbAlphaMaskChannel] * _AlphaColor.a) + _AlphaAlphaAdd);
				
				if (_RgbRedGlobalMaskChannel   > 0) maskFinal.r = customBlend(maskFinal.r, poiMods.globalMask[_RgbRedGlobalMaskChannel-1],   _RgbRedGlobalMaskBlendType  );
				if (_RgbGreenGlobalMaskChannel > 0) maskFinal.g = customBlend(maskFinal.g, poiMods.globalMask[_RgbGreenGlobalMaskChannel-1], _RgbGreenGlobalMaskBlendType);
				if (_RgbBlueGlobalMaskChannel  > 0) maskFinal.b = customBlend(maskFinal.b, poiMods.globalMask[_RgbBlueGlobalMaskChannel-1],  _RgbBlueGlobalMaskBlendType );
				if (_RgbAlphaGlobalMaskChannel > 0) maskFinal.a = customBlend(maskFinal.a, poiMods.globalMask[_RgbAlphaGlobalMaskChannel-1], _RgbAlphaGlobalMaskBlendType);
				
				//UNITY_BRANCH
				if (_RGBBlendMultiplicative)
				{
					float3 RGBColor = 1;
					RGBColor = lerp(RGBColor, red.rgb * poiThemeColor(poiMods, _RedColor.rgb, _RedColorThemeIndex), maskFinal.r);
					RGBColor = lerp(RGBColor, green.rgb * poiThemeColor(poiMods, _GreenColor.rgb, _GreenColorThemeIndex), maskFinal.g);
					RGBColor = lerp(RGBColor, blue.rgb * poiThemeColor(poiMods, _BlueColor.rgb, _BlueColorThemeIndex), maskFinal.b);
					RGBColor = lerp(RGBColor, alpha.rgb * poiThemeColor(poiMods, _AlphaColor.rgb, _AlphaColorThemeIndex), maskFinal.a);
					
					poiFragData.baseColor *= RGBColor;
				}
				else
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, red.rgb * poiThemeColor(poiMods, _RedColor.rgb, _RedColorThemeIndex), maskFinal.r);
					poiFragData.baseColor = lerp(poiFragData.baseColor, green.rgb * poiThemeColor(poiMods, _GreenColor.rgb, _GreenColorThemeIndex), maskFinal.g);
					poiFragData.baseColor = lerp(poiFragData.baseColor, blue.rgb * poiThemeColor(poiMods, _BlueColor.rgb, _BlueColorThemeIndex), maskFinal.b);
					poiFragData.baseColor = lerp(poiFragData.baseColor, alpha.rgb * poiThemeColor(poiMods, _AlphaColor.rgb, _AlphaColorThemeIndex), maskFinal.a);
				}
			}
			#endif
			//endex
			
			#if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_BRANCH_DETAIL) || defined(GEOM_TYPE_FROND) || defined(DEPTH_OF_FIELD_COC_VIEW)
			float2 decalUV(float uvNumber, float2 position, half rotation, half rotationSpeed, half2 scale, float4 scaleOffset, float depth, in PoiMesh poiMesh, in PoiCam poiCam)
			{
				scaleOffset = float4(-scaleOffset.x, scaleOffset.y, -scaleOffset.z, scaleOffset.w);
				float2 centerOffset = float2((scaleOffset.x + scaleOffset.y)/2, (scaleOffset.z + scaleOffset.w)/2);
				float2 uv = poiMesh.uv[uvNumber] + calcParallax(depth + 1, poiCam);
				float2 decalCenter = position + centerOffset;
				float theta = radians(rotation + _Time.z * rotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
				uv = remap(uv, float2(0, 0) - scale / 2 + position + scaleOffset.xz, scale / 2 + position + scaleOffset.yw, float2(0, 0), float2(1, 1));
				return uv;
			}
			
			inline float3 decalHueShift(float enabled, float3 color, float shift, float shiftSpeed)
			{
				//UNITY_BRANCH
				if (enabled)
				{
					color = hueShift(color, shift + _Time.x * shiftSpeed);
				}
				return color;
			}
			
			inline float applyTilingClipping(float enabled, float2 uv)
			{
				float ret = 1;
				//UNITY_BRANCH
				if (!enabled)
				{
					if (uv.x > 1 || uv.y > 1 || uv.x < 0 || uv.y < 0)
					{
						ret = 0;
					}
				}
				return ret;
			}
			
			struct PoiDecal
			{
				float m_DecalMaskChannel;
				float m_DecalGlobalMask;
				float m_DecalGlobalMaskBlendType;
				float m_DecalApplyGlobalMaskIndex;
				float m_DecalApplyGlobalMaskBlendType;
				float4 m_DecalTexture_ST;
				float2 m_DecalTexturePan;
				float m_DecalTextureUV;
				float4 m_DecalColor;
				float m_DecalColorThemeIndex;
				fixed m_DecalTiled;
				float m_DecalBlendType;
				half m_DecalRotation;
				half2 m_DecalScale;
				float4 m_DecalSideOffset;
				half2 m_DecalPosition;
				half m_DecalRotationSpeed;
				float m_DecalEmissionStrength;
				float m_DecalBlendAlpha;
				float m_DecalOverrideAlpha;
				float m_DecalHueShiftEnabled;
				float m_DecalHueShift;
				float m_DecalHueShiftSpeed;
				float m_DecalDepth;
				float m_DecalHueAngleStrength;
				float m_DecalChannelSeparationEnable;
				float m_DecalChannelSeparation;
				float m_DecalChannelSeparationPremultiply;
				float m_DecalChannelSeparationHue;
				float m_DecalChannelSeparationVertical;
				float m_DecalChannelSeparationAngleStrength;
				
				#if defined(POI_AUDIOLINK)
				half m_AudioLinkDecalScaleBand;
				float4 m_AudioLinkDecalScale;
				half m_AudioLinkDecalRotationBand;
				float2 m_AudioLinkDecalRotation;
				half m_AudioLinkDecalAlphaBand;
				float2 m_AudioLinkDecalAlpha;
				half m_AudioLinkDecalEmissionBand;
				float2 m_AudioLinkDecalEmission;
				float m_DecalRotationCTALBand;
				float m_DecalRotationCTALSpeed;
				float m_DecalRotationCTALType;
				float m_AudioLinkDecalColorChord;
				float m_AudioLinkDecalSideBand;
				float4 m_AudioLinkDecalSideMin;
				float4 m_AudioLinkDecalSideMax;
				float2 m_AudioLinkDecalChannelSeparation;
				float m_AudioLinkDecalChannelSeparationBand;
				#endif
				
				float4 decalColor;
				float2 decalScale;
				float decalRotation;
				float2 uv;
				float4 dduv;
				float4 sideMod;
				float decalChannelOffset;
				float4 decalMask;
				
				void Init(in float4 DecalMask)
				{
					decalMask = DecalMask;
					decalScale = m_DecalScale;
				}
				
				void InitAudiolink(in PoiMods poiMods)
				{
					#ifdef POI_AUDIOLINK
					if (poiMods.audioLinkAvailable)
					{
						decalScale += lerp(m_AudioLinkDecalScale.xy, m_AudioLinkDecalScale.zw, poiMods.audioLink[m_AudioLinkDecalScaleBand]);
						sideMod += lerp(m_AudioLinkDecalSideMin, m_AudioLinkDecalSideMax, poiMods.audioLink[m_AudioLinkDecalSideBand]);
						decalRotation += lerp(m_AudioLinkDecalRotation.x, m_AudioLinkDecalRotation.y, poiMods.audioLink[m_AudioLinkDecalRotationBand]);
						decalRotation += AudioLinkGetChronoTime(m_DecalRotationCTALType, m_DecalRotationCTALBand) * m_DecalRotationCTALSpeed * 360;
						decalChannelOffset += lerp(m_AudioLinkDecalChannelSeparation[0], m_AudioLinkDecalChannelSeparation[1], poiMods.audioLink[m_AudioLinkDecalChannelSeparationBand]);
					}
					#endif
				}
				
				void SampleDecalNoTexture(in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					decalColor = float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
				}
				
				void SampleDecal(sampler2D decalTexture, in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					// Adjust derivatives for _ST of decal texture
					float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
					decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
				}
				
				void SampleDecalChannelSeparation(sampler2D decalTexture, in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					decalColor = 0;
					decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
					float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
					float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					
					float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
					float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
					
					float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					
					sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					
					float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
					
					if (m_DecalChannelSeparationPremultiply)
					{
						decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
					}
					else
					{
						decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
					}
					decalColor.a = 0.5 * (sample0.a + sample1.a);
					decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
				}
				
				void Apply(inout float alphaOverride, inout float decalAlpha, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
				{
					if (m_DecalGlobalMask > 0)
					{
						decalColor.a = maskBlend(decalColor.a, poiMods.globalMask[m_DecalGlobalMask - 1], m_DecalGlobalMaskBlendType);
					}
					
					float audioLinkDecalAlpha = 0;
					float audioLinkDecalEmission = 0;
					#ifdef POI_AUDIOLINK
					audioLinkDecalEmission = lerp(m_AudioLinkDecalEmission.x, m_AudioLinkDecalEmission.y, poiMods.audioLink[m_AudioLinkDecalEmissionBand]) * poiMods.audioLinkAvailable;
					
					if (m_AudioLinkDecalColorChord)
					{
						if (poiMods.audioLinkAvailable)
						{
							decalColor.rgb *= AudioLinkLerp(ALPASS_CCSTRIP + float2(uv.x * AUDIOLINK_WIDTH, 0)).rgb;
						}
						else
						{
							decalAlpha = 0;
						}
					}
					audioLinkDecalAlpha = lerp(m_AudioLinkDecalAlpha.x, m_AudioLinkDecalAlpha.y, poiMods.audioLink[m_AudioLinkDecalAlphaBand]) * poiMods.audioLinkAvailable;
					#endif
					
					if (m_DecalOverrideAlpha)
					{
						alphaOverride += 1;
						decalAlpha = lerp(decalAlpha, min(decalAlpha, decalColor.a), decalMask[m_DecalMaskChannel]);
					}
					
					float decalAlphaMixed = decalColor.a * saturate(m_DecalBlendAlpha + audioLinkDecalAlpha);
					
					if (m_DecalApplyGlobalMaskIndex > 0)
					{
						applyToGlobalMask(poiMods, m_DecalApplyGlobalMaskIndex - 1, m_DecalApplyGlobalMaskBlendType, decalAlphaMixed);
					}
					
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, decalColor.rgb, m_DecalBlendType), decalAlphaMixed);
					poiFragData.emission += decalColor.rgb * decalColor.a * max(m_DecalEmissionStrength + audioLinkDecalEmission, 0);
				}
			};
			
			void applyDecals(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
			{
				float decalAlpha = 1;
				float alphaOverride = 0;
				#if defined(PROP_DECALMASK) || !defined(OPTIMIZER_ENABLED)
				float4 decalMask = POI2D_SAMPLER_PAN(_DecalMask, _MainTex, poiUV(poiMesh.uv[_DecalMaskUV], _DecalMask_ST), _DecalMaskPan);
				#else
				float4 decalMask = 1;
				#endif
				
				#ifdef TPS_Penetrator
				if (_DecalTPSDepthMaskEnabled)
				{
					decalMask.r = lerp(0, decalMask.r * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal0TPSMaskStrength);
					decalMask.g = lerp(0, decalMask.g * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal1TPSMaskStrength);
					decalMask.b = lerp(0, decalMask.b * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal2TPSMaskStrength);
					decalMask.a = lerp(0, decalMask.a * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal3TPSMaskStrength);
				}
				#endif
				float4 decalColor = 1;
				float2 uv = 0;
				
				// yaes
				
				//ifex _DecalEnabled==0
				#ifdef GEOM_TYPE_BRANCH
				PoiDecal Decal0;
				PoiInitStruct(PoiDecal, Decal0)
				
				Decal0.m_DecalMaskChannel = _Decal0MaskChannel;
				Decal0.m_DecalGlobalMask = _Decal0GlobalMask;
				Decal0.m_DecalGlobalMaskBlendType = _Decal0GlobalMaskBlendType;
				Decal0.m_DecalApplyGlobalMaskIndex = _Decal0ApplyGlobalMaskIndex;
				Decal0.m_DecalApplyGlobalMaskBlendType = _Decal0ApplyGlobalMaskBlendType;
				Decal0.m_DecalTexture_ST = _DecalTexture_ST;
				Decal0.m_DecalTexturePan = _DecalTexturePan;
				Decal0.m_DecalTextureUV = _DecalTextureUV;
				Decal0.m_DecalColor = _DecalColor;
				Decal0.m_DecalColorThemeIndex = _DecalColorThemeIndex;
				Decal0.m_DecalTiled = _DecalTiled;
				Decal0.m_DecalBlendType = _DecalBlendType;
				Decal0.m_DecalRotation = _DecalRotation;
				Decal0.m_DecalScale = _DecalScale;
				Decal0.m_DecalSideOffset = _DecalSideOffset;
				Decal0.m_DecalPosition = _DecalPosition;
				Decal0.m_DecalRotationSpeed = _DecalRotationSpeed;
				Decal0.m_DecalEmissionStrength = _DecalEmissionStrength;
				Decal0.m_DecalBlendAlpha = _DecalBlendAlpha;
				Decal0.m_DecalOverrideAlpha = _DecalOverrideAlpha;
				Decal0.m_DecalHueShiftEnabled = _DecalHueShiftEnabled;
				Decal0.m_DecalHueShift = _DecalHueShift;
				Decal0.m_DecalHueShiftSpeed = _DecalHueShiftSpeed;
				Decal0.m_DecalDepth = _Decal0Depth;
				Decal0.m_DecalHueAngleStrength = _Decal0HueAngleStrength;
				Decal0.m_DecalChannelSeparationEnable = _Decal0ChannelSeparationEnable;
				Decal0.m_DecalChannelSeparation = _Decal0ChannelSeparation;
				Decal0.m_DecalChannelSeparationPremultiply = _Decal0ChannelSeparationPremultiply;
				Decal0.m_DecalChannelSeparationHue = _Decal0ChannelSeparationHue;
				Decal0.m_DecalChannelSeparationVertical = _Decal0ChannelSeparationVertical;
				Decal0.m_DecalChannelSeparationAngleStrength = _Decal0ChannelSeparationAngleStrength;
				
				Decal0.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal0.m_AudioLinkDecalScaleBand = _AudioLinkDecal0ScaleBand;
				Decal0.m_AudioLinkDecalScale = _AudioLinkDecal0Scale;
				Decal0.m_AudioLinkDecalRotationBand = _AudioLinkDecal0RotationBand;
				Decal0.m_AudioLinkDecalRotation = _AudioLinkDecal0Rotation;
				Decal0.m_AudioLinkDecalAlphaBand = _AudioLinkDecal0AlphaBand;
				Decal0.m_AudioLinkDecalAlpha = _AudioLinkDecal0Alpha;
				Decal0.m_AudioLinkDecalEmissionBand = _AudioLinkDecal0EmissionBand;
				Decal0.m_AudioLinkDecalEmission = _AudioLinkDecal0Emission;
				Decal0.m_DecalRotationCTALBand = _DecalRotationCTALBand0;
				Decal0.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed0;
				Decal0.m_DecalRotationCTALType = _DecalRotationCTALType0;
				Decal0.m_AudioLinkDecalColorChord = _AudioLinkDecalCC0;
				Decal0.m_AudioLinkDecalSideBand = _AudioLinkDecal0SideBand;
				Decal0.m_AudioLinkDecalSideMin = _AudioLinkDecal0SideMin;
				Decal0.m_AudioLinkDecalSideMax = _AudioLinkDecal0SideMax;
				Decal0.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal0ChannelSeparation;
				Decal0.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal0ChannelSeparationBand;
				
				Decal0.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal0ChannelSeparationEnable==0
				if (_Decal0ChannelSeparationEnable)
				{
					Decal0.SampleDecalChannelSeparation(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal0ChannelSeparationEnable==1
				if (!_Decal0ChannelSeparationEnable)
				{
					Decal0.SampleDecal(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal0.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal0.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled1==0
				#ifdef GEOM_TYPE_BRANCH_DETAIL
				PoiDecal Decal1;
				PoiInitStruct(PoiDecal, Decal1)
				
				Decal1.m_DecalMaskChannel = _Decal1MaskChannel;
				Decal1.m_DecalGlobalMask = _Decal1GlobalMask;
				Decal1.m_DecalGlobalMaskBlendType = _Decal1GlobalMaskBlendType;
				Decal1.m_DecalApplyGlobalMaskIndex = _Decal1ApplyGlobalMaskIndex;
				Decal1.m_DecalApplyGlobalMaskBlendType = _Decal1ApplyGlobalMaskBlendType;
				Decal1.m_DecalTexture_ST = _DecalTexture1_ST;
				Decal1.m_DecalTexturePan = _DecalTexture1Pan;
				Decal1.m_DecalTextureUV = _DecalTexture1UV;
				Decal1.m_DecalColor = _DecalColor1;
				Decal1.m_DecalColorThemeIndex = _DecalColor1ThemeIndex;
				Decal1.m_DecalTiled = _DecalTiled1;
				Decal1.m_DecalBlendType = _DecalBlendType1;
				Decal1.m_DecalRotation = _DecalRotation1;
				Decal1.m_DecalScale = _DecalScale1;
				Decal1.m_DecalSideOffset = _DecalSideOffset1;
				Decal1.m_DecalPosition = _DecalPosition1;
				Decal1.m_DecalRotationSpeed = _DecalRotationSpeed1;
				Decal1.m_DecalEmissionStrength = _DecalEmissionStrength1;
				Decal1.m_DecalBlendAlpha = _DecalBlendAlpha1;
				Decal1.m_DecalOverrideAlpha = _DecalOverrideAlpha1;
				Decal1.m_DecalHueShiftEnabled = _DecalHueShiftEnabled1;
				Decal1.m_DecalHueShift = _DecalHueShift1;
				Decal1.m_DecalHueShiftSpeed = _DecalHueShiftSpeed1;
				Decal1.m_DecalDepth = _Decal1Depth;
				Decal1.m_DecalHueAngleStrength = _Decal1HueAngleStrength;
				Decal1.m_DecalChannelSeparationEnable = _Decal1ChannelSeparationEnable;
				Decal1.m_DecalChannelSeparation = _Decal1ChannelSeparation;
				Decal1.m_DecalChannelSeparationPremultiply = _Decal1ChannelSeparationPremultiply;
				Decal1.m_DecalChannelSeparationHue = _Decal1ChannelSeparationHue;
				Decal1.m_DecalChannelSeparationVertical = _Decal1ChannelSeparationVertical;
				Decal1.m_DecalChannelSeparationAngleStrength = _Decal1ChannelSeparationAngleStrength;
				
				Decal1.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal1.m_AudioLinkDecalScaleBand = _AudioLinkDecal1ScaleBand;
				Decal1.m_AudioLinkDecalScale = _AudioLinkDecal1Scale;
				Decal1.m_AudioLinkDecalRotationBand = _AudioLinkDecal1RotationBand;
				Decal1.m_AudioLinkDecalRotation = _AudioLinkDecal1Rotation;
				Decal1.m_AudioLinkDecalAlphaBand = _AudioLinkDecal1AlphaBand;
				Decal1.m_AudioLinkDecalAlpha = _AudioLinkDecal1Alpha;
				Decal1.m_AudioLinkDecalEmissionBand = _AudioLinkDecal1EmissionBand;
				Decal1.m_AudioLinkDecalEmission = _AudioLinkDecal1Emission;
				Decal1.m_DecalRotationCTALBand = _DecalRotationCTALBand1;
				Decal1.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed1;
				Decal1.m_DecalRotationCTALType = _DecalRotationCTALType1;
				Decal1.m_AudioLinkDecalColorChord = _AudioLinkDecalCC1;
				Decal1.m_AudioLinkDecalSideBand = _AudioLinkDecal1SideBand;
				Decal1.m_AudioLinkDecalSideMin = _AudioLinkDecal1SideMin;
				Decal1.m_AudioLinkDecalSideMax = _AudioLinkDecal1SideMax;
				Decal1.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal1ChannelSeparation;
				Decal1.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal1ChannelSeparationBand;
				
				Decal1.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal1ChannelSeparationEnable==0
				if (_Decal1ChannelSeparationEnable)
				{
					Decal1.SampleDecalChannelSeparation(_DecalTexture1, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal1ChannelSeparationEnable==1
				if (!_Decal1ChannelSeparationEnable)
				{
					Decal1.SampleDecal(_DecalTexture1, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal1.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal1.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled2==0
				#ifdef GEOM_TYPE_FROND
				PoiDecal Decal2;
				PoiInitStruct(PoiDecal, Decal2)
				
				Decal2.m_DecalMaskChannel = _Decal2MaskChannel;
				Decal2.m_DecalGlobalMask = _Decal2GlobalMask;
				Decal2.m_DecalGlobalMaskBlendType = _Decal2GlobalMaskBlendType;
				Decal2.m_DecalApplyGlobalMaskIndex = _Decal2ApplyGlobalMaskIndex;
				Decal2.m_DecalApplyGlobalMaskBlendType = _Decal2ApplyGlobalMaskBlendType;
				Decal2.m_DecalTexture_ST = _DecalTexture2_ST;
				Decal2.m_DecalTexturePan = _DecalTexture2Pan;
				Decal2.m_DecalTextureUV = _DecalTexture2UV;
				Decal2.m_DecalColor = _DecalColor2;
				Decal2.m_DecalColorThemeIndex = _DecalColor2ThemeIndex;
				Decal2.m_DecalTiled = _DecalTiled2;
				Decal2.m_DecalBlendType = _DecalBlendType2;
				Decal2.m_DecalRotation = _DecalRotation2;
				Decal2.m_DecalScale = _DecalScale2;
				Decal2.m_DecalSideOffset = _DecalSideOffset2;
				Decal2.m_DecalPosition = _DecalPosition2;
				Decal2.m_DecalRotationSpeed = _DecalRotationSpeed2;
				Decal2.m_DecalEmissionStrength = _DecalEmissionStrength2;
				Decal2.m_DecalBlendAlpha = _DecalBlendAlpha2;
				Decal2.m_DecalOverrideAlpha = _DecalOverrideAlpha2;
				Decal2.m_DecalHueShiftEnabled = _DecalHueShiftEnabled2;
				Decal2.m_DecalHueShift = _DecalHueShift2;
				Decal2.m_DecalHueShiftSpeed = _DecalHueShiftSpeed2;
				Decal2.m_DecalDepth = _Decal2Depth;
				Decal2.m_DecalHueAngleStrength = _Decal2HueAngleStrength;
				Decal2.m_DecalChannelSeparationEnable = _Decal2ChannelSeparationEnable;
				Decal2.m_DecalChannelSeparation = _Decal2ChannelSeparation;
				Decal2.m_DecalChannelSeparationPremultiply = _Decal2ChannelSeparationPremultiply;
				Decal2.m_DecalChannelSeparationHue = _Decal2ChannelSeparationHue;
				Decal2.m_DecalChannelSeparationVertical = _Decal2ChannelSeparationVertical;
				Decal2.m_DecalChannelSeparationAngleStrength = _Decal2ChannelSeparationAngleStrength;
				
				Decal2.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal2.m_AudioLinkDecalScaleBand = _AudioLinkDecal2ScaleBand;
				Decal2.m_AudioLinkDecalScale = _AudioLinkDecal2Scale;
				Decal2.m_AudioLinkDecalRotationBand = _AudioLinkDecal2RotationBand;
				Decal2.m_AudioLinkDecalRotation = _AudioLinkDecal2Rotation;
				Decal2.m_AudioLinkDecalAlphaBand = _AudioLinkDecal2AlphaBand;
				Decal2.m_AudioLinkDecalAlpha = _AudioLinkDecal2Alpha;
				Decal2.m_AudioLinkDecalEmissionBand = _AudioLinkDecal2EmissionBand;
				Decal2.m_AudioLinkDecalEmission = _AudioLinkDecal2Emission;
				Decal2.m_DecalRotationCTALBand = _DecalRotationCTALBand2;
				Decal2.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed2;
				Decal2.m_DecalRotationCTALType = _DecalRotationCTALType2;
				Decal2.m_AudioLinkDecalColorChord = _AudioLinkDecalCC2;
				Decal2.m_AudioLinkDecalSideBand = _AudioLinkDecal2SideBand;
				Decal2.m_AudioLinkDecalSideMin = _AudioLinkDecal2SideMin;
				Decal2.m_AudioLinkDecalSideMax = _AudioLinkDecal2SideMax;
				Decal2.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal2ChannelSeparation;
				Decal2.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal2ChannelSeparationBand;
				
				Decal2.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal2ChannelSeparationEnable==0
				if (_Decal2ChannelSeparationEnable)
				{
					Decal2.SampleDecalChannelSeparation(_DecalTexture2, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal2ChannelSeparationEnable==1
				if (!_Decal2ChannelSeparationEnable)
				{
					Decal2.SampleDecal(_DecalTexture2, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal2.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal2.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled3==0
				#ifdef DEPTH_OF_FIELD_COC_VIEW
				PoiDecal Decal3;
				PoiInitStruct(PoiDecal, Decal3)
				
				Decal3.m_DecalMaskChannel = _Decal3MaskChannel;
				Decal3.m_DecalGlobalMask = _Decal3GlobalMask;
				Decal3.m_DecalGlobalMaskBlendType = _Decal3GlobalMaskBlendType;
				Decal3.m_DecalApplyGlobalMaskIndex = _Decal3ApplyGlobalMaskIndex;
				Decal3.m_DecalApplyGlobalMaskBlendType = _Decal3ApplyGlobalMaskBlendType;
				Decal3.m_DecalTexture_ST = _DecalTexture3_ST;
				Decal3.m_DecalTexturePan = _DecalTexture3Pan;
				Decal3.m_DecalTextureUV = _DecalTexture3UV;
				Decal3.m_DecalColor = _DecalColor3;
				Decal3.m_DecalColorThemeIndex = _DecalColor3ThemeIndex;
				Decal3.m_DecalTiled = _DecalTiled3;
				Decal3.m_DecalBlendType = _DecalBlendType3;
				Decal3.m_DecalRotation = _DecalRotation3;
				Decal3.m_DecalScale = _DecalScale3;
				Decal3.m_DecalSideOffset = _DecalSideOffset3;
				Decal3.m_DecalPosition = _DecalPosition3;
				Decal3.m_DecalRotationSpeed = _DecalRotationSpeed3;
				Decal3.m_DecalEmissionStrength = _DecalEmissionStrength3;
				Decal3.m_DecalBlendAlpha = _DecalBlendAlpha3;
				Decal3.m_DecalOverrideAlpha = _DecalOverrideAlpha3;
				Decal3.m_DecalHueShiftEnabled = _DecalHueShiftEnabled3;
				Decal3.m_DecalHueShift = _DecalHueShift3;
				Decal3.m_DecalHueShiftSpeed = _DecalHueShiftSpeed3;
				Decal3.m_DecalDepth = _Decal3Depth;
				Decal3.m_DecalHueAngleStrength = _Decal3HueAngleStrength;
				Decal3.m_DecalChannelSeparationEnable = _Decal3ChannelSeparationEnable;
				Decal3.m_DecalChannelSeparation = _Decal3ChannelSeparation;
				Decal3.m_DecalChannelSeparationPremultiply = _Decal3ChannelSeparationPremultiply;
				Decal3.m_DecalChannelSeparationHue = _Decal3ChannelSeparationHue;
				Decal3.m_DecalChannelSeparationVertical = _Decal3ChannelSeparationVertical;
				Decal3.m_DecalChannelSeparationAngleStrength = _Decal3ChannelSeparationAngleStrength;
				
				Decal3.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal3.m_AudioLinkDecalScaleBand = _AudioLinkDecal3ScaleBand;
				Decal3.m_AudioLinkDecalScale = _AudioLinkDecal3Scale;
				Decal3.m_AudioLinkDecalRotationBand = _AudioLinkDecal3RotationBand;
				Decal3.m_AudioLinkDecalRotation = _AudioLinkDecal3Rotation;
				Decal3.m_AudioLinkDecalAlphaBand = _AudioLinkDecal3AlphaBand;
				Decal3.m_AudioLinkDecalAlpha = _AudioLinkDecal3Alpha;
				Decal3.m_AudioLinkDecalEmissionBand = _AudioLinkDecal3EmissionBand;
				Decal3.m_AudioLinkDecalEmission = _AudioLinkDecal3Emission;
				Decal3.m_DecalRotationCTALBand = _DecalRotationCTALBand3;
				Decal3.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed3;
				Decal3.m_DecalRotationCTALType = _DecalRotationCTALType3;
				Decal3.m_AudioLinkDecalColorChord = _AudioLinkDecalCC3;
				Decal3.m_AudioLinkDecalSideBand = _AudioLinkDecal3SideBand;
				Decal3.m_AudioLinkDecalSideMin = _AudioLinkDecal3SideMin;
				Decal3.m_AudioLinkDecalSideMax = _AudioLinkDecal3SideMax;
				Decal3.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal3ChannelSeparation;
				Decal3.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal3ChannelSeparationBand;
				
				Decal3.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal3ChannelSeparationEnable==0
				if (_Decal3ChannelSeparationEnable)
				{
					Decal3.SampleDecalChannelSeparation(_DecalTexture3, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal3ChannelSeparationEnable==1
				if (!_Decal3ChannelSeparationEnable)
				{
					Decal3.SampleDecal(_DecalTexture3, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal3.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal3.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				if (alphaOverride)
				{
					poiFragData.alpha *= decalAlpha;
				}
				poiFragData.baseColor = saturate(poiFragData.baseColor);
			}
			#endif
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			void applyDissolve(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods, in PoiCam poiCam, in PoiLight poiLight)
			{
				#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
				float dissolveMask = POI2D_SAMPLER_PAN(_DissolveMask, _MainTex, poiUV(poiMesh.uv[_DissolveMaskUV], _DissolveMask_ST), _DissolveMaskPan).r;
				#else
				float dissolveMask = 1;
				#endif
				UNITY_BRANCH
				if (_DissolveUseVertexColors > 0)
				{
					// Vertex Color Imprecision hype
					dissolveMask = ceil(poiMesh.vertexColor[_DissolveUseVertexColors] * 100000) / 100000;
				}
				if (_DissolveMaskGlobalMask > 0)
				{
					dissolveMask = maskBlend(dissolveMask, poiMods.globalMask[_DissolveMaskGlobalMask-1], _DissolveMaskGlobalMaskBlendType);
				}
				
				#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
				dissolveToTexture = POI2D_SAMPLER_PAN(_DissolveToTexture, _MainTex, poiUV(poiMesh.uv[_DissolveToTextureUV], _DissolveToTexture_ST), _DissolveToTexturePan) * float4(poiThemeColor(poiMods, _DissolveTextureColor.rgb, _DissolveTextureColorThemeIndex), _DissolveTextureColor.a);
				#else
				dissolveToTexture = _DissolveTextureColor;
				#endif
				
				#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float dissolveNoiseTexture = POI2D_SAMPLER_PAN(_DissolveNoiseTexture, _MainTex, poiUV(poiMesh.uv[_DissolveNoiseTextureUV], _DissolveNoiseTexture_ST), _DissolveNoiseTexturePan).r;
				#else
				float dissolveNoiseTexture = 1;
				#endif
				
				float da = _DissolveAlpha
				+ _DissolveAlpha0
				+ _DissolveAlpha1
				+ _DissolveAlpha2
				+ _DissolveAlpha3
				+ _DissolveAlpha4
				+ _DissolveAlpha5
				+ _DissolveAlpha6
				+ _DissolveAlpha7
				+ _DissolveAlpha8
				+ _DissolveAlpha9;
				float dds = _DissolveDetailStrength;
				
				if(_UVTileDissolveEnabled)
				{
					float2 udim = floor(poiMesh.uv[(int)_UVTileDissolveUV]);
					
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					da += (udim.y >= 0 && udim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMask);
					da += (udim.y >= 1 && udim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMask);
					da += (udim.y >= 2 && udim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMask);
					da += (udim.y >= 3 && udim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMask);
				}
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (_EnableDissolveAudioLink && poiMods.audioLinkAvailable)
				{
					da += lerp(_AudioLinkDissolveAlpha.x, _AudioLinkDissolveAlpha.y, poiMods.audioLink[_AudioLinkDissolveAlphaBand]);
					dds += lerp(_AudioLinkDissolveDetail.x, _AudioLinkDissolveDetail.y, poiMods.audioLink[_AudioLinkDissolveDetailBand]);
				}
				#endif
				
				da = saturate(da);
				dds = saturate(dds);
				
				if (_DissolveMaskInvert)
				{
					dissolveMask = 1 - dissolveMask;
				}
				#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
				float dissolveDetailNoise = POI2D_SAMPLER_PAN(_DissolveDetailNoise, _MainTex, poiUV(poiMesh.uv[_DissolveDetailNoiseUV], _DissolveDetailNoise_ST), _DissolveDetailNoisePan);
				#else
				float dissolveDetailNoise = 0;
				#endif
				if (_DissolveInvertNoise)
				{
					dissolveNoiseTexture = 1 - dissolveNoiseTexture;
				}
				if (_DissolveInvertDetailNoise)
				{
					dissolveDetailNoise = 1 - dissolveDetailNoise;
				}
				if (_ContinuousDissolve != 0)
				{
					da = sin(_Time.x * _ContinuousDissolve) * .5 + .5;
				}
				da *= dissolveMask;
				dissolveAlpha = da;
				edgeAlpha = 0;
				
				[flatten]
				switch(_DissolveType)
				{
					default: // Basic (case 1)
					{
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						float noise = saturate(dissolveNoiseTexture - dissolveDetailNoise * dds);
						
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
					case 2: // Point to Point
					{
						float3 direction;
						float3 currentPos;
						float distanceTo = 0;
						direction = normalize(_DissolveEndPoint - _DissolveStartPoint);
						currentPos = lerp(_DissolveStartPoint, _DissolveEndPoint, dissolveAlpha);
						
						UNITY_BRANCH
						if (_DissolveP2PWorldLocal != 1)
						{
							float3 pos = _DissolveP2PWorldLocal == 0 ? poiMesh.localPos.rgb : poiMesh.vertexColor.rgb;
							distanceTo = dot(pos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = step(distanceTo, 0);
							edgeAlpha *= 1 - dissolveAlpha;
						}
						else
						{
							distanceTo = dot(poiMesh.worldPos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = (distanceTo < 0) ? 1 : 0;
							edgeAlpha *= 1 - dissolveAlpha;
						}
						
						if(_DissolveP2PClamp)
						{
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 3: // Spherical
					{
						if(_SphericalDissolveInvert)
						{
							da = remap(da, 1, 0, -_DissolveEdgeWidth, 1);
						} else {
							da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						}
						
						dissolveAlpha = da;
						dds *= smoothstep(0, 0.2*dds + 0.01, dissolveAlpha) * lerp(1, smoothstep(1, 1 - 0.2*dds - 0.01, dissolveAlpha), _DissolveDetailEdgeSmoothing);
						float currentDistance = lerp(0, _SphericalDissolveRadius, dissolveAlpha);
						float fragDistance = distance(_SphericalDissolveCenter, poiMesh.localPos.xyz);
						float normalizedDistance;
						normalizedDistance = (fragDistance - currentDistance) / (_SphericalDissolveRadius + 0.0001)  - dissolveDetailNoise * dds;
						
						if(_SphericalDissolveInvert)
						{
							dissolveAlpha = (normalizedDistance > 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, -normalizedDistance);
						} else {
							dissolveAlpha = (normalizedDistance < 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, normalizedDistance);
						}
						
						if(_SphericalDissolveClamp)
						{
							da = lerp(da, 1 - da, _SphericalDissolveInvert);
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 4: // CenterOut
					{
						float ramp = 0.5;
						float noise;
						
						[flatten]
						switch(_CenterOutDissolveMode)
						{
							case 1: // View Direction
							{
								ramp = saturate(lerp(poiLight.vertexNDotV, poiLight.nDotV, _CenterOutDissolveNormals));
								break;
							}
							case 2: // Custom Direction
							{
								ramp = dot(normalize(_CenterOutDissolveDirection), lerp(poiMesh.normals[0], poiMesh.normals[1], _CenterOutDissolveNormals));
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
							case 3: // Light Direction
							{
								ramp = lerp(poiLight.vertexNDotL, poiLight.nDotL, _CenterOutDissolveNormals);
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
						}
						
						if(_CenterOutDissolvePower != 1)
						{
							ramp = pow(ramp, _CenterOutDissolvePower);
						}
						
						if(!_CenterOutDissolveInvert)
						{
							ramp = 1 - ramp;
						}
						
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						
						noise = saturate(ramp - dissolveDetailNoise * dds);
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
				}
				
				#ifndef POI_SHADOW
				UNITY_BRANCH
				if (_DissolveHueShiftEnabled)
				{
					dissolveToTexture.rgb = hueShift(dissolveToTexture.rgb, _DissolveHueShift + _Time.x * _DissolveHueShiftSpeed);
				}
				#endif
				
				poiFragData.alpha = lerp(poiFragData.alpha, dissolveToTexture.a, dissolveAlpha * .999999);
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				poiFragData.baseColor = lerp(poiFragData.baseColor, dissolveToTexture.rgb, dissolveAlpha * .999999);
				
				UNITY_BRANCH
				if (_DissolveEdgeWidth || (_DissolveType == 2 && _DissolveP2PEdgeLength != 0))
				{
					edgeColor = tex2D(_DissolveEdgeGradient, poiUV(float2(edgeAlpha, edgeAlpha), _DissolveEdgeGradient_ST)) * float4(poiThemeColor(poiMods, _DissolveEdgeColor.rgb, _DissolveEdgeColorThemeIndex), _DissolveEdgeColor.a);
					#ifndef POI_SHADOW
					UNITY_BRANCH
					if (_DissolveEdgeHueShiftEnabled)
					{
						edgeColor.rgb = hueShift(edgeColor.rgb, _DissolveEdgeHueShift + _Time.x * _DissolveEdgeHueShiftSpeed);
					}
					#endif
					poiFragData.baseColor = lerp(poiFragData.baseColor, edgeColor.rgb, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				}
				
				poiFragData.emission += lerp(0, dissolveToTexture * _DissolveToEmissionStrength, dissolveAlpha) + lerp(0, edgeColor.rgb * _DissolveEdgeEmission, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				#endif
			}
			#endif
			//endex
			
			//ifex _ShadingEnabled==0
			#ifdef VIGNETTE_MASKED
			
			#ifdef _LIGHTINGMODE_CLOTH
			float V_SmithGGXCorrelated(float roughness, float NoV, float NoL)
			{
				// Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"
				float a2 = roughness * roughness;
				// TODO: lambdaV can be pre-computed for all the lights, it should be moved out of this function
				float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);
				float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);
				float v = 0.5 / (lambdaV + lambdaL);
				// a2=0 => v = 1 / 4*NoL*NoV   => min=1/4, max=+inf
				// a2=1 => v = 1 / 2*(NoL+NoV) => min=1/4, max=+inf
				// clamp to the maximum value representable in mediump
				return v;
			}
			
			float D_GGX(float roughness, float NoH)
			{
				// Walter et al. 2007, "Microfacet Models for Refraction through Rough Surfaces"
				
				// In mediump, there are two problems computing 1.0 - NoH^2
				// 1) 1.0 - NoH^2 suffers floating point cancellation when NoH^2 is close to 1 (highlights)
				// 2) NoH doesn't have enough precision around 1.0
				// Both problem can be fixed by computing 1-NoH^2 in highp and providing NoH in highp as well
				
				// However, we can do better using Lagrange's identity:
				//      ||a x b||^2 = ||a||^2 ||b||^2 - (a . b)^2
				// since N and H are unit vectors: ||N x H||^2 = 1.0 - NoH^2
				// This computes 1.0 - NoH^2 directly (which is close to zero in the highlights and has
				// enough precision).
				// Overall this yields better performance, keeping all computations in mediump
				float oneMinusNoHSquared = 1.0 - NoH * NoH;
				
				float a = NoH * roughness;
				float k = roughness / (oneMinusNoHSquared + a * a);
				float d = k * k * (1.0 / UNITY_PI);
				return d;
			}
			
			// https://github.com/google/filament/blob/main/shaders/src/brdf.fs#L94-L100
			float D_Charlie(float roughness, float NoH)
			{
				// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
				float invAlpha = 1.0 / roughness;
				float cos2h = NoH * NoH;
				float sin2h = max(1.0 - cos2h, 0.0078125); // 0.0078125 = 2^(-14/2), so sin2h^2 > 0 in fp16
				return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * UNITY_PI);
			}
			
			// https://github.com/google/filament/blob/main/shaders/src/brdf.fs#L136-L139
			float V_Neubelt(float NoV, float NoL)
			{
				// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
				return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
			}
			
			float Distribution(float roughness, float NoH, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(GGXTerm(roughness, NoH), D_Charlie(roughness, NoH), cloth);
				}
				//endex
				return cloth <= 0.5 ? GGXTerm(roughness, NoH) : D_Charlie(roughness, NoH);
			}
			
			float Visibility(float roughness, float NoV, float NoL, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(V_SmithGGXCorrelated(roughness, NoV, NoL), V_Neubelt(NoV, NoL), cloth);
				}
				//endex
				return cloth <= 0.5 ? V_SmithGGXCorrelated(roughness, NoV, NoL) : V_Neubelt(NoV, NoL);
			}
			
			float F_Schlick(float3 f0, float f90, float VoH)
			{
				// Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"
				return f0 + (f90 - f0) * pow(1.0 - VoH, 5);
			}
			
			float F_Schlick(float3 f0, float VoH)
			{
				float f = pow(1.0 - VoH, 5.0);
				return f + f0 * (1.0 - f);
			}
			
			float Fresnel(float3 f0, float LoH)
			{
				float f90 = saturate(dot(f0, float(50.0 * 0.33).xxx));
				return F_Schlick(f0, f90, LoH);
			}
			
			float Fd_Burley(float roughness, float NoV, float NoL, float LoH)
			{
				// Burley 2012, "Physically-Based Shading at Disney"
				float f90 = 0.5 + 2.0 * roughness * LoH * LoH;
				float lightScatter = F_Schlick(1.0, f90, NoL);
				float viewScatter = F_Schlick(1.0, f90, NoV);
				return lightScatter * viewScatter;
			}
			
			// Energy conserving wrap diffuse term, does *not* include the divide by PI
			float Fd_Wrap(float NoL, float w)
			{
				return saturate((NoL + w) / pow(1.0 + w, 2));
			}
			
			float4 SampleDFG(float NoV, float perceptualRoughness)
			{
				return _ClothDFG.Sample(sampler_ClothDFG, float3(NoV, perceptualRoughness, 0));
			}
			
			float3 EnvBRDF(float2 dfg, float3 f0)
			{
				return f0 * dfg.x + dfg.y;
			}
			
			float3 EnvBRDFMultiscatter(float3 dfg, float3 f0, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(lerp(dfg.xxx, dfg.yyy, f0), f0 * dfg.z, cloth);
				}
				//endex
				return cloth <= 0.5 ? lerp(dfg.xxx, dfg.yyy, f0) : f0 * dfg.z;
			}
			
			float3 EnvBRDFEnergyCompensation(float3 dfg, float3 f0, float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return lerp(1.0 + f0 * (1.0 / dfg.y - 1.0), 1, cloth);
				}
				//endex
				return cloth <= 0.5 ? 1.0 + f0 * (1.0 / dfg.y - 1.0) : 1;
			}
			
			//
			float ClothMetallic(float cloth)
			{
				//ifex _ClothLerp==0
				if (_ClothLerp)
				{
					return cloth;
				}
				//endex
				return cloth <= 0.5 ? 1 : 0;
			}
			
			float3 Specular(float roughness, PoiLight poiLight, float f0, float3 normal, float cloth)
			{
				float NoL = poiLight.nDotLSaturated;
				float NoH = poiLight.nDotH;
				float LoH = poiLight.lDotH;
				float NoV = poiLight.nDotV;
				
				float D = Distribution(roughness, NoH, cloth);
				float V = Visibility(roughness, NoV, NoL, cloth);
				float3 F = Fresnel(f0, LoH);
				
				return (D * V) * F;
			}
			
			float3 getBoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
			{
				#if UNITY_SPECCUBE_BOX_PROJECTION
				if (cubemapPosition.w > 0)
				{
					float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
					float scalar = min(min(factors.x, factors.y), factors.z);
					direction = direction * scalar + (position - cubemapPosition.xyz);
				}
				#endif
				
				return direction;
			}
			
			float SpecularAO(float NoV, float ao, float roughness)
			{
				return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);
			}
			
			float3 IndirectSpecular(float3 dfg, float roughness, float occlusion, float energyCompensation, float cloth, float3 indirectDiffuse, float f0, PoiLight poiLight, PoiFragData poiFragData, PoiCam poiCam, PoiMesh poiMesh)
			{
				float3 normal = poiMesh.normals[1];
				
				float3 reflDir = reflect(-poiCam.viewDir, normal);
				
				Unity_GlossyEnvironmentData envData;
				envData.roughness = roughness;
				envData.reflUVW = getBoxProjection(reflDir, poiMesh.worldPos, unity_SpecCube0_ProbePosition,
				unity_SpecCube0_BoxMin.xyz, unity_SpecCube0_BoxMax.xyz);
				
				float3 probe0 = Unity_GlossyEnvironment(UNITY_PASS_TEXCUBE(unity_SpecCube0), unity_SpecCube0_HDR, envData);
				float3 indirectSpecular = probe0;
				
				#if UNITY_SPECCUBE_BLENDING
				UNITY_BRANCH
				if (unity_SpecCube0_BoxMin.w < 0.99999)
				{
					envData.reflUVW = getBoxProjection(reflDir, poiMesh.worldPos, unity_SpecCube1_ProbePosition, unity_SpecCube1_BoxMin.xyz, unity_SpecCube1_BoxMax.xyz);
					float3 probe1 = Unity_GlossyEnvironment(UNITY_PASS_TEXCUBE_SAMPLER(unity_SpecCube1, unity_SpecCube0), unity_SpecCube1_HDR, envData);
					indirectSpecular = lerp(probe1, probe0, unity_SpecCube0_BoxMin.w);
				}
				#endif
				
				float horizon = min(1 + dot(reflDir, normal), 1);
				indirectSpecular = indirectSpecular * horizon * horizon * energyCompensation * EnvBRDFMultiscatter(dfg, f0, cloth);
				
				indirectSpecular *= SpecularAO(poiLight.nDotV, occlusion, roughness);
				return indirectSpecular;
			};
			#endif
			
			#ifdef _LIGHTINGMODE_WRAPPED
			// Wrapped
			// Green’s model with adjustable energy
			// http://blog.stevemcauley.com/2011/12/03/energy-conserving-wrapped-diffuse/
			// Modified for adjustable conservation ratio and over-wrap to directionless
			float RTWrapFunc(in float dt, in float w, in float norm)
			{
				float cw = saturate(w);
				
				float o = (dt + cw) / ((1.0 + cw) * (1.0 + cw * norm));
				float flt = 1.0 - 0.85 * norm;
				if (w > 1.0)
				{
					o = lerp(o, flt, w - 1.0);
				}
				return o;
			}
			
			float3 GreenWrapSH(float fA) // Greens unoptimized and non-normalized
			
			{
				float fAs = saturate(fA);
				float4 t = float4(fA + 1, fAs - 1, fA - 2, fAs + 1); // DJL edit: allow wrapping to L0-only at w=2
				return float3(t.x, -t.z * t.x / 3, 0.25 * t.y * t.y * t.w);
			}
			float3 GreenWrapSHOpt(float fW) // optimised and normalized https://blog.selfshadow.com/2012/01/07/righting-wrap-part-2/
			
			{
				const float4 t0 = float4(0.0, 1.0 / 4.0, -1.0 / 3.0, -1.0 / 2.0);
				const float4 t1 = float4(1.0, 2.0 / 3.0, 1.0 / 4.0, 0.0);
				float3 fWs = float3(fW, fW, saturate(fW)); // DJL edit: allow wrapping to L0-only at w=2
				
				float3 r;
				r.xyz = t0.xxy * fWs + t0.xzw;
				r.xyz = r.xyz * fWs + t1.xyz;
				return r;
			}
			float3 ShadeSH9_wrapped(float3 normal, float wrap)
			{
				float3 x0, x1, x2;
				float3 conv = lerp(GreenWrapSH(wrap), GreenWrapSHOpt(wrap), _LightingWrappedNormalization); // Should try optimizing this...
				conv *= float3(1, 1.5, 4); // Undo pre-applied cosine convolution by using the inverse
				
				// Constant (L0)
				x0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				// Remove pre-applied constant part from L(2,0) to apply correct convolution
				float3 L2_0 = float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / - 3.0;
				x0 -= L2_0;
				
				// Linear (L1) polynomial terms
				x1.r = dot(unity_SHAr.xyz, normal);
				x1.g = dot(unity_SHAg.xyz, normal);
				x1.b = dot(unity_SHAb.xyz, normal);
				
				// 4 of the quadratic (L2) polynomials
				float4 vB = normal.xyzz * normal.yzzx;
				x2.r = dot(unity_SHBr, vB);
				x2.g = dot(unity_SHBg, vB);
				x2.b = dot(unity_SHBb, vB);
				
				// Final (5th) quadratic (L2) polynomial
				float vC = normal.x * normal.x - normal.y * normal.y;
				x2 += unity_SHC.rgb * vC;
				// Move back the constant part of L(2,0)
				x2 += L2_0;
				
				return x0 * conv.x + x1 * conv.y + x2 * conv.z;
			}
			
			float3 GetSHDirectionL1()
			{
				// For efficiency, we only get the direction from L1.
				// Because getting it from L2 would be too hard!
				return Unity_SafeNormalize((unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz));
			}
			// Returns the value from SH in the lighting direction with the
			// brightest intensity.
			half3 GetSHMaxL1()
			{
				float3 maxDirection = GetSHDirectionL1();
				return ShadeSH9_wrapped(maxDirection, 0);
			}
			#endif
			
			#ifdef _LIGHTINGMODE_SHADEMAP
			void applyShadeMapping(inout PoiFragData poiFragData, PoiMesh poiMesh, inout PoiLight poiLight)
			{
				float shadowAttenuation = lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				float attenuation = 1;
				#if defined(POINT) || defined(SPOT)
				shadowAttenuation = lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
				attenuation = poiLight.attenuation;
				#endif
				
				float MainColorFeatherStep = _BaseColor_Step - _BaseShade_Feather;
				float firstColorFeatherStep = _ShadeColor_Step - _1st2nd_Shades_Feather;
				
				#if defined(PROP_1ST_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
				float4 firstShadeMap = POI2D_SAMPLER_PAN(_1st_ShadeMap, _MainTex, poiUV(poiMesh.uv[_1st_ShadeMapUV], _1st_ShadeMap_ST), _1st_ShadeMapPan);
				#else
				float4 firstShadeMap = float4(1, 1, 1, 1);
				#endif
				firstShadeMap = lerp(firstShadeMap, float4(poiFragData.baseColor, 1), _Use_BaseAs1st);
				
				#if defined(PROP_2ND_SHADEMAP) || !defined(OPTIMIZER_ENABLED)
				float4 secondShadeMap = POI2D_SAMPLER_PAN(_2nd_ShadeMap, _MainTex, poiUV(poiMesh.uv[_2nd_ShadeMapUV], _2nd_ShadeMap_ST), _2nd_ShadeMapPan);
				#else
				float4 secondShadeMap = float4(1, 1, 1, 1);
				#endif
				secondShadeMap = lerp(secondShadeMap, firstShadeMap, _Use_1stAs2nd);
				
				firstShadeMap.rgb *= _1st_ShadeColor.rgb; //* lighColor
				secondShadeMap.rgb *= _2nd_ShadeColor.rgb; //* LightColor;
				
				float shadowMask = 1;
				shadowMask *= _Use_1stShadeMapAlpha_As_ShadowMask ? (_1stShadeMapMask_Inverse ? (1.0 - firstShadeMap.a) : firstShadeMap.a) : 1;
				shadowMask *= _Use_2ndShadeMapAlpha_As_ShadowMask ? (_2ndShadeMapMask_Inverse ? (1.0 - secondShadeMap.a) : secondShadeMap.a) : 1;
				
				float mainShadowMask = saturate(1 - ((poiLight.lightMap) - MainColorFeatherStep) / (_BaseColor_Step - MainColorFeatherStep) * (shadowMask));
				float firstSecondShadowMask = saturate(1 - ((poiLight.lightMap) - firstColorFeatherStep) / (_ShadeColor_Step - firstColorFeatherStep) * (shadowMask));
				
				mainShadowMask *= poiLight.shadowMask * _ShadowStrength;
				firstSecondShadowMask *= poiLight.shadowMask * _ShadowStrength;
				
				// 0 lerp | 1 multiply
				if (_ShadingShadeMapBlendType == 0)
				{
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, lerp(firstShadeMap.rgb, secondShadeMap.rgb, firstSecondShadowMask), mainShadowMask) * attenuation;
				}
				else
				{
					poiFragData.baseColor.rgb *= lerp(1, lerp(firstShadeMap.rgb, secondShadeMap.rgb, firstSecondShadowMask), mainShadowMask) * attenuation;
				}
				poiLight.rampedLightMap = 1 - mainShadowMask;
			}
			#endif
			
			#ifdef _LIGHTINGMODE_REALISTIC
			// For https://docs.unity3d.com/Manual/LightMode-Mixed-Subtractive.html
			#if defined(LIGHTMAP_ON) && defined(SHADOWS_SCREEN)
			#if defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK)
			#define SUBTRACTIVE_LIGHTING 1
			#endif
			#endif
			
			void ApplySubtractiveLighting(inout UnityIndirect indirectLight)
			{
				#if SUBTRACTIVE_LIGHTING
				poiLight.attenuation = FadeShadows(lerp(1, poiLight.attenuation, _AttenuationMultiplier));
				
				float ndotl = saturate(dot(i.normal, _WorldSpaceLightPos0.xyz));
				float3 shadowedLightEstimate = ndotl * (1 - poiLight.attenuation) * _LightColor0.rgb;
				float3 subtractedLight = indirectLight.diffuse - shadowedLightEstimate;
				subtractedLight = max(subtractedLight, unity_ShadowColor.rgb);
				subtractedLight = lerp(subtractedLight, indirectLight.diffuse, _LightShadowData.x);
				indirectLight.diffuse = min(subtractedLight, indirectLight.diffuse);
				#endif
			}
			
			UnityIndirect CreateIndirectLight(in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight)
			{
				UnityIndirect indirectLight;
				indirectLight.diffuse = 0;
				indirectLight.specular = 0;
				
				#if defined(LIGHTMAP_ON)
				indirectLight.diffuse = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, poiMesh.lightmapUV.xy));
				
				#if defined(DIRLIGHTMAP_COMBINED)
				float4 lightmapDirection = UNITY_SAMPLE_TEX2D_SAMPLER(
				unity_LightmapInd, unity_Lightmap, poiMesh.lightmapUV.xy
				);
				indirectLight.diffuse = DecodeDirectionalLightmap(
				indirectLight.diffuse, lightmapDirection, poiMesh.normals[1]
				);
				#endif
				ApplySubtractiveLighting(indirectLight);
				#endif
				
				#if defined(DYNAMICLIGHTMAP_ON)
				float3 dynamicLightDiffuse = DecodeRealtimeLightmap(
				UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, poiMesh.lightmapUV.zw)
				);
				
				#if defined(DIRLIGHTMAP_COMBINED)
				float4 dynamicLightmapDirection = UNITY_SAMPLE_TEX2D_SAMPLER(
				unity_DynamicDirectionality, unity_DynamicLightmap,
				poiMesh.lightmapUV.zw
				);
				indirectLight.diffuse += DecodeDirectionalLightmap(
				dynamicLightDiffuse, dynamicLightmapDirection, poiMesh.normals[1]
				);
				#else
				indirectLight.diffuse += dynamicLightDiffuse;
				#endif
				#endif
				
				#if !defined(LIGHTMAP_ON) && !defined(DYNAMICLIGHTMAP_ON)
				#if UNITY_LIGHT_PROBE_PROXY_VOLUME
				if (unity_ProbeVolumeParams.x == 1)
				{
					indirectLight.diffuse = SHEvalLinearL0L1_SampleProbeVolume(
					float4(poiMesh.normals[1], 1), poiMesh.worldPos
					);
					indirectLight.diffuse = max(0, indirectLight.diffuse);
					#if defined(UNITY_COLORSPACE_GAMMA)
					indirectLight.diffuse = LinearToGammaSpace(indirectLight.diffuse);
					#endif
				}
				else
				{
					indirectLight.diffuse += max(0, ShadeSH9(float4(poiMesh.normals[1], 1)));
				}
				#else
				indirectLight.diffuse += max(0, ShadeSH9(float4(poiMesh.normals[1], 1)));
				#endif
				#endif
				
				indirectLight.diffuse *= poiLight.occlusion;
				
				return indirectLight;
			}
			#endif
			
			void calculateShading(inout PoiLight poiLight, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam)
			{
				float shadowAttenuation = lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				float attenuation = 1;
				#if defined(POINT) || defined(SPOT)
				shadowAttenuation = lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
				attenuation = poiLight.attenuation;
				#endif
				
				#ifdef UNITY_PASS_FORWARDADD
				if (_LightingAdditiveType == 0) // Realistic
				{
					poiLight.rampedLightMap = max(0, poiLight.nDotL);
					poiLight.finalLighting = poiLight.directColor * attenuation * max(0, poiLight.nDotL) * poiLight.detailShadow * shadowAttenuation;
					return;
				}
				else if (_LightingAdditiveType == 1) // Toon
				{
					#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
					float passthrough = 0;
					#else
					float passthrough = _LightingAdditivePassthrough;
					#endif
					
					if (_LightingAdditiveGradientEnd == _LightingAdditiveGradientStart) _LightingAdditiveGradientEnd += 0.001;
					
					poiLight.rampedLightMap = smoothstep(_LightingAdditiveGradientEnd, _LightingAdditiveGradientStart, 1 - (.5 * poiLight.nDotL + .5));
					#if defined(POINT) || defined(SPOT)
					poiLight.finalLighting = lerp(poiLight.directColor * max(min(poiLight.additiveShadow, poiLight.detailShadow), passthrough), poiLight.indirectColor, smoothstep(_LightingAdditiveGradientStart, _LightingAdditiveGradientEnd, 1 - (.5 * poiLight.nDotL + .5))) * poiLight.attenuation;
					#else
					poiLight.finalLighting = lerp(poiLight.directColor * max(min(poiLight.attenuation, poiLight.detailShadow), passthrough), poiLight.indirectColor, smoothstep(_LightingAdditiveGradientStart, _LightingAdditiveGradientEnd, 1 - (.5 * poiLight.nDotL + .5)));
					#endif
					return;
				}
				#endif
				
				float shadowStrength = _ShadowStrength * poiLight.shadowMask;
				
				#ifdef POI_PASS_OUTLINE
				shadowStrength = lerp(0, shadowStrength, _OutlineShadowStrength);
				#endif
				
				// These blocks shouldn't need ifex, they should be removed on lock when their keywords aren't present
				
				#ifdef _LIGHTINGMODE_FLAT
				poiLight.finalLighting = poiLight.directColor * attenuation * shadowAttenuation;
				poiLight.rampedLightMap = poiLight.nDotLSaturated;
				#endif
				
				#ifdef _LIGHTINGMODE_TEXTURERAMP
				poiLight.rampedLightMap = lerp(1, UNITY_SAMPLE_TEX2D(_ToonRamp, poiLight.lightMap + _ShadowOffset).rgb, shadowStrength);
				poiLight.finalLighting = lerp(_LightingShadowColor * lerp(poiLight.indirectColor, poiLight.rampedLightMap * poiLight.directColor, _LightingIgnoreAmbientColor) * poiLight.occlusion, poiLight.directColor, poiLight.rampedLightMap) * attenuation;
				#endif
				
				#ifdef _LIGHTINGMODE_MULTILAYER_MATH
				#if defined(PROP_MULTILAYERMATHBLURMAP) || !defined(OPTIMIZER_ENABLED)
				float4 blurMap = POI2D_SAMPLER_PAN(_MultilayerMathBlurMap, _MainTex, poiUV(poiMesh.uv[_MultilayerMathBlurMapUV], _MultilayerMathBlurMap_ST), _MultilayerMathBlurMapPan);
				#else
				float4 blurMap = 1;
				#endif
				
				float4 lns = float4(1, 1, 1, 1);
				
				float3 lightMap = poiLight.lightMapNoAttenuation.xxx;
				lightMap.x *= lerp(1.0, poiLight.attenuation, _ShadowReceive);
				lightMap.y *= lerp(1.0, poiLight.attenuation, _Shadow2ndReceive);
				lightMap.z *= lerp(1.0, poiLight.attenuation, _Shadow3rdReceive);
				
				if (_LightingMulitlayerNonLinear)
				{
					lns.x = poiEdgeNonLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r);
					lns.y = poiEdgeNonLinearNoSaturate(lightMap.y, _Shadow2ndBorder, _Shadow2ndBlur * blurMap.g);
					lns.z = poiEdgeNonLinearNoSaturate(lightMap.z, _Shadow3rdBorder, _Shadow3rdBlur * blurMap.b);
					lns.w = poiEdgeNonLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r, _ShadowBorderRange);
				}
				else
				{
					lns.x = poiEdgeLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r);
					lns.y = poiEdgeLinearNoSaturate(lightMap.y, _Shadow2ndBorder, _Shadow2ndBlur * blurMap.g);
					lns.z = poiEdgeLinearNoSaturate(lightMap.z, _Shadow3rdBorder, _Shadow3rdBlur * blurMap.b);
					lns.w = poiEdgeLinearNoSaturate(lightMap.x, _ShadowBorder, _ShadowBlur * blurMap.r, _ShadowBorderRange);
				}
				lns = saturate(lns);
				
				float3 indirectColor = 1;
				
				if (_ShadowColor.a > 0)
				{
					#if defined(PROP_SHADOWCOLORTEX) || !defined(OPTIMIZER_ENABLED)
					float4 shadowColorTex = POI2D_SAMPLER_PAN(_ShadowColorTex, _MainTex, poiUV(poiMesh.uv[_ShadowColorTexUV], _ShadowColorTex_ST), _ShadowColorTexPan);
					#else
					float4 shadowColorTex = float4(1, 1, 1, 1);
					#endif
					indirectColor = lerp(float3(1, 1, 1), shadowColorTex.rgb, shadowColorTex.a) * _ShadowColor.rgb;
				}
				if (_Shadow2ndColor.a > 0)
				{
					#if defined(PROP_SHADOW2NDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
					float4 shadow2ndColorTex = POI2D_SAMPLER_PAN(_Shadow2ndColorTex, _MainTex, poiUV(poiMesh.uv[_Shadow2ndColorTexUV], _Shadow2ndColorTex_ST), _Shadow2ndColorTexPan);
					#else
					float4 shadow2ndColorTex = float4(1, 1, 1, 1);
					#endif
					shadow2ndColorTex.rgb = lerp(float3(1, 1, 1), shadow2ndColorTex.rgb, shadow2ndColorTex.a) * _Shadow2ndColor.rgb;
					lns.y = _Shadow2ndColor.a - lns.y * _Shadow2ndColor.a;
					indirectColor = lerp(indirectColor, shadow2ndColorTex.rgb, lns.y);
				}
				if (_Shadow3rdColor.a > 0)
				{
					#if defined(PROP_SHADOW3RDCOLORTEX) || !defined(OPTIMIZER_ENABLED)
					float4 shadow3rdColorTex = POI2D_SAMPLER_PAN(_Shadow3rdColorTex, _MainTex, poiUV(poiMesh.uv[_Shadow3rdColorTexUV], _Shadow3rdColorTex_ST), _Shadow3rdColorTexPan);
					#else
					float4 shadow3rdColorTex = float4(1, 1, 1, 1);
					#endif
					shadow3rdColorTex.rgb = lerp(float3(1, 1, 1), shadow3rdColorTex.rgb, shadow3rdColorTex.a) * _Shadow3rdColor.rgb;
					lns.z = _Shadow3rdColor.a - lns.z * _Shadow3rdColor.a;
					indirectColor = lerp(indirectColor, shadow3rdColorTex.rgb, lns.z);
				}
				
				indirectColor = lerp(indirectColor, indirectColor * poiFragData.baseColor, _ShadowMainStrength);
				poiLight.rampedLightMap = lns.x;
				indirectColor = lerp(indirectColor, 1, lns.w * _ShadowBorderColor.rgb);
				indirectColor = indirectColor * lerp(poiLight.indirectColor, poiLight.directColor, _LightingIgnoreAmbientColor);
				indirectColor = lerp(poiLight.directColor, indirectColor, shadowStrength * poiLight.shadowMask);
				poiLight.finalLighting = lerp(indirectColor, poiLight.directColor, lns.x) * attenuation;
				#endif
				
				#ifdef _LIGHTINGMODE_SHADEMAP
				poiLight.finalLighting = poiLight.directColor;
				#endif
				
				#ifdef _LIGHTINGMODE_REALISTIC
				UnityLight light;
				light.dir = poiLight.direction;
				light.color = saturate(_LightColor0.rgb * shadowAttenuation * attenuation * poiLight.detailShadow);
				light.ndotl = poiLight.nDotLSaturated;
				UnityIndirect indirectLight = (UnityIndirect)0;
				#ifdef UNITY_PASS_FORWARDBASE
				indirectLight = CreateIndirectLight(poiMesh, poiCam, poiLight);
				#endif
				#ifdef UNITY_PASS_FORWARDBASE
				light.color = max(light.color * _PPLightingMultiplier, 0);
				light.color = max(light.color + _PPLightingAddition, 0);
				indirectLight.diffuse = max(indirectLight.diffuse * _PPLightingMultiplier, 0);
				indirectLight.diffuse = max(indirectLight.diffuse + _PPLightingAddition, 0);
				#endif
				
				poiLight.rampedLightMap = poiLight.nDotLSaturated;
				poiLight.finalLighting = max(UNITY_BRDF_PBS(1, 0, 0, 0, poiMesh.normals[1], poiCam.viewDir, light, indirectLight).xyz, _LightingMinLightBrightness);
				#endif
				
				#ifdef _LIGHTINGMODE_CLOTH
				#if defined(PROP_CLOTHMETALLICSMOOTHNESSMAP) || !defined(OPTIMIZER_ENABLED)
				float4 clothmapsample = POI2D_SAMPLER_PAN(_ClothMetallicSmoothnessMap, _MainTex, poiUV(poiMesh.uv[_ClothMetallicSmoothnessMapUV], _ClothMetallicSmoothnessMap_ST), _ClothMetallicSmoothnessMapPan);
				float roughness = 1 - (clothmapsample.a * _ClothSmoothness);
				float reflectance = _ClothReflectance * clothmapsample.b;
				float clothmask = clothmapsample.g;
				float metallic = pow(clothmapsample.r * _ClothMetallic, 2) * ClothMetallic(clothmask);
				roughness = _ClothMetallicSmoothnessMapInvert == 1 ? 1 - roughness : roughness;
				#else
				float roughness = 1 - (_ClothSmoothness);
				float metallic = pow(_ClothMetallic, 2);
				float reflectance = _ClothReflectance;
				float clothmask = 1;
				#endif
				
				float perceptualRoughness = pow(roughness, 2);
				float clampedRoughness = max(0.002, perceptualRoughness);
				
				float f0 = 0.16 * reflectance * reflectance * (1 - metallic) + poiFragData.baseColor * metallic;
				float3 fresnel = Fresnel(f0, poiLight.nDotV);
				
				float3 dfg = SampleDFG(poiLight.nDotV, perceptualRoughness);
				
				float energyCompensation = EnvBRDFEnergyCompensation(dfg, f0, clothmask);
				
				poiLight.finalLighting = Fd_Burley(perceptualRoughness, poiLight.nDotV, poiLight.nDotLSaturated, poiLight.lDotH);
				poiLight.finalLighting *= _LightColor0 * attenuation * shadowAttenuation * poiLight.nDotLSaturated;
				float3 specular = max(0, Specular(clampedRoughness, poiLight, f0, poiMesh.normals[1], clothmask) * poiLight.finalLighting * energyCompensation * UNITY_PI); // (D * V) * F
				
				#ifdef UNITY_PASS_FORWARDBASE
				float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				float3 indirectDiffuse;
				indirectDiffuse.r = shEvaluateDiffuseL1Geomerics_local(L0.r, unity_SHAr.xyz, poiMesh.normals[1]);
				indirectDiffuse.g = shEvaluateDiffuseL1Geomerics_local(L0.g, unity_SHAg.xyz, poiMesh.normals[1]);
				indirectDiffuse.b = shEvaluateDiffuseL1Geomerics_local(L0.b, unity_SHAb.xyz, poiMesh.normals[1]);
				indirectDiffuse = max(0, indirectDiffuse);
				
				float3 indirectSpecular = IndirectSpecular(dfg, roughness, poiLight.occlusion, energyCompensation, clothmask, indirectDiffuse, f0, poiLight, poiFragData, poiCam, poiMesh);
				poiLight.finalLightAdd += max(0, specular + indirectSpecular);
				poiLight.finalLighting += indirectDiffuse * poiLight.occlusion;
				#endif
				
				poiFragData.baseColor.xyz *= (1 - metallic);
				#endif
				
				#ifdef _LIGHTINGMODE_WRAPPED
				#define GREYSCALE_VECTOR float3(.33333, .33333, .33333)
				float3 directColor = _LightColor0.rgb * saturate(RTWrapFunc(poiLight.nDotL, _LightingWrappedWrap, _LightingWrappedNormalization)) * shadowAttenuation;
				float3 indirectColor = 0;
				#ifdef UNITY_PASS_FORWARDBASE
				indirectColor = ShadeSH9_wrapped(poiMesh.normals[_LightingIndirectUsesNormals], _LightingWrappedWrap) * poiLight.occlusion;
				#endif
				directColor = lerp(directColor, dot(directColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic); // Duplicated from Lightdata due to recreating the light colour
				indirectColor = lerp(indirectColor, dot(indirectColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic); // Ditto^
				
				float3 ShadeSH9Plus_2 = GetSHMaxL1();
				float bw_topDirectLighting_2 = dot(_LightColor0.rgb, GREYSCALE_VECTOR);
				float bw_directLighting = dot(directColor, GREYSCALE_VECTOR);
				float bw_indirectLighting = dot(indirectColor, GREYSCALE_VECTOR);
				float bw_topIndirectLighting = dot(ShadeSH9Plus_2, GREYSCALE_VECTOR);
				
				indirectColor = lerp(indirectColor, 1, _LightingIgnoreAmbientColor);
				
				poiLight.lightMap = smoothstep(0, bw_topIndirectLighting + bw_topDirectLighting_2, bw_indirectLighting + bw_directLighting) * poiLight.detailShadow;
				poiLight.rampedLightMap = saturate((poiLight.lightMap - (1 - _LightingGradientEnd)) / saturate((1 - _LightingGradientStart) - (1 - _LightingGradientEnd) + fwidth(poiLight.lightMap)));
				float3 mathRamp = lerp(float3(1, 1, 1), saturate(lerp((_LightingShadowColor * indirectColor), float3(1, 1, 1), saturate(poiLight.rampedLightMap))), _ShadowStrength);
				
				float3 finalWrap = directColor + indirectColor;
				if (_LightingCapEnabled)
				{
					finalWrap = clamp(finalWrap, _LightingMinLightBrightness, _LightingCap);
				}
				else
				{
					finalWrap = max(finalWrap, _LightingMinLightBrightness);
				}
				finalWrap *= attenuation;
				poiLight.finalLighting = finalWrap * saturate(mathRamp + 1 - _ShadowStrength);
				#endif
				
				#ifdef _LIGHTINGMODE_SKIN
				float3 ambientNormalWorld = poiMesh.normals[1];//aTangentToWorld(s, s.blurredNormalTangent);
				poiLight.rampedLightMap = poiLight.nDotLSaturated;
				
				// Scattering mask.
				#if defined(PROP_SKINTHICKNESS) || !defined(OPTIMIZER_ENABLED)
				float subsurface = 1 - POI2D_SAMPLER_PAN(_SkinThicknessMap, _MainTex, poiUV(poiMesh.uv[_SkinThicknessMapUV], _SkinThicknessMap_ST), _SkinThicknessMapPan).r;
				#else
				float subsurface = 1;
				#endif
				if (_SkinThicknessMapInvert)
				{
					subsurface = 1 - subsurface;
				}
				if (_SkinThicknessPower != 1)
				{
					subsurface = pow(subsurface, _SkinThicknessPower);
				}
				float skinScattering = saturate(subsurface * _SssScale * 2);
				
				// Skin subsurface depth absorption tint.
				// cf http://www.crytek.com/download/2014_03_25_CRYENGINE_GDC_Schultz.pdf pg 35
				// link dead, https://ia600902.us.archive.org/25/items/crytek_presentations/2014_03_25_CRYENGINE_GDC_Schultz.pdf
				half3 absorption = exp((1.0h - subsurface) * _SssTransmissionAbsorption.rgb);
				
				// Albedo scale for absorption assumes ~0.5 luminance for Caucasian skin.
				absorption *= saturate(poiFragData.baseColor * unity_ColorSpaceDouble.rgb);
				
				// Blurred normals for indirect diffuse and direct scattering.
				ambientNormalWorld = normalize(lerp(poiMesh.normals[1], ambientNormalWorld, _SssBumpBlur));
				
				float ndlBlur = dot(poiMesh.normals[1], poiLight.direction) * 0.5h + 0.5h;
				float lumi = dot(poiLight.directColor, half3(0.2126h, 0.7152h, 0.0722h));
				float4 sssLookupUv = float4(ndlBlur, skinScattering * lumi, 0.0f, 0.0f);
				half3 sss = poiLight.lightMap * tex2Dlod(_SkinLUT, sssLookupUv).rgb;
				poiLight.finalLighting = lerp(poiLight.directColor, min(lerp(poiLight.indirectColor * _LightingShadowColor, _LightingShadowColor, _LightingIgnoreAmbientColor) * poiLight.occlusion + (sss * poiLight.directColor), poiLight.directColor), _ShadowStrength) * attenuation;
				#endif
				
				#ifdef _LIGHTINGMODE_SDF
				float3 forward = normalize(UnityObjectToWorldDir(float4(_SDFForward.xyz, 1)));
				float3 left = normalize(UnityObjectToWorldDir(float4(_SDFLeft.xyz, 1)));
				float3 lightDirHorizontal = normalize(float3(poiLight.direction.x, 0, poiLight.direction.z));
				
				float lightAtten = 1 - (dot(lightDirHorizontal, forward) * 0.5 + 0.5);
				float filpU = sign(dot(lightDirHorizontal, left));
				
				#if defined(PROP_SDFSHADINGTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float shadowSDF = POI2D_SAMPLER_PAN(_SDFShadingTexture, _MainTex, poiUV(poiMesh.uv[_SDFShadingTextureUV], _SDFShadingTexture_ST) * float2(filpU, 1), _SDFShadingTexturePan).r;
				#else
				float shadowSDF = float2(1, 1);
				#endif
				float blur = _SDFBlur * 0.1;
				float faceShadow = smoothstep(lightAtten - blur, lightAtten + blur, shadowSDF) * poiLight.detailShadow;
				
				float3 indirectColor = _LightingShadowColor.rgb;
				indirectColor = indirectColor * lerp(poiLight.indirectColor, poiLight.directColor, _LightingIgnoreAmbientColor);
				indirectColor = lerp(poiLight.directColor, indirectColor, _ShadowStrength * poiLight.shadowMask);
				
				poiLight.finalLighting = lerp(indirectColor, poiLight.directColor, faceShadow) * attenuation;
				#endif
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					float3 vertexLighting = float3(0, 0, 0);
					for (int index = 0; index < 4; index++)
					{
						//UNITY_BRANCH
						if (_LightingAdditiveType == 0 || _LightingAdditiveType == 3)
						{
							vertexLighting += poiLight.vColor[index] * poiLight.vAttenuationDotNL[index] * poiLight.detailShadow; // Realistic
							
						}
						
						//UNITY_BRANCH
						if (_LightingAdditiveType == 1) // Toon
						
						{
							vertexLighting += lerp(poiLight.vColor[index] * poiLight.vAttenuation[index], poiLight.vColor[index] * _LightingAdditivePassthrough * poiLight.vAttenuation[index], smoothstep(_LightingAdditiveGradientStart, _LightingAdditiveGradientEnd, 1 - (.5 * poiLight.vDotNL[index] + .5))) * poiLight.detailShadow;
						}
						//UNITY_BRANCH
						/*
						if (_LightingAdditiveType == 2) //if(_LightingAdditiveType == 2) // Wrapped
						
						{
							float uv = saturate(RTWrapFunc(-poiLight.vDotNL[index], _LightingWrappedWrap, _LightingWrappedNormalization)) * poiLight.detailShadow;
							poiLight.rampedLightMap = lerp(_LightingShadowColor, float3(1, 1, 1), saturate(1 - smoothstep(_LightingGradientStart - .000001, _LightingGradientEnd, 1 - uv)));
							vertexLighting += poiLight.vColor[index] * poiLight.rampedLightMap * saturate(poiLight.vAttenuation[index] * uv);
						}
						*/
					}
					float3 mixedLight = poiLight.finalLighting;
					poiLight.finalLighting = vertexLighting + poiLight.finalLighting;
					#endif
				}
			}
			#endif
			//endex
			
			//ifex _EnableAniso==0
			#ifdef POI_ANISOTROPICS
			/*
			float D_GGX_Anisotropic(float at, float ab, float TdotH, float BdotH, float NdotH)
			{
				// Burley 2012, "Physically-Based Shading at Disney"
				
				// The values at and ab are perceptualRoughness^2, a2 is therefore perceptualRoughness^4
				// The dot product below computes perceptualRoughness^8. We cannot fit in fp16 without clamping
				// the roughness to too high values so we perform the dot product and the division in fp32
				float a2 = at * ab;
				float3 d = float3(ab * TdotH, at * BdotH, a2 * NdotH);
				float d2 = dot(d, d);
				float b2 = a2 / d2;
				return a2 * b2 * b2 * (1.0 / UNITY_PI);
			}
			
			//-------------------------------------GGX Anisotropic visibility function
			float V_SmithGGXCorrelated_Anisotropic(float at, float ab, float TdotV, float BdotV, float TdotL, float BdotL, float NdotV, float NdotL)
			{
				// Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"
				float lambdaV = NdotL * length(float3(at * TdotV, ab * BdotV, NdotV));
				float lambdaL = NdotV * length(float3(at * TdotL, ab * BdotL, NdotL));
				return 0.5 / (lambdaV + lambdaL);
			}
			*/
			
			float calculateAnisotropics(float3 binormal, float offset, float3 normal, float3 viewDir, float3 LightDirection, float exponent, float strength, float shadowMask)
			{
				float3 ShiftedTangent = normalize(binormal + offset * normal);
				float3 H = normalize(LightDirection + viewDir);
				float dotTH = dot(ShiftedTangent, H);
				float sinTH = sqrt(1.0 - dotTH * dotTH);
				float dirAtten = smoothstep(-1.0, 0.0, dotTH);
				return saturate(dirAtten * pow(sinTH, exponent) * strength) * shadowMask;
			}
			
			float aaEdgeFeather(float value, float edge, float feather)
			{
				float edgeMin = saturate(edge - feather * 0.5);
				float edgeMax = saturate(edge + feather * 0.5);
				return saturate((value - edgeMin) / saturate(edgeMax - edgeMin + fwidth(value)));
			}
			
			float3 applyAnisotropics(inout PoiFragData poiFragData, inout PoiLight poiLight, in PoiCam poiCam, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_ANISOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				float4 specMap = POI2D_SAMPLER_PAN(_AnisoColorMap, _MainTex, poiUV(poiMesh.uv[_AnisoColorMapUV], _AnisoColorMap_ST), _AnisoColorMapPan);
				#else
				float4 specMap = float4(1, 1, 1, 0);
				#endif
				
				float shadowMask = lerp(1, poiMax(poiLight.rampedLightMap), _AnisoHideInShadow);
				#ifdef POI_PASS_ADD
				shadowMask *= poiLight.attenuation * poiLight.additiveShadow;
				#endif
				
				float spec0 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso0SwitchDirection), _Aniso0Offset +_Aniso0OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.direction, _Aniso0Power * 1000, _Aniso0Strength, shadowMask);
				float spec1 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso1SwitchDirection), _Aniso1Offset +_Aniso1OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.direction, _Aniso1Power * 1000, _Aniso1Strength, shadowMask);
				
				spec0 = lerp(spec0, aaEdgeFeather(spec0, _Aniso0Edge, _Aniso0Blur), _Aniso0ToonMode);
				spec1 = lerp(spec1, aaEdgeFeather(spec1, _Aniso1Edge, _Aniso1Blur), _Aniso1ToonMode);
				
				float3 spec0Color = specMap.rgb * _Aniso0Tint;
				float3 spec1Color = specMap.rgb * _Aniso1Tint;
				
				float3 finalSpec = saturate(saturate(spec0 * spec0Color) + saturate(spec1 * spec1Color)) * lerp(1, poiFragData.baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor);
				float3 baseColor = poiFragData.baseColor;
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, spec1Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor), _AnisoReplace * spec1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, spec0Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor), _AnisoReplace * spec0);
				poiLight.finalLightAdd += max(0, finalSpec * _AnisoAdd);
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						float vSpec0 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso0SwitchDirection), _Aniso0Offset +_Aniso0OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.vDirection[index], _Aniso0Power * 1000, _Aniso0Strength, poiLight.vAttenuationDotNL[index]);
						float vSpec1 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso1SwitchDirection), _Aniso1Offset +_Aniso1OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.vDirection[index], _Aniso1Power * 1000, _Aniso1Strength, poiLight.vAttenuationDotNL[index]);
						
						vSpec0 = lerp(vSpec0, aaEdgeFeather(vSpec0, _Aniso0Edge, _Aniso0Blur), _Aniso0ToonMode);
						vSpec1 = lerp(vSpec1, aaEdgeFeather(vSpec1, _Aniso1Edge, _Aniso1Blur), _Aniso1ToonMode);
						
						float3 vSpec0Color = specMap.rgb * _Aniso0Tint;
						float3 vSpec1Color = specMap.rgb * _Aniso1Tint;
						
						poiLight.finalLightAdd += max(0, saturate(saturate(vSpec0 * spec0Color) + saturate(vSpec1 * spec1Color)) * lerp(1, poiFragData.baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor) * _AnisoAdd);
						
						poiFragData.baseColor = lerp(poiFragData.baseColor, spec1Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor), _AnisoReplace * vSpec1);
						poiFragData.baseColor = lerp(poiFragData.baseColor, spec0Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor), _AnisoReplace * vSpec0);
					}
					#endif
				}
				
				//ifex _AnisoDebugToggle==0
				if(_AnisoDebugToggle)
				{
					switch(_AnisoDebugMode)
					{
						// final Spec
						case 1:
						{
							return finalSpec;
							break;
						}
						case 2:
						{
							return spec0 * spec0Color;
							break;
						}
						case 3:
						{
							return spec1 * spec1Color;
							break;
						}
					}
				}
				//endex
				
				return float3(0, 0, 0);
			}
			#endif
			//endex
			
			//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
			void blendMatcap(inout PoiLight poiLight, inout PoiFragData poiFragData, in PoiMods poiMods, float add, float lightAdd, float multiply, float replace, float mixed, float screen, float4 matcapColor, float matcapMask, float emissionStrength, float matcapLightMask, uint globalMaskIndex, float globalMaskBlendType)
			{
				if (matcapLightMask)
				{
					matcapMask *= lerp(1, poiLight.rampedLightMap, matcapLightMask);
				}
				if (globalMaskIndex > 0)
				{
					matcapMask = maskBlend(matcapMask, poiMods.globalMask[globalMaskIndex - 1], globalMaskBlendType);
				}
				
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, matcapColor.rgb, replace * matcapMask * matcapColor.a * .999999);
				poiFragData.baseColor.rgb *= lerp(1, matcapColor.rgb, multiply * matcapMask * matcapColor.a);
				poiFragData.baseColor.rgb += matcapColor.rgb * add * matcapMask * matcapColor.a;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, blendScreen(poiFragData.baseColor.rgb, matcapColor.rgb), screen * matcapMask * matcapColor.a);
				poiLight.finalLightAdd += matcapColor.rgb * lightAdd * matcapMask * matcapColor.a;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * matcapColor.rgb, mixed * matcapMask * matcapColor.a);
				poiFragData.emission += matcapColor.rgb * emissionStrength * matcapMask * matcapColor.a;
			}
			//endex
			//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
			#if defined(POI_MATCAP0) || defined(COLOR_GRADING_HDR_3D) || defined(POI_MATCAP2) || defined(POI_MATCAP3)
			void applyMatcap(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiMods poiMods)
			{
				float4 matcap = 0;
				float matcapMask = 0;
				float4 matcap2 = 0;
				float matcap2Mask = 0;
				float4 matcap3 = 0;
				float matcap3Mask = 0;
				float4 matcap4 = 0;
				float matcap4Mask = 0;
				float2 matcapUV = 0;
				//endex
				
				//ifex _MatcapEnable==0
				// Matcap 1
				#ifdef POI_MATCAP0
				float3 normal0 = poiMesh.normals[_MatcapNormal];
				#ifdef POI_MATCAP0_CUSTOM_NORMAL
				#if defined(PROP_MATCAP0NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal0 = calculateNormal(poiMesh.normals[_MatcapNormal], poiMesh, _Matcap0NormalMap, _Matcap0NormalMap_ST, _Matcap0NormalMapPan, _Matcap0NormalMapUV, _Matcap0NormalMapScale);
				#endif
				#endif
				
				switch(_MatcapUVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal0, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _MatcapBorder + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal0), dot(worldViewUp, normal0)) * _MatcapBorder + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal0);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _MatcapBorder + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_MatcapUVToBlend], _MatCapBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _MatcapRotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcapSmoothness;
				float mipCount0 = 9;
				if (_MatcapSmoothnessEnabled)
				{
					if (_Matcap_TexelSize.z == 8192) mipCount0 = 13;
					if (_Matcap_TexelSize.z == 4096) mipCount0 = 12;
					if (_Matcap_TexelSize.z == 2048) mipCount0 = 11;
					if (_Matcap_TexelSize.z == 1024) mipCount0 = 10;
					if (_Matcap_TexelSize.z == 512) mipCount0 = 9;
					if (_Matcap_TexelSize.z == 256) mipCount0 = 8;
					if (_Matcap_TexelSize.z == 128) mipCount0 = 7;
					if (_Matcap_TexelSize.z == 64) mipCount0 = 6;
					if (_Matcap_TexelSize.z == 32) mipCount0 = 5;
					
					matcapSmoothness = _MatcapSmoothness;
					
					if (_MatcapMaskSmoothnessApply)
					{
						#if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
						matcapSmoothness *= POI2D_SAMPLER_PAN(_MatcapMask, _MainTex, poiUV(poiMesh.uv[_MatcapMaskUV], _MatcapMask_ST), _MatcapMaskPan)[_MatcapMaskSmoothnessChannel];
						#endif
					}
					matcapSmoothness = (1 - matcapSmoothness) * mipCount0;
				}
				
				#if defined(PROP_MATCAP) || !defined(OPTIMIZER_ENABLED)
				if (_MatcapSmoothnessEnabled)
				{
					matcap = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap), matcapSmoothness) * float4(poiThemeColor(poiMods, _MatcapColor.rgb, _MatcapColorThemeIndex), _MatcapColor.a);
				}
				else
				{
					matcap = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap)) * float4(poiThemeColor(poiMods, _MatcapColor.rgb, _MatcapColorThemeIndex), _MatcapColor.a);
				}
				#else
				matcap = float4(poiThemeColor(poiMods, _MatcapColor.rgb, _MatcapColorThemeIndex), _MatcapColor.a);
				#endif
				
				matcap.rgb *= _MatcapIntensity;
				matcap.rgb = lerp(matcap.rgb, matcap.rgb * poiFragData.baseColor.rgb, _MatcapBaseColorMix);
				
				#if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
				matcapMask = POI2D_SAMPLER_PAN(_MatcapMask, _MainTex, poiUV(poiMesh.uv[_MatcapMaskUV], _MatcapMask_ST), _MatcapMaskPan)[_MatcapMaskChannel];
				#else
				matcapMask = 1;
				#endif
				
				if (_MatcapMaskInvert)
				{
					matcapMask = 1 - matcapMask;
				}
				
				#ifdef TPS_Penetrator
				if (_MatcapTPSDepthEnabled)
				{
					matcapMask = lerp(0, matcapMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _MatcapTPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap.a, matcapMask * _MatcapAlphaOverride);
				
				//UNITY_BRANCH
				if (_MatcapHueShiftEnabled)
				{
					matcap.rgb = hueShift(matcap.rgb, _MatcapHueShift + _Time.x * _MatcapHueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _MatcapAdd, _MatcapAddToLight, _MatcapMultiply, _MatcapReplace, _MatcapMixed, _MatcapScreen, matcap, matcapMask, _MatcapEmissionStrength, _MatcapLightMask, _MatcapMaskGlobalMask, _MatcapMaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _Matcap2Enable==0
				// Matcap 2
				#ifdef COLOR_GRADING_HDR_3D
				
				float3 normal1 = poiMesh.normals[_Matcap2Normal];
				#ifdef POI_MATCAP1_CUSTOM_NORMAL
				#if defined(PROP_MATCAP1NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal1 = calculateNormal(poiMesh.normals[_Matcap2Normal], poiMesh, _Matcap1NormalMap, _Matcap1NormalMap_ST, _Matcap1NormalMapPan, _Matcap1NormalMapUV, _Matcap1NormalMapScale);
				#endif
				#endif
				
				matcapUV = 0;
				
				switch(_Matcap2UVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal1, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _Matcap2Border + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal1), dot(worldViewUp, normal1)) * _Matcap2Border + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal1);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _Matcap2Border + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_Matcap2UVToBlend], _MatCap2ndBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _Matcap2Rotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcap2Smoothness;
				float mipCount2 = 9;
				if (_Matcap2SmoothnessEnabled)
				{
					if (_Matcap2_TexelSize.z == 8192) mipCount2 = 13;
					if (_Matcap2_TexelSize.z == 4096) mipCount2 = 12;
					if (_Matcap2_TexelSize.z == 2048) mipCount2 = 11;
					if (_Matcap2_TexelSize.z == 1024) mipCount2 = 10;
					if (_Matcap2_TexelSize.z == 512) mipCount2 = 9;
					if (_Matcap2_TexelSize.z == 256) mipCount2 = 8;
					if (_Matcap2_TexelSize.z == 128) mipCount2 = 7;
					if (_Matcap2_TexelSize.z == 64) mipCount2 = 6;
					if (_Matcap2_TexelSize.z == 32) mipCount2 = 5;
					
					matcap2Smoothness = _Matcap2Smoothness;
					
					if (_Matcap2MaskSmoothnessApply)
					{
						#if defined(PROP_MATCAP2MASK) || !defined(OPTIMIZER_ENABLED)
						matcap2Smoothness *= POI2D_SAMPLER_PAN(_Matcap2Mask, _MainTex, poiUV(poiMesh.uv[_Matcap2MaskUV], _Matcap2Mask_ST), _Matcap2MaskPan)[_Matcap2MaskSmoothnessChannel];
						#endif
					}
					matcap2Smoothness = (1 - matcap2Smoothness) * mipCount2;
				}
				
				#if defined(PROP_MATCAP2) || !defined(OPTIMIZER_ENABLED)
				if (_Matcap2SmoothnessEnabled)
				{
					matcap2 = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap2, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap2), matcap2Smoothness) * float4(poiThemeColor(poiMods, _Matcap2Color.rgb, _Matcap2ColorThemeIndex), _Matcap2Color.a);
				}
				else
				{
					matcap2 = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap2, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap2)) * float4(poiThemeColor(poiMods, _Matcap2Color.rgb, _Matcap2ColorThemeIndex), _Matcap2Color.a);
				}
				#else
				matcap2 = float4(poiThemeColor(poiMods, _Matcap2Color.rgb, _Matcap2ColorThemeIndex), _Matcap2Color.a);
				#endif
				
				matcap2.rgb *= _Matcap2Intensity;
				matcap2.rgb = lerp(matcap2.rgb, matcap2.rgb * poiFragData.baseColor.rgb, _Matcap2BaseColorMix);
				
				#if defined(PROP_MATCAP2MASK) || !defined(OPTIMIZER_ENABLED)
				matcap2Mask = POI2D_SAMPLER_PAN(_Matcap2Mask, _MainTex, poiUV(poiMesh.uv[_Matcap2MaskUV], _Matcap2Mask_ST), _Matcap2MaskPan)[_Matcap2MaskChannel];
				#else
				matcap2Mask = 1;
				#endif
				if (_Matcap2MaskInvert)
				{
					matcap2Mask = 1 - matcap2Mask;
				}
				
				#ifdef TPS_Penetrator
				if (_Matcap2TPSDepthEnabled)
				{
					matcap2Mask = lerp(0, matcap2Mask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Matcap2TPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap2.a, matcap2Mask * _Matcap2AlphaOverride);
				
				//UNITY_BRANCH
				if (_Matcap2HueShiftEnabled)
				{
					matcap2.rgb = hueShift(matcap2.rgb, _Matcap2HueShift + _Time.x * _Matcap2HueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _Matcap2Add, _Matcap2AddToLight, _Matcap2Multiply, _Matcap2Replace, _Matcap2Mixed, _Matcap2Screen, matcap2, matcap2Mask, _Matcap2EmissionStrength, _Matcap2LightMask, _Matcap2MaskGlobalMask, _Matcap2MaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _Matcap3Enable==0
				// Matcap 3
				#ifdef POI_MATCAP2
				
				float3 normal2 = poiMesh.normals[_Matcap3Normal];
				#ifdef POI_MATCAP2_CUSTOM_NORMAL
				#if defined(PROP_MATCAP2NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal2 = calculateNormal(poiMesh.normals[_Matcap3Normal], poiMesh, _Matcap2NormalMap, _Matcap2NormalMap_ST, _Matcap2NormalMapPan, _Matcap2NormalMapUV, _Matcap2NormalMapScale);
				#endif
				#endif
				
				matcapUV = 0;
				
				switch(_Matcap3UVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal2, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _Matcap3Border + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal2), dot(worldViewUp, normal2)) * _Matcap3Border + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal2);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _Matcap3Border + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_Matcap3UVToBlend], _MatCap3rdBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _Matcap3Rotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcap3Smoothness;
				float mipCount3 = 9;
				if (_Matcap3SmoothnessEnabled)
				{
					if (_Matcap3_TexelSize.z == 8192) mipCount3 = 13;
					if (_Matcap3_TexelSize.z == 4096) mipCount3 = 12;
					if (_Matcap3_TexelSize.z == 2048) mipCount3 = 11;
					if (_Matcap3_TexelSize.z == 1024) mipCount3 = 10;
					if (_Matcap3_TexelSize.z == 512) mipCount3 = 9;
					if (_Matcap3_TexelSize.z == 256) mipCount3 = 8;
					if (_Matcap3_TexelSize.z == 128) mipCount3 = 7;
					if (_Matcap3_TexelSize.z == 64) mipCount3 = 6;
					if (_Matcap3_TexelSize.z == 32) mipCount3 = 5;
					
					matcap3Smoothness = _Matcap3Smoothness;
					
					if (_Matcap3MaskSmoothnessApply)
					{
						#if defined(PROP_MATCAP3MASK) || !defined(OPTIMIZER_ENABLED)
						matcap3Smoothness *= POI2D_SAMPLER_PAN(_Matcap3Mask, _MainTex, poiUV(poiMesh.uv[_Matcap3MaskUV], _Matcap3Mask_ST), _Matcap3MaskPan)[_Matcap3MaskSmoothnessChannel];
						#endif
					}
					matcap3Smoothness = (1 - matcap3Smoothness) * mipCount3;
				}
				
				#if defined(PROP_MATCAP3) || !defined(OPTIMIZER_ENABLED)
				if (_Matcap3SmoothnessEnabled)
				{
					matcap3 = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap3, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap3), matcap3Smoothness) * float4(poiThemeColor(poiMods, _Matcap3Color.rgb, _Matcap3ColorThemeIndex), _Matcap3Color.a);
				}
				else
				{
					matcap3 = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap3, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap3)) * float4(poiThemeColor(poiMods, _Matcap3Color.rgb, _Matcap3ColorThemeIndex), _Matcap3Color.a);
				}
				#else
				matcap3 = float4(poiThemeColor(poiMods, _Matcap3Color.rgb, _Matcap3ColorThemeIndex), _Matcap3Color.a);
				#endif
				
				matcap3.rgb *= _Matcap3Intensity;
				matcap3.rgb = lerp(matcap3.rgb, matcap3.rgb * poiFragData.baseColor.rgb, _Matcap3BaseColorMix);
				
				#if defined(PROP_MATCAP3MASK) || !defined(OPTIMIZER_ENABLED)
				matcap3Mask = POI2D_SAMPLER_PAN(_Matcap3Mask, _MainTex, poiUV(poiMesh.uv[_Matcap3MaskUV], _Matcap3Mask_ST), _Matcap3MaskPan)[_Matcap3MaskChannel];
				#else
				matcap3Mask = 1;
				#endif
				if (_Matcap3MaskInvert)
				{
					matcap3Mask = 1 - matcap3Mask;
				}
				
				#ifdef TPS_Penetrator
				if (_Matcap3TPSDepthEnabled)
				{
					matcap3Mask = lerp(0, matcap3Mask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Matcap3TPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap3.a, matcap3Mask * _Matcap3AlphaOverride);
				
				//UNITY_BRANCH
				if (_Matcap3HueShiftEnabled)
				{
					matcap3.rgb = hueShift(matcap3.rgb, _Matcap3HueShift + _Time.x * _Matcap3HueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _Matcap3Add, _Matcap3AddToLight, _Matcap3Multiply, _Matcap3Replace, _Matcap3Mixed, _Matcap3Screen, matcap3, matcap3Mask, _Matcap3EmissionStrength, _Matcap3LightMask, _Matcap3MaskGlobalMask, _Matcap3MaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _Matcap4Enable==0
				// Matcap 4
				#ifdef POI_MATCAP3
				
				float3 normal3 = poiMesh.normals[_Matcap4Normal];
				#ifdef POI_MATCAP3_CUSTOM_NORMAL
				#if defined(PROP_MATCAP3NORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal3 = calculateNormal(poiMesh.normals[_Matcap4Normal], poiMesh, _Matcap3NormalMap, _Matcap3NormalMap_ST, _Matcap3NormalMapPan, _Matcap3NormalMapUV, _Matcap3NormalMapScale);
				#endif
				#endif
				
				matcapUV = 0;
				
				switch(_Matcap4UVMode)
				{
					// Normal / UTS
					case 0:
					{
						float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal3, 0))).rgb;
						float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
						float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
						float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
						
						matcapUV = noSknewViewNormal.rg * _Matcap4Border + 0.5;
						break;
					}
					// Top Pinch
					case 1:
					{
						float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
						float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
						matcapUV = float2(dot(worldViewRight, normal3), dot(worldViewUp, normal3)) * _Matcap4Border + 0.5;
						break;
					}
					// Custom Double Sided
					case 2:
					{
						float3 reflection = reflect(-poiCam.viewDir, normal3);
						float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
						matcapUV = uv * _Matcap4Border + 0.5;
						break;
					}
				}
				matcapUV = lerp(matcapUV, poiMesh.uv[_Matcap4UVToBlend], _MatCap4thBlendUV1.xy);
				matcapUV = RotateUV(matcapUV, _Matcap4Rotation * PI, float2(.5, .5), 1.0f);
				
				if (IsInMirror())
				{
					matcapUV.x = 1 - matcapUV.x;
				}
				
				float matcap4Smoothness;
				float mipCount4 = 9;
				if (_Matcap4SmoothnessEnabled)
				{
					if (_Matcap4_TexelSize.z == 8192) mipCount4 = 13;
					if (_Matcap4_TexelSize.z == 4096) mipCount4 = 12;
					if (_Matcap4_TexelSize.z == 2048) mipCount4 = 11;
					if (_Matcap4_TexelSize.z == 1024) mipCount4 = 10;
					if (_Matcap4_TexelSize.z == 512) mipCount4 = 9;
					if (_Matcap4_TexelSize.z == 256) mipCount4 = 8;
					if (_Matcap4_TexelSize.z == 128) mipCount4 = 7;
					if (_Matcap4_TexelSize.z == 64) mipCount4 = 6;
					if (_Matcap4_TexelSize.z == 32) mipCount4 = 5;
					
					matcap4Smoothness = _Matcap4Smoothness;
					
					if (_Matcap4MaskSmoothnessApply)
					{
						#if defined(PROP_MATCAP4MASK) || !defined(OPTIMIZER_ENABLED)
						matcap4Smoothness *= POI2D_SAMPLER_PAN(_Matcap4Mask, _MainTex, poiUV(poiMesh.uv[_Matcap4MaskUV], _Matcap4Mask_ST), _Matcap4MaskPan)[_Matcap4MaskSmoothnessChannel];
						#endif
					}
					matcap4Smoothness = (1 - matcap4Smoothness) * mipCount4;
				}
				
				#if defined(PROP_MATCAP4) || !defined(OPTIMIZER_ENABLED)
				if (_Matcap4SmoothnessEnabled)
				{
					matcap4 = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap4, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap4), matcap4Smoothness) * float4(poiThemeColor(poiMods, _Matcap4Color.rgb, _Matcap4ColorThemeIndex), _Matcap4Color.a);
				}
				else
				{
					matcap4 = UNITY_SAMPLE_TEX2D_SAMPLER(_Matcap4, _MainTex, TRANSFORM_TEX(matcapUV, _Matcap4)) * float4(poiThemeColor(poiMods, _Matcap4Color.rgb, _Matcap4ColorThemeIndex), _Matcap4Color.a);
				}
				#else
				matcap4 = float4(poiThemeColor(poiMods, _Matcap4Color.rgb, _Matcap4ColorThemeIndex), _Matcap4Color.a);
				#endif
				
				matcap4.rgb *= _Matcap4Intensity;
				matcap4.rgb = lerp(matcap4.rgb, matcap4.rgb * poiFragData.baseColor.rgb, _Matcap4BaseColorMix);
				
				#if defined(PROP_MATCAP4MASK) || !defined(OPTIMIZER_ENABLED)
				matcap4Mask = POI2D_SAMPLER_PAN(_Matcap4Mask, _MainTex, poiUV(poiMesh.uv[_Matcap4MaskUV], _Matcap4Mask_ST), _Matcap4MaskPan)[_Matcap4MaskChannel];
				#else
				matcap4Mask = 1;
				#endif
				if (_Matcap4MaskInvert)
				{
					matcap4Mask = 1 - matcap4Mask;
				}
				
				#ifdef TPS_Penetrator
				if (_Matcap4TPSDepthEnabled)
				{
					matcap4Mask = lerp(0, matcap4Mask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Matcap4TPSMaskStrength);
				}
				#endif
				
				poiFragData.alpha *= lerp(1, matcap4.a, matcap4Mask * _Matcap4AlphaOverride);
				
				//UNITY_BRANCH
				if (_Matcap4HueShiftEnabled)
				{
					matcap4.rgb = hueShift(matcap4.rgb, _Matcap4HueShift + _Time.x * _Matcap4HueShiftSpeed);
				}
				
				blendMatcap(poiLight, poiFragData, poiMods, _Matcap4Add, _Matcap4AddToLight, _Matcap4Multiply, _Matcap4Replace, _Matcap4Mixed, _Matcap4Screen, matcap4, matcap4Mask, _Matcap4EmissionStrength, _Matcap4LightMask, _Matcap4MaskGlobalMask, _Matcap4MaskGlobalMaskBlendType);
				#endif
				//endex
				//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
				
			}
			#endif
			//endex
			
			//ifex _CubeMapEnabled==0
			#ifdef _CUBEMAP
			#if defined(PROP_CUBEMAP) || !defined(OPTIMIZER_ENABLED)
			// From Unity's MIT'd Skybox-Cubed.shader
			float3 RotateAroundYInDegrees(float3 dir, float degrees)
			{
				float alpha = degrees * UNITY_PI / 180.0;
				float sina, cosa;
				sincos(alpha, sina, cosa);
				float2x2 m = float2x2(cosa, -sina, sina, cosa);
				return float3(mul(m, dir.xz), dir.y).xzy;
			}
			#endif
			void applyCubemap(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
			{
				float3 CubeMapUV = 0;
				
				switch(_CubeMapUVMode)
				{
					case 0: // Skybox
					CubeMapUV = -poiCam.viewDir;
					break;
					case 1: // Reflection
					CubeMapUV = poiCam.reflectionDir;
					break;
					case 2: // World Normal Direction
					CubeMapUV = lerp(poiMesh.normals[0], poiMesh.normals[1], _CubeMapWorldNormalsStrength);
					break;
					case 3: // Local Normal Direction
					CubeMapUV = poiMesh.objNormal;
					break;
				}
				
				#if defined(PROP_CUBEMAP) || !defined(OPTIMIZER_ENABLED)
				if (any(_CubeMapRotation.xyz) || any(_CubeMapRotationPan.xyz))
				{
					// Do funny swizzle so we don't have to make a new function for every direction
					CubeMapUV = RotateAroundYInDegrees(CubeMapUV.yxz, _CubeMapRotation.x + (_CubeMapRotationPan.x * _Time.y)).yxz;
					CubeMapUV = RotateAroundYInDegrees(CubeMapUV.xyz, _CubeMapRotation.y + (_CubeMapRotationPan.y * _Time.y)).xyz;
					CubeMapUV = RotateAroundYInDegrees(CubeMapUV.xzy, _CubeMapRotation.z + (_CubeMapRotationPan.z * _Time.y)).xzy;
				}
				float4 cubeMap = texCUBE(_CubeMap, CubeMapUV);
				cubeMap.rgb *= poiThemeColor(poiMods, _CubeMapColor, _CubeMapColorThemeIndex);
				#else
				float4 cubeMap = float4(0.21763764082, 0.21763764082, 0.21763764082, .5) * float4(poiThemeColor(poiMods, _CubeMapColor, _CubeMapColorThemeIndex), 1);
				#endif
				
				cubeMap.rgb *= _CubeMapIntensity;
				#if defined(PROP_CUBEMAPMASK) || !defined(OPTIMIZER_ENABLED)
				float CubeMapMask = POI2D_SAMPLER_PAN(_CubeMapMask, _MainTex, poiUV(poiMesh.uv[_CubeMapMaskUV], _CubeMapMask_ST), _CubeMapMaskPan)[_CubeMapMaskChannel];
				#else
				float CubeMapMask = 1;
				#endif
				
				if (_CubeMapMaskGlobalMask > 0)
				{
					CubeMapMask = maskBlend(CubeMapMask, poiMods.globalMask[_CubeMapMaskGlobalMask-1], _CubeMapMaskGlobalMaskBlendType);
				}
				
				if (_CubeMapMaskInvert)
				{
					CubeMapMask = 1 - CubeMapMask;
				}
				
				//UNITY_BRANCH
				if (_CubeMapHueShiftEnabled)
				{
					cubeMap.rgb = hueShift(cubeMap.rgb, _CubeMapHueShift + _Time.x * _CubeMapHueShiftSpeed);
				}
				CubeMapMask = min(CubeMapMask, lerp(1, poiLight.rampedLightMap, _CubeMapLightMask));
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, cubeMap.rgb, _CubeMapReplace * CubeMapMask * cubeMap.a);
				poiFragData.baseColor.rgb *= lerp(1, cubeMap.rgb, _CubeMapMultiply * CubeMapMask * cubeMap.a);
				poiFragData.baseColor.rgb += cubeMap.rgb * _CubeMapAdd * CubeMapMask * cubeMap.a;
				poiFragData.emission += cubeMap.rgb * _CubeMapEmissionStrength * CubeMapMask * cubeMap.a;
			}
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			void ApplyAudioLinkDecal(in PoiMesh poiMesh, inout PoiFragData poiFragData, in PoiMods poiMods)
			{
				float4 colorAndMask = float4(1, 1, 1, 1);
				#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
				colorAndMask = POI2D_SAMPLER_PAN(_ALDecalColorMask, _MainTex, poiUV(poiMesh.uv[_ALDecalColorMaskUV], _ALDecalColorMask_ST), _ALDecalColorMaskPan);
				#endif
				
				float2 uv = poiMesh.uv[_ALDecalUV];
				float2 decalCenter = _ALUVPosition;
				float theta = radians(_ALUVRotation + _Time.z * _ALUVRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
				uv = remap(uv, float2(0, 0) - _ALUVScale.xz / 2 + _ALUVPosition, _ALUVScale.yw / 2 + _ALUVPosition, float2(0, 0), float2(1, 1));
				
				// Mask
				float4 audioLinkMask = 1.0;
				
				// UV
				float2 aluv = uv;
				if (_ALDecalUVMode == 1)
				{
					float2 uvdir = uv * 2 - 1;
					aluv.x = frac(atan2(uvdir.y, uvdir.x) * UNITY_INV_TWO_PI);
					aluv.y = length(uvdir);
				}
				
				// Scale / Offset / Step
				float maskY = aluv.y;
				if (_ALDecalUVMode == 1)
				{
					maskY = remap(maskY, _ALDecaldCircleDimensions.x, _ALDecaldCircleDimensions.y, 0, 1);
				}
				float maskX = aluv.x;
				if (_ALDecalUVMode == 1)
				{
					maskX = remap(maskX, _ALDecaldCircleDimensions.z, _ALDecaldCircleDimensions.w, 0, 1);
				}
				
				float maskVolume = _ALDecalVolumeStep != 0.0 ? floor(maskY * _ALDecalVolumeStep) / _ALDecalVolumeStep : maskY;
				float maskBand = _ALDecalBandStep != 0.0 ? floor(maskX * _ALDecalBandStep) / _ALDecalBandStep : maskX;
				
				// Copy
				audioLinkMask.r = maskVolume;
				audioLinkMask.g = maskBand;
				
				// Clip
				audioLinkMask.b = maskVolume < _ALDecalVolumeClipMin || maskVolume > _ALDecalVolumeClipMax ? 0.0 : audioLinkMask.b;
				audioLinkMask.b = maskBand < _ALDecalBandClipMin || maskBand > _ALDecalBandClipMax ? 0.0 : audioLinkMask.b;
				
				// Shape Clip
				if (_ALDecalShapeClip)
				{
					float volumeth = _ALDecalShapeClipVolumeWidth;
					if (_ALDecalVolumeStep != 0.0) audioLinkMask.b = frac(maskY * _ALDecalVolumeStep) > volumeth ? 0.0 : audioLinkMask.b;
					
					float bandwidth = _ALDecalUVMode == 1 ? _ALDecalShapeClipBandWidth / aluv.y : _ALDecalShapeClipBandWidth;
					float bandth = 1.0 - bandwidth;
					if (_ALDecalBandStep != 0.0) audioLinkMask.b = frac(maskX * _ALDecalBandStep + bandth * 0.5) < bandth ? 0.0 : audioLinkMask.b;
				}
				
				// AudioLink
				float2 audioLinkUV = float2(frac(audioLinkMask.g * 2.0), 4.5 / 4.0 + floor(audioLinkMask.g * 2.0) / 4.0);
				audioLinkUV.y *= 0.0625;
				float4 audioTexture = _AudioTexture.Sample(sampler_linear_clamp, audioLinkUV);
				float audioVal = audioTexture.b * _ALDecalVolume * lerp(_ALDecalBaseBoost, _ALDecalTrebleBoost, audioLinkMask.g);
				float audioLinkValue = _ALDecalLineWidth < 1.0 ? abs(audioVal - audioLinkMask.r) < _ALDecalLineWidth : audioVal > audioLinkMask.r * 2.0;
				audioLinkValue = saturate(audioLinkValue) * audioLinkMask.b;
				//clip(audioLinkValue - .5);
				audioLinkValue *= colorAndMask.a;
				
				if (!poiMods.audioLinkAvailable)
				{
					audioLinkValue = 0;
				}
				
				float3 alColorChord = _AudioTexture.Sample(sampler_linear_clamp, float2(maskX, 24.5 / 64.0)).rgb;
				float volumeColorSrc = audioLinkMask.g;
				if (_ALDecalVolumeColorSource == 1) volumeColorSrc = audioLinkMask.r;
				if (_ALDecalVolumeColorSource == 2) volumeColorSrc = audioVal;
				
				float3 lowColor = _ALDecalVolumeColorLow.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorLow.rgb, _ALDecalVolumeColorLowThemeIndex);
				float3 midColor = _ALDecalVolumeColorMid.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorMid.rgb, _ALDecalVolumeColorMidThemeIndex);
				float3 highColor = _ALDecalVolumeColorHigh.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorHigh.rgb, _ALDecalVolumeColorHighThemeIndex);
				
				float3 volumeColor = lerp(lowColor, midColor, saturate(volumeColorSrc * 2));
				volumeColor = lerp(volumeColor, highColor, saturate(volumeColorSrc * 2 - 1));
				
				float3 emissionColor = lerp(lowColor * _ALDecalLowEmission, midColor * _ALDecalMidEmission, saturate(volumeColorSrc * 2));
				emissionColor = lerp(emissionColor, highColor * _ALDecalHighEmission, saturate(volumeColorSrc * 2 - 1));
				
				//poiFragData.baseColor = lerp(poiFragData.baseColor, volumeColor, audioLinkValue);
				#if defined(POI_PASS_BASE) || defined(POI_PASS_ADD)
				poiFragData.emission += emissionColor * audioLinkValue;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor, customBlend(poiFragData.baseColor, volumeColor * colorAndMask.rgb, _ALDecalBlendType), saturate(_ALDecalBlendAlpha * audioLinkValue));
				#endif
				poiFragData.alpha = lerp(poiFragData.alpha, poiFragData.alpha * audioLinkValue, _ALDecalControlsAlpha);
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableVolumeColor==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_VOLUMECOLOR
			void ApplyAudioLinkVolumeColor(in PoiMesh poiMesh, inout PoiFragData poiFragData, in PoiMods poiMods)
			{
				float volume = AudioLinkLerpMultiline(ALPASS_DFT + float2(poiMesh.uv[_ALVolumeColorUV][_ALVolumeColorDirection] * AUDIOLINK_ETOTALBINS, 0.0)).b;
				
				float3 lowColor = _ALVolumeColorLow.rgb * poiThemeColor(poiMods, _ALVolumeColorLow.rgb, _ALVolumeColorLowThemeIndex);
				float3 midColor = _ALVolumeColorMid.rgb * poiThemeColor(poiMods, _ALVolumeColorMid.rgb, _ALVolumeColorMidThemeIndex);
				float3 highColor = _ALVolumeColorHigh.rgb * poiThemeColor(poiMods, _ALVolumeColorHigh.rgb, _ALVolumeColorHighThemeIndex);
				
				float3 volumeColor = lerp(lowColor, midColor, saturate(volume * 2));
				volumeColor = lerp(volumeColor, highColor, saturate(volume * 2 - 1));
				
				float3 emissionColor = lerp(lowColor * _ALLowEmission, midColor * _ALMidEmission, saturate(volume * 2));
				emissionColor = lerp(emissionColor, highColor * _ALHighEmission, saturate(volume * 2 - 1));
				
				#if defined(POI_PASS_BASE) || defined(POI_PASS_ADD)
				poiFragData.emission += emissionColor * poiMods.audioLinkAvailable;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor, customBlend(poiFragData.baseColor, volumeColor, _ALVolumeColorBlendType), saturate(_ALVolumeColorBlendAlpha * poiMods.audioLinkAvailable));
				#endif
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			void applyFlipbook(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_FLIPBOOKTEXARRAY) || !defined(OPTIMIZER_ENABLED)
				float4 flipBookPixel = float4(0, 0, 0, 0);
				#if defined(PROP_FLIPBOOKMASK) || !defined(OPTIMIZER_ENABLED)
				float flipBookMask = POI2D_SAMPLER_PAN(_FlipbookMask, _MainTex, poiUV(poiMesh.uv[_FlipbookMaskUV], _FlipbookMask_ST), _FlipbookMaskPan)[_FlipbookMaskChannel];
				#else
				float flipBookMask = 1;
				#endif
				if (_FlipbookMaskGlobalMask > 0)
				{
					flipBookMask = maskBlend(flipBookMask, poiMods.globalMask[_FlipbookMaskGlobalMask-1], _FlipbookMaskGlobalMaskBlendType);
				}
				float4 flipbookScaleOffset = _FlipbookScaleOffset;
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookScaleOffset.xy += lerp(_AudioLinkFlipbookScale.xy, _AudioLinkFlipbookScale.zw, poiMods.audioLink[_AudioLinkFlipbookScaleBand]);
				}
				#endif
				
				flipbookScaleOffset.xy = 1 - flipbookScaleOffset.xy;
				float2 uv = frac(poiMesh.uv[_FlipbookTexArrayUV]);
				float theta = radians(_FlipbookRotation + _Time.z * _FlipbookRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				float2 spriteCenter = flipbookScaleOffset.zw + .5;
				// 2d rotation
				uv = float2((uv.x - spriteCenter.x) * cs - (uv.y - spriteCenter.y) * sn + spriteCenter.x, (uv.x - spriteCenter.x) * sn + (uv.y - spriteCenter.y) * cs + spriteCenter.y);
				float4 sideOffset = float4(-(_FlipbookSideOffset.x), _FlipbookSideOffset.y, -(_FlipbookSideOffset.z), _FlipbookSideOffset.w);
				float2 newUV = remap(uv, float2(0, 0) + flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.xz, float2(1, 1) - flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.yw, float2(0, 0), float2(1, 1));
				
				UNITY_BRANCH
				if (_FlipbookTiled == 0)
				{
					if (max(newUV.x, newUV.y) > 1 || min(newUV.x, newUV.y) < 0)
					{
						return;
					}
				}
				float currentFrame = 0;
				float width;
				float height;
				float totalFrames;
				_FlipbookTexArray.GetDimensions(width, height, totalFrames);
				
				if (_FlipbookStartAndEnd)
				{
					totalFrames -= (totalFrames - min(max(_FlipbookStartFrame, _FlipbookEndFrame), totalFrames));
					totalFrames -= max(0, _FlipbookStartFrame);
				}
				if (!_FlipbookManualFrameControl)
				{
					if (_FlipbookFPS != 0)
					{
						currentFrame = ((_Time.y / (1 / _FlipbookFPS)) + _FlipbookFrameOffset) % totalFrames;
						if (_FlipbookStartAndEnd)
						{
							currentFrame += _FlipbookStartFrame;
						}
					}
				}
				else
				{
					currentFrame = fmod(_FlipbookCurrentFrame, totalFrames);
				}
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					if (_FlipbookChronotensityEnabled)
					{
						currentFrame += AudioLinkGetChronoTime(_FlipbookChronoType, _FlipbookChronotensityBand) * _FlipbookChronotensitySpeed;
					}
					currentFrame += lerp(_AudioLinkFlipbookFrame.x, _AudioLinkFlipbookFrame.y, poiMods.audioLink[_AudioLinkFlipbookFrameBand]);
					float totalFramesAL = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesAL += max(0, _FlipbookStartFrame);
					}
					currentFrame %= totalFramesAL;
				}
				#endif
				flipBookPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor(currentFrame)));
				UNITY_BRANCH
				if (_FlipbookCrossfadeEnabled)
				{
					float totalFramesCF = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesCF += max(0, _FlipbookStartFrame);
					}
					float4 flipbookNextPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor((currentFrame + 1) % totalFramesCF)));
					flipBookPixel = lerp(flipBookPixel, flipbookNextPixel, smoothstep(_FlipbookCrossfadeRange.x, _FlipbookCrossfadeRange.y, frac(currentFrame)));
				}
				
				UNITY_BRANCH
				if (_FlipbookIntensityControlsAlpha)
				{
					flipBookPixel.a = poiMax(flipBookPixel.rgb);
				}
				UNITY_BRANCH
				if (_FlipbookColorReplaces)
				{
					flipBookPixel.rgb = poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				else
				{
					flipBookPixel.rgb *= poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				
				UNITY_BRANCH
				if (_FlipbookHueShiftEnabled)
				{
					flipBookPixel.rgb = hueShift(flipBookPixel.rgb, _FlipbookHueShift + _Time.x * _FlipbookHueShiftSpeed);
				}
				half flipbookAlpha = 1;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookAlpha += saturate(lerp(_AudioLinkFlipbookAlpha.x, _AudioLinkFlipbookAlpha.y, poiMods.audioLink[_AudioLinkFlipbookAlphaBand]));
				}
				#endif
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * _FlipbookReplace * flipBookMask * flipbookAlpha);
				poiFragData.baseColor = poiFragData.baseColor + flipBookPixel.rgb * _FlipbookAdd * flipBookMask * flipbookAlpha;
				poiFragData.baseColor = poiFragData.baseColor * lerp(1, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * flipBookMask * _FlipbookMultiply * flipbookAlpha);
				
				float flipbookEmissionStrength = _FlipbookEmissionStrength;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookEmissionStrength += max(lerp(_AudioLinkFlipbookEmission.x, _AudioLinkFlipbookEmission.y, poiMods.audioLink[_AudioLinkFlipbookEmissionBand]), 0);
				}
				#endif
				
				poiFragData.emission += lerp(0, flipBookPixel.rgb * flipbookEmissionStrength, flipBookPixel.a * _FlipbookColor.a * flipBookMask * flipbookAlpha);
				
				#endif
				
				UNITY_BRANCH
				if (_FlipbookAlphaControlsFinalAlpha)
				{
					poiFragData.alpha = lerp(poiFragData.alpha, flipBookPixel.a * _FlipbookColor.a, flipBookMask);
				}
				#endif
			}
			
			#endif
			//endex
			
			//ifex _EnableRimLighting==0 && _EnableRim2Lighting==0
			#if defined(_GLOSSYREFLECTIONS_OFF) || defined(POI_RIM2)
			#if defined(_RIMSTYLE_POIYOMI) || defined(_RIM2STYLE_POIYOMI)
			void ApplyPoiyomiRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, inout PoiMods poiMods, float Is_NormalMapToRimLight, float RimInvert, float RimPower, float RimStrength, float RimShadowWidth, float RimShadowToggle, float RimWidth, float RimBlendStrength, float RimMask, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimTex, float4 RimLightColor, float RimLightColorThemeIndex, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimSharpness, float RimShadowMaskRampType, float RimShadowMaskInvert, float RimShadowMaskStrength, float2 RimShadowAlpha, float RimApplyGlobalMaskIndex, float RimApplyGlobalMaskBlendType, float RimBaseColorMix, float RimBrightness, float RimBlendMode, half AudioLinkRimWidthBand, float2 AudioLinkRimWidthAdd, half AudioLinkRimEmissionBand, float2 AudioLinkRimEmissionAdd, half AudioLinkRimBrightnessBand, float2 AudioLinkRimBrightnessAdd, float RimClamp, float rimBias, float rimBiasIntensity)
			{
				float viewDotNormal = abs(dot(poiCam.viewDir, lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight)));
				
				UNITY_BRANCH
				if (RimInvert)
				{
					viewDotNormal = 1 - viewDotNormal;
				}
				
				viewDotNormal = pow(viewDotNormal, RimPower);
				
				if (RimShadowWidth && RimShadowToggle)
				{
					viewDotNormal += lerp(0, (1 - poiLight.nDotLNormalized) * 3, RimShadowWidth);
				}
				
				viewDotNormal *= lerp(1, rimBias, rimBiasIntensity);
				
				float rimStrength = RimStrength;
				
				float rimWidth = lerp( - .05, 1, RimWidth);
				
				float blendStrength = RimBlendStrength;
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (poiMods.audioLinkAvailable)
				{
					rimWidth = clamp(rimWidth + lerp(AudioLinkRimWidthAdd.x, AudioLinkRimWidthAdd.y, poiMods.audioLink[AudioLinkRimWidthBand]), - .05, 1);
					rimStrength += lerp(AudioLinkRimEmissionAdd.x, AudioLinkRimEmissionAdd.y, poiMods.audioLink[AudioLinkRimEmissionBand]);
					blendStrength += lerp(AudioLinkRimBrightnessAdd.x, AudioLinkRimBrightnessAdd.y, poiMods.audioLink[AudioLinkRimBrightnessBand]);
				}
				#endif
				
				float rimMask = RimMask;
				
				if (RimGlobalMask > 0)
				{
					rimMask = maskBlend(rimMask, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				
				float4 rimColor = RimTex;
				rimColor *= float4(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex), RimLightColor.a);
				
				UNITY_BRANCH
				if (RimHueShiftEnabled)
				{
					rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				
				float rim = 1 - smoothstep(min(RimSharpness, rimWidth), rimWidth, viewDotNormal);
				rim *= RimLightColor.a * rimColor.a * rimMask;
				
				if (RimShadowToggle)
				{
					switch(RimShadowMaskRampType)
					{
						case 0:
						float rampedLightMap = poiLight.rampedLightMap;
						if (RimShadowMaskInvert) rampedLightMap = 1 - rampedLightMap;
						rim = lerp(rim, rim * rampedLightMap, RimShadowMaskStrength);
						break;
						case 1:
						float nDotLNormalized = poiLight.nDotLNormalized;
						if (RimShadowMaskInvert) nDotLNormalized = 1 - nDotLNormalized;
						rim = lerp(rim, rim * smoothstep(RimShadowAlpha.x, RimShadowAlpha.y, nDotLNormalized), RimShadowMaskStrength);
						break;
					}
				}
				
				if (RimApplyGlobalMaskIndex > 0)
				{
					applyToGlobalMask(poiMods, RimApplyGlobalMaskIndex-1, RimApplyGlobalMaskBlendType, rim * blendStrength);
				}
				
				float3 finalRimColor = rimColor.rgb * lerp(1, poiFragData.baseColor, RimBaseColorMix);
				finalRimColor *= RimBrightness;
				// Add 0, Replace 1, Multiply 2, Mixed 3
				switch(RimBlendMode)
				{
					case 0: poiFragData.baseColor += finalRimColor * rim * blendStrength; break;
					case 1: poiFragData.baseColor = lerp(poiFragData.baseColor, finalRimColor, rim * blendStrength); break;
					case 2: poiFragData.baseColor = lerp(poiFragData.baseColor, poiFragData.baseColor * finalRimColor, rim * blendStrength); break;
					case 3: poiFragData.baseColor = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * finalRimColor, rim * blendStrength); break;
				}
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
				poiFragData.emission += finalRimColor * rim * rimStrength;
			}
			#endif
			#if defined(_RIMSTYLE_UTS2) || defined(_RIM2STYLE_UTS2)
			void ApplyUTS2RimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float Set_RimLightMask_var, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimLightColor, float RimLightColorThemeIndex, float Is_LightColor_RimLight, float Is_NormalMapToRimLight, float RimLight_Power, float RimLight_InsideMask, float RimLight_FeatherOff, float LightDirection_MaskOn, float Tweak_LightDirection_MaskLevel, float Add_Antipodean_RimLight, float4 Ap_RimLightColor, float RimApColorThemeIndex, float Is_LightColor_Ap_RimLight, float Ap_RimLight_Power, float Ap_RimLight_FeatherOff, float Tweak_RimLightMaskLevel, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimClamp)
			{
				if (RimGlobalMask > 0)
				{
					Set_RimLightMask_var = maskBlend(Set_RimLightMask_var, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				
				float3 rimColor = float3(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex));
				float3 _Is_LightColor_RimLight_var = lerp(rimColor, (rimColor * poiLight.directColor), Is_LightColor_RimLight);
				float _RimArea_var = (1.0 - dot(lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight), poiCam.viewDir));
				float _RimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, RimLight_Power)));
				float _Rimlight_InsideMask_var = saturate(lerp((0.0 + ((_RimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _RimLightPower_var), RimLight_FeatherOff));
				float _VertHalfLambert_var = 0.5 * dot(poiMesh.normals[0], poiLight.direction) + 0.5;
				float3 _LightDirection_MaskOn_var = lerp((_Is_LightColor_RimLight_var * _Rimlight_InsideMask_var), (_Is_LightColor_RimLight_var * saturate((_Rimlight_InsideMask_var - ((1.0 - _VertHalfLambert_var) + Tweak_LightDirection_MaskLevel)))), LightDirection_MaskOn);
				float _ApRimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, Ap_RimLight_Power)));
				float3 ApRimColor = float3(poiThemeColor(poiMods, Ap_RimLightColor.rgb, RimApColorThemeIndex));
				float3 _RimLight_var = (saturate((Set_RimLightMask_var + Tweak_RimLightMaskLevel)) * lerp(_LightDirection_MaskOn_var, (_LightDirection_MaskOn_var + (lerp(ApRimColor, (ApRimColor * poiLight.directColor), Is_LightColor_Ap_RimLight) * saturate((lerp((0.0 + ((_ApRimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _ApRimLightPower_var), Ap_RimLight_FeatherOff) - (saturate(_VertHalfLambert_var) + Tweak_LightDirection_MaskLevel))))), Add_Antipodean_RimLight));
				UNITY_BRANCH
				if (RimHueShiftEnabled)
				{
					_RimLight_var = hueShift(_RimLight_var, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				poiFragData.baseColor += _RimLight_var;
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
			}
			#endif
			#if defined(_RIMSTYLE_LILTOON) || defined(_RIM2STYLE_LILTOON)
			void ApplyLiltoonRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float4 RimColor, float4 RimIndirColor, float4 RimColorTex, float RimMainStrength, float RimNormalStrength, float RimDirRange, float RimIndirRange, float RimFresnelPower, float RimBackfaceMask, float RimDirStrength, float RimBorder, float RimBlur, float RimIndirBorder, float RimIndirBlur, float RimShadowMask, float RimEnableLighting, float RimVRParallaxStrength, float RimGlobalMask, float RimGlobalMaskBlendType, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimClamp)
			{
				if (RimGlobalMask > 0)
				{
					RimColorTex.a = maskBlend(RimColorTex.a, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				float4 rimColor = RimColor;
				float4 rimIndirColor = RimIndirColor;
				rimColor *= RimColorTex;
				rimIndirColor *= RimColorTex;
				
				if (RimHueShiftEnabled)
				{
					rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
					rimIndirColor.rgb = hueShift(rimIndirColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				
				rimColor.rgb = lerp(rimColor.rgb, rimColor.rgb * poiFragData.baseColor, RimMainStrength);
				
				// View direction
				float3 centerViewDir = !IsOrthographicCamera() ? normalize(getCameraPosition() - poiMesh.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 viewDir = lerp(centerViewDir, poiCam.viewDir, RimVRParallaxStrength);
				
				// Normal
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], RimNormalStrength);
				float nvabs = abs(dot(normal, viewDir));
				
				// Factor
				float lnRaw = dot(poiLight.direction, normal) * 0.5 + 0.5;
				float lnDir = saturate((lnRaw + RimDirRange) / (1.0 + RimDirRange));
				float lnIndir = saturate((1.0-lnRaw + RimIndirRange) / (1.0 + RimIndirRange));
				float rim = pow(saturate(1.0 - nvabs), RimFresnelPower);
				rim = !poiMesh.isFrontFace && RimBackfaceMask ? 0.0 : rim;
				float rimDir = lerp(rim, rim * lnDir, RimDirStrength);
				float rimIndir = rim * lnIndir * RimDirStrength;
				
				rimDir = poiEdgeLinear(rimDir, RimBorder, RimBlur);
				rimIndir = poiEdgeLinear(rimIndir, RimIndirBorder, RimIndirBlur);
				
				rimDir = lerp(rimDir, rimDir * poiLight.rampedLightMap, RimShadowMask);
				rimIndir = lerp(rimIndir, rimIndir * poiLight.rampedLightMap, RimShadowMask);
				
				// Blend
				float3 rimSum = rimDir * rimColor.a * rimColor.rgb + rimIndir * rimIndirColor.a * rimIndirColor.rgb;
				poiFragData.baseColor += rimSum * RimEnableLighting;
				poiFragData.emission += rimSum * (1-RimEnableLighting);
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#ifdef _POI_DEPTH_RIMLIGHT
			
			float PositivePow(float base, float power)
			{
				return pow(max(abs(base), Epsilon), power);
			}
			
			float GetScaleWithHight()
			{
				return _ScreenParams.y / 1080;
			}
			
			float GetSSRimScale(float z)
			{
				float w = (1.0 / (PositivePow(z + saturate(UNITY_MATRIX_P._m00), 1.5) + 0.75)) * GetScaleWithHight();
				w *= lerp(1, UNITY_MATRIX_P._m00, 0.60 * saturate(0.25 * z * z));
				return w < 0.01 ? 0 : w;
			}
			
			void ApplyDepthRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiLight poiLight, in PoiMods poiMods)
			{
				float rim = 0;
				float perspectiveDivide = 1.0f / poiCam.clipPos.w;
				float4 direction = poiCam.worldDirection * perspectiveDivide;
				float2 screenPos = poiCam.grabPos.xy * perspectiveDivide;
				float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, screenPos);
				
				#if UNITY_REVERSED_Z
				if (z == 0) return;
				#else
				if (z == 1) return;
				#endif
				
				float depth = CorrectedLinearEyeDepth(z, direction.w);
				
				switch(_DepthRimType)
				{
					case 0:
					{
						float3 viewPos = UnityObjectToViewPos(poiMesh.localPos);
						float3 viewDir = normalize(viewPos);
						
						float3 viewNorm = mul((float3x3)UNITY_MATRIX_V, poiMesh.normals[_DepthRimNormalToUse]);
						float3 viewCrossNorm = cross(viewDir, viewNorm);
						float2 N_View = normalize(float2(-viewCrossNorm.y, viewCrossNorm.x));
						
						float3 viewLight = mul((float3x3)UNITY_MATRIX_V, poiLight.direction);
						float3 viewCrossLight = cross(viewDir, viewLight);
						float2 L_View = normalize(float2(-viewCrossLight.y, viewCrossLight.x));
						
						//float lDotN = saturate(poiLight.nDotL + _RimLightLength);
						float scale = _DepthRimWidth * GetSSRimScale(depth);
						float2 ssUV1 = clamp(screenPos + N_View * .1 * scale, 0, _ScreenParams.xy - 1);
						float depthDiff = z - SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, ssUV1) ;
						
						rim = smoothstep(0.24 * _DepthRimSharpness * z, 0.25 * z, depthDiff);
						rim *= lerp(1, (dot(L_View, N_View) > 0), _DepthRimHideInShadow);
					}
					break;
					case 1:
					{
						//float lDotN = saturate(poiLight.nDotL + _RimLightLength);
						float scale = _DepthRimWidth * GetSSRimScale(depth);
						float depthDiff = 0;
						for (int i = 0; i < 9; i++)
						{
							float2 ssUV1 = clamp(screenPos + sobelSamplePoints[i] * .1 * scale, 0, _ScreenParams.xy - 1);
							depthDiff = max(depthDiff, z - SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, ssUV1));
						}
						rim = smoothstep(0.24 * _DepthRimSharpness * z, 0.25 * z, depthDiff);
						rim *= lerp(1, lerp(poiLight.vertexNDotL > 0, poiLight.nDotL > 0, _DepthRimNormalToUse), _DepthRimHideInShadow);
					}
					break;
				}
				
				float3 rimColor = poiThemeColor(poiMods, _DepthRimColor.rgb, _DepthRimColorThemeIndex).rgb * lerp(1, poiLight.directColor, _DepthRimMixLightColor) * lerp(1, poiFragData.baseColor, _DepthRimMixBaseColor) * _DepthRimBrightness;
				
				poiLight.finalLightAdd += rim * rimColor * _DepthRimAdditiveLighting;
				poiFragData.emission += rim * rimColor * _DepthRimEmission;
				poiFragData.baseColor = lerp(poiFragData.baseColor, rimColor, rim * _DepthRimReplace);
				poiFragData.baseColor += rim * rimColor * _DepthRimAdd;
				poiFragData.baseColor *= lerp(1, rimColor, rim * _DepthRimMultiply);
			}
			#endif
			//endex
			
			//ifex _GlitterEnable==0
			#ifdef _SUNDISK_SIMPLE
			
			float3 RandomColorFromPoint(float2 rando)
			{
				fixed hue = random2(rando.x + rando.y).x;
				fixed saturation = lerp(_GlitterMinMaxSaturation.x, _GlitterMinMaxSaturation.y, rando.x);
				fixed value = lerp(_GlitterMinMaxBrightness.x, _GlitterMinMaxBrightness.y, rando.y);
				float3 hsv = float3(hue, saturation, value);
				return HSVtoRGB(hsv);
			}
			
			void applyGlitter(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods)
			{
				// Scale
				float2 st = frac(poiMesh.uv[_GlitterUV] + _GlitterUVPanning.xy * _Time.x) * _GlitterFrequency;
				
				// Tile the space
				float2 i_st = floor(st);
				float2 f_st = frac(st);
				
				float m_dist = 10.;  // minimun distance
				float2 m_point = 0;        // minimum point
				float2 randoPoint = 0;
				float2 dank;
				for (int j = -1; j <= 1; j++)
				{
					for (int i = -1; i <= 1; i++)
					{
						float2 neighbor = float2(i, j);
						float2 pos = random2(i_st + neighbor);
						float2 rando = pos;
						pos = 0.5 + 0.5 * sin(_GlitterJitter * 6.2831 * pos);
						float2 diff = neighbor + pos - f_st;
						float dist = length(diff);
						
						if (dist < m_dist)
						{
							dank = diff;
							m_dist = dist;
							m_point = pos;
							randoPoint = rando;
						}
					}
				}
				
				float randomFromPoint = random(randoPoint);
				
				float size = _GlitterSize;
				UNITY_BRANCH
				if (_GlitterRandomSize)
				{
					size = remapClamped(0, 1, randomFromPoint, _GlitterMinMaxSize.x, _GlitterMinMaxSize.y);
				}
				
				// Assign a color using the closest point position
				//color += dot(m_point, float2(.3, .6));
				
				// Add distance field to closest point center
				// color.g = m_dist;
				
				// Show isolines
				//color -= abs(sin(40.0 * m_dist)) * 0.07;
				
				// Draw cell center
				half glitterAlpha = 1;
				switch(_GlitterShape)
				{
					case 0: //circle
					glitterAlpha = saturate((size - m_dist) / clamp(fwidth(m_dist), 0.0001, 1.0));
					break;
					case 1: //sqaure
					float jaggyFix = pow(poiCam.distanceToVert, 2) * _GlitterJaggyFix;
					
					UNITY_BRANCH
					if (_GlitterRandomRotation == 1 || _GlitterTextureRotation != 0)
					{
						float2 center = float2(0, 0);
						float randomBoy = 0;
						UNITY_BRANCH
						if (_GlitterRandomRotation)
						{
							randomBoy = random(randoPoint);
						}
						float theta = radians((randomBoy + _Time.x * _GlitterTextureRotation) * 360);
						float cs = cos(theta);
						float sn = sin(theta);
						dank = float2((dank.x - center.x) * cs - (dank.y - center.y) * sn + center.x, (dank.x - center.x) * sn + (dank.y - center.y) * cs + center.y);
						glitterAlpha = (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.x))) * (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.y)));
					}
					else
					{
						glitterAlpha = (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.x))) * (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.y)));
					}
					break;
				}
				
				float3 finalGlitter = 0;
				
				half3 glitterColor = poiThemeColor(poiMods, _GlitterColor, _GlitterColorThemeIndex);
				
				float3 norm = lerp(poiMesh.normals[0], poiMesh.normals[1], _GlitterUseNormals);
				float3 randomRotation = 0;
				switch(_GlitterMode)
				{
					case 0:
					UNITY_BRANCH
					if (_GlitterSpeed > 0)
					{
						randomRotation = randomFloat3WiggleRange(randoPoint, _GlitterAngleRange, _GlitterSpeed);
					}
					else
					{
						randomRotation = randomFloat3Range(randoPoint, _GlitterAngleRange);
					}
					
					float3 glitterReflectionDirection = normalize(mul(poiRotationMatrixFromAngles(randomRotation), norm));
					finalGlitter = lerp(0, _GlitterMinBrightness * glitterAlpha, glitterAlpha) + max(pow(saturate(dot(lerp(glitterReflectionDirection, poiCam.viewDir, _GlitterBias), poiCam.viewDir)), _GlitterContrast), 0);
					finalGlitter *= glitterAlpha;
					break;
					case 1:
					float offset = random(randoPoint);
					float brightness = sin((_Time.x + offset) * _GlitterSpeed) * _glitterFrequencyLinearEmissive - (_glitterFrequencyLinearEmissive - 1);
					finalGlitter = max(_GlitterMinBrightness * glitterAlpha, brightness * glitterAlpha * smoothstep(0, 1, 1 - m_dist * _GlitterCenterSize * 10));
					break;
					case 2:
					if (_GlitterSpeed > 0)
					{
						randomRotation = randomFloat3WiggleRange(randoPoint, _GlitterAngleRange, _GlitterSpeed);
					}
					else
					{
						randomRotation = randomFloat3Range(randoPoint, _GlitterAngleRange);
					}
					
					float3 glitterLightReflectionDirection = normalize(mul(poiRotationMatrixFromAngles(randomRotation), norm));
					
					#ifdef POI_PASS_ADD
					glitterAlpha *= poiLight.nDotLSaturated * poiLight.attenuation;
					#endif
					#ifdef UNITY_PASS_FORWARDBASE
					glitterAlpha *= poiLight.nDotLSaturated;
					#endif
					
					float3 halfDir = normalize(poiLight.direction + poiCam.viewDir);
					float specAngle = max(dot(halfDir, glitterLightReflectionDirection), 0.0);
					
					finalGlitter = lerp(0, _GlitterMinBrightness * glitterAlpha, glitterAlpha) + max(pow(specAngle, _GlitterContrast), 0);
					
					glitterColor *= poiLight.directColor;
					finalGlitter *= glitterAlpha;
					
					break;
				}
				
				glitterColor *= lerp(1, poiFragData.baseColor, _GlitterUseSurfaceColor);
				#if defined(PROP_GLITTERCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				glitterColor *= POI2D_SAMPLER_PAN(_GlitterColorMap, _MainTex, poiUV(poiMesh.uv[_GlitterColorMapUV], _GlitterColorMap_ST), _GlitterColorMapPan).rgb;
				#endif
				float2 uv = remapClamped(-size, size, dank, 0, 1);
				UNITY_BRANCH
				if (_GlitterRandomRotation == 1 || _GlitterTextureRotation != 0 && !_GlitterShape)
				{
					float2 fakeUVCenter = float2(.5, .5);
					float randomBoy = 0;
					UNITY_BRANCH
					if (_GlitterRandomRotation)
					{
						randomBoy = random(randoPoint);
					}
					float theta = radians((randomBoy + _Time.x * _GlitterTextureRotation) * 360);
					float cs = cos(theta);
					float sn = sin(theta);
					uv = float2((uv.x - fakeUVCenter.x) * cs - (uv.y - fakeUVCenter.y) * sn + fakeUVCenter.x, (uv.x - fakeUVCenter.x) * sn + (uv.y - fakeUVCenter.y) * cs + fakeUVCenter.y);
				}
				
				#if defined(PROP_GLITTERTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 glitterTexture = POI2D_SAMPLER_PAN(_GlitterTexture, _MainTex, poiUV(uv, _GlitterTexture_ST), _GlitterTexturePan);
				#else
				float4 glitterTexture = 1;
				#endif
				//float4 glitterTexture = _GlitterTexture.SampleGrad(sampler_MainTex, frac(uv), ddx(uv), ddy(uv));
				glitterColor *= glitterTexture.rgb;
				#if defined(PROP_GLITTERMASK) || !defined(OPTIMIZER_ENABLED)
				float glitterMask = POI2D_SAMPLER_PAN(_GlitterMask, _MainTex, poiUV(poiMesh.uv[_GlitterMaskUV], _GlitterMask_ST), _GlitterMaskPan)[_GlitterMaskChannel];
				#else
				float glitterMask = 1;
				#endif
				
				glitterMask *= lerp(1, poiLight.rampedLightMap, _GlitterHideInShadow);
				
				if (_GlitterMaskGlobalMask > 0)
				{
					glitterMask = maskBlend(glitterMask, poiMods.globalMask[_GlitterMaskGlobalMask - 1], _GlitterMaskGlobalMaskBlendType);
				}
				
				if (_GlitterRandomColors)
				{
					glitterColor *= RandomColorFromPoint(random2(randoPoint.x + randoPoint.y));
				}
				
				UNITY_BRANCH
				if (_GlitterHueShiftEnabled)
				{
					glitterColor.rgb = hueShift(glitterColor.rgb, _GlitterHueShift + _Time.x * _GlitterHueShiftSpeed);
				}
				
				UNITY_BRANCH
				if (_GlitterBlendType == 1)
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, finalGlitter * glitterColor * _GlitterBrightness, finalGlitter * glitterTexture.a * glitterMask);
					poiFragData.emission += finalGlitter * glitterColor * max(0, (_GlitterBrightness - 1) * glitterTexture.a) * glitterMask;
				}
				else
				{
					poiFragData.emission += finalGlitter * glitterColor * _GlitterBrightness * glitterTexture.a * glitterMask;
				}
			}
			#endif
			//endex
			
			//ifex _SubsurfaceScattering==0
			#ifdef POI_SUBSURFACESCATTERING
			void applySubsurfaceScattering(in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh)
			{
				#if defined(PROP_SSSTHICKNESSMAP) || !defined(OPTIMIZER_ENABLED)
				float SSS = 1 - POI2D_SAMPLER_PAN(_SSSThicknessMap, _MainTex, poiUV(poiMesh.uv[_SSSThicknessMapUV], _SSSThicknessMap_ST), _SSSThicknessMapPan)[_SSSThicknessMapChannel];
				#else
				float SSS = 1;
				#endif
				
				float3 vLTLight = poiLight.direction + poiMesh.normals[0] * _SSSDistortion;
				float flTDot = pow(saturate(dot(poiCam.viewDir, -vLTLight)), _SSSSpread) * _SSSStrength;
				#ifdef UNITY_PASS_FORWARDBASE
				float3 fLT = (flTDot) * saturate(SSS + - 1 * _SSSThicknessMod);
				#else
				float3 fLT = poiLight.additiveShadow * (flTDot) * saturate(SSS + - 1 * _SSSThicknessMod);
				#endif
				
				poiLight.finalLightAdd += fLT * poiLight.directColor * _SSSColor * poiLight.attenuation;
			}
			#endif
			//endex
			
			//ifex _MochieBRDF==0 && _ClearCoatBRDF==0
			#if defined(MOCHIE_PBR) || defined(POI_CLEARCOAT)
			
			/*
			* Copyright 2022 orels1
			*
			* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
			*
			* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
			*
			* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
			*/
			
			// https://github.com/orels1/orels-Unity-Shaders
			
			float GSAA_Filament(float3 worldNormal, float perceptualRoughness, float gsaaVariance, float gsaaThreshold)
			{
				// Kaplanyan 2016, "Stable specular highlights"
				// Tokuyoshi 2017, "Error Reduction and Simplification for Shading Anti-Aliasing"
				// Tokuyoshi and Kaplanyan 2019, "Improved Geometric Specular Antialiasing"
				
				// This implementation is meant for deferred rendering in the original paper but
				// we use it in forward rendering as well (as discussed in Tokuyoshi and Kaplanyan
				// 2019). The main reason is that the forward version requires an expensive transform
				// of the float vector by the tangent frame for every light. This is therefore an
				// approximation but it works well enough for our needs and provides an improvement
				// over our original implementation based on Vlachos 2015, "Advanced VR Rendering".
				
				float3 du = ddx(worldNormal);
				float3 dv = ddy(worldNormal);
				
				float variance = gsaaVariance * (dot(du, du) + dot(dv, dv));
				
				float roughness = perceptualRoughness * perceptualRoughness;
				float kernelRoughness = min(2.0 * variance, gsaaThreshold);
				float squareRoughness = saturate(roughness * roughness + kernelRoughness);
				
				return sqrt(sqrt(squareRoughness));
			}
			
			/*
			MIT END
			*/
			
			bool SceneHasReflections()
			{
				float width, height;
				unity_SpecCube0.GetDimensions(width, height);
				return !(width * height < 2);
			}
			
			float3 GetWorldReflections(float3 reflDir, float3 worldPos, float roughness)
			{
				float3 baseReflDir = reflDir;
				reflDir = BoxProjection(reflDir, worldPos, unity_SpecCube0_ProbePosition, unity_SpecCube0_BoxMin, unity_SpecCube0_BoxMax);
				float4 envSample0 = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflDir, roughness * UNITY_SPECCUBE_LOD_STEPS);
				float3 p0 = DecodeHDR(envSample0, unity_SpecCube0_HDR);
				float interpolator = unity_SpecCube0_BoxMin.w;
				UNITY_BRANCH
				if (interpolator < 0.99999)
				{
					float3 refDirBlend = BoxProjection(baseReflDir, worldPos, unity_SpecCube1_ProbePosition, unity_SpecCube1_BoxMin, unity_SpecCube1_BoxMax);
					float4 envSample1 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, refDirBlend, roughness * UNITY_SPECCUBE_LOD_STEPS);
					float3 p1 = DecodeHDR(envSample1, unity_SpecCube1_HDR);
					p0 = lerp(p1, p0, interpolator);
				}
				return p0;
			}
			
			float3 GetReflections(in PoiCam poiCam, in PoiLight pl, in PoiMesh poiMesh, float roughness, float ForceFallback, float LightFallback, samplerCUBE reflectionCube, float4 hdrData, float3 reflectionDir)
			{
				float3 reflections = 0;
				float3 lighting = pl.finalLighting;
				// This is a separate conditional so it can optimize out when ForceFallback isn't animated
				if (ForceFallback == 0)
				{
					UNITY_BRANCH
					if (SceneHasReflections())
					{
						#ifdef UNITY_PASS_FORWARDBASE
						reflections = GetWorldReflections(reflectionDir, poiMesh.worldPos.xyz, roughness);
						#endif
					}
					else
					{
						#ifdef UNITY_PASS_FORWARDBASE
						reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
						reflections = DecodeHDR(float4(reflections, 1), hdrData) * lerp(1, pl.finalLighting, LightFallback);
						#endif
						#ifdef POI_PASS_ADD
						if (LightFallback)
						{
							reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
							reflections = DecodeHDR(float4(reflections, 1), hdrData) * pl.finalLighting;
						}
						#endif
					}
				}
				else
				{
					#ifdef UNITY_PASS_FORWARDBASE
					reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
					reflections = DecodeHDR(float4(reflections, 1), hdrData) * lerp(1, pl.finalLighting, LightFallback);
					#endif
					#ifdef POI_PASS_ADD
					if (LightFallback)
					{
						reflections = texCUBElod(reflectionCube, float4(reflectionDir, roughness * UNITY_SPECCUBE_LOD_STEPS));
						reflections = DecodeHDR(float4(reflections, 1), hdrData) * pl.finalLighting;
					}
					#endif
				}
				reflections *= pl.occlusion;
				return reflections;
			}
			
			float GetGGXTerm(float nDotL, float nDotV, float nDotH, float roughness)
			{
				float visibilityTerm = 0;
				if (nDotL > 0)
				{
					float rough = roughness;
					float rough2 = roughness * roughness;
					
					float lambdaV = nDotL * (nDotV * (1 - rough) + rough);
					float lambdaL = nDotV * (nDotL * (1 - rough) + rough);
					
					visibilityTerm = 0.5f / (lambdaV + lambdaL + 1e-5f);
					float d = (nDotH * rough2 - nDotH) * nDotH + 1.0f;
					float dotTerm = UNITY_INV_PI * rough2 / (d * d + 1e-7f);
					
					visibilityTerm *= dotTerm * UNITY_PI;
				}
				return visibilityTerm;
			}
			
			void GetSpecFresTerm(float nDotL, float nDotV, float nDotH, float lDotH, inout float3 specularTerm, inout float3 fresnelTerm, float3 specCol, float roughness)
			{
				specularTerm = GetGGXTerm(nDotL, nDotV, nDotH, roughness);
				fresnelTerm = FresnelTerm(specCol, lDotH);
				specularTerm = max(0, specularTerm * max(0.00001, nDotL));
			}
			
			float GetRoughness(float smoothness)
			{
				float rough = 1 - smoothness;
				rough *= 1.7 - 0.7 * rough;
				return rough;
			}
			#endif
			//endex
			
			//ifex _MochieBRDF==0
			#ifdef MOCHIE_PBR
			void MochieBRDF(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				float smoothness = _MochieRoughnessMultiplier;
				float smoothness2 = _MochieRoughnessMultiplier2;
				float metallic = _MochieMetallicMultiplier;
				float specularMask = 1;
				float reflectionMask = 1;
				
				smoothness *= poiMods.PBR.x;
				smoothness2 *= poiMods.PBR.x;
				metallic *= poiMods.PBR.y;
				specularMask *= poiMods.PBR.z;
				reflectionMask *= poiMods.PBR.w;
				
				#if defined(PROP_MOCHIEMETALLICMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 PBRMaps = POI2D_SAMPLER_PAN_STOCHASTIC(_MochieMetallicMaps, _MainTex, poiUV(poiMesh.uv[_MochieMetallicMapsUV], _MochieMetallicMaps_ST), _MochieMetallicMapsPan, _MochieMetallicMapsStochastic);
				UNITY_BRANCH
				if (_PBRSplitMaskSample)
				{
					float4 PBRSplitMask = POI2D_SAMPLER_PAN_STOCHASTIC(_MochieMetallicMaps, _MainTex, poiUV(poiMesh.uv[_MochieMetallicMasksUV], _PBRMaskScaleTiling), _MochieMetallicMasksPan.xy, _PBRSplitMaskStochastic);
					assignValueToVectorFromIndex(PBRMaps, _MochieMetallicMapsReflectionMaskChannel, PBRSplitMask[_MochieMetallicMapsReflectionMaskChannel]);
					assignValueToVectorFromIndex(PBRMaps, _MochieMetallicMapsSpecularMaskChannel, PBRSplitMask[_MochieMetallicMapsSpecularMaskChannel]);
				}
				
				if (_MochieMetallicMapsMetallicChannel < 4)
				{
					metallic *= PBRMaps[_MochieMetallicMapsMetallicChannel];
				}
				if (_MochieMetallicMapsRoughnessChannel < 4)
				{
					smoothness *= PBRMaps[_MochieMetallicMapsRoughnessChannel];
					smoothness2 *= PBRMaps[_MochieMetallicMapsRoughnessChannel];
				}
				if (_MochieMetallicMapsReflectionMaskChannel < 4)
				{
					reflectionMask *= PBRMaps[_MochieMetallicMapsReflectionMaskChannel];
				}
				if (_MochieMetallicMapsSpecularMaskChannel < 4)
				{
					specularMask *= PBRMaps[_MochieMetallicMapsSpecularMaskChannel];
				}
				#endif
				
				reflectionMask *= _MochieReflectionStrength;
				specularMask *= _MochieSpecularStrength;
				
				if (_MochieMetallicGlobalMask > 0)
				{
					metallic = customBlend(metallic, poiMods.globalMask[_MochieMetallicGlobalMask - 1], _MochieMetallicGlobalMaskBlendType);
				}
				if (_MochieSmoothnessGlobalMask > 0)
				{
					smoothness = customBlend(smoothness, poiMods.globalMask[_MochieSmoothnessGlobalMask - 1], _MochieSmoothnessGlobalMaskBlendType);
					smoothness2 = customBlend(smoothness2, poiMods.globalMask[_MochieSmoothnessGlobalMask - 1], _MochieSmoothnessGlobalMaskBlendType);
				}
				if (_MochieReflectionStrengthGlobalMask > 0)
				{
					reflectionMask = customBlend(reflectionMask, poiMods.globalMask[_MochieReflectionStrengthGlobalMask - 1], _MochieReflectionStrengthGlobalMaskBlendType);
				}
				if (_MochieSpecularStrengthGlobalMask > 0)
				{
					specularMask = customBlend(specularMask, poiMods.globalMask[_MochieSpecularStrengthGlobalMask - 1], _MochieSpecularStrengthGlobalMaskBlendType);
				}
				
				if (_MochieMetallicMapInvert)
				{
					metallic = 1 - metallic;
				}
				if (_MochieRoughnessMapInvert)
				{
					smoothness = 1 - smoothness;
					smoothness2 = 1 - smoothness2;
				}
				if (_MochieReflectionMaskInvert)
				{
					reflectionMask = 1 - reflectionMask;
				}
				if (_MochieSpecularMaskInvert)
				{
					specularMask = 1 - specularMask;
				}
				#ifdef TPS_Penetrator
				if (_BRDFTPSDepthEnabled)
				{
					reflectionMask = lerp(0, reflectionMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _BRDFTPSReflectionMaskStrength);
					specularMask = lerp(0, specularMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _BRDFTPSSpecularMaskStrength);
				}
				#endif
				
				float roughness = GetRoughness(smoothness);
				float roughness2 = GetRoughness(smoothness2);
				float3 specCol = lerp(unity_ColorSpaceDielectricSpec.rgb, poiFragData.baseColor, metallic);
				float omr = unity_ColorSpaceDielectricSpec.a - metallic * unity_ColorSpaceDielectricSpec.a;
				float percepRough = 1 - smoothness;
				float percepRough2 = 1 - smoothness2;
				UNITY_BRANCH
				if (_MochieGSAAEnabled)
				{
					percepRough = GSAA_Filament(poiMesh.normals[_PBRNormalSelect], percepRough, _PoiGSAAVariance, _PoiGSAAThreshold);
					if (_Specular2ndLayer == 1 && _MochieSpecularStrength2 > 0)
					{
						percepRough2 = GSAA_Filament(poiMesh.normals[_PBRNormalSelect], percepRough2, _PoiGSAAVariance, _PoiGSAAThreshold);
					}
				}
				float brdfRoughness = percepRough * percepRough;
				brdfRoughness = max(brdfRoughness, 0.002);
				
				float brdfRoughness2 = percepRough2 * percepRough2;
				brdfRoughness2 = max(brdfRoughness2, 0.002);
				
				float3 diffuse = poiFragData.baseColor;
				float3 specular = 0;
				float3 specular2 = 0;
				float3 vSpecular = 0;
				float3 vSpecular2 = 0;
				float3 reflections = 0;
				float3 environment = 0;
				
				float attenuation = min(poiLight.nDotLSaturated, lerp(poiLight.attenuation, 1, _IgnoreCastedShadows));
				#ifdef POI_PASS_ADD
				attenuation *= lerp(poiLight.additiveShadow, 1, _IgnoreCastedShadows);
				#endif
				
				float3 fresnelTerm = 1;
				float3 specularTerm = 1;
				
				float pbrNDotL = lerp(poiLight.vertexNDotL, poiLight.nDotL, _PBRNormalSelect);
				float pbrNDotV = lerp(poiLight.vertexNDotV, poiLight.nDotV, _PBRNormalSelect);
				float pbrNDotH = lerp(poiLight.vertexNDotH, poiLight.nDotH, _PBRNormalSelect);
				float3 pbrReflectionDir = lerp(poiCam.vertexReflectionDir, poiCam.reflectionDir, _PBRNormalSelect);
				
				GetSpecFresTerm(pbrNDotL, pbrNDotV, pbrNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness);
				specular = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * attenuation;
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						fresnelTerm = 1;
						specularTerm = 1;
						float pbrVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], _PBRNormalSelect);
						float pbrVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], _PBRNormalSelect);
						GetSpecFresTerm(pbrVDotNL, pbrNDotV, pbrVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness);
						vSpecular += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * poiLight.vAttenuation[index];
					}
					#endif
				}
				
				if (_Specular2ndLayer == 1)
				{
					float3 fresnelTerm = 1;
					float3 specularTerm = 1;
					GetSpecFresTerm(pbrNDotL, pbrNDotV, pbrNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness2);
					specular2 = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * attenuation * _MochieSpecularStrength2;
					
					if (_LightingVertexLightingEnabled)
					{
						#if defined(VERTEXLIGHT_ON)
						for (int index = 0; index < 4; index++)
						{
							fresnelTerm = 1;
							specularTerm = 1;
							float pbrVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], _PBRNormalSelect);
							float pbrVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], _PBRNormalSelect);
							GetSpecFresTerm(pbrVDotNL, pbrNDotV, pbrVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness2);
							vSpecular2 += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _MochieSpecularTint, _MochieSpecularTintThemeIndex) * poiLight.occlusion * poiLight.vAttenuation[index] * _MochieSpecularStrength2;
						}
						#endif
					}
				}
				
				float surfaceReduction = (1.0 / (brdfRoughness * brdfRoughness + 1.0));
				float grazingTerm = saturate(smoothness + (1 - omr));
				float3 reflCol = GetReflections(poiCam, poiLight, poiMesh, roughness, _MochieForceFallback, _MochieLitFallback, _MochieReflCube, _MochieReflCube_HDR, pbrReflectionDir);
				reflections = surfaceReduction * reflCol * lerp(1, FresnelLerp(specCol, grazingTerm, pbrNDotV), _RefSpecFresnel);
				reflections *= poiThemeColor(poiMods, _MochieReflectionTint, _MochieReflectionTintThemeIndex);
				reflections *= reflectionMask;
				#ifdef POI_PASS_ADD
				reflections *= poiLight.attenuation;
				#endif
				diffuse = lerp(diffuse, diffuse * omr, reflectionMask);
				
				poiMods.PBR = float4(smoothness, metallic, specularMask, reflectionMask);
				
				environment = max(specular + vSpecular, specular2 + vSpecular2);
				environment += reflections;
				diffuse *= poiLight.finalLighting;
				poiFragData.finalColor = diffuse;
				poiLight.finalLightAdd += environment;
			}
			#endif
			//endex
			//ifex _ClearCoatBRDF==0
			#ifdef POI_CLEARCOAT
			void poiClearCoat(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float clearCoatMask = _ClearCoatStrength;
				float smoothness = _ClearCoatSmoothness;
				float reflectionMask = _ClearCoatReflectionStrength;
				float specularMask = _ClearCoatSpecularStrength;
				
				#if defined(PROP_CLEARCOATMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 PBRMaps = POI2D_SAMPLER_PAN_STOCHASTIC(_ClearCoatMaps, _MainTex, poiUV(poiMesh.uv[_ClearCoatMapsUV], _ClearCoatMaps_ST), _ClearCoatMapsPan, _ClearCoatMapsStochastic);
				
				if (_ClearCoatMapsClearCoatMaskChannel < 4)
				{
					clearCoatMask *= PBRMaps[_ClearCoatMapsClearCoatMaskChannel];
				}
				if (_ClearCoatMapsRoughnessChannel < 4)
				{
					smoothness *= PBRMaps[_ClearCoatMapsRoughnessChannel];
				}
				if (_ClearCoatMapsReflectionMaskChannel < 4)
				{
					reflectionMask *= PBRMaps[_ClearCoatMapsReflectionMaskChannel];
				}
				if (_ClearCoatMapsSpecularMaskChannel < 4)
				{
					specularMask *= PBRMaps[_ClearCoatMapsSpecularMaskChannel];
				}
				#endif
				
				if (_ClearCoatGlobalMask > 0)
				{
					clearCoatMask = customBlend(reflectionMask, poiMods.globalMask[_ClearCoatGlobalMask - 1], _ClearCoatGlobalMaskBlendType);
				}
				if (_ClearCoatSmoothnessGlobalMask > 0)
				{
					smoothness = customBlend(smoothness, poiMods.globalMask[_ClearCoatSmoothnessGlobalMask - 1], _ClearCoatSmoothnessGlobalMaskBlendType);
				}
				if (_ClearCoatReflectionStrengthGlobalMask > 0)
				{
					reflectionMask = customBlend(reflectionMask, poiMods.globalMask[_ClearCoatReflectionStrengthGlobalMask - 1], _ClearCoatReflectionStrengthGlobalMaskBlendType);
				}
				if (_ClearCoatSpecularStrengthGlobalMask > 0)
				{
					specularMask = customBlend(specularMask, poiMods.globalMask[_ClearCoatSpecularStrengthGlobalMask - 1], _ClearCoatSpecularStrengthGlobalMaskBlendType);
				}
				
				if (_ClearCoatMaskInvert)
				{
					clearCoatMask = 1 - clearCoatMask;
				}
				if (_ClearCoatSmoothnessMapInvert)
				{
					smoothness = 1 - smoothness;
				}
				if (_ClearCoatReflectionMaskInvert)
				{
					reflectionMask = 1 - reflectionMask;
				}
				if (_ClearCoatSpecularMaskInvert)
				{
					specularMask = 1 - specularMask;
				}
				#ifdef TPS_Penetrator
				if (_ClearCoatTPSDepthMaskEnabled)
				{
					clearCoatMask = lerp(0, clearCoatMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _ClearCoatTPSMaskStrength);
				}
				#endif
				
				float roughness = GetRoughness(smoothness);
				float3 specCol = 0.220916301;
				float omr = unity_ColorSpaceDielectricSpec.a;
				float percepRough = 1 - smoothness;
				UNITY_BRANCH
				if (_ClearCoatGSAAEnabled)
				{
					percepRough = GSAA_Filament(poiMesh.normals[_ClearCoatNormalSelect], percepRough, _ClearCoatGSAAVariance, _ClearCoatGSAAThreshold);
				}
				float brdfRoughness = percepRough * percepRough;
				brdfRoughness = max(brdfRoughness, 0.002);
				
				float3 diffuse = 0;
				float3 specular = 0;
				float3 vSpecular = 0;
				float3 reflections = 0;
				float3 environment = 0;
				float attenuation = min(poiLight.nDotLSaturated, lerp(poiLight.attenuation, 1, _CCIgnoreCastedShadows));
				
				float3 fresnelTerm = 1;
				float3 specularTerm = 1;
				
				float clearcoatNDotL = lerp(poiLight.vertexNDotL, poiLight.nDotL, _ClearCoatNormalSelect);
				float clearcoatNDotV = lerp(poiLight.vertexNDotV, poiLight.nDotV, _ClearCoatNormalSelect);
				float clearcoatNDotH = lerp(poiLight.vertexNDotH, poiLight.nDotH, _ClearCoatNormalSelect);
				float3 clearcoatReflectionDir = lerp(poiCam.vertexReflectionDir, poiCam.reflectionDir, _ClearCoatNormalSelect);
				
				GetSpecFresTerm(clearcoatNDotL, clearcoatNDotV, clearcoatNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness);
				specular = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _ClearCoatSpecularTint, _ClearCoatSpecularTintThemeIndex) * poiLight.occlusion * attenuation;
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						fresnelTerm = 1;
						specularTerm = 1;
						float clearcoatVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], _ClearCoatNormalSelect);
						float clearcoatVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], _ClearCoatNormalSelect);
						GetSpecFresTerm(clearcoatVDotNL, clearcoatNDotV, clearcoatVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness);
						vSpecular += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, _ClearCoatSpecularTint, _ClearCoatSpecularTintThemeIndex) * poiLight.occlusion * poiLight.vAttenuation[index];
					}
					#endif
				}
				
				float surfaceReduction = (1.0 / (brdfRoughness * brdfRoughness + 1.0));
				float grazingTerm = saturate(smoothness + (1 - omr));
				float3 reflCol = GetReflections(poiCam, poiLight, poiMesh, roughness, _ClearCoatForceFallback, _ClearCoatLitFallback, _ClearCoatFallback, _ClearCoatFallback_HDR, clearcoatReflectionDir);
				reflections = surfaceReduction * reflCol * lerp(1, FresnelLerp(specCol, grazingTerm, clearcoatNDotV), _ClearcoatFresnel);
				reflections *= poiThemeColor(poiMods, _ClearCoatReflectionTint, _ClearCoatReflectionTintThemeIndex) * reflectionMask;
				#ifdef POI_PASS_ADD
				reflections *= poiLight.attenuation;
				#endif
				diffuse = lerp(diffuse, diffuse * omr, reflectionMask);
				
				environment = specular + vSpecular;
				#ifdef UNITY_PASS_FORWARDBASE
				environment += reflections;
				#endif
				//diffuse *= poiLight.finalLighting;
				diffuse += environment;
				poiLight.finalLightAdd += saturate(diffuse * clearCoatMask);
			}
			#endif
			//endex
			
			//ifex _StylizedSpecular==0
			#ifdef POI_STYLIZED_StylizedSpecular
			void stylizedSpecular(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float specArea = 0.5 * poiLight.nDotH + 0.5;
				#if defined(PROP_HIGHCOLOR_TEX) || !defined(OPTIMIZER_ENABLED)
				float3 specularMap = POI2D_SAMPLER_PAN(_HighColor_Tex, _MainTex, poiUV(poiMesh.uv[_HighColor_TexUV], _HighColor_Tex_ST), _HighColor_TexPan);
				#else
				float3 specularMap = 1;
				#endif
				
				// Spec 1
				float specMask1 = 0;
				float specMask2 = 0;
				if (_Is_SpecularToHighColor)
				{
					specMask1 += pow(specArea, exp2(lerp(11, 1, _HighColor_Power))) * _Layer1Strength;
					specMask2 += pow(specArea, exp2(lerp(11, 1, _Layer2Size))) * _Layer2Strength;
				}
				else
				{
					specMask1 += poiEdgeNonLinear(specArea, (1.0 - pow(_HighColor_Power, 5)), _StylizedSpecularFeather) * _Layer1Strength;
					specMask2 += poiEdgeNonLinear(specArea, (1.0 - pow(_Layer2Size, 5)), _StylizedSpecular2Feather) * _Layer2Strength;
				}
				
				#if defined(PROP_SET_HIGHCOLORMASK) || !defined(OPTIMIZER_ENABLED)
				float specularMask = POI2D_SAMPLER_PAN(_Set_HighColorMask, _MainTex, poiUV(poiMesh.uv[_Set_HighColorMaskUV], _Set_HighColorMask_ST), _Set_HighColorMaskPan)[_Set_HighColorMaskChannel];
				#else
				float specularMask = 1;
				#endif
				
				specularMask = saturate(specularMask + _Tweak_HighColorMaskLevel);
				
				float specMask = saturate(specMask1 + specMask2) * specularMask * lerp(poiLight.rampedLightMap, 1, _StylizedSpecularIgnoreShadow);
				float attenuation = min(lerp(poiLight.nDotLSaturated, 1, _StylizedSpecularIgnoreNormal), lerp(lerp(poiLight.attenuation, 1, _SSIgnoreCastedShadows), 1, _StylizedSpecularIgnoreShadow));
				#ifdef POI_PASS_ADD
				attenuation *= lerp(poiLight.additiveShadow, 1, _SSIgnoreCastedShadows);
				#endif
				if (_Is_BlendAddToHiColor == 1)
				{
					poiLight.finalLightAdd += max(0, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.directColor, _UseLightColor) * specMask * poiLight.occlusion * attenuation * _StylizedSpecularStrength);
				}
				else
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.directColor, _UseLightColor), saturate(specMask * poiLight.occlusion * attenuation * _StylizedSpecularStrength));
				}
				//poiFragData.baseColor = _StylizedSpecularStrength;
				
				float3 vSpecMask = 0;
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						if (!any(poiLight.vPosition[index])) continue;
						specArea = 0.5 * poiLight.vDotNH[index] + 0.5;
						if (_Is_SpecularToHighColor)
						{
							vSpecMask = pow(specArea, exp2(lerp(11, 1, _HighColor_Power))) * _Layer1Strength * poiLight.vAttenuation[index];
							vSpecMask = max(vSpecMask, pow(specArea, exp2(lerp(11, 1, _Layer2Size))) * _Layer2Strength * poiLight.vAttenuation[index]);
						}
						else
						{
							vSpecMask = poiEdgeNonLinear(specArea, (1.0 - pow(_HighColor_Power, 5)), _StylizedSpecularFeather) * _Layer1Strength * poiLight.vAttenuation[index];
							vSpecMask = max(vSpecMask, poiEdgeNonLinear(specArea, (1.0 - pow(_Layer2Size, 5)), _StylizedSpecular2Feather) * _Layer2Strength * poiLight.vAttenuation[index]);
						}
						vSpecMask *= specularMask;
						if (_Is_BlendAddToHiColor == 1)
						{
							poiLight.finalLightAdd += max(0, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.vColor[index], _UseLightColor) * vSpecMask * poiLight.occlusion * _StylizedSpecularStrength);
						}
						else
						{
							poiFragData.baseColor = lerp(poiFragData.baseColor, specularMap * poiThemeColor(poiMods, _HighColor, _HighColorThemeIndex) * lerp(1, poiLight.vColor[index], _UseLightColor), saturate(vSpecMask * poiLight.occlusion * _StylizedSpecularStrength));
						}
					}
					#endif
				}
			}
			#endif
			//endex
			
			//ifex _EnablePathing==0
			#ifdef POI_PATHING
			void applyPathing(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float3 albedo = poiFragData.baseColor;
				float3 pathEmission;
				#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
				float4 path = _PathingMap.Sample(SmpRepeatPoint, poiUV(poiMesh.uv[_PathingMapUV], _PathingMap_ST) + _PathingMapPan.xy * _Time.x);
				#else
				float4 path = float4(1, 1, 1, 1);
				#endif
				float4 PathColor[4];
				half pathAudioLinkPathTimeOffsetBand[4] = {
					0, 0, 0, 0
				};
				half2 pathAudioLinkTimeOffset[4] = {
					half2(0, 0), half2(0, 0), half2(0, 0), half2(0, 0)
				};
				half pathAudioLinkPathWidthOffsetBand[4] = {
					0, 0, 0, 0
				};
				half2 pathAudioLinkWidthOffset[4] = {
					half2(0, 0), half2(0, 0), half2(0, 0), half2(0, 0)
				};
				PathColor[0] = _PathColorR;
				PathColor[1] = _PathColorG;
				PathColor[2] = _PathColorB;
				PathColor[3] = _PathColorA;
				
				// Combined data
				if (_PathGradientType == 1)
				{
					path = (path.r + path.g + path.b + path.a) * .25;
				}
				
				#if defined(PROP_PATHINGCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				float4 pathColorMap = POI2D_SAMPLER_PAN(_PathingColorMap, _MainTex, poiUV(poiMesh.uv[_PathingColorMapUV], _PathingColorMap_ST), _PathingColorMapPan);
				#else
				float4 pathColorMap = float4(1, 1, 1, 1);
				#endif
				
				float4 pathAudioLinkEmission = 0;
				float4 pathTime = 0;
				float3 pathAlpha[4] = {
					float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0)
				};
				
				#ifdef POI_AUDIOLINK
				float4 chronoType = float4(_PathChronoTypeR, _PathChronoTypeG, _PathChronoTypeB, _PathChronoTypeA);
				float4 chronoBand = float4(_PathChronoBandR, _PathChronoBandG, _PathChronoBandB, _PathChronoBandA);
				float4 chronoSpeed = float4(_PathChronoSpeedR, _PathChronoSpeedG, _PathChronoSpeedB, _PathChronoSpeedA);
				float3 autoCorrelator[4] = {
					float3(_PathALAutoCorrelatorR, _PathALAutoCorrelatorRangeR[0], _PathALAutoCorrelatorRangeR[1]), float3(_PathALAutoCorrelatorG, _PathALAutoCorrelatorRangeG[0], _PathALAutoCorrelatorRangeG[1]),
					float3(_PathALAutoCorrelatorB, _PathALAutoCorrelatorRangeB[0], _PathALAutoCorrelatorRangeB[1]), float3(_PathALAutoCorrelatorA, _PathALAutoCorrelatorRangeA[0], _PathALAutoCorrelatorRangeA[1])
				};
				float4 history[4] = {
					float4(_PathALHistoryR, _PathALHistoryBandR, _PathALHistoryRangeR[0], _PathALHistoryRangeR[1]), float4(_PathALHistoryG, _PathALHistoryBandG, _PathALHistoryRangeG[0], _PathALHistoryRangeG[1]),
					float4(_PathALHistoryB, _PathALHistoryBandB, _PathALHistoryRangeB[0], _PathALHistoryRangeB[1]), float4(_PathALHistoryA, _PathALHistoryBandA, _PathALHistoryRangeA[0], _PathALHistoryRangeA[1])
				};
				
				if (poiMods.audioLinkAvailable)
				{
					if (_PathALTimeOffset)
					{
						pathAudioLinkPathTimeOffsetBand[0] = _AudioLinkPathTimeOffsetBandR;
						pathAudioLinkPathTimeOffsetBand[1] = _AudioLinkPathTimeOffsetBandG;
						pathAudioLinkPathTimeOffsetBand[2] = _AudioLinkPathTimeOffsetBandB;
						pathAudioLinkPathTimeOffsetBand[3] = _AudioLinkPathTimeOffsetBandA;
						pathAudioLinkTimeOffset[0] = _AudioLinkPathTimeOffsetR.xy;
						pathAudioLinkTimeOffset[1] = _AudioLinkPathTimeOffsetG.xy;
						pathAudioLinkTimeOffset[2] = _AudioLinkPathTimeOffsetB.xy;
						pathAudioLinkTimeOffset[3] = _AudioLinkPathTimeOffsetA.xy;
					}
					
					if (_PathALWidthOffset)
					{
						pathAudioLinkPathWidthOffsetBand[0] = _AudioLinkPathWidthOffsetBandR;
						pathAudioLinkPathWidthOffsetBand[1] = _AudioLinkPathWidthOffsetBandG;
						pathAudioLinkPathWidthOffsetBand[2] = _AudioLinkPathWidthOffsetBandB;
						pathAudioLinkPathWidthOffsetBand[3] = _AudioLinkPathWidthOffsetBandA;
						pathAudioLinkWidthOffset[0] = _AudioLinkPathWidthOffsetR.xy;
						pathAudioLinkWidthOffset[1] = _AudioLinkPathWidthOffsetG.xy;
						pathAudioLinkWidthOffset[2] = _AudioLinkPathWidthOffsetB.xy;
						pathAudioLinkWidthOffset[3] = _AudioLinkPathWidthOffsetA.xy;
					}
					// Emission Offset
					if (_PathALEmissionOffset)
					{
						pathAudioLinkEmission.r += lerp(_AudioLinkPathEmissionAddR.x, _AudioLinkPathEmissionAddR.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandR]);
						pathAudioLinkEmission.g += lerp(_AudioLinkPathEmissionAddG.x, _AudioLinkPathEmissionAddG.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandG]);
						pathAudioLinkEmission.b += lerp(_AudioLinkPathEmissionAddB.x, _AudioLinkPathEmissionAddB.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandB]);
						pathAudioLinkEmission.a += lerp(_AudioLinkPathEmissionAddA.x, _AudioLinkPathEmissionAddA.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandA]);
					}
					
					if(_PathALColorChord)
					{
						if (_PathALCCR)
						{
							PathColor[0] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[0] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCG)
						{
							PathColor[1] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[1] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCB)
						{
							PathColor[2] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[2] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCA)
						{
							PathColor[3] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[3] * AUDIOLINK_WIDTH, 0));
						}
					}
				}
				#endif
				
				[unroll]
				for (int index = 0; index < 4; index++)
				{
					float timeOffset = 0;
					#ifdef POI_AUDIOLINK
					UNITY_BRANCH
					if (poiMods.audioLinkAvailable)
					{
						if (_PathALTimeOffset)
						{
							timeOffset += lerp(pathAudioLinkTimeOffset[index].x, pathAudioLinkTimeOffset[index].y, poiMods.audioLink[pathAudioLinkPathTimeOffsetBand[index]]);
						}
						
						if (_PathALChrono)
						{
							timeOffset += AudioLinkGetChronoTime(chronoType[index], chronoBand[index]) * chronoSpeed[index];
						}
					}
					#endif
					pathTime[index] = _PathTime[index] != -999.0f ? frac(_PathTime[index] + _PathOffset[index] + timeOffset) : frac(_Time.x * _PathSpeed[index] + _PathOffset[index] + timeOffset);
					
					if (_PathSegments[index])
					{
						float pathSegments = abs(_PathSegments[index]);
						pathTime = (ceil(pathTime * pathSegments) - .5) / pathSegments;
					}
					
					if (path[index])
					{
						// Cutting it in half because it goes out in both directions for now
						half pathWidth = _PathWidth[index] * .5;
						#ifdef POI_AUDIOLINK
						UNITY_BRANCH
						if (poiMods.audioLinkAvailable)
						{
							if (_PathALWidthOffset)
							{
								pathWidth += lerp(pathAudioLinkWidthOffset[index].x, pathAudioLinkWidthOffset[index].y, poiMods.audioLink[pathAudioLinkPathWidthOffsetBand[index]]);
							}
						}
						#endif
						
						//fill
						pathAlpha[index].x = pathTime[index] > path[index];
						//path
						pathAlpha[index].y = saturate((1 - abs(lerp(-pathWidth, 1 + pathWidth, pathTime[index]) - path[index])) - (1 - pathWidth)) * (1 / pathWidth);
						//loop
						pathAlpha[index].z = saturate((1 - distance(pathTime[index], path[index])) - (1 - pathWidth)) * (1 / pathWidth);
						pathAlpha[index].z += saturate(distance(pathTime[index], path[index]) - (1 - pathWidth)) * (1 / pathWidth);
						pathAlpha[index] = smoothstep(0, _PathSoftness[index] + .00001, pathAlpha[index]);
						
						#ifdef POI_AUDIOLINK
						if (poiMods.audioLinkAvailable)
						{
							if (_PathALHistory && history[index][0])
							{
								// history[index]: [0]: on/off, [1]: band, [2]/[3] min/max
								float historyUV = lerp(history[index][2], history[index][3], path[index]);
								
								if (_PathSegments[index])
								{
									float pathSegments = abs(_PathSegments[index]);
									historyUV = (ceil(historyUV * pathSegments) - .5) / pathSegments;
								}
								
								historyUV *= AUDIOLINK_WIDTH;
								
								float historyValue = AudioLinkLerp(ALPASS_AUDIOLINK + float2(historyUV, history[index][1]))[0];
								
								if(_PathALHistoryMode == 0) // Mask
								pathAlpha[index] *= historyValue;
								else // Override
								pathAlpha[index] = historyValue;
							}
							
							if (_PathALAutoCorrelator && autoCorrelator[index][0] != 0)
							{
								// autoCorrelator[index]: [0]: on/off, [1]/[2]: min/max
								// Choose from only part of the autocorrelator
								float autoCorrelatorUV = lerp(autoCorrelator[index][1], autoCorrelator[index][2], path[index]);
								if (autoCorrelator[index][0] == 2) // Mirror
								{
									autoCorrelatorUV = abs(1. - autoCorrelatorUV * 2.);
								}
								
								if (_PathSegments[index])
								{
									float pathSegments = abs(_PathSegments[index]);
									autoCorrelatorUV = (ceil(autoCorrelatorUV * pathSegments) - .5) / pathSegments;
								}
								
								// Normalize Autocorrelator Value
								float autoCorrelatorValue = AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2(autoCorrelatorUV * AUDIOLINK_WIDTH, 0))[0];
								float autoCorrelatorMax = AudioLinkLerp(ALPASS_AUTOCORRELATOR);
								autoCorrelatorValue = saturate(abs(autoCorrelatorValue) * rcp(autoCorrelatorMax));
								
								// Autocorrelator is normalized, so can look weird at lower volume levels. use Filtered VU intensity to make it smoothly fall off at low volume levels.
								float4 vu = AudioLinkData(ALPASS_FILTEREDVU_INTENSITY + uint2(0, 0));
								autoCorrelatorValue *= smoothstep(0.01, 0.2, vu);
								
								if(_PathALAutoCorrelatorMode == 0) // Mask
								pathAlpha[index] *= autoCorrelatorValue;
								else // Override
								pathAlpha[index] = autoCorrelatorValue;
								
							}
						}
						#endif
					}
				}
				
				// Emission
				pathEmission = 0;
				pathEmission += pathAlpha[0][_PathTypeR] * poiThemeColor(poiMods, PathColor[0].rgb, _PathColorRThemeIndex) * (_PathEmissionStrength[0] + pathAudioLinkEmission.r);
				pathEmission += pathAlpha[1][_PathTypeG] * poiThemeColor(poiMods, PathColor[1].rgb, _PathColorGThemeIndex) * (_PathEmissionStrength[1] + pathAudioLinkEmission.g);
				pathEmission += pathAlpha[2][_PathTypeB] * poiThemeColor(poiMods, PathColor[2].rgb, _PathColorBThemeIndex) * (_PathEmissionStrength[2] + pathAudioLinkEmission.b);
				pathEmission += pathAlpha[3][_PathTypeA] * poiThemeColor(poiMods, PathColor[3].rgb, _PathColorAThemeIndex) * (_PathEmissionStrength[3] + pathAudioLinkEmission.a);
				pathEmission *= pathColorMap.rgb * pathColorMap.a;
				
				float3 colorReplace = 0;
				colorReplace = pathAlpha[0][_PathTypeR] * poiThemeColor(poiMods, PathColor[0].rgb, _PathColorRThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[0].a * pathAlpha[0][_PathTypeR]);
				colorReplace = pathAlpha[1][_PathTypeG] * poiThemeColor(poiMods, PathColor[1].rgb, _PathColorGThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[1].a * pathAlpha[1][_PathTypeG]);
				colorReplace = pathAlpha[2][_PathTypeB] * poiThemeColor(poiMods, PathColor[2].rgb, _PathColorBThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[2].a * pathAlpha[2][_PathTypeB]);
				colorReplace = pathAlpha[3][_PathTypeA] * poiThemeColor(poiMods, PathColor[3].rgb, _PathColorAThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[3].a * pathAlpha[3][_PathTypeA]);
				
				float alpha = max(max(max(pathAlpha[0][_PathTypeR], pathAlpha[1][_PathTypeG]), pathAlpha[2][_PathTypeB]), pathAlpha[3][_PathTypeA]);
				
				poiFragData.alpha *= lerp(1, alpha, _PathingOverrideAlpha);
				poiFragData.baseColor = albedo.rgb;
				poiFragData.emission += pathEmission;
			}
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			void applyMirror(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float inMirror = 0;
				if (_VisibilityMode == 1) // VRC
				inMirror = VRCMirrorMode() > 0;
				else // Generic (CVR, etc)
				inMirror = IsInMirror();
				
				#if (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 mirrorTexture = POI2D_SAMPLER_PAN(_MirrorTexture, _MainTex, poiUV(poiMesh.uv[_MirrorTextureUV], _MirrorTexture_ST), _MirrorTexturePan);
				if (inMirror)
				{
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, mirrorTexture.rgb, _MirrorTextureBlendType), mirrorTexture.a * _MirrorColor.a);
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#else
				if (inMirror)
				{
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#endif
				#endif
			}
			#endif
			//endex
			
			//ifex _EnableTouchGlow==0
			#ifdef GRAIN
			void applyDepthFX(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float3 touchEmission = 0;
				
				float perspectiveDivide = 1.0f / poiCam.clipPos.w;
				float4 direction = poiCam.worldDirection * perspectiveDivide;
				float2 screenPos = poiCam.grabPos.xy * perspectiveDivide;
				float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, screenPos);
				
				#if UNITY_REVERSED_Z
				if (z == 0)
				#else
				if (z == 1)
				#endif
				return;
				
				float depth = CorrectedLinearEyeDepth(z, direction.w);
				float3 worldpos = direction * depth + _WorldSpaceCameraPos.xyz;
				/*
				finalColor.rgb = frac(worldpos);
				return;
				*/
				
				float diff = distance(worldpos, poiMesh.worldPos);
				//poiFragData.finalColor = diff;
				
				#if defined(PROP_DEPTHMASK) || !defined(OPTIMIZER_ENABLED)
				float depthMask = POI2D_SAMPLER_PAN(_DepthMask, _MainTex, poiUV(poiMesh.uv[_DepthMaskUV], _DepthMask_ST), _DepthMaskPan)[_DepthMaskChannel];
				#else
				float depthMask = 1;
				#endif
				
				if (_DepthMaskGlobalMask > 0)
				{
					depthMask = maskBlend(depthMask, poiMods.globalMask[_DepthMaskGlobalMask-1], _DepthMaskGlobalMaskBlendType);
				}
				
				if (_DepthColorToggle)
				{
					float colorBlendAlpha = lerp(_DepthColorMinValue, _DepthColorMaxValue, remapClamped(_DepthColorMinDepth, _DepthColorMaxDepth, diff));
					
					#if defined(PROP_DEPTHTEXTURE) || !defined(OPTIMIZER_ENABLED)
					float2 depthTextureUV = float2(0, 0);
					if (_DepthTextureUV == 8)
					{
						depthTextureUV = lerp(0, 1, remapClamped(_DepthColorMinDepth, _DepthColorMaxDepth, diff));
					}
					else
					{
						depthTextureUV = poiMesh.uv[_DepthTextureUV];
					}
					float3 depthColor = POI2D_SAMPLER_PAN(_DepthTexture, _MainTex, poiUV(depthTextureUV, _DepthTexture_ST), _DepthTexturePan).rgb * poiThemeColor(poiMods, _DepthColor, _DepthColorThemeIndex);
					#else
					float3 depthColor = poiThemeColor(poiMods, _DepthColor, _DepthColorThemeIndex);
					#endif
					
					switch(_DepthColorBlendMode)
					{
						case 0:
						{
							poiFragData.finalColor = lerp(poiFragData.finalColor, depthColor, colorBlendAlpha * depthMask);
							break;
						}
						case 1:
						{
							poiFragData.finalColor *= lerp(1, depthColor, colorBlendAlpha * depthMask);
							break;
						}
						case 2:
						{
							poiFragData.finalColor = saturate(poiFragData.finalColor + lerp(0, depthColor, colorBlendAlpha * depthMask));
							break;
						}
					}
					poiFragData.emission += depthColor * colorBlendAlpha * _DepthEmissionStrength * depthMask;
				}
				
				if (_DepthAlphaToggle)
				{
					poiFragData.alpha *= lerp(poiFragData.alpha, saturate(lerp(_DepthAlphaMinValue, _DepthAlphaMaxValue, remapClamped(_DepthAlphaMinDepth, _DepthAlphaMaxDepth, diff))), depthMask);
				}
			}
			#endif
			//endex
			
			//ifex _EnableIridescence==0
			#ifdef POI_IRIDESCENCE
			float3 calculateIridescenceNormal(PoiMesh poiMesh, float3 baseNormal, int normalSelection)
			{
				float3 normal = baseNormal;
				#if defined(PROP_IRIDESCENCENORMALMAP) || !defined(OPTIMIZER_ENABLED)
				normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(_IridescenceNormalMap, _MainTex, poiUV(poiMesh.uv[_IridescenceNormalMapUV], _IridescenceNormalMap_ST), _IridescenceNormalMapPan), _IridescenceNormalIntensity);
				normal = normalize(normal.x * poiMesh.tangent[normalSelection] + normal.y * poiMesh.binormal[normalSelection] + normal.z * baseNormal);
				#endif
				return normal;
			}
			
			void applyIridescence(inout PoiFragData poiFragData, PoiMesh poiMesh, PoiCam poiCam, inout PoiMods poiMods)
			{
				float3 normal = poiMesh.normals[_IridescenceNormalSelection];
				if (_IridescenceNormalToggle)
				{
					normal = calculateIridescenceNormal(poiMesh, normal, _IridescenceNormalSelection);
				}
				float ndotv = dot(normal, poiCam.viewDir);
				
				float4 iridescenceColor = 1;
				#if defined(PROP_IRIDESCENCERAMP) || !defined(OPTIMIZER_ENABLED)
				float2 iridescencePan = _IridescenceRampPan * _Time.x + _IridescenceRamp_ST.zw;
				#ifdef POI_AUDIOLINK
				iridescencePan += AudioLinkGetChronoTime(_IridescenceAudioLinkChronoPanType, _IridescenceAudioLinkChronoPanBand) * _IridescenceAudioLinkChronoPanSpeed;
				#endif
				iridescenceColor = UNITY_SAMPLE_TEX2D_SAMPLER(_IridescenceRamp, _MainTex, (1 - abs(ndotv)) * _IridescenceRamp_ST.xy + iridescencePan);
				if (_IridescenceHueShiftEnabled == 1)
				{
					float hue = _IridescenceHueShift + frac(_Time.x * _IridescenceHueShiftSpeed);
					iridescenceColor.rgb = hueShift(iridescenceColor.rgb, hue);
				}
				#endif
				
				float iridescenceMask = 1;
				#if defined(PROP_IRIDESCENCEMASK) || !defined(OPTIMIZER_ENABLED)
				iridescenceMask = POI2D_SAMPLER_PAN(_IridescenceMask, _MainTex, poiUV(poiMesh.uv[_IridescenceMaskUV], _IridescenceMask_ST), _IridescenceMaskPan)[_IridescenceMaskChannel];
				if (_IridescenceMaskInvert == 1)
				{
					iridescenceMask = 1 - iridescenceMask;
				}
				#endif
				
				if (_IridescenceMaskGlobalMask > 0)
				{
					iridescenceMask = maskBlend(iridescenceMask, poiMods.globalMask[_IridescenceMaskGlobalMask-1], _IridescenceMaskGlobalMaskBlendType);
				}
				
				float emissionStrength = _IridescenceEmissionStrength;
				float iridescenceIntensity = _IridescenceIntensity;
				#ifdef POI_AUDIOLINK
				if (any(_IridescenceAudioLinkEmissionAdd))
				{
					emissionStrength += lerp(_IridescenceAudioLinkEmissionAdd[0], _IridescenceAudioLinkEmissionAdd[1], poiMods.audioLink[_IridescenceAudioLinkEmissionAddBand]);
				}
				if (any(_IridescenceAudioLinkIntensityAdd))
				{
					iridescenceIntensity += lerp(_IridescenceAudioLinkIntensityAdd[0], _IridescenceAudioLinkIntensityAdd[1], poiMods.audioLink[_IridescenceAudioLinkIntensityAddBand]);
				}
				#endif
				
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, saturate(iridescenceColor.rgb * iridescenceIntensity), iridescenceColor.a * _IridescenceReplaceBlend * iridescenceMask);
				poiFragData.baseColor.rgb += saturate(iridescenceColor.rgb * iridescenceIntensity * iridescenceColor.a * _IridescenceAddBlend * iridescenceMask);
				poiFragData.baseColor.rgb *= saturate(lerp(1, iridescenceColor.rgb * iridescenceIntensity, iridescenceColor.a * _IridescenceMultiplyBlend * iridescenceMask));
				
				poiFragData.emission += saturate(iridescenceColor.rgb * _IridescenceIntensity) * iridescenceColor.a * iridescenceMask * emissionStrength;
			}
			#endif
			//endex
			
			//ifex _TextEnabled==0
			#ifdef EFFECT_BUMP
			
			float2 TransformUV(float2 offset, float rotation, float2 scale, float2 uv)
			{
				float theta = radians(rotation);
				scale = 1 - scale;
				float cs = cos(theta);
				float sn = sin(theta);
				float2 centerPoint = offset + .5;
				uv = float2((uv.x - centerPoint.x) * cs - (uv.y - centerPoint.y) * sn + centerPoint.x, (uv.x - centerPoint.x) * sn + (uv.y - centerPoint.y) * cs + centerPoint.y);
				
				return remap(uv, float2(0, 0) + offset + (scale * .5), float2(1, 1) + offset - (scale * .5), float2(0, 0), float2(1, 1));
			}
			
			float2 getAsciiCoordinate(float index)
			{
				return float2((index - 1) / 16, 1 - ((floor(index / 16 - glyphWidth)) / 16));
			}
			
			float median(float r, float g, float b)
			{
				return max(min(r, g), min(max(r, g), b));
			}
			
			void ApplyPositionText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				float3 cameraPos = clamp(getCameraPosition(), -999, 999);
				float3 absCameraPos = abs(cameraPos);
				float totalCharacters = 20;
				float positionArray[20];
				positionArray[0] = cameraPos.x >= 0 ? ASCII_NEGATIVE : ASCII_POSITIVE;
				positionArray[1] = floor((absCameraPos.x * .01) % 10) + 48;
				positionArray[2] = floor((absCameraPos.x * .1) % 10) + 48;
				positionArray[3] = floor(absCameraPos.x % 10) + 48;
				positionArray[4] = ASCII_PERIOD;
				positionArray[5] = floor((absCameraPos.x * 10) % 10) + 48;
				positionArray[6] = ASCII_COMMA;
				positionArray[7] = cameraPos.y >= 0 ? ASCII_NEGATIVE : ASCII_POSITIVE;
				positionArray[8] = floor((absCameraPos.y * .01) % 10) + 48;
				positionArray[9] = floor((absCameraPos.y * .1) % 10) + 48;
				positionArray[10] = floor(absCameraPos.y % 10) + 48;
				positionArray[11] = ASCII_PERIOD;
				positionArray[12] = floor((absCameraPos.y * 10) % 10) + 48;
				positionArray[13] = ASCII_COMMA;
				positionArray[14] = cameraPos.z >= 0 ? ASCII_NEGATIVE : ASCII_POSITIVE;
				positionArray[15] = floor((absCameraPos.z * .01) % 10) + 48;
				positionArray[16] = floor((absCameraPos.z * .1) % 10) + 48;
				positionArray[17] = floor(absCameraPos.z % 10) + 48;
				positionArray[18] = ASCII_PERIOD;
				positionArray[19] = floor((absCameraPos.z * 10) % 10) + 48;
				
				uv = TransformUV(_TextPositionOffset, _TextPositionRotation, _TextPositionScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(positionArray[currentCharacter]);
				
				float2 startUV = float2(1 / totalCharacters * currentCharacter, 0);
				float2 endUV = float2(1 / totalCharacters * (currentCharacter + 1), 1);
				
				fixed4 textPositionPadding = _TextPositionPadding;
				textPositionPadding *= 1 / totalCharacters;
				
				uv = remapClamped(startUV, endUV, uv, float2(glyphPos.x + textPositionPadding.x, glyphPos.y - glyphWidth + textPositionPadding.y), float2(glyphPos.x + glyphWidth - textPositionPadding.z, glyphPos.y - textPositionPadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textPositionPadding.z - .001 || uv.x < glyphPos.x + textPositionPadding.x + .001 || uv.y > glyphPos.y - textPositionPadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textPositionPadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextPositionColor.rgb, _TextPositionColorThemeIndex), opacity * _TextPositionColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextPositionColor.rgb, _TextPositionColorThemeIndex) * opacity * _TextPositionEmissionStrength;
			}
			
			void ApplyTimeText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				float instanceTime = _Time.y;
				float hours = instanceTime / 3600;
				float minutes = (instanceTime / 60) % 60;
				float seconds = instanceTime % 60;
				float totalCharacters = 8;
				float timeArray[8];
				timeArray[0] = floor((hours * .1) % 10) + 48;
				timeArray[1] = floor(hours % 10) + 48;
				timeArray[2] = ASCII_SEMICOLON;
				timeArray[3] = floor((minutes * .1) % 10) + 48;
				timeArray[4] = floor(minutes % 10) + 48;
				timeArray[5] = ASCII_SEMICOLON;
				timeArray[6] = floor((seconds * .1) % 10) + 48;
				timeArray[7] = floor(seconds % 10) + 48;
				
				uv = TransformUV(_TextTimeOffset, _TextTimeRotation, _TextTimeScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(timeArray[currentCharacter]);
				// 0.1428571 = 1/7 = 1 / totalCharacters
				float startUV = 1 / totalCharacters * currentCharacter;
				float endUV = 1 / totalCharacters * (currentCharacter + 1);
				
				fixed4 textTimePadding = _TextTimePadding;
				textTimePadding *= 1 / totalCharacters;
				
				uv = remapClamped(float2(startUV, 0), float2(endUV, 1), uv, float2(glyphPos.x + textTimePadding.x, glyphPos.y - glyphWidth + textTimePadding.y), float2(glyphPos.x + glyphWidth - textTimePadding.z, glyphPos.y - textTimePadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textTimePadding.z - .001 || uv.x < glyphPos.x + textTimePadding.x + .001 || uv.y > glyphPos.y - textTimePadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textTimePadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextTimeColor.rgb, _TextTimeColorThemeIndex), opacity * _TextTimeColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextTimeColor.rgb, _TextTimeColorThemeIndex) * opacity * _TextTimeEmissionStrength;
			}
			
			void ApplyFPSText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				float smoothDeltaTime = clamp(unity_DeltaTime.w, 0, 999);
				float totalCharacters = 7;
				float fpsArray[7];
				fpsArray[0] = ASCII_F;
				fpsArray[1] = ASCII_P;
				fpsArray[2] = ASCII_S;
				fpsArray[3] = ASCII_SEMICOLON;
				fpsArray[4] = floor((smoothDeltaTime * .01) % 10) + 48;
				fpsArray[5] = floor((smoothDeltaTime * .1) % 10) + 48;
				fpsArray[6] = floor(smoothDeltaTime % 10) + 48;
				
				uv = TransformUV(_TextFPSOffset, _TextFPSRotation, _TextFPSScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(fpsArray[currentCharacter]);
				// 0.1428571 = 1/7 = 1 / totalCharacters
				float startUV = 1 / totalCharacters * currentCharacter;
				float endUV = 1 / totalCharacters * (currentCharacter + 1);
				
				float4 textFPSPadding = _TextFPSPadding;
				textFPSPadding *= 1 / totalCharacters;
				
				uv = remapClamped(float2(startUV, 0), float2(endUV, 1), uv, float2(glyphPos.x + textFPSPadding.x, glyphPos.y - glyphWidth + textFPSPadding.y), float2(glyphPos.x + glyphWidth - textFPSPadding.z, glyphPos.y - textFPSPadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textFPSPadding.z - .001 || uv.x < glyphPos.x + textFPSPadding.x + .001 || uv.y > glyphPos.y - textFPSPadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textFPSPadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextFPSColor.rgb, _TextFPSColorThemeIndex), opacity * _TextFPSColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextFPSColor.rgb, _TextFPSColorThemeIndex) * opacity * _TextFPSEmissionStrength;
			}
			
			void ApplyNumericText(inout PoiFragData poiFragData, float2 uv, in PoiMods poiMods)
			{
				// If both digits are set to zero: exit.
				if (_TextNumericWholeDigits == 0 && _TextNumericDecimalDigits == 0)
				{
					return;
				}
				
				uint wholeNumber = 0;
				uint decimalNumber = 0;
				uint wholeDigits = _TextNumericWholeDigits;
				uint decimalDigits = _TextNumericDecimalDigits;
				float NumericArray[10];										// 10 is the max amount of characters = 1 sign + 4 max whole digits + 1 decimal mark + 4 max decimal digits
				uint arrayIndex = 0;
				float totalCharacters = 1 + wholeDigits + decimalDigits; 	// Sign Character + Whole Digits + Decimal Digits
				
				//Determine Sign (_TextNumericValue is usually animated)
				float charSign = _TextNumericValue >= 0 ? ASCII_SPACE : ASCII_NEGATIVE;
				
				NumericArray[arrayIndex] = charSign;						//First character is always the sign
				arrayIndex++;
				
				//Isolate whole number and fill array
				if (wholeDigits > 0)
				{
					wholeNumber = uint(glsl_mod(abs(_TextNumericValue), pow(10, wholeDigits)));
					
					int expIndex = -1 * (wholeDigits - 1);  // Exponent Index
					bool leadingZero = true;
					// Pouplate the Array
					while (arrayIndex <= wholeDigits)
					{
						// Grab the corresponding digit from the whole number going from left to right.
						int digit = floor(glsl_mod(wholeNumber * pow(10, expIndex), 10));
						// Take the resulting value and add 48 to get the corresponding location in the font array.
						NumericArray[arrayIndex] = digit + 48;
						
						//Trim Leading Zeroes, but leave at least one.
						if (_TextNumericTrimZeroes == true)
						{
							//If the digit is zero and there hasn't been any digits greater than 0 previously.
							if (digit == 0 && leadingZero == true && arrayIndex != wholeDigits)
							{
								//Overwrite the leading zero.
								NumericArray[arrayIndex] = ASCII_SPACE;
							}
							else
							{
								leadingZero = false;
							}
						}
						expIndex++;
						arrayIndex++;
					}
				}
				
				// Isolate decimal number and fill array
				if (decimalDigits > 0)
				{
					// Add a decimal point
					NumericArray[arrayIndex] = ASCII_PERIOD;
					int decimalPointer = arrayIndex;
					arrayIndex++;
					totalCharacters++;
					
					decimalNumber = uint(frac(abs(_TextNumericValue)) * pow(10.00001, decimalDigits));    // Isolate the decimal number
					
					int expIndex = -1 * (decimalDigits - 1);                                          // Exponent Index
					//Populate the Array with the remaining digits
					while (arrayIndex < (totalCharacters))
					{
						// Grab the corresponding digit from the whole number going from left to right.
						int digit = floor(glsl_mod(decimalNumber * pow(10, expIndex), 10));
						// Take the resulting value and add 48 to get the corresponding location in the font array.
						NumericArray[arrayIndex] = digit + 48;
						
						expIndex++;
						arrayIndex++;
					}
				}
				
				uv = TransformUV(_TextNumericOffset, _TextNumericRotation, _TextNumericScale, uv);
				
				if (uv.x > 1 || uv.x < 0 || uv.y > 1 || uv.y < 0)
				{
					return;
				}
				
				float currentCharacter = floor(uv.x * totalCharacters);
				float2 glyphPos = getAsciiCoordinate(NumericArray[currentCharacter]);
				float startUV = 1 / totalCharacters * currentCharacter;
				float endUV = 1 / totalCharacters * (currentCharacter + 1);
				
				float4 textNumericPadding = _TextNumericPadding;
				textNumericPadding *= 1 / totalCharacters;
				
				uv = remapClamped(float2(startUV, 0), float2(endUV, 1), uv, float2(glyphPos.x + textNumericPadding.x, glyphPos.y - glyphWidth + textNumericPadding.y), float2(glyphPos.x + glyphWidth - textNumericPadding.z, glyphPos.y - textNumericPadding.w));
				
				if (uv.x > glyphPos.x + glyphWidth - textNumericPadding.z - .001 || uv.x < glyphPos.x + textNumericPadding.x + .001 || uv.y > glyphPos.y - textNumericPadding.w - .001 || uv.y < glyphPos.y - glyphWidth + textNumericPadding.y + .001)
				{
					return;
				}
				
				float3 samp = tex2D(_TextGlyphs, TRANSFORM_TEX(uv, _TextGlyphs)).rgb;
				float2 msdfUnit = _TextPixelRange / _TextGlyphs_TexelSize.zw;
				float sigDist = median(samp.r, samp.g, samp.b) - 0.5;
				sigDist *= max(dot(msdfUnit, 0.5 / fwidth(uv)), 1);
				float opacity = clamp(sigDist + 0.5, 0, 1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, poiThemeColor(poiMods, _TextNumericColor.rgb, _TextNumericColorThemeIndex), opacity * _TextNumericColor.a);
				globalTextEmission += poiThemeColor(poiMods, _TextNumericColor.rgb, _TextNumericColorThemeIndex) * opacity * _TextNumericEmissionStrength;
			}
			
			void ApplyTextOverlayColor(inout PoiFragData poiFragData, PoiMesh poiMesh, in PoiMods poiMods)
			{
				globalTextEmission = 0;
				float positionalOpacity = 0;
				
				if (_TextFPSEnabled == 1)
				ApplyFPSText(poiFragData, poiMesh.uv[_TextFPSUV], poiMods);
				if (_TextPositionEnabled == 1)
				ApplyPositionText(poiFragData, poiMesh.uv[_TextPositionUV], poiMods);
				if (_TextTimeEnabled == 1)
				ApplyTimeText(poiFragData, poiMesh.uv[_TextTimeUV], poiMods);
				if (_TextNumericEnabled == 1)
				ApplyNumericText(poiFragData, poiMesh.uv[_TextNumericUV], poiMods);
				
				poiFragData.emission += globalTextEmission;
			}
			#endif
			//endex
			
			//ifex _PostProcess==0
			#ifdef POSTPROCESS
			float3 poiPosterize(float3 color, float steps)
			{
				float3 newColor = color;
				steps = floor(steps);
				newColor.r = floor(newColor.r * steps) / steps;
				newColor.g = floor(newColor.g * steps) / steps;
				newColor.b = floor(newColor.b * steps) / steps;
				return newColor;
			}
			
			float oetf_sRGB_scalar(float L)
			{
				float V = 1.055 * (pow(L, 1.0 / 2.4)) - 0.055;
				if (L <= 0.0031308)
				V = L * 12.92;
				return V;
			}
			
			float3 oetf_sRGB(float3 L)
			{
				return float3(oetf_sRGB_scalar(L.r), oetf_sRGB_scalar(L.g), oetf_sRGB_scalar(L.b));
			}
			
			float eotf_sRGB_scalar(float V)
			{
				float L = pow((V + 0.055) / 1.055, 2.4);
				if (V <= oetf_sRGB_scalar(0.0031308))
				L = V / 12.92;
				return L;
			}
			
			float3 GetHDR(float3 rgb)
			{
				return float3(eotf_sRGB_scalar(rgb.r), eotf_sRGB_scalar(rgb.g), eotf_sRGB_scalar(rgb.b));
			}
			
			float3 GetContrast(float3 col, float contrast)
			{
				return lerp(float3(0.5, 0.5, 0.5), col, contrast);
			}
			
			float3 GetSaturation(float3 col, float interpolator)
			{
				return lerp(dot(col, float3(0.3, 0.59, 0.11)), col, interpolator);
			}
			
			void applyPostProcessing(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				float3 col = poiFragData.finalColor;
				col = hueShift(col, _PPHue);
				col *= _PPTint;
				col *= _PPRGB;
				col = GetSaturation(col, _PPSaturation);
				col = lerp(col, GetHDR(col), _PPHDR);
				col = GetContrast(col, _PPContrast);
				col *= _PPBrightness;
				col += _PPLightness;
				
				float ppMask = 1;
				#if defined(PROP_PPMASK) || !defined(OPTIMIZER_ENABLED)
				ppMask = POI2D_SAMPLER_PAN(_PPMask, _MainTex, poiUV(poiMesh.uv[_PPMaskUV], _PPMask_ST), _PPMaskPan)[_PPMaskChannel];
				ppMask = lerp(ppMask, 1 - ppMask, _PPMaskInvert);
				col = lerp(poiFragData.finalColor, col, ppMask);
				#endif
				
				if (_PPPosterization)
				{
					col = lerp(col, poiPosterize(col, _PPPosterizationAmount), ppMask);
				}
				
				poiFragData.finalColor = col;
			}
			#endif
			//endex
			
			// normal correct code from https://github.com/yoship1639/UniToon (MIT)
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			void applyNormalCorrect(inout VertexOut i)
			{
				float3 normalCorrectObject = i.localPos.xyz - _NormalCorrectOrigin;
				normalCorrectObject.y = 0;
				normalCorrectObject = normalize(normalCorrectObject);
				float3 normalCorrectWorld = UnityObjectToWorldDir(normalCorrectObject);
				i.normal.xyz = normalize(lerp(i.normal.xyz, normalCorrectWorld, _NormalCorrectAmount));
				i.objNormal.xyz = normalize(lerp(i.objNormal.xyz, normalCorrectObject, _NormalCorrectAmount));
			}
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float3 applyBacklight(float3 videoTexture, half backlightStrength)
			{
				return max(backlightStrength, videoTexture.rgb);
			}
			
			float3 applyViewAngleTN(float3 videoTexture, PoiCam poiCam, PoiMesh poiMesh)
			{
				float3 reflectionVector = normalize(reflect(poiCam.viewDir.rgb, poiMesh.normals[1].rgb));
				float upwardShift = dot(reflectionVector, poiMesh.binormal[0]);
				upwardShift = pow(upwardShift, 1);
				float sideShift = dot(reflectionVector, poiMesh.tangent[0]);
				sideShift *= pow(sideShift, 3);
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = LinearToGammaSpace(videoTexture);
				#endif
				videoTexture = saturate(lerp(half3(0.5, 0.5, 0.5), videoTexture, upwardShift + 1));
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = GammaToLinearSpace(videoTexture);
				#endif
				videoTexture = (lerp(videoTexture, videoTexture.gbr, sideShift));
				return videoTexture;
			}
			
			float calculateCRTPixelBrightness(float2 uv)
			{
				float totalPixels = _VideoResolution.x * _VideoResolution.y;
				float2 uvPixel = float2((floor((1 - uv.y) * _VideoResolution.y)) / _VideoResolution.y, (floor(uv.x * _VideoResolution.x)) / _VideoResolution.x);
				float currentPixelNumber = _VideoResolution.x * (_VideoResolution.y * uvPixel.x) + _VideoResolution.y * uvPixel.y;
				float currentPixelAlpha = currentPixelNumber / totalPixels;
				half electronBeamAlpha = frac(_Time.y * _VideoCRTRefreshRate);
				float electronBeamPixelNumber = totalPixels * electronBeamAlpha;
				
				float DistanceInPixelsFromCurrentElectronBeamPixel = 0;
				if (electronBeamPixelNumber >= currentPixelNumber)
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber - currentPixelNumber;
				}
				else
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber + (totalPixels - currentPixelNumber);
				}
				float CRTFrameTime = 1 / _VideoCRTRefreshRate;
				float timeSincecurrentPixelWasHitByElectronBeam = (DistanceInPixelsFromCurrentElectronBeamPixel / totalPixels);
				
				return saturate(_VideoCRTPixelEnergizedTime - timeSincecurrentPixelWasHitByElectronBeam);
			}
			
			void applyContrastSettings(inout float3 pixel)
			{
				#if !UNITY_COLORSPACE_GAMMA
				pixel = LinearToGammaSpace(pixel);
				#endif
				pixel = saturate(lerp(half3(0.5, 0.5, 0.5), pixel, _VideoContrast + 1));
				#if !UNITY_COLORSPACE_GAMMA
				pixel = GammaToLinearSpace(pixel);
				#endif
			}
			
			void applySaturationSettings(inout float3 pixel)
			{
				pixel = lerp(pixel.rgb, dot(pixel.rgb, float3(0.3, 0.59, 0.11)), -(_VideoSaturation));
			}
			
			void applyVideoSettings(inout float3 pixel)
			{
				applySaturationSettings(pixel);
				applyContrastSettings(pixel);
			}
			
			void calculateLCD(inout float4 videoTexture, float3 pixels)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateTN(inout float4 videoTexture, float3 pixels, PoiCam poiCam, PoiMesh poiMesh)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				videoTexture.rgb = applyViewAngleTN(videoTexture, poiCam, poiMesh);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateCRT(inout float4 videoTexture, float3 pixels, float2 uv)
			{
				float brightness = calculateCRTPixelBrightness(uv);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * brightness * _VideoBacklight;
			}
			void calculateOLED(inout float4 videoTexture, float3 pixels)
			{
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateGameboy(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				// half brightness = saturate((videoTexture.r + videoTexture.g + videoTexture.b) * .3333333);
				half brightness = LinearRgbToLuminance(LinearToGammaSpace(videoTexture.rgb));
				#if defined(PROP_VIDEOGAMEBOYRAMP) || !defined(OPTIMIZER_ENABLED)
				videoTexture.rgb = tex2Dlod(_VideoGameboyRamp, float4(brightness.xx, 0, 0));
				#else
				float3 dg = float3(0.00392156863, 0.0392156863, 0.00392156863);
				float3 lg = float3(0.333333333, 0.5, 0.00392156863);
				videoTexture.rgb = lerp(dg, lg, brightness);
				#endif
			}
			void calculateProjector(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				
				float3 projectorColor = videoTexture * _VideoBacklight;
				videoTexture.r = clamp(projectorColor.r, videoTexture.r, 1000);
				videoTexture.g = clamp(projectorColor.g, videoTexture.g, 1000);
				videoTexture.b = clamp(projectorColor.b, videoTexture.b, 1000);
			}
			
			void applyVideoEffectsMainTex(inout float4 mainTexture, in PoiMesh poiMesh)
			{
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					float2 originalUVs = uvs;
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
					mainTexture = _MainTex.SampleGrad(sampler_MainTex, uvs, ddx(originalUVs), ddy(originalUVs));
				}
			}
			void applyVideoEffects(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
			{
				#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float3 pixels = tex2D(_VideoPixelTexture, poiUV(poiMesh.uv[_VideoPixelTextureUV], _VideoPixelTexture_ST) * _VideoResolution);
				#else
				float3 pixels = 1;
				#endif
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				else
				{
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				float4 modifiedVideoTexture = 0;
				modifiedVideoTexture.rgb = poiFragData.baseColor;
				modifiedVideoTexture.a = poiFragData.alpha;
				
				// UNITY_BRANCH
				// if(_VideoRepeatVideoTexture == 1)
				// {
				// 	if(poiMesh.uv[_VideoUVNumber].x > 1 || poiMesh.uv[_VideoUVNumber].x < 0 || poiMesh.uv[_VideoUVNumber].y > 1 || poiMesh.uv[_VideoUVNumber].y < 0)
				// 	{
				// 		return;
				// 	}
				// }
				
				switch(_VideoType)
				{
					case 0: // LCD
					{
						calculateLCD(modifiedVideoTexture, pixels);
						break;
					}
					case 1: // TN
					{
						calculateTN(modifiedVideoTexture, pixels, poiCam, poiMesh);
						break;
					}
					case 2: // CRT
					{
						calculateCRT(modifiedVideoTexture, pixels, uvs);
						break;
					}
					case 3: // OLED
					{
						calculateOLED(modifiedVideoTexture, pixels);
						break;
					}
					case 4: // Gameboy
					{
						calculateGameboy(modifiedVideoTexture);
						break;
					}
					case 5: // Projector
					{
						calculateProjector(modifiedVideoTexture);
						break;
					}
				}
				#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float screenMask = POI2D_SAMPLER_PAN(_VideoMaskTexture, _MainTex, poiUV(poiMesh.uv[_VideoMaskTextureUV], _VideoMaskTexture_ST), _VideoMaskTexturePan)[_VideoMaskTextureChannel];
				#else
				float screenMask = 1;
				#endif
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, modifiedVideoTexture, screenMask);
				// UNITY_BRANCH
				if (_VideoEmissionEnabled)
				{
					poiFragData.emission += modifiedVideoTexture.rgb * screenMask;
				}
			}
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			void ApplyBacklight(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiCam poiCam, inout PoiMods poiMods)
			{
				
				// Color
				float3 backlightColor = _BacklightColor.rgb;
				#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				backlightColor *= POI2D_SAMPLER_PAN(_BacklightColorTex, _MainTex, poiUV(poiMesh.uv[_BacklightColorTexUV], _BacklightColorTex_ST), _BacklightColorTexPan).rgb;
				#endif
				
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], _BacklightNormalStrength);
				// Factor
				float3 headDir = normalize(getCameraPosition() - poiMesh.worldPos.xyz);
				float headDotLight = dot(headDir, poiLight.direction);
				float backlightFactor = pow(saturate(-headDotLight * 0.5 + 0.5), max(0, _BacklightDirectivity));
				float backlightLN = dot(normalize(-headDir * _BacklightViewStrength + poiLight.direction), normal) * 0.5 + 0.5;
				if(_BacklightReceiveShadow) backlightLN *= saturate(poiLight.attenuation);
				backlightLN = poiEdgeLinear(backlightLN, _BacklightBorder, _BacklightBlur);
				float backlight = saturate(backlightFactor * backlightLN);
				backlight = !poiMesh.isFrontFace && _BacklightBackfaceMask ? 0.0 : backlight;
				
				// Blend
				backlightColor = lerp(backlightColor, backlightColor * poiFragData.baseColor, _BacklightMainStrength);
				poiLight.finalLightAdd += backlight * backlightColor * poiLight.directColor;
			}
			#endif
			//endex
			
			float4 frag(VertexOut i, uint facing : SV_IsFrontFace) : SV_Target
			{
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				
				PoiMesh poiMesh;
				PoiInitStruct(PoiMesh, poiMesh);
				
				PoiLight poiLight;
				PoiInitStruct(PoiLight, poiLight);
				
				PoiVertexLights poiVertexLights;
				PoiInitStruct(PoiVertexLights, poiVertexLights);
				
				PoiCam poiCam;
				PoiInitStruct(PoiCam, poiCam);
				
				PoiMods poiMods;
				PoiInitStruct(PoiMods, poiMods);
				poiMods.globalEmission = 1;
				poiMods.PBR = 1;
				
				PoiFragData poiFragData;
				poiFragData.emission = 0;
				poiFragData.baseColor = float3(0, 0, 0);
				poiFragData.finalColor = float3(0, 0, 0);
				poiFragData.alpha = 1;
				
				#ifdef POI_UDIMDISCARD
				applyUDIMDiscard(i);
				#endif
				
				//ifex _NormalCorrect==0
				#ifdef POI_NORMALCORRECT
				applyNormalCorrect(i);
				#endif
				//endex
				
				// Mesh Data
				poiMesh.objectPosition = i.objectPos;
				poiMesh.objNormal = i.objNormal;
				poiMesh.normals[0] = i.normal;
				poiMesh.tangent[0] = i.tangent;
				poiMesh.binormal[0] = i.binormal;
				poiMesh.worldPos = i.worldPos.xyz;
				poiMesh.localPos = i.localPos.xyz;
				poiMesh.vertexColor = i.vertexColor;
				poiMesh.isFrontFace = facing;
				
				#ifndef POI_PASS_OUTLINE
				if (!poiMesh.isFrontFace)
				{
					poiMesh.normals[0] *= -1;
					poiMesh.tangent[0] *= -1;
					poiMesh.binormal[0] *= -1;
				}
				#endif
				
				poiCam.viewDir = !IsOrthographicCamera() ? normalize(_WorldSpaceCameraPos - i.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 tanToWorld0 = float3(i.tangent.x, i.binormal.x, i.normal.x);
				float3 tanToWorld1 = float3(i.tangent.y, i.binormal.y, i.normal.y);
				float3 tanToWorld2 = float3(i.tangent.z, i.binormal.z, i.normal.z);
				float3 ase_tanViewDir = tanToWorld0 * poiCam.viewDir.x + tanToWorld1 * poiCam.viewDir.y + tanToWorld2 * poiCam.viewDir.z;
				poiCam.tangentViewDir = normalize(ase_tanViewDir);
				
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 6 Distorted UV
				#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
				poiMesh.lightmapUV = i.lightmapUV;
				#endif
				poiMesh.parallaxUV = poiCam.tangentViewDir.xy / max(poiCam.tangentViewDir.z, 0.0001);
				poiMesh.uv[0] = i.uv[0];
				poiMesh.uv[1] = i.uv[1];
				poiMesh.uv[2] = i.uv[2];
				poiMesh.uv[3] = i.uv[3];
				poiMesh.uv[4] = poiMesh.uv[0];
				poiMesh.uv[5] = poiMesh.uv[0];
				poiMesh.uv[6] = poiMesh.uv[0];
				poiMesh.uv[7] = poiMesh.uv[0];
				poiMesh.uv[8] = poiMesh.uv[0];
				
				poiMesh.uv[4] = calculatePanosphereUV(poiMesh);
				poiMesh.uv[5] = calculateWorldUV(poiMesh);
				poiMesh.uv[6] = calculatePolarCoordinate(poiMesh);
				poiMesh.uv[8] = calculatelocalUV(poiMesh);
				//ifex _EnableDistortion==0
				#ifdef USER_LUT
				poiMesh.uv[7] = distortedUV(poiMesh);
				#endif
				//endex
				/*
				half3 worldViewUp = normalize(half3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, half3(0, 1, 0)));
				half3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
				poiMesh[8] = half2(dot(worldViewRight, poiMesh.normals[_MatcapNormal]), dot(worldViewUp, poiMesh.normals[_MatcapNormal])) * _MatcapBorder + 0.5;
				*/
				
				//ifex _PoiParallax==0
				#ifdef POI_PARALLAX
				#ifndef POI_PASS_OUTLINE
				//return frac(i.tangentViewDir.x);
				//return float4(i.binormal.xyz,1);
				applyParallax(poiMesh, poiLight, poiCam);
				#endif
				#endif
				//endex
				
				poiMods.globalMask[0]  = 1;
				poiMods.globalMask[1]  = 1;
				poiMods.globalMask[2]  = 1;
				poiMods.globalMask[3]  = 1;
				poiMods.globalMask[4]  = 1;
				poiMods.globalMask[5]  = 1;
				poiMods.globalMask[6]  = 1;
				poiMods.globalMask[7]  = 1;
				poiMods.globalMask[8]  = 1;
				poiMods.globalMask[9]  = 1;
				poiMods.globalMask[10] = 1;
				poiMods.globalMask[11] = 1;
				poiMods.globalMask[12] = 1;
				poiMods.globalMask[13] = 1;
				poiMods.globalMask[14] = 1;
				poiMods.globalMask[15] = 1;
				//ifex _GlobalMaskTexturesEnable==0
				#ifdef POI_GLOBALMASK_TEXTURES
				ApplyGlobalMaskTextures(poiMesh, poiMods);
				#endif
				//endex
				ApplyGlobalMaskModifiers(poiMesh, poiMods, poiCam);
				//ifex _GlobalMaskOptionsEnable==0
				if(_GlobalMaskOptionsEnable)
				{
					ApplyGlobalMaskOptions(poiMods);
				}
				//endex
				
				float2 mainUV = poiMesh.uv[_MainTexUV].xy;
				
				if (_MainPixelMode)
				{
					mainUV = sharpSample(_MainTex_TexelSize, mainUV);
				}
				
				float4 mainTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_MainTex, _MainTex, poiUV(mainUV, _MainTex_ST), _MainTexPan, _MainTexStochastic);
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffectsMainTex(mainTexture, poiMesh);
				}
				//endex
				
				#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
				poiMesh.tangentSpaceNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_BumpMap, _MainTex, poiUV(poiMesh.uv[_BumpMapUV].xy, _BumpMap_ST), _BumpMapPan, _BumpMapStochastic), _BumpScale);
				#else
				poiMesh.tangentSpaceNormal = UnpackNormal(float4(0.5, 0.5, 1, 1));
				#endif
				
				//ifex _DetailEnabled==0
				#if defined(FINALPASS) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				ApplyDetailNormal(poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				//ifex _RgbNormalsEnabled==0
				#if defined(GEOM_TYPE_MESH) && defined(VIGNETTE) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				calculateRGBNormals(poiMesh, poiMods);
				#endif
				//endex
				//endex
				
				poiMesh.normals[1] = normalize(
				poiMesh.tangentSpaceNormal.x * poiMesh.tangent[0] +
				poiMesh.tangentSpaceNormal.y * poiMesh.binormal[0] +
				poiMesh.tangentSpaceNormal.z * poiMesh.normals[0]
				);
				
				poiMesh.tangent[1] = cross(poiMesh.binormal[0], -poiMesh.normals[1]);
				poiMesh.binormal[1] = cross(-poiMesh.normals[1], poiMesh.tangent[0]);
				
				// Camera data
				poiCam.forwardDir = getCameraForward();
				poiCam.worldPos = _WorldSpaceCameraPos;
				poiCam.reflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[1]);
				poiCam.vertexReflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[0]);
				//poiCam.distanceToModel = distance(poiMesh.modelPos, poiCam.worldPos);
				poiCam.distanceToVert = distance(poiMesh.worldPos, poiCam.worldPos);
				poiCam.grabPos = i.grabPos;
				poiCam.screenUV = calcScreenUVs(i.grabPos);
				poiCam.vDotN = abs(dot(poiCam.viewDir, poiMesh.normals[1]));
				poiCam.clipPos = i.pos;
				poiCam.worldDirection = i.worldDirection;
				
				calculateGlobalThemes(poiMods);
				
				poiLight.finalLightAdd = 0;
				
				// Ambient Occlusion
				#if defined(PROP_LIGHTINGAOMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 AOMaps = POI2D_SAMPLER_PAN(_LightingAOMaps, _MainTex, poiUV(poiMesh.uv[_LightingAOMapsUV], _LightingAOMaps_ST), _LightingAOMapsPan);
				poiLight.occlusion = min(min(min(lerp(1, AOMaps.r, _LightDataAOStrengthR), lerp(1, AOMaps.g, _LightDataAOStrengthG)), lerp(1, AOMaps.b, _LightDataAOStrengthB)), lerp(1, AOMaps.a, _LightDataAOStrengthA));
				#else
				poiLight.occlusion = 1;
				#endif
				
				if (_LightDataAOGlobalMaskR > 0)
				{
					poiLight.occlusion = maskBlend(poiLight.occlusion, poiMods.globalMask[_LightDataAOGlobalMaskR - 1], _LightDataAOGlobalMaskBlendTypeR);
				}
				
				// Detail Shadows
				#if defined(PROP_LIGHTINGDETAILSHADOWMAPS) || !defined(OPTIMIZER_ENABLED)
				float4 DetailShadows = POI2D_SAMPLER_PAN(_LightingDetailShadowMaps, _MainTex, poiUV(poiMesh.uv[_LightingDetailShadowMapsUV], _LightingDetailShadowMaps_ST), _LightingDetailShadowMapsPan);
				#ifndef POI_PASS_ADD
				poiLight.detailShadow = lerp(1, DetailShadows.r, _LightingDetailShadowStrengthR) * lerp(1, DetailShadows.g, _LightingDetailShadowStrengthG) * lerp(1, DetailShadows.b, _LightingDetailShadowStrengthB) * lerp(1, DetailShadows.a, _LightingDetailShadowStrengthA);
				#else
				poiLight.detailShadow = lerp(1, DetailShadows.r, _LightingAddDetailShadowStrengthR) * lerp(1, DetailShadows.g, _LightingAddDetailShadowStrengthG) * lerp(1, DetailShadows.b, _LightingAddDetailShadowStrengthB) * lerp(1, DetailShadows.a, _LightingAddDetailShadowStrengthA);
				#endif
				#else
				poiLight.detailShadow = 1;
				#endif
				
				if (_LightDataDetailShadowGlobalMaskR > 0)
				{
					poiLight.detailShadow = maskBlend(poiLight.detailShadow, poiMods.globalMask[_LightDataDetailShadowGlobalMaskR - 1], _LightDataDetailShadowGlobalMaskBlendTypeR);
				}
				
				// Shadow Masks
				#if defined(PROP_LIGHTINGSHADOWMASKS) || !defined(OPTIMIZER_ENABLED)
				float4 ShadowMasks = POI2D_SAMPLER_PAN(_LightingShadowMasks, _MainTex, poiUV(poiMesh.uv[_LightingShadowMasksUV], _LightingShadowMasks_ST), _LightingShadowMasksPan);
				poiLight.shadowMask = lerp(1, ShadowMasks.r, _LightingShadowMaskStrengthR) * lerp(1, ShadowMasks.g, _LightingShadowMaskStrengthG) * lerp(1, ShadowMasks.b, _LightingShadowMaskStrengthB) * lerp(1, ShadowMasks.a, _LightingShadowMaskStrengthA);
				#else
				poiLight.shadowMask = 1;
				#endif
				
				if (_LightDataShadowMaskGlobalMaskR > 0)
				{
					poiLight.shadowMask = maskBlend(poiLight.shadowMask, poiMods.globalMask[_LightDataShadowMaskGlobalMaskR - 1], _LightDataShadowMaskGlobalMaskBlendTypeR);
				}
				
				#ifdef UNITY_PASS_FORWARDBASE
				
				bool lightExists = false;
				if (any(_LightColor0.rgb >= 0.002))
				{
					lightExists = true;
				}
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					float4 toLightX = unity_4LightPosX0 - i.worldPos.x;
					float4 toLightY = unity_4LightPosY0 - i.worldPos.y;
					float4 toLightZ = unity_4LightPosZ0 - i.worldPos.z;
					float4 lengthSq = 0;
					lengthSq += toLightX * toLightX;
					lengthSq += toLightY * toLightY;
					lengthSq += toLightZ * toLightZ;
					
					float4 lightAttenSq = unity_4LightAtten0;
					float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
					float4 vLightWeight = saturate(1 - (lengthSq * lightAttenSq / 25));
					poiLight.vAttenuation = min(atten, vLightWeight * vLightWeight);
					
					poiLight.vDotNL = 0;
					poiLight.vDotNL += toLightX * poiMesh.normals[1].x;
					poiLight.vDotNL += toLightY * poiMesh.normals[1].y;
					poiLight.vDotNL += toLightZ * poiMesh.normals[1].z;
					
					float4 corr = rsqrt(lengthSq);
					poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);
					
					poiLight.vertexVDotNL = 0;
					poiLight.vertexVDotNL += toLightX * poiMesh.normals[0].x;
					poiLight.vertexVDotNL += toLightY * poiMesh.normals[0].y;
					poiLight.vertexVDotNL += toLightZ * poiMesh.normals[0].z;
					
					poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);
					
					poiLight.vAttenuationDotNL = saturate(poiLight.vAttenuation * saturate(poiLight.vDotNL));
					
					[unroll]
					for (int index = 0; index < 4; index++)
					{
						poiLight.vPosition[index] = float3(unity_4LightPosX0[index], unity_4LightPosY0[index], unity_4LightPosZ0[index]);
						
						float3 vertexToLightSource = poiLight.vPosition[index] - poiMesh.worldPos;
						poiLight.vDirection[index] = normalize(vertexToLightSource);
						//poiLight.vAttenuationDotNL[index] = 1.0 / (1.0 + unity_4LightAtten0[index] * poiLight.vDotNL[index]);
						poiLight.vColor[index] = _LightingAdditiveLimited ? min(_LightingAdditiveLimit, unity_LightColor[index].rgb) : unity_LightColor[index].rgb;
						poiLight.vColor[index] = lerp(poiLight.vColor[index], dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
						poiLight.vHalfDir[index] = Unity_SafeNormalize(poiLight.vDirection[index] + poiCam.viewDir);
						poiLight.vDotNL[index] = dot(poiMesh.normals[1], poiLight.vDirection[index]);
						poiLight.vCorrectedDotNL[index] = .5 * (poiLight.vDotNL[index] + 1);
						poiLight.vDotLH[index] = saturate(dot(poiLight.vDirection[index], poiLight.vHalfDir[index]));
						
						poiLight.vDotNH[index] = dot(poiMesh.normals[1], poiLight.vHalfDir[index]);
						poiLight.vertexVDotNH[index] = saturate(dot(poiMesh.normals[0], poiLight.vHalfDir[index]));
					}
					#endif
				}
				
				//UNITY_BRANCH
				if (_LightingColorMode == 0) // Poi Custom Light Color
				
				{
					float3 magic = max(BetterSH9(normalize(unity_SHAr + unity_SHAg + unity_SHAb)), 0);
					float3 normalLight = _LightColor0.rgb + BetterSH9(float4(0, 0, 0, 1));
					
					float magiLumi = calculateluminance(magic);
					float normaLumi = calculateluminance(normalLight);
					float maginormalumi = magiLumi + normaLumi;
					
					float magiratio = magiLumi / maginormalumi;
					float normaRatio = normaLumi / maginormalumi;
					
					float target = calculateluminance(magic * magiratio + normalLight * normaRatio);
					float3 properLightColor = magic + normalLight;
					float properLuminance = calculateluminance(magic + normalLight);
					poiLight.directColor = properLightColor * max(0.0001, (target / properLuminance));
					
					poiLight.indirectColor = BetterSH9(float4(lerp(0, poiMesh.normals[1], _LightingIndirectUsesNormals), 1));
				}
				
				//UNITY_BRANCH
				if (_LightingColorMode == 1) // More standard approach to light color
				
				{
					float3 indirectColor = BetterSH9(float4(poiMesh.normals[1], 1));
					if (lightExists)
					{
						poiLight.directColor = _LightColor0.rgb;
						poiLight.indirectColor = indirectColor;
					}
					else
					{
						poiLight.directColor = indirectColor * 0.6;
						poiLight.indirectColor = indirectColor * 0.5;
					}
				}
				
				if (_LightingColorMode == 2) // UTS style
				
				{
					poiLight.indirectColor = saturate(max(half3(0.05, 0.05, 0.05) * _Unlit_Intensity, max(ShadeSH9(half4(0.0, 0.0, 0.0, 1.0)), ShadeSH9(half4(0.0, -1.0, 0.0, 1.0)).rgb) * _Unlit_Intensity));
					poiLight.directColor = max(poiLight.indirectColor, _LightColor0.rgb);
				}
				
				if (_LightingColorMode == 3) // OpenLit
				
				{
					float3 lightDirectionForSH9 = OpenLitLightingDirectionForSH9();
					OpenLitShadeSH9ToonDouble(lightDirectionForSH9, poiLight.directColor, poiLight.indirectColor);
					poiLight.directColor += _LightColor0.rgb;
					// OpenLit does a few other things by default like clamp direct colour
					// see https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl#L174
					// Should we add (if) statements to override Poi versions of these things?
					// Or should we add new properties with same names with the same functions?
					
				}
				
				float lightMapMode = _LightingMapMode;
				//UNITY_BRANCH
				if (_LightingDirectionMode == 0)
				{
					poiLight.direction = _WorldSpaceLightPos0.xyz + unity_SHAr.xyz + unity_SHAg.xyz + unity_SHAb.xyz;
				}
				if (_LightingDirectionMode == 1 || _LightingDirectionMode == 2)
				{
					//UNITY_BRANCH
					if (_LightingDirectionMode == 1)
					{
						poiLight.direction = mul(unity_ObjectToWorld, _LightngForcedDirection).xyz;;
					}
					//UNITY_BRANCH
					if (_LightingDirectionMode == 2)
					{
						poiLight.direction = _LightngForcedDirection;
					}
					if (lightMapMode == 0)
					{
						lightMapMode == 1;
					}
				}
				
				if (_LightingDirectionMode == 3) // UTS
				
				{
					float3 defaultLightDirection = normalize(UNITY_MATRIX_V[2].xyz + UNITY_MATRIX_V[1].xyz);
					float3 lightDirection = normalize(lerp(defaultLightDirection, _WorldSpaceLightPos0.xyz, any(_WorldSpaceLightPos0.xyz)));
					poiLight.direction = lightDirection;
				}
				if (_LightingDirectionMode == 4) // OpenLit
				
				{
					poiLight.direction = OpenLitLightingDirection(); // float4 customDir = 0; // Do we want to give users to alter this (OpenLit always does!)?
					
				}
				
				if (!any(poiLight.direction))
				{
					poiLight.direction = float3(.4, 1, .4);
				}
				
				poiLight.direction = normalize(poiLight.direction);
				poiLight.attenuationStrength = _LightingCastedShadows;
				poiLight.attenuation = 1;
				if (!all(_LightColor0.rgb == 0.0))
				{
					UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos)
					poiLight.attenuation *= attenuation;
				}
				
				if (!any(poiLight.directColor) && !any(poiLight.indirectColor) && lightMapMode == 0)
				{
					lightMapMode = 1;
					if (_LightingDirectionMode == 0)
					{
						poiLight.direction = normalize(float3(.4, 1, .4));
					}
				}
				
				poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
				poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
				poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
				poiLight.nDotLSaturated = saturate(poiLight.nDotL);
				poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
				poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
				poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
				poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
				poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
				poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
				poiLight.lDotH = max(0.00001, dot(poiLight.direction, poiLight.halfDir));
				
				// Poi special light map
				if (lightMapMode == 0)
				{
					float3 ShadeSH9Plus = GetSHLength();
					float3 ShadeSH9Minus = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;
					
					float3 greyScaleVector = float3(.33333, .33333, .33333);
					float bw_lightColor = dot(poiLight.directColor, greyScaleVector);
					float bw_directLighting = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor * lerp(1, poiLight.attenuation, poiLight.attenuationStrength)) + dot(ShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
					float bw_directLightingNoAtten = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor) + dot(ShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
					float bw_bottomIndirectLighting = dot(ShadeSH9Minus, greyScaleVector);
					float bw_topIndirectLighting = dot(ShadeSH9Plus, greyScaleVector);
					float lightDifference = ((bw_topIndirectLighting + bw_lightColor) - bw_bottomIndirectLighting);
					poiLight.lightMap = smoothstep(0, lightDifference, bw_directLighting - bw_bottomIndirectLighting) * poiLight.detailShadow;
					
					poiLight.lightMap = smoothstep(0, lightDifference, bw_directLighting - bw_bottomIndirectLighting) * poiLight.detailShadow;
					poiLight.lightMapNoAttenuation = smoothstep(0, lightDifference, bw_directLightingNoAtten - bw_bottomIndirectLighting) * poiLight.detailShadow;
				}
				// Normalized nDotL
				if (lightMapMode == 1)
				{
					poiLight.lightMapNoAttenuation = poiLight.nDotLNormalized;
					poiLight.lightMap = poiLight.nDotLNormalized * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				}
				// Saturated nDotL
				if (lightMapMode == 2)
				{
					poiLight.lightMapNoAttenuation = poiLight.nDotLSaturated;
					poiLight.lightMap = poiLight.nDotLSaturated * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
				}
				
				poiLight.directColor = max(poiLight.directColor, 0.0001);
				poiLight.indirectColor = max(poiLight.indirectColor, 0.0001);
				if (_LightingColorMode == 3)
				{
					// OpenLit
					poiLight.directColor = max(poiLight.directColor, _LightingMinLightBrightness);
				}
				else
				{
					poiLight.directColor = max(poiLight.directColor, poiLight.directColor * min(10000, (_LightingMinLightBrightness * rcp(calculateluminance(poiLight.directColor)))));
					poiLight.indirectColor = max(poiLight.indirectColor, poiLight.indirectColor * min(10000, (_LightingMinLightBrightness * rcp(calculateluminance(poiLight.indirectColor)))));
				}
				
				poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
				poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
				
				if (_LightingCapEnabled)
				{
					poiLight.directColor = min(poiLight.directColor, _LightingCap);
					poiLight.indirectColor = min(poiLight.indirectColor, _LightingCap);
				}
				
				if (_LightingForceColorEnabled)
				{
					poiLight.directColor = poiThemeColor(poiMods, _LightingForcedColor, _LightingForcedColorThemeIndex);
				}
				
				#ifdef UNITY_PASS_FORWARDBASE
				poiLight.directColor = max(poiLight.directColor * _PPLightingMultiplier, 0);
				poiLight.directColor = max(poiLight.directColor + _PPLightingAddition, 0);
				poiLight.indirectColor = max(poiLight.indirectColor * _PPLightingMultiplier, 0);
				poiLight.indirectColor = max(poiLight.indirectColor + _PPLightingAddition, 0);
				#endif
				
				#endif
				
				#ifdef POI_PASS_ADD
				if (!_LightingAdditiveEnable)
				{
					return float4(mainTexture.rgb * .0001, 1);
				}
				
				#if defined(DIRECTIONAL)
				if (_DisableDirectionalInAdd)
				{
					return float4(mainTexture.rgb * .0001, 1);
				}
				#endif
				
				poiLight.direction = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz * _WorldSpaceLightPos0.w);
				#if defined(POINT) || defined(SPOT)
				#ifdef POINT
				unityShadowCoord3 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1)).xyz;
				poiLight.attenuation = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).r;
				#endif
				
				#ifdef SPOT
				unityShadowCoord4 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1));
				poiLight.attenuation = (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz);
				#endif
				#else
				UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos)
				poiLight.attenuation = attenuation;
				#endif
				poiLight.additiveShadow = UNITY_SHADOW_ATTENUATION(i, poiMesh.worldPos);
				poiLight.attenuationStrength = _LightingAdditiveCastedShadows;
				poiLight.directColor = _LightingAdditiveLimited ? min(_LightingAdditiveLimit, _LightColor0.rgb) : _LightColor0.rgb;
				
				#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
				poiLight.indirectColor = 0;
				#else
				poiLight.indirectColor = lerp(0, poiLight.directColor, _LightingAdditivePassthrough);
				#endif
				
				poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
				poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
				
				poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
				poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
				poiLight.nDotLSaturated = saturate(poiLight.nDotL);
				poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
				poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
				poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
				poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
				poiLight.lDotH = dot(poiLight.direction, poiLight.halfDir);
				poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
				poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
				poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
				
				// Normalized nDotL
				if (_LightingMapMode == 1)
				{
					poiLight.lightMap = poiLight.nDotLNormalized;
				}
				// Saturated nDotL
				if (_LightingMapMode == 2 || _LightingMapMode == 0)
				{
					poiLight.lightMap = poiLight.nDotLSaturated;
				}
				poiLight.lightMap *= lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
				#endif
				
				//ifex _LightDataDebugEnabled==0
				if (_LightDataDebugEnabled)
				{
					#ifdef UNITY_PASS_FORWARDBASE
					//UNITY_BRANCH
					if (_LightingDebugVisualize <= 6)
					{
						switch(_LightingDebugVisualize)
						{
							case 0: // Direct Light Color
							return float4(poiLight.directColor + mainTexture.rgb * .0001, 1);
							break;
							case 1: // Indirect Light Color
							return float4(poiLight.indirectColor + mainTexture.rgb * .0001, 1);
							break;
							case 2: // Light Map
							return float4(poiLight.lightMap + mainTexture.rgb * .0001, 1);
							break;
							case 3: // Attenuation
							return float4(poiLight.attenuation + mainTexture.rgb * .0001, 1);
							break;
							case 4: // N Dot L
							return float4(poiLight.nDotLNormalized, poiLight.nDotLNormalized, poiLight.nDotLNormalized, 1) + mainTexture * .0001;
							break;
							case 5:
							return float4(poiLight.halfDir, 1) + mainTexture * .0001;
							break;
							case 6:
							return float4(poiLight.direction, 1) + mainTexture * .0001;
							break;
						}
					}
					else
					{
						return POI_SAFE_RGB1;
					}
					#endif
					#ifdef POI_PASS_ADD
					//UNITY_BRANCH
					if (_LightingDebugVisualize < 6)
					{
						return POI_SAFE_RGB1;
					}
					else
					{
						switch(_LightingDebugVisualize)
						{
							case 7:
							return float4(poiLight.directColor * poiLight.attenuation + mainTexture.rgb * .0001, 1);
							break;
							case 8:
							return float4(poiLight.attenuation + mainTexture.rgb * .0001, 1);
							break;
							case 9:
							return float4(poiLight.additiveShadow + mainTexture.rgb * .0001, 1);
							break;
							case 10:
							return float4(poiLight.nDotLNormalized + mainTexture.rgb * .0001, 1);
							break;
							case 11:
							return float4(poiLight.halfDir, 1) + mainTexture * .0001;
							break;
						}
					}
					#endif
				}
				//endex
				
				//ifex _EnableAudioLink==0
				#ifdef POI_AUDIOLINK
				SetupAudioLink(poiFragData, poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _BlackLightMaskingEnabled==0
				#ifdef POI_BLACKLIGHTMASKING
				calculateBlackLightMasks(poiMesh, poiMods);
				#endif
				//endex
				
				poiFragData.baseColor = mainTexture.rgb * poiThemeColor(poiMods, _Color.rgb, _ColorThemeIndex);
				poiFragData.alpha = mainTexture.a * _Color.a;
				
				//ifex _MainColorAdjustToggle==0
				#ifdef COLOR_GRADING_HDR
				#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 hueShiftAlpha = POI2D_SAMPLER_PAN(_MainColorAdjustTexture, _MainTex, poiUV(poiMesh.uv[_MainColorAdjustTextureUV], _MainColorAdjustTexture_ST), _MainColorAdjustTexturePan);
				#else
				float4 hueShiftAlpha = 1;
				#endif
				
				if (_MainHueGlobalMask > 0)
				{
					hueShiftAlpha.r = maskBlend(hueShiftAlpha.r, poiMods.globalMask[_MainHueGlobalMask-1], _MainHueGlobalMaskBlendType);
				}
				if (_MainSaturationGlobalMask > 0)
				{
					hueShiftAlpha.b = maskBlend(hueShiftAlpha.b, poiMods.globalMask[_MainSaturationGlobalMask-1], _MainSaturationGlobalMaskBlendType);
				}
				if (_MainBrightnessGlobalMask > 0)
				{
					hueShiftAlpha.g = maskBlend(hueShiftAlpha.g, poiMods.globalMask[_MainBrightnessGlobalMask-1], _MainBrightnessGlobalMaskBlendType);
				}
				
				if (_MainHueShiftToggle)
				{
					float shift = _MainHueShift;
					#ifdef POI_AUDIOLINK
					//UNITY_BRANCH
					if (poiMods.audioLinkAvailable && _MainHueALCTEnabled)
					{
						shift += AudioLinkGetChronoTime(_MainALHueShiftCTIndex, _MainALHueShiftBand) * _MainHueALMotionSpeed;
					}
					#endif
					if (_MainHueShiftReplace)
					{
						poiFragData.baseColor = lerp(poiFragData.baseColor, hueShift(poiFragData.baseColor, shift + _MainHueShiftSpeed * _Time.x), hueShiftAlpha.r);
					}
					else
					{
						poiFragData.baseColor = hueShift(poiFragData.baseColor, frac((shift - (1 - hueShiftAlpha.r) + _MainHueShiftSpeed * _Time.x)));
					}
				}
				poiFragData.baseColor = lerp(poiFragData.baseColor, dot(poiFragData.baseColor, float3(0.3, 0.59, 0.11)), -(_Saturation) * hueShiftAlpha.b);
				poiFragData.baseColor = saturate(poiFragData.baseColor + _MainBrightness * hueShiftAlpha.g);
				#endif
				//endex
				
				#if defined(PROP_CLIPPINGMASK) || !defined(OPTIMIZER_ENABLED)
				float alphaMask = POI2D_SAMPLER_PAN(_ClippingMask, _MainTex, poiUV(poiMesh.uv[_ClippingMaskUV], _ClippingMask_ST), _ClippingMaskPan).r;
				if (_Inverse_Clipping)
				{
					alphaMask = 1 - alphaMask;
				}
				
				poiFragData.alpha *= alphaMask;
				#endif
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffects(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				}
				//endex
				
				applyAlphaOptions(poiFragData, poiMesh, poiCam, poiMods);
				
				//ifex _DetailEnabled==0
				#ifdef FINALPASS
				ApplyDetailColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _MainVertexColoringEnabled==0
				applyVertexColor(poiFragData, poiMesh);
				//endex
				
				//ifex _BackFaceEnabled!=1
				#ifdef POI_BACKFACE
				ApplyBackFaceColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				#ifdef VIGNETTE
				calculateRGBMask(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				#if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_BRANCH_DETAIL) || defined(GEOM_TYPE_FROND) || defined(DEPTH_OF_FIELD_COC_VIEW)
				applyDecals(poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				applyDissolve(poiFragData, poiMesh, poiMods, poiCam, poiLight);
				#endif
				//endex
				
				//ifex _ShadingEnabled==0
				#if defined(_LIGHTINGMODE_SHADEMAP) && defined(VIGNETTE_MASKED)
				#ifndef POI_PASS_OUTLINE
				#ifdef _LIGHTINGMODE_SHADEMAP
				applyShadeMapping(poiFragData, poiMesh, poiLight);
				#endif
				#endif
				#endif
				//endex
				
				//ifex _ShadingEnabled==0
				#ifdef VIGNETTE_MASKED
				#ifdef POI_PASS_OUTLINE
				//UNITY_BRANCH
				if (_OutlineLit)
				{
					calculateShading(poiLight, poiFragData, poiMesh, poiCam);
				}
				else
				{
					poiLight.finalLighting = 1;
				}
				#else
				calculateShading(poiLight, poiFragData, poiMesh, poiCam);
				#endif
				#else
				//endex
				poiLight.finalLighting = 1;
				poiLight.rampedLightMap = poiEdgeNonLinear(poiLight.nDotL, 0.1, .1);
				//ifex _ShadingEnabled==0
				#endif
				//endex
				
				//ifex _EnableAniso==0
				#ifdef POI_ANISOTROPICS
				//ifex _AnisoDebugToggle==0
				if(_AnisoDebugToggle)
				{
					return float4(applyAnisotropics(poiFragData, poiLight, poiCam, poiMesh, poiMods), 1) + POI_SAFE_RGB1;
				}
				//endex
				applyAnisotropics(poiFragData, poiLight, poiCam, poiMesh, poiMods);
				
				#endif
				//endex
				
				//ifex _MatcapEnable==0 && _Matcap2Enable==0 && _Matcap3Enable==0 && _Matcap4Enable==0
				#if defined(POI_MATCAP0) || defined(COLOR_GRADING_HDR_3D) || defined(POI_MATCAP2) || defined(POI_MATCAP3)
				applyMatcap(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _CubeMapEnabled==0
				#ifdef _CUBEMAP
				applyCubemap(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _EnableALDecal==0
				#ifdef POI_AUDIOLINK
				#ifdef POI_AL_DECAL
				ApplyAudioLinkDecal(poiMesh, poiFragData, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableVolumeColor==0
				#ifdef POI_AUDIOLINK
				#ifdef POI_AL_VOLUMECOLOR
				ApplyAudioLinkVolumeColor(poiMesh, poiFragData, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableFlipbook==0
				#ifdef _SUNDISK_HIGH_QUALITY
				applyFlipbook(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableRimLighting==0
				#ifdef _GLOSSYREFLECTIONS_OFF
				#ifdef _RIMSTYLE_POIYOMI
				#if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
				float4 rimMaskAndBias = POI2D_SAMPLER_PAN(_RimMask, _MainTex, poiUV(poiMesh.uv[_RimMaskUV], _RimMask_ST), _RimMaskPan);
				float rimMask = rimMaskAndBias[_RimMaskChannel];
				float rimBias = rimMaskAndBias.a;
				#else
				float rimMask = 1;
				float rimBias = 0;
				#endif
				
				if(_RimMaskInvert)
				{
					rimMask = 1 - rimMask;
				}
				
				#if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rimColor = POI2D_SAMPLER_PAN(_RimTex, _MainTex, poiUV(poiMesh.uv[_RimTexUV], _RimTex_ST), _RimTexPan);
				#else
				float4 rimColor = 1;
				#endif
				half AudioLinkRimWidthBand = 0;
				float2 AudioLinkRimWidthAdd = 0;
				half AudioLinkRimEmissionBand = 0;
				float2 AudioLinkRimEmissionAdd = 0;
				half AudioLinkRimBrightnessBand = 0;
				float2 AudioLinkRimBrightnessAdd = 0;
				#ifdef POI_AUDIOLINK
				AudioLinkRimWidthBand = _AudioLinkRimWidthBand;
				AudioLinkRimWidthAdd = _AudioLinkRimWidthAdd;
				AudioLinkRimEmissionBand = _AudioLinkRimEmissionBand;
				AudioLinkRimEmissionAdd = _AudioLinkRimEmissionAdd;
				AudioLinkRimBrightnessBand = _AudioLinkRimBrightnessBand;
				AudioLinkRimBrightnessAdd = _AudioLinkRimBrightnessAdd;
				#endif
				ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Is_NormalMapToRimLight, _RimLightingInvert, _RimPower, _RimStrength, _RimShadowWidth, _RimShadowToggle, _RimWidth, _RimBlendStrength, rimMask, _RimGlobalMask, _RimGlobalMaskBlendType, rimColor, _RimLightColor, _RimLightColorThemeIndex, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimSharpness, _RimShadowMaskRampType, _RimShadowMaskInvert, _RimShadowMaskStrength, _RimShadowAlpha, _RimApplyGlobalMaskIndex, _RimApplyGlobalMaskBlendType, _RimBaseColorMix, _RimBrightness, _RimBlendMode, AudioLinkRimWidthBand, AudioLinkRimWidthAdd, AudioLinkRimEmissionBand, AudioLinkRimEmissionAdd, AudioLinkRimBrightnessBand, AudioLinkRimBrightnessAdd, _RimClamp, rimBias, _RimBiasIntensity);
				#endif
				#ifdef _RIMSTYLE_UTS2
				#if defined(PROP_SET_RIMLIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float Set_RimLightMask_var = POI2D_SAMPLER_PAN(_Set_RimLightMask, _MainTex, poiUV(poiMesh.uv[_Set_RimLightMaskUV], _Set_RimLightMask_ST), _Set_RimLightMaskPan)[_Set_RimLightMaskChannel];
				#else
				float Set_RimLightMask_var = 1;
				#endif
				ApplyUTS2RimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, Set_RimLightMask_var, _RimGlobalMask, _RimGlobalMaskBlendType, _RimLightColor, _RimLightColorThemeIndex, _Is_LightColor_RimLight, _Is_NormalMapToRimLight, _RimLight_Power, _RimLight_InsideMask, _RimLight_FeatherOff, _LightDirection_MaskOn, _Tweak_LightDirection_MaskLevel, _Add_Antipodean_RimLight, _Ap_RimLightColor, _RimApColorThemeIndex, _Is_LightColor_Ap_RimLight, _Ap_RimLight_Power, _Ap_RimLight_FeatherOff, _Tweak_RimLightMaskLevel, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimClamp);
				#endif
				#ifdef _RIMSTYLE_LILTOON
				#if defined(PROP_RIMCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rimColorTex = POI2D_SAMPLER_PAN(_RimColorTex, _MainTex, poiUV(poiMesh.uv[_RimColorTexUV], _RimColorTex_ST), _RimColorTexPan);
				#else
				float4 rimColorTex = 1;
				#endif
				ApplyLiltoonRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _RimColor, _RimIndirColor, rimColorTex, _RimMainStrength, _RimNormalStrength, _RimDirRange, _RimIndirRange, _RimFresnelPower, _RimBackfaceMask, _RimDirStrength, _RimBorder, _RimBlur, _RimIndirBorder, _RimIndirBlur, _RimShadowMask, _RimEnableLighting, _RimVRParallaxStrength, _RimGlobalMask, _RimGlobalMaskBlendType, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimClamp);
				#endif
				#endif
				//endex
				//ifex _EnableRim2Lighting==0
				#ifdef POI_RIM2
				#ifdef _RIM2STYLE_POIYOMI
				#if defined(PROP_RIM2MASK) || !defined(OPTIMIZER_ENABLED)
				float4 rim2MaskAndBias = POI2D_SAMPLER_PAN(_Rim2Mask, _MainTex, poiUV(poiMesh.uv[_Rim2MaskUV], _Rim2Mask_ST), _Rim2MaskPan);
				float rim2Mask = rim2MaskAndBias[_Rim2MaskChannel];
				float rim2Bias = rim2MaskAndBias.a;
				#else
				float rim2Mask = 1;
				float rim2Bias = 0;
				#endif
				
				if(_Rim2MaskInvert)
				{
					rim2Mask = 1 - rim2Mask;
				}
				
				#if defined(PROP_RIM2TEX) || !defined(OPTIMIZER_ENABLED)
				float4 rim2Color = POI2D_SAMPLER_PAN(_Rim2Tex, _MainTex, poiUV(poiMesh.uv[_Rim2TexUV], _Rim2Tex_ST), _Rim2TexPan);
				#else
				float4 rim2Color = 1;
				#endif
				half AudioLinkRim2WidthBand = 0;
				float2 AudioLinkRim2WidthAdd = 0;
				half AudioLinkRim2EmissionBand = 0;
				float2 AudioLinkRim2EmissionAdd = 0;
				half AudioLinkRim2BrightnessBand = 0;
				float2 AudioLinkRim2BrightnessAdd = 0;
				#ifdef POI_AUDIOLINK
				AudioLinkRim2WidthBand = _AudioLinkRim2WidthBand;
				AudioLinkRim2WidthAdd = _AudioLinkRim2WidthAdd;
				AudioLinkRim2EmissionBand = _AudioLinkRim2EmissionBand;
				AudioLinkRim2EmissionAdd = _AudioLinkRim2EmissionAdd;
				AudioLinkRim2BrightnessBand = _AudioLinkRim2BrightnessBand;
				AudioLinkRim2BrightnessAdd = _AudioLinkRim2BrightnessAdd;
				#endif
				ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Is_NormalMapToRim2Light, _Rim2LightingInvert, _Rim2Power, _Rim2Strength, _Rim2ShadowWidth, _Rim2ShadowToggle, _Rim2Width, _Rim2BlendStrength, rim2Mask, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, rim2Color, _Rim2LightColor, _Rim2LightColorThemeIndex, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Sharpness, _Rim2ShadowMaskRampType, _Rim2ShadowMaskInvert, _Rim2ShadowMaskStrength, _Rim2ShadowAlpha, _Rim2ApplyGlobalMaskIndex, _Rim2ApplyGlobalMaskBlendType, _Rim2BaseColorMix, _Rim2Brightness, _Rim2BlendMode, AudioLinkRim2WidthBand, AudioLinkRim2WidthAdd, AudioLinkRim2EmissionBand, AudioLinkRim2EmissionAdd, AudioLinkRim2BrightnessBand, AudioLinkRim2BrightnessAdd, _Rim2Clamp, rim2Bias, _Rim2BiasIntensity);
				#endif
				#ifdef _RIM2STYLE_UTS2
				#if defined(PROP_SET_RIM2LIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float Set_Rim2LightMask_var = POI2D_SAMPLER_PAN(_Set_Rim2LightMask, _MainTex, poiUV(poiMesh.uv[_Set_Rim2LightMaskUV], _Set_Rim2LightMask_ST), _Set_Rim2LightMaskPan)[_Set_Rim2LightMaskChannel];
				#else
				float Set_Rim2LightMask_var = 1;
				#endif
				ApplyUTS2RimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, Set_Rim2LightMask_var, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, _Rim2LightColor, _Rim2LightColorThemeIndex, _Is_LightColor_Rim2Light, _Is_NormalMapToRim2Light, _Rim2Light_Power, _Rim2Light_InsideMask, _Rim2Light_FeatherOff, _LightDirection_MaskOn2, _Tweak_LightDirection_MaskLevel2, _Add_Antipodean_Rim2Light, _Ap_Rim2LightColor, _Rim2ApColorThemeIndex, _Is_LightColor_Ap_Rim2Light, _Ap_Rim2Light_Power, _Ap_Rim2Light_FeatherOff, _Tweak_Rim2LightMaskLevel, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Clamp);
				#endif
				#ifdef _RIM2STYLE_LILTOON
				#if defined(PROP_RIM2COLORTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rim2ColorTex = POI2D_SAMPLER_PAN(_Rim2ColorTex, _MainTex, poiUV(poiMesh.uv[_Rim2ColorTexUV], _Rim2ColorTex_ST), _Rim2ColorTexPan);
				#else
				float4 rim2ColorTex = 1;
				#endif
				ApplyLiltoonRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Rim2Color, _Rim2IndirColor, rim2ColorTex, _Rim2MainStrength, _Rim2NormalStrength, _Rim2DirRange, _Rim2IndirRange, _Rim2FresnelPower, _Rim2BackfaceMask, _Rim2DirStrength, _Rim2Border, _Rim2Blur, _Rim2IndirBorder, _Rim2IndirBlur, _Rim2ShadowMask, _Rim2EnableLighting, _Rim2VRParallaxStrength, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Clamp);
				#endif
				#endif
				//endex
				
				//ifex _EnableDepthRimLighting==0
				#ifdef _POI_DEPTH_RIMLIGHT
				if (!IsInMirror())
				{
					ApplyDepthRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods);
				}
				#endif
				//endex
				
				//ifex _GlitterEnable==0
				#ifdef _SUNDISK_SIMPLE
				applyGlitter(poiFragData, poiMesh, poiCam, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _StylizedSpecular==0
				#ifdef POI_STYLIZED_StylizedSpecular
				stylizedSpecular(poiFragData, poiCam, poiLight, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnablePathing==0
				#ifdef POI_PATHING
				// Only run pathing if a map exists.
				#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
				applyPathing(poiFragData, poiMesh, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				applyMirror(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableIridescence==0
				#ifdef POI_IRIDESCENCE
				applyIridescence(poiFragData, poiMesh, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _TextEnabled==0
				#ifdef EFFECT_BUMP
				ApplyTextOverlayColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				if (_AlphaPremultiply)
				{
					poiFragData.baseColor *= saturate(poiFragData.alpha);
				}
				poiFragData.finalColor = poiFragData.baseColor;
				
				poiFragData.finalColor = poiFragData.baseColor * poiLight.finalLighting;
				
				//ifex _SubsurfaceScattering==0
				#ifdef POI_SUBSURFACESCATTERING
				applySubsurfaceScattering(poiCam, poiLight, poiMesh);
				#endif
				//endex
				
				//ifex _MochieBRDF==0
				#ifdef MOCHIE_PBR
				MochieBRDF(poiFragData, poiCam, poiLight, poiMesh, poiMods);
				#endif
				//endex
				//ifex _ClearCoatBRDF==0
				#ifdef POI_CLEARCOAT
				poiClearCoat(poiFragData, poiCam, poiLight, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableTouchGlow==0
				#ifdef GRAIN
				applyDepthFX(poiFragData, poiCam, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _BacklightEnabled!=1
				#ifdef POI_BACKLIGHT
				ApplyBacklight(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _FXProximityColor==0
				if (_FXProximityColor)
				{
					float3 position = _FXProximityColorType ? poiMesh.worldPos : poiMesh.objectPosition;
					poiFragData.finalColor *= lerp(poiThemeColor(poiMods, _FXProximityColorMinColor.rgb, _FXProximityColorMinColorThemeIndex), poiThemeColor(poiMods, _FXProximityColorMaxColor.rgb, _FXProximityColorMaxColorThemeIndex), smoothstep(_FXProximityColorMinDistance, _FXProximityColorMaxDistance, distance(position, poiCam.worldPos)));
					
					if (_FXProximityColorBackFace)
					{
						poiFragData.finalColor = lerp(poiFragData.finalColor * _FXProximityColorMinColor.rgb, poiFragData.finalColor, saturate(poiMesh.isFrontFace));
					}
				}
				//endex
				
				//UNITY_BRANCH
				if (_IgnoreFog == 0)
				{
					UNITY_APPLY_FOG(i.fogCoord, poiFragData.finalColor);
				}
				
				poiFragData.alpha = _AlphaForceOpaque ? 1 : poiFragData.alpha;
				
				//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
				ApplyAlphaToCoverage(poiFragData, poiMesh);
				//endex
				
				//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
				applyDithering(poiFragData, poiCam);
				//endex
				
				poiFragData.finalColor += poiLight.finalLightAdd;
				
				if (_Mode == POI_MODE_OPAQUE)
				{
					poiFragData.alpha = 1;
				}
				
				clip(poiFragData.alpha - _Cutoff);
				
				if (_Mode == POI_MODE_CUTOUT && !_AlphaToCoverage)
				{
					poiFragData.alpha = 1;
				}
				
				if (_AddBlendOp == 4)
				{
					poiFragData.alpha = saturate(poiFragData.alpha * _AlphaBoostFA);
				}
				
				if (_Mode != POI_MODE_TRANSPARENT)
				{
					poiFragData.finalColor *= poiFragData.alpha;
				}
				return float4(poiFragData.finalColor, poiFragData.alpha) + POI_SAFE_RGB0;
			}
			
			ENDCG
		}
		
		Pass
		{
			Tags { "LightMode" = "ShadowCaster" }
			
			Stencil
			{
				Ref [_StencilRef]
				ReadMask [_StencilReadMask]
				WriteMask [_StencilWriteMask]
				//ifex _StencilType==1
				Comp [_StencilCompareFunction]
				Pass [_StencilPassOp]
				Fail [_StencilFailOp]
				ZFail [_StencilZFailOp]
				//endex
				
				//ifex _StencilType==0
				CompBack [_StencilBackCompareFunction]
				PassBack [_StencilBackPassOp]
				FailBack [_StencilBackFailOp]
				ZFailBack [_StencilBackZFailOp]
				
				CompFront [_StencilFrontCompareFunction]
				PassFront [_StencilFrontPassOp]
				FailFront [_StencilFrontFailOp]
				ZFailFront [_StencilFrontZFailOp]
				//endex
			}
			
			ZWrite [_ZWrite]
			Cull [_Cull]
			AlphaToMask Off
			ZTest [_ZTest]
			ColorMask [_ColorMask]
			Offset [_OffsetFactor], [_OffsetUnits]
			
			BlendOp [_BlendOp], [_BlendOpAlpha]
			Blend [_SrcBlend] [_DstBlend], [_SrcBlendAlpha] [_DstBlendAlpha]
			
			CGPROGRAM
			/*
			// Disable warnings we aren't interested in
			#if defined(UNITY_COMPILER_HLSL)
			#pragma warning(disable : 3205) // conversion of larger type to smaller
			#pragma warning(disable : 3568) // unknown pragma ignored
			#pragma warning(disable : 3571) // "pow(f,e) will not work for negative f"; however in majority of our calls to pow we know f is not negative
			#pragma warning(disable : 3206) // implicit truncation of vector type
			#endif
			*/
			#pragma target 5.0
			
			#pragma shader_feature_local _STOCHASTICMODE_DELIOT_HEITZ _STOCHASTICMODE_HEXTILE _STOCHASTICMODE_NONE
			
			//ifex _MainColorAdjustToggle==0
			#pragma shader_feature COLOR_GRADING_HDR
			//endex
			
			//#pragma shader_feature KEYWORD
			
			//ifex _GlobalMaskTexturesEnable==0
			#pragma shader_feature_local POI_GLOBALMASK_TEXTURES
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#pragma shader_feature_local POI_UDIMDISCARD
			//endex
			
			//ifex _EnableDistortion==0
			#pragma shader_feature USER_LUT
			//endex
			
			//ifex _PoiParallax==0
			#pragma shader_feature_local POI_PARALLAX
			//endex
			
			//ifex _EnableAudioLink==0
			#pragma shader_feature_local POI_AUDIOLINK
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#pragma shader_feature_local POI_BLACKLIGHTMASKING
			//endex
			
			//ifex _DetailEnabled==0
			#pragma shader_feature FINALPASS
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#pragma shader_feature AUTO_EXPOSURE
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#pragma shader_feature_local POI_VERTEX_GLITCHING
			#pragma shader_feature_local POI_VERTEX_GLITCHING_TEXTURE
			//endex
			
			//ifex _EnableDepthBulge==0
			#pragma shader_feature_local POI_DEPTHBULGE
			//endex
			
			//ifex _BackFaceEnabled!=1
			#pragma shader_feature_local POI_BACKFACE
			//endex
			
			//ifex _RGBMaskEnabled==0
			#pragma shader_feature VIGNETTE
			#pragma shader_feature GEOM_TYPE_MESH
			//endex
			
			//ifex _DecalEnabled==0
			#pragma shader_feature GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#pragma shader_feature GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#pragma shader_feature GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#pragma shader_feature DEPTH_OF_FIELD_COC_VIEW
			//endex
			
			//ifex _EnableDissolve==0
			#pragma shader_feature DISTORT
			//endex
			
			//ifex _ShadingEnabled==0
			#pragma shader_feature_local VIGNETTE_MASKED
			#pragma shader_feature_local _LIGHTINGMODE_TEXTURERAMP _LIGHTINGMODE_MULTILAYER_MATH _LIGHTINGMODE_SHADEMAP _LIGHTINGMODE_REALISTIC _LIGHTINGMODE_WRAPPED _LIGHTINGMODE_SKIN _LIGHTINGMODE_FLAT _LIGHTINGMODE_CLOTH _LIGHTINGMODE_SDF
			//endex
			
			//ifex _EnableAniso==0
			#pragma shader_feature_local POI_ANISOTROPICS
			//endex
			
			//ifex _MatcapEnable==0
			#pragma shader_feature_local POI_MATCAP0
			#pragma shader_feature_local POI_MATCAP0_CUSTOM_NORMAL
			//endex
			//ifex _Matcap2Enable==0
			#pragma shader_feature COLOR_GRADING_HDR_3D
			#pragma shader_feature_local POI_MATCAP1_CUSTOM_NORMAL
			//endex
			//ifex _Matcap3Enable==0
			#pragma shader_feature_local POI_MATCAP2
			#pragma shader_feature_local POI_MATCAP2_CUSTOM_NORMAL
			//endex
			//ifex _Matcap4Enable==0
			#pragma shader_feature_local POI_MATCAP3
			#pragma shader_feature_local POI_MATCAP3_CUSTOM_NORMAL
			//endex
			
			//ifex _CubeMapEnabled==0
			#pragma shader_feature_local _CUBEMAP
			//endex
			
			//ifex _EnableALDecal==0
			#pragma shader_feature_local POI_AL_DECAL
			//endex
			
			//ifex _EnableVolumeColor==0
			#pragma shader_feature_local POI_AL_VOLUMECOLOR
			//endex
			
			//ifex _EnableFlipbook==0
			#pragma shader_feature _SUNDISK_HIGH_QUALITY
			//endex
			
			//ifex _EnableEmission==0
			#pragma shader_feature _EMISSION
			//endex
			//ifex _EnableEmission1==0
			#pragma shader_feature_local POI_EMISSION_1
			//endex
			//ifex _EnableEmission2==0
			#pragma shader_feature_local POI_EMISSION_2
			//endex
			//ifex _EnableEmission3==0
			#pragma shader_feature_local POI_EMISSION_3
			//endex
			
			//ifex _EnableRimLighting==0
			#pragma shader_feature_local _GLOSSYREFLECTIONS_OFF
			#pragma shader_feature_local _RIMSTYLE_POIYOMI _RIMSTYLE_UTS2 _RIMSTYLE_LILTOON
			//endex
			//ifex _EnableRim2Lighting==0
			#pragma shader_feature_local POI_RIM2
			#pragma shader_feature_local _RIM2STYLE_POIYOMI _RIM2STYLE_UTS2 _RIM2STYLE_LILTOON
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#pragma shader_feature_local _POI_DEPTH_RIMLIGHT
			//endex
			
			//ifex _GlitterEnable==0
			#pragma shader_feature _SUNDISK_SIMPLE
			//endex
			
			//ifex _SubsurfaceScattering==0
			#pragma shader_feature_local POI_SUBSURFACESCATTERING
			//endex
			
			//ifex _MochieBRDF==0
			#pragma shader_feature_local MOCHIE_PBR
			//endex
			//ifex _ClearCoatBRDF==0
			#pragma shader_feature_local POI_CLEARCOAT
			//endex
			
			//ifex _EnableEnvironmentalRim==0
			#pragma shader_feature_local POI_ENVIRORIM
			//endex
			
			//ifex _StylizedSpecular==0
			#pragma shader_feature_local POI_STYLIZED_StylizedSpecular
			//endex
			
			//ifex _EnablePathing==0
			#pragma shader_feature_local POI_PATHING
			//endex
			
			//ifex _EnableMirrorOptions==0
			#pragma shader_feature_local POI_MIRROR
			//endex
			
			//ifex _EnableTouchGlow==0
			#pragma shader_feature GRAIN
			//endex
			
			//ifex _EnableIridescence==0
			#pragma shader_feature_local POI_IRIDESCENCE
			//endex
			
			//ifex _TextEnabled==0
			#pragma shader_feature EFFECT_BUMP
			//endex
			
			//ifex _PostProcess==0
			#pragma shader_feature_local POSTPROCESS
			//endex
			
			//ifex _PoiInternalParallax==0
			#pragma shader_feature_local POI_INTERNALPARALLAX
			//endex
			
			//ifex _NormalCorrect==0
			#pragma shader_feature_local POI_NORMALCORRECT
			//endex
			
			//ifex _BacklightEnabled!=1
			#pragma shader_feature_local POI_BACKLIGHT
			//endex
			
			#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
			#pragma multi_compile_instancing
			#pragma multi_compile_shadowcaster
			#pragma multi_compile_fog
			#define POI_PASS_SHADOW
			
			// UNITY Includes
			#include "UnityCG.cginc"
			#include "UnityStandardUtils.cginc"
			#include "AutoLight.cginc"
			#include "UnityLightingCommon.cginc"
			#include "UnityPBSLighting.cginc"
			#ifdef POI_PASS_META
			#include "UnityMetaPass.cginc"
			#endif
			#pragma vertex vert
			
			#pragma fragment frag
			
			#define DielectricSpec float4(0.04, 0.04, 0.04, 1.0 - 0.04)
			#define PI float(3.14159265359)
			
			#define POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex,samplertex,coord,dx,dy) tex.SampleGrad (sampler##samplertex,coord,dx,dy)
			
			#define POI_PAN_UV(uv, pan) (uv + _Time.x * pan)
			#define POI2D_SAMPLER_PAN(tex, texSampler, uv, pan) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, POI_PAN_UV(uv, pan)))
			#define POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, POI_PAN_UV(uv, pan), dx, dy))
			#define POI2D_SAMPLER(tex, texSampler, uv) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_GRAD(tex, texSampler, uv, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, uv, dx, dy))
			#define POI2D_PAN(tex, uv, pan) (tex2D(tex, POI_PAN_UV(uv, pan)))
			#define POI2D(tex, uv) (tex2D(tex, uv))
			#define POI_SAMPLE_TEX2D(tex, uv) (UNITY_SAMPLE_TEX2D(tex, uv))
			#define POI_SAMPLE_TEX2D_PAN(tex, uv, pan) (UNITY_SAMPLE_TEX2D(tex, POI_PAN_UV(uv, pan)))
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_MAINTEX_SAMPLER_PAN_INLINED(tex, poiMesh) (POI2D_SAMPLER_PAN(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan))
			
			#define POI_SAFE_RGB0 float4(mainTexture.rgb * .0001, 0)
			#define POI_SAFE_RGB1 float4(mainTexture.rgb * .0001, 1)
			#define POI_SAFE_RGBA mainTexture
			
			#if defined(UNITY_COMPILER_HLSL)
			#define PoiInitStruct(type, name) name = (type)0;
			#else
			#define PoiInitStruct(type, name)
			#endif
			
			#define POI_ERROR(poiMesh, gridSize) lerp(float3(1, 0, 1), float3(0, 0, 0), fmod(floor((poiMesh.worldPos.x) * gridSize) + floor((poiMesh.worldPos.y) * gridSize) + floor((poiMesh.worldPos.z) * gridSize), 2) == 0)
			#define POI_NAN (asfloat(-1))
			
			#define POI_MODE_OPAQUE 0
			#define POI_MODE_CUTOUT 1
			#define POI_MODE_FADE 2
			#define POI_MODE_TRANSPARENT 3
			#define POI_MODE_ADDITIVE 4
			#define POI_MODE_SOFTADDITIVE 5
			#define POI_MODE_MULTIPLICATIVE 6
			#define POI_MODE_2XMULTIPLICATIVE 7
			#define POI_MODE_TRANSCLIPPING 9
			
			/*
			Texture2D ;
			float4 _ST;
			float2 Pan;
			float UV;
			float Stochastic;
			
			[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7 )]
			*/
			
			#define POI_DECLARETEX_ST_UV(tex) float4 tex##_ST; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN_STOCHASTIC(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV; float tex##Stochastic;
			//ifex _EnableAudioLink==0
			// Map of where features in AudioLink are.
			#define ALPASS_DFT                      uint2(0,4)   //Size: 128, 2
			#define ALPASS_WAVEFORM                 uint2(0,6)   //Size: 128, 16
			#define ALPASS_AUDIOLINK                uint2(0,0)   //Size: 128, 4
			#define ALPASS_AUDIOBASS                uint2(0,0)   //Size: 128, 1
			#define ALPASS_AUDIOLOWMIDS             uint2(0,1)   //Size: 128, 1
			#define ALPASS_AUDIOHIGHMIDS            uint2(0,2)   //Size: 128, 1
			#define ALPASS_AUDIOTREBLE              uint2(0,3)   //Size: 128, 1
			#define ALPASS_AUDIOLINKHISTORY         uint2(1,0)   //Size: 127, 4
			#define ALPASS_GENERALVU                uint2(0,22)  //Size: 12, 1
			#define ALPASS_CCINTERNAL               uint2(12,22) //Size: 12, 2
			#define ALPASS_CCCOLORS                 uint2(25,22) //Size: 11, 1
			#define ALPASS_CCSTRIP                  uint2(0,24)  //Size: 128, 1
			#define ALPASS_CCLIGHTS                 uint2(0,25)  //Size: 128, 2
			#define ALPASS_AUTOCORRELATOR           uint2(0,27)  //Size: 128, 1
			#define ALPASS_GENERALVU_INSTANCE_TIME  uint2(2,22)
			#define ALPASS_GENERALVU_LOCAL_TIME     uint2(3,22)
			#define ALPASS_GENERALVU_NETWORK_TIME   uint2(4,22)
			#define ALPASS_GENERALVU_PLAYERINFO     uint2(6,22)
			// Added in version 2.5
			#define ALPASS_FILTEREDAUDIOLINK        uint2(0,28)  //Size: 16, 4
			// Added in version 2.6
			#define ALPASS_CHRONOTENSITY            uint2(16,28) //Size: 8, 4
			#define ALPASS_THEME_COLOR0             uint2(0,23)
			#define ALPASS_THEME_COLOR1             uint2(1,23)
			#define ALPASS_THEME_COLOR2             uint2(2,23)
			#define ALPASS_THEME_COLOR3             uint2(3,23)
			#define ALPASS_FILTEREDVU               uint2(24,28) //Size: 4, 4
			#define ALPASS_FILTEREDVU_INTENSITY     uint2(24,28) //Size: 4, 1
			#define ALPASS_FILTEREDVU_MARKER        uint2(24,29) //Size: 4, 1
			
			// Some basic constants to use (Note, these should be compatible with
			// future version of AudioLink, but may change.
			#define AUDIOLINK_SAMPHIST              3069        // Internal use for algos, do not change.
			#define AUDIOLINK_SAMPLEDATA24          2046
			#define AUDIOLINK_EXPBINS               24
			#define AUDIOLINK_EXPOCT                10
			#define AUDIOLINK_ETOTALBINS (AUDIOLINK_EXPBINS * AUDIOLINK_EXPOCT)
			#define AUDIOLINK_WIDTH                 128
			#define AUDIOLINK_SPS                   48000       // Samples per second
			#define AUDIOLINK_ROOTNOTE              0
			#define AUDIOLINK_4BAND_FREQFLOOR       0.123
			#define AUDIOLINK_4BAND_FREQCEILING     1
			#define AUDIOLINK_BOTTOM_FREQUENCY      13.75
			#define AUDIOLINK_BASE_AMPLITUDE        2.5
			#define AUDIOLINK_DELAY_COEFFICIENT_MIN 0.3
			#define AUDIOLINK_DELAY_COEFFICIENT_MAX 0.9
			#define AUDIOLINK_DFT_Q                 4.0
			#define AUDIOLINK_TREBLE_CORRECTION     5.0
			
			// ColorChord constants
			#define COLORCHORD_EMAXBIN              192
			#define COLORCHORD_IIR_DECAY_1          0.90
			#define COLORCHORD_IIR_DECAY_2          0.85
			#define COLORCHORD_CONSTANT_DECAY_1     0.01
			#define COLORCHORD_CONSTANT_DECAY_2     0.0
			#define COLORCHORD_NOTE_CLOSEST         3.0
			#define COLORCHORD_NEW_NOTE_GAIN        8.0
			#define COLORCHORD_MAX_NOTES            10
			
			uniform float4               _AudioTexture_TexelSize;
			
			#ifdef SHADER_TARGET_SURFACE_ANALYSIS
			#define AUDIOLINK_STANDARD_INDEXING
			#endif
			
			// Mechanism to index into texture.
			#ifdef AUDIOLINK_STANDARD_INDEXING
			sampler2D _AudioTexture;
			#define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, float4(uint2(xycoord) * _AudioTexture_TexelSize.xy, 0, 0))
			#else
			uniform Texture2D<float4> _AudioTexture;
			SamplerState sampler_AudioTexture;
			#define AudioLinkData(xycoord) _AudioTexture[uint2(xycoord)]
			#endif
			uniform sampler2D _Stored;
			uniform float4 _Stored_TexelSize;
			#define LumaData(x,y) tex2Dlod(_Stored, float4(x, y, 0, 0))
			//endex
			
			float _Mode;
			
			float _StochasticDeliotHeitzDensity;
			float _StochasticHexGridDensity;
			float _StochasticHexRotationStrength;
			float _StochasticHexFallOffContrast;
			float _StochasticHexFallOffPower;
			
			float _IgnoreFog;
			float _RenderingReduceClipDistance;
			float _AddBlendOp;
			
			float4 _Color;
			float _ColorThemeIndex;
			UNITY_DECLARE_TEX2D(_MainTex);
			UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);
			float _MainPixelMode;
			float4 _MainTex_ST;
			float2 _MainTexPan;
			float _MainTexUV;
			float4 _MainTex_TexelSize;
			float _MainTexStochastic;
			#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BumpMap;
			#endif
			float4 _BumpMap_ST;
			float2 _BumpMapPan;
			float _BumpMapUV;
			float _BumpScale;
			float _BumpMapStochastic;
			Texture2D _ClippingMask;
			float4 _ClippingMask_ST;
			float2 _ClippingMaskPan;
			float _ClippingMaskUV;
			float _Inverse_Clipping;
			float _Cutoff;
			//ifex _MainColorAdjustToggle==0
			float _MainColorAdjustToggle;
			#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MainColorAdjustTexture;
			#endif
			float4 _MainColorAdjustTexture_ST;
			float2 _MainColorAdjustTexturePan;
			float _MainColorAdjustTextureUV;
			float _MainHueShiftToggle;
			float _MainHueShiftReplace;
			float _MainHueShift;
			float _MainHueShiftSpeed;
			float _Saturation;
			float _MainBrightness;
			
			float _MainHueALCTEnabled;
			float _MainALHueShiftBand;
			float _MainALHueShiftCTIndex;
			float _MainHueALMotionSpeed;
			
			float _MainHueGlobalMask;
			float _MainHueGlobalMaskBlendType;
			float _MainSaturationGlobalMask;
			float _MainSaturationGlobalMaskBlendType;
			float _MainBrightnessGlobalMask;
			float _MainBrightnessGlobalMaskBlendType;
			//endex
			
			SamplerState sampler_linear_clamp;
			SamplerState sampler_linear_repeat;
			
			float _AlphaForceOpaque;
			float _AlphaMod;
			float _AlphaPremultiply;
			float _AlphaBoostFA;
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			float _AlphaToCoverage;
			float _AlphaSharpenedA2C;
			float _AlphaMipScale;
			//endex
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			float _AlphaDithering;
			float _AlphaDitherGradient;
			float _AlphaDitherBias;
			//endex
			
			//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
			float _AlphaDistanceFade;
			float _AlphaDistanceFadeType;
			float _AlphaDistanceFadeMinAlpha;
			float _AlphaDistanceFadeMaxAlpha;
			float _AlphaDistanceFadeMin;
			float _AlphaDistanceFadeMax;
			float _AlphaDistanceFadeGlobalMask;
			float _AlphaDistanceFadeGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
			float _AlphaFresnel;
			float _AlphaFresnelAlpha;
			float _AlphaFresnelSharpness;
			float _AlphaFresnelWidth;
			float _AlphaFresnelInvert;
			float _AlphaFresnelGlobalMask;
			float _AlphaFresnelGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
			float _AlphaAngular;
			float _AngleType;
			float _AngleCompareTo;
			float3 _AngleForwardDirection;
			float _CameraAngleMin;
			float _CameraAngleMax;
			float _ModelAngleMin;
			float _ModelAngleMax;
			float _AngleMinAlpha;
			float _AlphaAngularGlobalMask;
			float _AlphaAngularGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
			float _AlphaAudioLinkEnabled;
			float2 _AlphaAudioLinkAddRange;
			float _AlphaAudioLinkAddBand;
			//endex
			
			float _AlphaGlobalMask;
			float _AlphaGlobalMaskBlendType;
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture0;
			#endif
			float4 _GlobalMaskTexture0_ST;
			float2 _GlobalMaskTexture0Pan;
			float _GlobalMaskTexture0UV;
			int _GlobalMaskTexture0Split;
			float4 _GlobalMaskTexture0SplitTilingOffset_G;
			float4 _GlobalMaskTexture0SplitPan_G;
			float4 _GlobalMaskTexture0SplitTilingOffset_B;
			float4 _GlobalMaskTexture0SplitPan_B;
			float4 _GlobalMaskTexture0SplitTilingOffset_A;
			float4 _GlobalMaskTexture0SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture1;
			#endif
			float4 _GlobalMaskTexture1_ST;
			float2 _GlobalMaskTexture1Pan;
			float _GlobalMaskTexture1UV;
			int _GlobalMaskTexture1Split;
			float4 _GlobalMaskTexture1SplitTilingOffset_G;
			float4 _GlobalMaskTexture1SplitPan_G;
			float4 _GlobalMaskTexture1SplitTilingOffset_B;
			float4 _GlobalMaskTexture1SplitPan_B;
			float4 _GlobalMaskTexture1SplitTilingOffset_A;
			float4 _GlobalMaskTexture1SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture2;
			#endif
			float4 _GlobalMaskTexture2_ST;
			float2 _GlobalMaskTexture2Pan;
			float _GlobalMaskTexture2UV;
			int _GlobalMaskTexture2Split;
			float4 _GlobalMaskTexture2SplitTilingOffset_G;
			float4 _GlobalMaskTexture2SplitPan_G;
			float4 _GlobalMaskTexture2SplitTilingOffset_B;
			float4 _GlobalMaskTexture2SplitPan_B;
			float4 _GlobalMaskTexture2SplitTilingOffset_A;
			float4 _GlobalMaskTexture2SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture3;
			#endif
			float4 _GlobalMaskTexture3_ST;
			float2 _GlobalMaskTexture3Pan;
			float _GlobalMaskTexture3UV;
			int _GlobalMaskTexture3Split;
			float4 _GlobalMaskTexture3SplitTilingOffset_G;
			float4 _GlobalMaskTexture3SplitPan_G;
			float4 _GlobalMaskTexture3SplitTilingOffset_B;
			float4 _GlobalMaskTexture3SplitPan_B;
			float4 _GlobalMaskTexture3SplitTilingOffset_A;
			float4 _GlobalMaskTexture3SplitPan_A;
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			float _GlobalMaskOptionsEnable;
			int _GlobalMaskOptionsType;
			
			//ifex _GlobalMaskOptionsType!=0
			float _GlobalMaskSlider_0;
			float _GlobalMaskSlider_1;
			float _GlobalMaskSlider_2;
			float _GlobalMaskSlider_3;
			float _GlobalMaskSlider_4;
			float _GlobalMaskSlider_5;
			float _GlobalMaskSlider_6;
			float _GlobalMaskSlider_7;
			float _GlobalMaskSlider_8;
			float _GlobalMaskSlider_9;
			float _GlobalMaskSlider_10;
			float _GlobalMaskSlider_11;
			float _GlobalMaskSlider_12;
			float _GlobalMaskSlider_13;
			float _GlobalMaskSlider_14;
			float _GlobalMaskSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=1
			float2 _GlobalMaskMinMaxSlider_0;
			float2 _GlobalMaskMinMaxSlider_1;
			float2 _GlobalMaskMinMaxSlider_2;
			float2 _GlobalMaskMinMaxSlider_3;
			float2 _GlobalMaskMinMaxSlider_4;
			float2 _GlobalMaskMinMaxSlider_5;
			float2 _GlobalMaskMinMaxSlider_6;
			float2 _GlobalMaskMinMaxSlider_7;
			float2 _GlobalMaskMinMaxSlider_8;
			float2 _GlobalMaskMinMaxSlider_9;
			float2 _GlobalMaskMinMaxSlider_10;
			float2 _GlobalMaskMinMaxSlider_11;
			float2 _GlobalMaskMinMaxSlider_12;
			float2 _GlobalMaskMinMaxSlider_13;
			float2 _GlobalMaskMinMaxSlider_14;
			float2 _GlobalMaskMinMaxSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=2
			int  _GlobalMaskToggleOn_0;
			int _GlobalMaskToggleOff_0;
			int  _GlobalMaskToggleOn_1;
			int _GlobalMaskToggleOff_1;
			int  _GlobalMaskToggleOn_2;
			int _GlobalMaskToggleOff_2;
			int  _GlobalMaskToggleOn_3;
			int _GlobalMaskToggleOff_3;
			int  _GlobalMaskToggleOn_4;
			int _GlobalMaskToggleOff_4;
			int  _GlobalMaskToggleOn_5;
			int _GlobalMaskToggleOff_5;
			int  _GlobalMaskToggleOn_6;
			int _GlobalMaskToggleOff_6;
			int  _GlobalMaskToggleOn_7;
			int _GlobalMaskToggleOff_7;
			int  _GlobalMaskToggleOn_8;
			int _GlobalMaskToggleOff_8;
			int  _GlobalMaskToggleOn_9;
			int _GlobalMaskToggleOff_9;
			int  _GlobalMaskToggleOn_10;
			int _GlobalMaskToggleOff_10;
			int  _GlobalMaskToggleOn_11;
			int _GlobalMaskToggleOff_11;
			int  _GlobalMaskToggleOn_12;
			int _GlobalMaskToggleOff_12;
			int  _GlobalMaskToggleOn_13;
			int _GlobalMaskToggleOff_13;
			int  _GlobalMaskToggleOn_14;
			int _GlobalMaskToggleOff_14;
			int  _GlobalMaskToggleOn_15;
			int _GlobalMaskToggleOff_15;
			//endex
			//endex
			//ifex _GlobalMaskModifiersBackfaceEnable==0
			float _GlobalMaskModifiersBackfaceEnable;
			float _GlobalMaskBackface_0;
			float _GlobalMaskBackface_1;
			float _GlobalMaskBackface_2;
			float _GlobalMaskBackface_3;
			float _GlobalMaskBackface_4;
			float _GlobalMaskBackface_5;
			float _GlobalMaskBackface_6;
			float _GlobalMaskBackface_7;
			float _GlobalMaskBackface_8;
			float _GlobalMaskBackface_9;
			float _GlobalMaskBackface_10;
			float _GlobalMaskBackface_11;
			float _GlobalMaskBackface_12;
			float _GlobalMaskBackface_13;
			float _GlobalMaskBackface_14;
			float _GlobalMaskBackface_15;
			//endex
			
			//ifex _GlobalMaskModifiersMirrorEnable==0
			float _GlobalMaskModifiersMirrorEnable;
			float _GlobalMaskMirrorVisibilityMode;
			float _GlobalMaskMirror_0;
			float _GlobalMaskMirror_1;
			float _GlobalMaskMirror_2;
			float _GlobalMaskMirror_3;
			float _GlobalMaskMirror_4;
			float _GlobalMaskMirror_5;
			float _GlobalMaskMirror_6;
			float _GlobalMaskMirror_7;
			float _GlobalMaskMirror_8;
			float _GlobalMaskMirror_9;
			float _GlobalMaskMirror_10;
			float _GlobalMaskMirror_11;
			float _GlobalMaskMirror_12;
			float _GlobalMaskMirror_13;
			float _GlobalMaskMirror_14;
			float _GlobalMaskMirror_15;
			//endex
			
			//ifex _GlobalMaskModifiersCameraEnable==0
			float _GlobalMaskModifiersCameraEnable;
			float _GlobalMaskCamera_0;
			float _GlobalMaskCamera_1;
			float _GlobalMaskCamera_2;
			float _GlobalMaskCamera_3;
			float _GlobalMaskCamera_4;
			float _GlobalMaskCamera_5;
			float _GlobalMaskCamera_6;
			float _GlobalMaskCamera_7;
			float _GlobalMaskCamera_8;
			float _GlobalMaskCamera_9;
			float _GlobalMaskCamera_10;
			float _GlobalMaskCamera_11;
			float _GlobalMaskCamera_12;
			float _GlobalMaskCamera_13;
			float _GlobalMaskCamera_14;
			float _GlobalMaskCamera_15;
			//endex
			
			//ifex _GlobalMaskModifiersDistanceEnable==0
			int _GlobalMaskModifiersDistanceEnable;
			
			//ifex _GlobalMaskDistanceEnable_0==0
			int _GlobalMaskDistanceEnable_0;
			int _GlobalMaskDistanceType_0;
			float _GlobalMaskDistanceMin_0;
			float _GlobalMaskDistanceMax_0;
			float _GlobalMaskDistanceMinAlpha_0;
			float _GlobalMaskDistanceMaxAlpha_0;
			int _GlobalMaskDistanceBlendType_0;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_1==0
			int _GlobalMaskDistanceEnable_1;
			int _GlobalMaskDistanceType_1;
			float _GlobalMaskDistanceMin_1;
			float _GlobalMaskDistanceMax_1;
			float _GlobalMaskDistanceMinAlpha_1;
			float _GlobalMaskDistanceMaxAlpha_1;
			int _GlobalMaskDistanceBlendType_1;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_2==0
			int _GlobalMaskDistanceEnable_2;
			int _GlobalMaskDistanceType_2;
			float _GlobalMaskDistanceMin_2;
			float _GlobalMaskDistanceMax_2;
			float _GlobalMaskDistanceMinAlpha_2;
			float _GlobalMaskDistanceMaxAlpha_2;
			int _GlobalMaskDistanceBlendType_2;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_3==0
			int _GlobalMaskDistanceEnable_3;
			int _GlobalMaskDistanceType_3;
			float _GlobalMaskDistanceMin_3;
			float _GlobalMaskDistanceMax_3;
			float _GlobalMaskDistanceMinAlpha_3;
			float _GlobalMaskDistanceMaxAlpha_3;
			int _GlobalMaskDistanceBlendType_3;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_4==0
			int _GlobalMaskDistanceEnable_4;
			int _GlobalMaskDistanceType_4;
			float _GlobalMaskDistanceMin_4;
			float _GlobalMaskDistanceMax_4;
			float _GlobalMaskDistanceMinAlpha_4;
			float _GlobalMaskDistanceMaxAlpha_4;
			int _GlobalMaskDistanceBlendType_4;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_5==0
			int _GlobalMaskDistanceEnable_5;
			int _GlobalMaskDistanceType_5;
			float _GlobalMaskDistanceMin_5;
			float _GlobalMaskDistanceMax_5;
			float _GlobalMaskDistanceMinAlpha_5;
			float _GlobalMaskDistanceMaxAlpha_5;
			int _GlobalMaskDistanceBlendType_5;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_6==0
			int _GlobalMaskDistanceEnable_6;
			int _GlobalMaskDistanceType_6;
			float _GlobalMaskDistanceMin_6;
			float _GlobalMaskDistanceMax_6;
			float _GlobalMaskDistanceMinAlpha_6;
			float _GlobalMaskDistanceMaxAlpha_6;
			int _GlobalMaskDistanceBlendType_6;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_7==0
			int _GlobalMaskDistanceEnable_7;
			int _GlobalMaskDistanceType_7;
			float _GlobalMaskDistanceMin_7;
			float _GlobalMaskDistanceMax_7;
			float _GlobalMaskDistanceMinAlpha_7;
			float _GlobalMaskDistanceMaxAlpha_7;
			int _GlobalMaskDistanceBlendType_7;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_8==0
			int _GlobalMaskDistanceEnable_8;
			int _GlobalMaskDistanceType_8;
			float _GlobalMaskDistanceMin_8;
			float _GlobalMaskDistanceMax_8;
			float _GlobalMaskDistanceMinAlpha_8;
			float _GlobalMaskDistanceMaxAlpha_8;
			int _GlobalMaskDistanceBlendType_8;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_9==0
			int _GlobalMaskDistanceEnable_9;
			int _GlobalMaskDistanceType_9;
			float _GlobalMaskDistanceMin_9;
			float _GlobalMaskDistanceMax_9;
			float _GlobalMaskDistanceMinAlpha_9;
			float _GlobalMaskDistanceMaxAlpha_9;
			int _GlobalMaskDistanceBlendType_9;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_10==0
			int _GlobalMaskDistanceEnable_10;
			int _GlobalMaskDistanceType_10;
			float _GlobalMaskDistanceMin_10;
			float _GlobalMaskDistanceMax_10;
			float _GlobalMaskDistanceMinAlpha_10;
			float _GlobalMaskDistanceMaxAlpha_10;
			int _GlobalMaskDistanceBlendType_10;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_11==0
			int _GlobalMaskDistanceEnable_11;
			int _GlobalMaskDistanceType_11;
			float _GlobalMaskDistanceMin_11;
			float _GlobalMaskDistanceMax_11;
			float _GlobalMaskDistanceMinAlpha_11;
			float _GlobalMaskDistanceMaxAlpha_11;
			int _GlobalMaskDistanceBlendType_11;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_12==0
			int _GlobalMaskDistanceEnable_12;
			int _GlobalMaskDistanceType_12;
			float _GlobalMaskDistanceMin_12;
			float _GlobalMaskDistanceMax_12;
			float _GlobalMaskDistanceMinAlpha_12;
			float _GlobalMaskDistanceMaxAlpha_12;
			int _GlobalMaskDistanceBlendType_12;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_13==0
			int _GlobalMaskDistanceEnable_13;
			int _GlobalMaskDistanceType_13;
			float _GlobalMaskDistanceMin_13;
			float _GlobalMaskDistanceMax_13;
			float _GlobalMaskDistanceMinAlpha_13;
			float _GlobalMaskDistanceMaxAlpha_13;
			int _GlobalMaskDistanceBlendType_13;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_14==0
			int _GlobalMaskDistanceEnable_14;
			int _GlobalMaskDistanceType_14;
			float _GlobalMaskDistanceMin_14;
			float _GlobalMaskDistanceMax_14;
			float _GlobalMaskDistanceMinAlpha_14;
			float _GlobalMaskDistanceMaxAlpha_14;
			int _GlobalMaskDistanceBlendType_14;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_15==0
			int _GlobalMaskDistanceEnable_15;
			int _GlobalMaskDistanceType_15;
			float _GlobalMaskDistanceMin_15;
			float _GlobalMaskDistanceMax_15;
			float _GlobalMaskDistanceMinAlpha_15;
			float _GlobalMaskDistanceMaxAlpha_15;
			int _GlobalMaskDistanceBlendType_15;
			//endex
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			float _UDIMDiscardMode;
			float _UDIMDiscardUV;
			float _UDIMDiscardRow3_0;
			float _UDIMDiscardRow3_1;
			float _UDIMDiscardRow3_2;
			float _UDIMDiscardRow3_3;
			float _UDIMDiscardRow2_0;
			float _UDIMDiscardRow2_1;
			float _UDIMDiscardRow2_2;
			float _UDIMDiscardRow2_3;
			float _UDIMDiscardRow1_0;
			float _UDIMDiscardRow1_1;
			float _UDIMDiscardRow1_2;
			float _UDIMDiscardRow1_3;
			float _UDIMDiscardRow0_0;
			float _UDIMDiscardRow0_1;
			float _UDIMDiscardRow0_2;
			float _UDIMDiscardRow0_3;
			#endif
			//endex
			
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture;
			float4 _DistortionFlowTexture_ST;
			float2 _DistortionFlowTexturePan;
			float _DistortionFlowTextureUV;
			#endif
			
			#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture1;
			float4 _DistortionFlowTexture1_ST;
			float2 _DistortionFlowTexture1Pan;
			float _DistortionFlowTexture1UV;
			#endif
			
			#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionMask;
			float4 _DistortionMask_ST;
			float2 _DistortionMaskPan;
			float _DistortionMaskUV;
			float _DistortionMaskChannel;
			#endif
			
			float _DistortionUvToDistort;
			float _DistortionStrength;
			float _DistortionStrength1;
			
			#ifdef POI_AUDIOLINK
			half _EnableDistortionAudioLink;
			half2 _DistortionStrengthAudioLink;
			half _DistortionStrengthAudioLinkBand;
			half2 _DistortionStrength1AudioLink;
			half _DistortionStrength1AudioLinkBand;
			#endif
			#endif
			//endex
			float _StereoEnabled;
			float _PolarUV;
			float2 _PolarCenter;
			float _PolarRadialScale;
			float _PolarLengthScale;
			float _PolarSpiralPower;
			float _PanoUseBothEyes;
			
			float _UVModWorldPos0;
			float _UVModWorldPos1;
			float _UVModLocalPos0;
			float _UVModLocalPos1;
			
			//ifex _PoiParallax==0
			#ifdef POI_PARALLAX
			
			sampler2D _HeightMap;
			float4 _HeightMap_ST;
			float2 _HeightMapPan;
			float _HeightMapUV;
			
			#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Heightmask;
			float4 _Heightmask_ST;
			float2 _HeightmaskPan;
			float _HeightmaskUV;
			float _HeightmaskChannel;
			float _HeightmaskInvert;
			SamplerState _linear_repeat;
			#endif
			
			float _ParallaxUV;
			float _HeightStrength;
			float _HeightOffset;
			float _HeightStepsMin;
			float _HeightStepsMax;
			
			float _CurvatureU;
			float _CurvatureV;
			float _CurvFix;
			#endif
			//endex
			
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			float _AudioLinkDelay;
			float _AudioLinkAnimToggle;
			
			float _AudioLinkSmoothingBass;
			float _AudioLinkSmoothingLowMid;
			float _AudioLinkSmoothingHighMid;
			float _AudioLinkSmoothingTreble;
			
			float _DebugWaveform;
			float _DebugDFT;
			float _DebugBass;
			float _DebugLowMids;
			float _DebugHighMids;
			float _DebugTreble;
			float _DebugCCColors;
			float _DebugCCStrip;
			float _DebugCCLights;
			float _DebugAutocorrelator;
			float _DebugChronotensity;
			float _AudioLinkCCStripY;
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			float _BlackLightMasking0Key;
			float2 _BlackLightMasking0Range;
			float _BlackLightMasking0GlobalMaskIndex;
			float _BlackLightMasking0GlobalMaskBlendType;
			
			float _BlackLightMasking1Key;
			float2 _BlackLightMasking1Range;
			float _BlackLightMasking1GlobalMaskIndex;
			float _BlackLightMasking1GlobalMaskBlendType;
			
			float _BlackLightMasking2Key;
			float2 _BlackLightMasking2Range;
			float _BlackLightMasking2GlobalMaskIndex;
			float _BlackLightMasking2GlobalMaskBlendType;
			
			float _BlackLightMasking3Key;
			float2 _BlackLightMasking3Range;
			float _BlackLightMasking3GlobalMaskIndex;
			float _BlackLightMasking3GlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#ifdef AUTO_EXPOSURE
			float4 _VertexManipulationLocalTranslation;
			float4 _VertexManipulationLocalRotation;
			float3 _VertexManipulationLocalRotationSpeed;
			float4 _VertexManipulationLocalScale;
			float4 _VertexManipulationWorldTranslation;
			float _VertexManipulationHeight;
			sampler2D _VertexManipulationHeightMask;
			float4 _VertexManipulationHeightMask_ST;
			float2 _VertexManipulationHeightMaskPan;
			float _VertexManipulationHeightMaskUV;
			float _VertexManipulationHeightMaskChannel;
			float _VertexManipulationHeightBias;
			float _VertexRoundingEnabled;
			int _VertexRoundingSpace;
			float _VertexRoundingDivision;
			
			//AL
			float _VertexAudioLinkEnabled;
			float3 _VertexLocalTranslationALMin;
			float3 _VertexLocalTranslationALMax;
			float _VertexLocalTranslationALBand;
			
			float3 _VertexLocalRotationAL;
			float _VertexLocalRotationALBand;
			
			float3 _VertexLocalRotationCTALSpeed;
			float _VertexLocalRotationCTALBandX;
			float _VertexLocalRotationCTALBandY;
			float _VertexLocalRotationCTALBandZ;
			float _VertexLocalRotationCTALTypeX;
			float _VertexLocalRotationCTALTypeY;
			float _VertexLocalRotationCTALTypeZ;
			
			float4 _VertexLocalScaleALMin;
			float4 _VertexLocalScaleALMax;
			float _VertexLocalScaleALBand;
			
			float3 _VertexWorldTranslationALMin;
			float3 _VertexWorldTranslationALMax;
			float _VertexWorldTranslationALBand;
			
			float2 _VertexManipulationHeightAL;
			float _VertexManipulationHeightBand;
			
			float2 _VertexRoundingRangeAL;
			float _VertexRoundingRangeBand;
			
			float _VertexBarrelMode;
			float _VertexBarrelWidth;
			float _VertexBarrelAlpha;
			float _VertexBarrelHeight;
			
			float _VertexSphereMode;
			float _VertexSphereRadius;
			float _VertexSphereHeight;
			float _VertexSphereAlpha;
			float4 _VertexSphereCenter;
			
			float _VertexSpectrumMotion;
			float3 _VertexSpectrumOffsetMin;
			float3 _VertexSpectrumOffsetMax;
			float _VertexSpectrumUV;
			float _VertexSpectrumUVDirection;
			#endif
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#ifdef POI_VERTEX_GLITCHING
			//Vertex Glitching
			#if defined(POI_VERTEX_GLITCHING_TEXTURE)
			float _VertexGlitchingUseTexture;
			sampler2D _VertexGlitchMap;
			float4 _VertexGlitchMap_ST;
			#endif
			float _VertexGlitchThreshold;
			float _VertexGlitchFrequency;
			float _VertexGlitchStrength;
			float _VertexGlitchDensity;
			
			float _VertexGlitchMirrorEnable;
			float _VertexGlitchMirror;
			
			float _VertexGlitchMapPanSpeed;
			float _VertexGlitchingAudioLinkEnabled;
			float _VertexGlitchingAudioLinkBand;
			float _VertexGlitchingAudiolinkOverride;
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			float _MainVertexColoringEnabled;
			float _MainVertexColoringLinearSpace;
			float _MainVertexColoring;
			float _MainUseVertexColorAlpha;
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			float _BackFaceEnabled;
			float _BackFaceDetailIntensity;
			float _BackFaceEmissionStrength;
			float2 _BackFacePanning;
			float4 _BackFaceColor;
			float _BackFaceColorThemeIndex;
			float _BackFaceReplaceAlpha;
			
			#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceTexture;
			#endif
			float4 _BackFaceTexture_ST;
			float2 _BackFaceTexturePan;
			float _BackFaceTextureUV;
			
			#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceMask;
			#endif
			float4 _BackFaceMask_ST;
			float2 _BackFaceMaskPan;
			float _BackFaceMaskUV;
			float _BackFaceMaskChannel;
			
			float _BackFaceHueShiftEnabled;
			float _BackFaceHueShift;
			float _BackFaceHueShiftSpeed;
			float _BackFaceEmissionLimiter;
			#endif
			
			//TODO detail strength stuff
			//endex
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			float _DissolveType;
			float _DissolveEdgeWidth;
			float4 _DissolveEdgeColor;
			sampler2D _DissolveEdgeGradient;
			float4 _DissolveEdgeGradient_ST;
			float2 _DissolveEdgeGradientPan;
			float _DissolveEdgeGradientUV;
			float _DissolveEdgeEmission;
			float4 _DissolveTextureColor;
			float _DissolveEdgeColorThemeIndex;
			float _DissolveTextureColorThemeIndex;
			
			#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveToTexture;
			#endif
			float4 _DissolveToTexture_ST;
			float2 _DissolveToTexturePan;
			float _DissolveToTextureUV;
			
			#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveNoiseTexture;
			#endif
			float4 _DissolveNoiseTexture_ST;
			float2 _DissolveNoiseTexturePan;
			float _DissolveNoiseTextureUV;
			
			#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveDetailNoise;
			#endif
			float4 _DissolveDetailNoise_ST;
			float2 _DissolveDetailNoisePan;
			float _DissolveDetailNoiseUV;
			
			#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveMask;
			#endif
			float4 _DissolveMask_ST;
			float2 _DissolveMaskPan;
			float _DissolveMaskUV;
			
			float _DissolveMaskGlobalMask;
			float _DissolveMaskGlobalMaskBlendType;
			float _DissolveMaskInvert;
			float _DissolveAlpha;
			float _ContinuousDissolve;
			float _DissolveDetailStrength;
			float _DissolveDetailEdgeSmoothing;
			float _DissolveEdgeHardness;
			float _DissolveInvertNoise;
			float _DissolveInvertDetailNoise;
			float _DissolveToEmissionStrength;
			
			// Point to Point
			float _DissolveP2PWorldLocal;
			float _DissolveP2PEdgeLength;
			float _DissolveP2PClamp;
			float4 _DissolveStartPoint;
			float4 _DissolveEndPoint;
			
			// Spherical
			float3 _SphericalDissolveCenter;
			float _SphericalDissolveRadius;
			float _SphericalDissolveInvert;
			float _SphericalDissolveClamp;
			
			// CenterOut
			float _CenterOutDissolveMode;
			float3 _CenterOutDissolveDirection;
			float _CenterOutDissolveInvert;
			float _CenterOutDissolveNormals;
			float _CenterOutDissolvePower;
			
			// World Dissolve
			float _DissolveWorldShape;
			float4 _DissolveShapePosition;
			float4 _DissolveShapeRotation;
			float _DissolveShapeScale;
			float _DissolveInvertShape;
			float _DissolveShapeEdgeLength;
			
			// UV Tile Dissolve
			float _UVTileDissolveEnabled;
			float _UVTileDissolveDiscardAtMax;
			float _UVTileDissolveUV;
			
			float _UVTileDissolveAlpha_Row3_0;
			float _UVTileDissolveAlpha_Row3_1;
			float _UVTileDissolveAlpha_Row3_2;
			float _UVTileDissolveAlpha_Row3_3;
			float _UVTileDissolveAlpha_Row2_0;
			float _UVTileDissolveAlpha_Row2_1;
			float _UVTileDissolveAlpha_Row2_2;
			float _UVTileDissolveAlpha_Row2_3;
			float _UVTileDissolveAlpha_Row1_0;
			float _UVTileDissolveAlpha_Row1_1;
			float _UVTileDissolveAlpha_Row1_2;
			float _UVTileDissolveAlpha_Row1_3;
			float _UVTileDissolveAlpha_Row0_0;
			float _UVTileDissolveAlpha_Row0_1;
			float _UVTileDissolveAlpha_Row0_2;
			float _UVTileDissolveAlpha_Row0_3;
			
			float _DissolveAlpha0;
			float _DissolveAlpha1;
			float _DissolveAlpha2;
			float _DissolveAlpha3;
			float _DissolveAlpha4;
			float _DissolveAlpha5;
			float _DissolveAlpha6;
			float _DissolveAlpha7;
			float _DissolveAlpha8;
			float _DissolveAlpha9;
			// Masking
			float _DissolveEmissionSide;
			float _DissolveEmission1Side;
			float _DissolveUseVertexColors;
			
			float4 edgeColor;
			float edgeAlpha;
			float dissolveAlpha;
			float4 dissolveToTexture;
			
			float _DissolveHueShiftEnabled;
			float _DissolveHueShiftSpeed;
			float _DissolveHueShift;
			float _DissolveEdgeHueShiftEnabled;
			float _DissolveEdgeHueShiftSpeed;
			float _DissolveEdgeHueShift;
			
			// Audio Link
			#ifdef POI_AUDIOLINK
			fixed _EnableDissolveAudioLink;
			half _AudioLinkDissolveAlphaBand;
			float2 _AudioLinkDissolveAlpha;
			half _AudioLinkDissolveDetailBand;
			float2 _AudioLinkDissolveDetail;
			#endif
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			float _ALDecalUV;
			float4 _ALUVScale;
			float2 _ALUVPosition;
			float _ALUVRotation;
			float _ALUVRotationSpeed;
			float4 _ALDecaldCircleDimensions;
			
			float _ALDecalUVMode;
			
			float _ALDecalVolumeStep;
			float _ALDecalVolumeClipMin;
			float _ALDecalVolumeClipMax;
			
			float _ALDecalBandStep;
			float _ALDecalBandClipMin;
			float _ALDecalBandClipMax;
			
			float _ALDecalShapeClip;
			float _ALDecalShapeClipVolumeWidth;
			float _ALDecalShapeClipBandWidth;
			
			#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ALDecalColorMask;
			float4 _ALDecalColorMask_ST;
			float2 _ALDecalColorMaskPan;
			float _ALDecalColorMaskUV;
			#endif
			
			float _ALDecalVolume;
			float _ALDecalBaseBoost;
			float _ALDecalTrebleBoost;
			float _ALDecalLineWidth;
			float _ALDecalVolumeColorSource;
			float3 _ALDecalVolumeColorLow;
			float _ALDecalVolumeColorLowThemeIndex;
			float3 _ALDecalVolumeColorMid;
			float _ALDecalVolumeColorMidThemeIndex;
			float3 _ALDecalVolumeColorHigh;
			float _ALDecalVolumeColorHighThemeIndex;
			float _ALDecalLowEmission;
			float _ALDecalMidEmission;
			float _ALDecalHighEmission;
			float _ALDecalBlendType;
			float _ALDecalBlendAlpha;
			float _ALDecalControlsAlpha;
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			UNITY_DECLARE_TEX2DARRAY(_FlipbookTexArray);
			float4 _FlipbookTexArray_ST;
			
			float4 _FlipbookColor;
			float _FlipbookColorThemeIndex;
			float _FlipbookFPS;
			// float _FlipbookTotalFrames;
			float4 _FlipbookScaleOffset;
			float4 _FlipbookSideOffset;
			float _FlipbookTiled;
			float _FlipbookManualFrameControl;
			float _FlipbookCurrentFrame;
			float _FlipbookStartAndEnd;
			float _FlipbookStartFrame;
			float _FlipbookEndFrame;
			float _FlipbookEmissionStrength;
			float _FlipbookRotation;
			float _EnableFlipbook;
			float _FlipbookTexArrayUV;
			float _FlipbookAlphaControlsFinalAlpha;
			float _FlipbookRotationSpeed;
			float _FlipbookIntensityControlsAlpha;
			float _FlipbookColorReplaces;
			float2 _FlipbookTexArrayPan;
			float _FlipbookFrameOffset;
			// blending
			float _FlipbookReplace;
			float _FlipbookMultiply;
			float _FlipbookAdd;
			
			#if defined(PROP_FLIPBOOKMASSK) || !defined(OPTIMIZED_ENABLED)
			Texture2D _FlipbookMask;
			#endif
			float4 _FlipbookMask_ST;
			float2 _FlipbookMaskPan;
			float _FlipbookMaskUV;
			float _FlipbookMaskChannel;
			float _FlipbookMaskGlobalMask;
			float _FlipbookMaskGlobalMaskBlendType;
			
			// anim
			float _FlipbookMovementType;
			float4 _FlipbookStartEndOffset;
			float _FlipbookMovementSpeed;
			
			// Crossfade
			float _FlipbookCrossfadeEnabled;
			float2 _FlipbookCrossfadeRange;
			
			// Hueshift
			float _FlipbookHueShiftEnabled;
			float _FlipbookHueShiftSpeed;
			float _FlipbookHueShift;
			
			#ifdef POI_AUDIOLINK
			float _FlipbookChronotensityEnabled;
			float _FlipbookChronotensityBand;
			float _FlipbookChronotensitySpeed;
			float _FlipbookChronoType;
			half _AudioLinkFlipbookScaleBand;
			half4 _AudioLinkFlipbookScale;
			half _AudioLinkFlipbookAlphaBand;
			half2 _AudioLinkFlipbookAlpha;
			half _AudioLinkFlipbookEmissionBand;
			half2 _AudioLinkFlipbookEmission;
			half _AudioLinkFlipbookFrameBand;
			half2 _AudioLinkFlipbookFrame;
			#endif
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			float _VisibilityMode;
			float _Mirror;
			#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MirrorTexture;
			#endif
			float4 _MirrorColor;
			float _MirrorColorThemeIndex;
			float _MirrorTextureBlendType;
			float4 _MirrorTexture_ST;
			float2 _MirrorTexturePan;
			float _MirrorTextureUV;
			
			float _VisibilityVRCRegular;
			float _VisibilityVRCMirrorVR;
			float _VisibilityVRCMirrorDesktop;
			float _VisibilityVRCCameraVR;
			float _VisibilityVRCCameraDesktop;
			float _VisibilityVRCCameraScreenshot;
			#endif
			//endex
			
			//ifex _EnableTouchGlow==0
			#if defined(PROP_DEPTHMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DepthMask;
			#endif
			float4 _DepthMask_ST;
			float2 _DepthMaskPan;
			float _DepthMaskUV;
			float _DepthMaskChannel;
			float _DepthMaskGlobalMask;
			float _DepthMaskGlobalMaskBlendType;
			
			// Color
			float _DepthColorToggle;
			float _DepthColorBlendMode;
			#if defined(PROP_DEPTHTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DepthTexture;
			#endif
			float4 _DepthTexture_ST;
			float2 _DepthTexturePan;
			float _DepthTextureUV;
			
			float3 _DepthColor;
			float _DepthColorThemeIndex;
			float _DepthColorMinDepth;
			float _DepthColorMaxDepth;
			float _DepthColorMinValue;
			float _DepthColorMaxValue;
			float _DepthEmissionStrength;
			
			// Emission
			
			// Alpha
			float _DepthAlphaToggle;
			float _DepthAlphaMinValue;
			float _DepthAlphaMaxValue;
			float _DepthAlphaMinDepth;
			float _DepthAlphaMaxDepth;
			//endex
			
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			float _NormalCorrectAmount;
			float3 _NormalCorrectOrigin;
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float _VideoEffectsEnable;
			#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
			sampler2D _VideoPixelTexture;
			float4 _VideoPixelTexture_ST;
			float _VideoPixelTextureUV;
			#endif
			#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _VideoMaskTexture;
			float4 _VideoMaskTexture_ST;
			float2 _VideoMaskTexturePan;
			float _VideoMaskTextureUV;
			float _VideoMaskTextureChannel;
			#endif
			
			float _VideoType;
			float2 _VideoResolution;
			sampler2D _VideoGameboyRamp;
			float _VideoBacklight;
			float _VideoCRTRefreshRate;
			float _VideoCRTPixelEnergizedTime;
			float _VideoRepeatVideoTexture;
			float _VideoPixelateToResolution;
			float2 _VideoMaskPanning;
			
			float _VideoSaturation;
			float _VideoContrast;
			float _VideoEmissionEnabled;
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			float4 _BacklightColor;
			#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BacklightColorTex;
			float4 _BacklightColorTex_ST;
			float2 _BacklightColorTexPan;
			float _BacklightColorTexUV;
			#endif
			float _BacklightMainStrength;
			float _BacklightNormalStrength;
			float _BacklightBorder;
			float _BacklightBlur;
			float _BacklightDirectivity;
			float _BacklightViewStrength;
			int _BacklightReceiveShadow;
			int _BacklightBackfaceMask;
			#endif
			//endex
			
			struct appdata
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
				float4 color : COLOR;
				float2 uv0 : TEXCOORD0;
				float2 uv1 : TEXCOORD1;
				float2 uv2 : TEXCOORD2;
				float2 uv3 : TEXCOORD3;
				uint vertexId : SV_VertexID;
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};
			
			struct VertexOut
			{
				float4 pos : SV_POSITION;
				float2 uv[4] : TEXCOORD0;
				float3 objNormal : TEXCOORD4;
				float3 normal : TEXCOORD5;
				float3 tangent : TEXCOORD6;
				float3 binormal : TEXCOORD7;
				float4 worldPos : TEXCOORD8;
				float4 localPos : TEXCOORD9;
				float3 objectPos : TEXCOORD10;
				float4 vertexColor : TEXCOORD11;
				float4 lightmapUV : TEXCOORD12;
				float4 grabPos: TEXCOORD13;
				float4 worldDirection: TEXCOORD14;
				float4 extra: TEXCOORD15;
				UNITY_SHADOW_COORDS(16)
				UNITY_FOG_COORDS(17)
				
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};
			
			struct PoiMesh
			{
				
				// 0 Vertex normal
				// 1 Fragment normal
				float3 normals[2];
				float3 objNormal;
				float3 tangentSpaceNormal;
				float3 binormal[2];
				float3 tangent[2];
				float3 worldPos;
				float3 localPos;
				float3 objectPosition;
				float isFrontFace;
				float4 vertexColor;
				float4 lightmapUV;
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 7 Distorted UV
				float2 uv[9];
				float2 parallaxUV;
			};
			
			struct PoiCam
			{
				float3 viewDir;
				float3 forwardDir;
				float3 worldPos;
				float distanceToVert;
				float4 clipPos;
				float3 reflectionDir;
				float3 vertexReflectionDir;
				float3 tangentViewDir;
				float4 grabPos;
				float2 screenUV;
				float vDotN;
				float4 worldDirection;
				
			};
			
			struct PoiMods
			{
				float4 PBR; // smoothness, metallic, smoothness mask, metallic mask
				float4 Mask;
				float4 audioLink;
				float audioLinkAvailable;
				float audioLinkVersion;
				float4 audioLinkTexture;
				float audioLinkViaLuma;
				float2 detailMask;
				float2 backFaceDetailIntensity;
				float globalEmission;
				float4 globalColorTheme[12];
				float globalMask[16];
				float ALTime[8];
			};
			
			struct PoiLight
			{
				
				float3 direction;
				float attenuation;
				float attenuationStrength;
				float3 directColor;
				float3 indirectColor;
				float occlusion;
				float shadowMask;
				float detailShadow;
				float3 halfDir;
				float lightMap;
				float lightMapNoAttenuation;
				float3 rampedLightMap;
				float vertexNDotL;
				float nDotL;
				float nDotV;
				float vertexNDotV;
				float nDotH;
				float vertexNDotH;
				float lDotv;
				float lDotH;
				float nDotLSaturated;
				float nDotLNormalized;
				#ifdef POI_PASS_ADD
				float additiveShadow;
				#endif
				float3 finalLighting;
				float3 finalLightAdd;
				
				#if defined(VERTEXLIGHT_ON)
				// Non Important Lights
				float4 vDotNL;
				float4 vertexVDotNL;
				float3 vColor[4];
				float4 vCorrectedDotNL;
				float4 vAttenuation;
				float4 vAttenuationDotNL;
				float3 vPosition[4];
				float3 vDirection[4];
				float3 vFinalLighting;
				float3 vHalfDir[4];
				half4 vDotNH;
				half4 vertexVDotNH;
				half4 vDotLH;
				#endif
				
			};
			
			struct PoiVertexLights
			{
				
				float3 direction;
				float3 color;
				float attenuation;
			};
			
			struct PoiFragData
			{
				float3 baseColor;
				float3 finalColor;
				float alpha;
				float3 emission;
			};
			
			// glsl_mod behaves better on negative numbers, and
			// in some situations actually outperforms HLSL's fmod()
			#ifndef glsl_mod
			#define glsl_mod(x, y) (((x) - (y) * floor((x) / (y))))
			#endif
			
			uniform float random_uniform_float_only_used_to_stop_compiler_warnings = 0.0f;
			
			float2 poiUV(float2 uv, float4 tex_st)
			{
				return uv * tex_st.xy + tex_st.zw;
			}
			
			float2 vertexUV(in VertexOut o, int index)
			{
				switch(index)
				{
					case 0:
					return o.uv[0];
					case 1:
					return o.uv[1];
					case 2:
					return o.uv[2];
					case 3:
					return o.uv[3];
					default:
					return o.uv[0];
				}
			}
			
			float2 vertexUV(in appdata v, int index)
			{
				switch(index)
				{
					case 0:
					return v.uv0;
					case 1:
					return v.uv1;
					case 2:
					return v.uv2;
					case 3:
					return v.uv3;
					default:
					return v.uv0;
				}
			}
			
			//Lighting Helpers
			float calculateluminance(float3 color)
			{
				return color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
			}
			
			// Set by VRChat (as of open beta 1245)
			// _VRChatCameraMode: 0 => Normal, 1 => VR HandCam, 2 => Desktop Handcam, 3 => Screenshot/Photo
			// _VRChatMirrorMode: 0 => Normal, 1 => Mirror (VR), 2 => Mirror (Deskie)
			float _VRChatCameraMode;
			float _VRChatMirrorMode;
			
			float VRCCameraMode()
			{
				return _VRChatCameraMode;
			}
			
			float VRCMirrorMode()
			{
				return _VRChatMirrorMode;
			}
			
			bool IsInMirror()
			{
				return unity_CameraProjection[2][0] != 0.f || unity_CameraProjection[2][1] != 0.f;
			}
			
			bool IsOrthographicCamera()
			{
				return unity_OrthoParams.w == 1 || UNITY_MATRIX_P[3][3] == 1;
			}
			
			float shEvaluateDiffuseL1Geomerics_local(float L0, float3 L1, float3 n)
			{
				// average energy
				float R0 = max(0, L0);
				
				// avg direction of incoming light
				float3 R1 = 0.5f * L1;
				
				// directional brightness
				float lenR1 = length(R1);
				
				// linear angle between normal and direction 0-1
				//float q = 0.5f * (1.0f + dot(R1 / lenR1, n));
				//float q = dot(R1 / lenR1, n) * 0.5 + 0.5;
				float q = dot(normalize(R1), n) * 0.5 + 0.5;
				q = saturate(q); // Thanks to ScruffyRuffles for the bug identity.
				
				// power for q
				// lerps from 1 (linear) to 3 (cubic) based on directionality
				float p = 1.0f + 2.0f * lenR1 / R0;
				
				// dynamic range constant
				// should vary between 4 (highly directional) and 0 (ambient)
				float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);
				
				return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));
			}
			
			half3 BetterSH9(half4 normal)
			{
				float3 indirect;
				float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;
				indirect.r = shEvaluateDiffuseL1Geomerics_local(L0.r, unity_SHAr.xyz, normal.xyz);
				indirect.g = shEvaluateDiffuseL1Geomerics_local(L0.g, unity_SHAg.xyz, normal.xyz);
				indirect.b = shEvaluateDiffuseL1Geomerics_local(L0.b, unity_SHAb.xyz, normal.xyz);
				indirect = max(0, indirect);
				indirect += SHEvalLinearL2(normal);
				return indirect;
			}
			
			// Silent's code ends here
			
			float3 getCameraForward()
			{
				#if UNITY_SINGLE_PASS_STEREO
				float3 p1 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 1, 1));
				float3 p2 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 0, 1));
				#else
				float3 p1 = mul(unity_CameraToWorld, float4(0, 0, 1, 1)).xyz;
				float3 p2 = mul(unity_CameraToWorld, float4(0, 0, 0, 1)).xyz;
				#endif
				return normalize(p2 - p1);
			}
			
			half3 GetSHLength()
			{
				half3 x, x1;
				x.r = length(unity_SHAr);
				x.g = length(unity_SHAg);
				x.b = length(unity_SHAb);
				x1.r = length(unity_SHBr);
				x1.g = length(unity_SHBg);
				x1.b = length(unity_SHBb);
				return x + x1;
			}
			
			float3 BoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
			{
				#if UNITY_SPECCUBE_BOX_PROJECTION
				//UNITY_BRANCH
				if (cubemapPosition.w > 0)
				{
					float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
					float scalar = min(min(factors.x, factors.y), factors.z);
					direction = direction * scalar + (position - cubemapPosition.xyz);
				}
				#endif
				return direction;
			}
			
			float poiMax(float2 i)
			{
				return max(i.x, i.y);
			}
			
			float poiMax(float3 i)
			{
				return max(max(i.x, i.y), i.z);
			}
			
			float poiMax(float4 i)
			{
				return max(max(max(i.x, i.y), i.z), i.w);
			}
			
			float3 calculateNormal(in float3 baseNormal, in PoiMesh poiMesh, in Texture2D normalTexture, in float4 normal_ST, in float2 normalPan, in float normalUV, in float normalIntensity)
			{
				float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
				return normalize(
				normal.x * poiMesh.tangent[0] +
				normal.y * poiMesh.binormal[0] +
				normal.z * baseNormal
				);
			}
			
			float remap(float x, float minOld, float maxOld, float minNew = 0, float maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float2 remap(float2 x, float2 minOld, float2 maxOld, float2 minNew = 0, float2 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float3 remap(float3 x, float3 minOld, float3 maxOld, float3 minNew = 0, float3 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float4 remap(float4 x, float4 minOld, float4 maxOld, float4 minNew = 0, float4 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float remapClamped(float minOld, float maxOld, float x, float minNew = 0, float maxNew = 1)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float2 remapClamped(float2 minOld, float2 maxOld, float2 x, float2 minNew, float2 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float3 remapClamped(float3 minOld, float3 maxOld, float3 x, float3 minNew, float3 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float4 remapClamped(float4 minOld, float4 maxOld, float4 x, float4 minNew, float4 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			float2 calcParallax(in float height, in PoiCam poiCam)
			{
				return ((height * - 1) + 1) * (poiCam.tangentViewDir.xy / poiCam.tangentViewDir.z);
			}
			
			/*
			0: Zero	                float4(0.0, 0.0, 0.0, 0.0),
			1: One	                float4(1.0, 1.0, 1.0, 1.0),
			2: DstColor	            destinationColor,
			3: SrcColor	            sourceColor,
			4: OneMinusDstColor	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
			5: SrcAlpha	            sourceColor.aaaa,
			6: OneMinusSrcColor	    float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
			7: DstAlpha	            destinationColor.aaaa,
			8: OneMinusDstAlpha	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor.,
			9: SrcAlphaSaturate     saturate(sourceColor.aaaa),
			10: OneMinusSrcAlpha	float4(1.0, 1.0, 1.0, 1.0) - sourceColor.aaaa,
			*/
			
			float4 poiBlend(const float sourceFactor, const  float4 sourceColor, const  float destinationFactor, const  float4 destinationColor, const float4 blendFactor)
			{
				float4 sA = 1 - blendFactor;
				const float4 blendData[11] = {
					float4(0.0, 0.0, 0.0, 0.0),
					float4(1.0, 1.0, 1.0, 1.0),
					destinationColor,
					sourceColor,
					float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sA,
					saturate(sourceColor.aaaa),
					1 - sA,
				};
				
				return lerp(blendData[sourceFactor] * sourceColor + blendData[destinationFactor] * destinationColor, sourceColor, sA);
			}
			
			// Average
			float blendAverage(float base, float blend)
			{
				return (base + blend) / 2.0;
			}
			float3 blendAverage(float3 base, float3 blend)
			{
				return (base + blend) / 2.0;
			}
			
			// Color burn
			float blendColorBurn(float base, float blend)
			{
				return (blend == 0.0) ? blend : max((1.0 - ((1.0 - base) * rcp(random_uniform_float_only_used_to_stop_compiler_warnings + blend))), 0.0);
			}
			
			float3 blendColorBurn(float3 base, float3 blend)
			{
				return float3(blendColorBurn(base.r, blend.r), blendColorBurn(base.g, blend.g), blendColorBurn(base.b, blend.b));
			}
			
			// Color Dodge
			float blendColorDodge(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0);
			}
			
			float3 blendColorDodge(float3 base, float3 blend)
			{
				return float3(blendColorDodge(base.r, blend.r), blendColorDodge(base.g, blend.g), blendColorDodge(base.b, blend.b));
			}
			
			// Darken
			float blendDarken(float base, float blend)
			{
				return min(blend, base);
			}
			
			float3 blendDarken(float3 base, float3 blend)
			{
				return float3(blendDarken(base.r, blend.r), blendDarken(base.g, blend.g), blendDarken(base.b, blend.b));
			}
			
			// Exclusion
			float blendExclusion(float base, float blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			float3 blendExclusion(float3 base, float3 blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			
			// Reflect
			float blendReflect(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0);
			}
			
			float3 blendReflect(float3 base, float3 blend)
			{
				return float3(blendReflect(base.r, blend.r), blendReflect(base.g, blend.g), blendReflect(base.b, blend.b));
			}
			
			// Glow
			float blendGlow(float base, float blend)
			{
				return blendReflect(blend, base);
			}
			float3 blendGlow(float3 base, float3 blend)
			{
				return blendReflect(blend, base);
			}
			
			// Overlay
			float blendOverlay(float base, float blend)
			{
				return base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend));
			}
			
			float3 blendOverlay(float3 base, float3 blend)
			{
				return float3(blendOverlay(base.r, blend.r), blendOverlay(base.g, blend.g), blendOverlay(base.b, blend.b));
			}
			
			// Hard Light
			float blendHardLight(float base, float blend)
			{
				return blendOverlay(blend, base);
			}
			float3 blendHardLight(float3 base, float3 blend)
			{
				return blendOverlay(blend, base);
			}
			
			// Vivid light
			float blendVividLight(float base, float blend)
			{
				return (blend < 0.5) ? blendColorBurn(base, (2.0 * blend)) : blendColorDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendVividLight(float3 base, float3 blend)
			{
				return float3(blendVividLight(base.r, blend.r), blendVividLight(base.g, blend.g), blendVividLight(base.b, blend.b));
			}
			
			// Hard mix
			float blendHardMix(float base, float blend)
			{
				return (blendVividLight(base, blend) < 0.5) ? 0.0 : 1.0;
			}
			
			float3 blendHardMix(float3 base, float3 blend)
			{
				return float3(blendHardMix(base.r, blend.r), blendHardMix(base.g, blend.g), blendHardMix(base.b, blend.b));
			}
			
			// Lighten
			float blendLighten(float base, float blend)
			{
				return max(blend, base);
			}
			
			float3 blendLighten(float3 base, float3 blend)
			{
				return float3(blendLighten(base.r, blend.r), blendLighten(base.g, blend.g), blendLighten(base.b, blend.b));
			}
			
			// Linear Burn
			float blendLinearBurn(float base, float blend)
			{
				// Note : Same implementation as BlendSubtractf
				return max(base + blend - 1.0, 0.0);
			}
			
			float3 blendLinearBurn(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendSubtract
				return max(base + blend - float3(1.0, 1.0, 1.0), float3(0.0, 0.0, 0.0));
			}
			
			// Linear Dodge
			float blendLinearDodge(float base, float blend)
			{
				// Note : Same implementation as BlendAddf
				return min(base + blend, 1.0);
			}
			
			float3 blendLinearDodge(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendAdd
				return min(base + blend, float3(1.0, 1.0, 1.0));
			}
			
			// Linear light
			float blendLinearLight(float base, float blend)
			{
				return blend < 0.5 ? blendLinearBurn(base, (2.0 * blend)) : blendLinearDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendLinearLight(float3 base, float3 blend)
			{
				return float3(blendLinearLight(base.r, blend.r), blendLinearLight(base.g, blend.g), blendLinearLight(base.b, blend.b));
			}
			
			// Multiply
			float blendMultiply(float base, float blend)
			{
				return base * blend;
			}
			float3 blendMultiply(float3 base, float3 blend)
			{
				return base * blend;
			}
			
			// Negation
			float blendNegation(float base, float blend)
			{
				return 1.0 - abs(1.0 - base - blend);
			}
			float3 blendNegation(float3 base, float3 blend)
			{
				return float3(1.0, 1.0, 1.0) - abs(float3(1.0, 1.0, 1.0) - base - blend);
			}
			
			// Normal
			float blendNormal(float base, float blend)
			{
				return blend;
			}
			float3 blendNormal(float3 base, float3 blend)
			{
				return blend;
			}
			
			// Phoenix
			float blendPhoenix(float base, float blend)
			{
				return min(base, blend) - max(base, blend) + 1.0;
			}
			float3 blendPhoenix(float3 base, float3 blend)
			{
				return min(base, blend) - max(base, blend) + float3(1.0, 1.0, 1.0);
			}
			
			// Pin light
			float blendPinLight(float base, float blend)
			{
				return (blend < 0.5) ? blendDarken(base, (2.0 * blend)) : blendLighten(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendPinLight(float3 base, float3 blend)
			{
				return float3(blendPinLight(base.r, blend.r), blendPinLight(base.g, blend.g), blendPinLight(base.b, blend.b));
			}
			
			// Screen
			float blendScreen(float base, float blend)
			{
				return 1.0 - ((1.0 - base) * (1.0 - blend));
			}
			
			float3 blendScreen(float3 base, float3 blend)
			{
				return float3(blendScreen(base.r, blend.r), blendScreen(base.g, blend.g), blendScreen(base.b, blend.b));
			}
			
			// Soft Light
			float blendSoftLight(float base, float blend)
			{
				return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
			}
			
			float3 blendSoftLight(float3 base, float3 blend)
			{
				return float3(blendSoftLight(base.r, blend.r), blendSoftLight(base.g, blend.g), blendSoftLight(base.b, blend.b));
			}
			
			// Subtract
			float blendSubtract(float base, float blend)
			{
				return max(base - blend, 0.0);
			}
			
			float3 blendSubtract(float3 base, float3 blend)
			{
				return max(base - blend, 0.0);
			}
			
			// Difference
			float blendDifference(float base, float blend)
			{
				return abs(base - blend);
			}
			
			float3 blendDifference(float3 base, float3 blend)
			{
				return abs(base - blend);
			}
			
			// Divide
			float blendDivide(float base, float blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float3 blendDivide(float3 base, float3 blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float blendMixed(float base, float blend)
			{
				return base + base * blend;
			}
			
			float3 blendMixed(float3 base, float3 blend)
			{
				return base + base * blend;
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float customBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType, float alpha)
			{
				float3 output = base;
				switch(blendType)
				{
					case 0: output = lerp(base, blend, alpha); break;
					case 2: output = base * lerp(1, blend, alpha); break;
					case 6: output = lerp(base, blendScreen(base, blend), alpha); break;
					case 8: output = lerp(base, blendLinearDodge(base, blend), alpha); break;
					case 9: output = lerp(base, blendOverlay(base, blend), alpha); break;
					case 20: output = lerp(base, blendMixed(base, blend), alpha); break;
					default: output = 0; break;
				}
				return output;
			}
			
			#define REPLACE 0
			#define SUBSTRACT 1
			#define MULTIPLY 2
			#define DIVIDE 3
			#define MIN 4
			#define MAX 5
			#define AVERAGE 6
			#define ADD 7
			
			float maskBlend(float baseMask, float blendMask, float blendType)
			{
				float output = 0;
				switch(blendType)
				{
					case REPLACE: output = blendMask; break;
					case SUBSTRACT: output = baseMask - blendMask; break;
					case MULTIPLY: output = baseMask * blendMask; break;
					case DIVIDE: output = baseMask / blendMask; break;
					case MIN: output = min(baseMask, blendMask); break;
					case MAX: output = max(baseMask, blendMask); break;
					case AVERAGE: output = (baseMask + blendMask) * 0.5; break;
					case ADD: output = baseMask + blendMask; break;
				}
				return saturate(output);
			}
			
			float random(float2 p)
			{
				return frac(sin(dot(p, float2(12.9898, 78.2383))) * 43758.5453123);
			}
			
			float2 random2(float2 p)
			{
				return frac(sin(float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)))) * 43758.5453);
			}
			
			float3 random3(float2 p)
			{
				return frac(sin(float3(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)), dot(p, float2(248.3, 315.9)))) * 43758.5453);
			}
			
			float3 random3(float3 p)
			{
				return frac(sin(float3(dot(p, float3(127.1, 311.7, 248.6)), dot(p, float3(269.5, 183.3, 423.3)), dot(p, float3(248.3, 315.9, 184.2)))) * 43758.5453);
			}
			
			float3 randomFloat3(float2 Seed, float maximum)
			{
				return (.5 + float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed), float2(12.9898, 78.233))) * 43758.5453)
				) * .5) * (maximum);
			}
			
			float3 randomFloat3Range(float2 Seed, float Range)
			{
				return (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1) * Range;
			}
			
			float3 randomFloat3WiggleRange(float2 Seed, float Range, float wiggleSpeed)
			{
				float3 rando = (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1);
				float speed = 1 + wiggleSpeed;
				return float3(sin((_Time.x + rando.x * PI) * speed), sin((_Time.x + rando.y * PI) * speed), sin((_Time.x + rando.z * PI) * speed)) * Range;
			}
			
			void poiDither(float4 In, float4 ScreenPosition, out float4 Out)
			{
				float2 uv = ScreenPosition.xy * _ScreenParams.xy;
				float DITHER_THRESHOLDS[16] = {
					1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0,
					13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0,
					4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0,
					16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0
				};
				uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
				Out = In - DITHER_THRESHOLDS[index];
			}
			
			static const float Epsilon = 1e-10;
			// The weights of RGB contributions to luminance.
			// Should sum to unity.
			static const float3 HCYwts = float3(0.299, 0.587, 0.114);
			static const float HCLgamma = 3;
			static const float HCLy0 = 100;
			static const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
			static const float3 wref = float3(1.0, 1.0, 1.0);
			#define TAU 6.28318531
			
			float3 HUEtoRGB(in float H)
			{
				float R = abs(H * 6 - 3) - 1;
				float G = 2 - abs(H * 6 - 2);
				float B = 2 - abs(H * 6 - 4);
				return saturate(float3(R, G, B));
			}
			
			float3 RGBtoHCV(in float3 RGB)
			{
				// Based on work by Sam Hocevar and Emil Persson
				float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
				float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
				float C = Q.x - min(Q.w, Q.y);
				float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
				return float3(H, C, Q.x);
			}
			
			float3 HSVtoRGB(in float3 HSV)
			{
				float3 RGB = HUEtoRGB(HSV.x);
				return ((RGB - 1) * HSV.y + 1) * HSV.z;
			}
			
			float3 RGBtoHSV(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float S = HCV.y / (HCV.z + Epsilon);
				return float3(HCV.x, S, HCV.z);
			}
			
			float3 HSLtoRGB(in float3 HSL)
			{
				float3 RGB = HUEtoRGB(HSL.x);
				float C = (1 - abs(2 * HSL.z - 1)) * HSL.y;
				return (RGB - 0.5) * C + HSL.z;
			}
			
			float3 RGBtoHSL(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float L = HCV.z - HCV.y * 0.5;
				float S = HCV.y / (1 - abs(L * 2 - 1) + Epsilon);
				return float3(HCV.x, S, L);
			}
			
			void DecomposeHDRColor(in float3 linearColorHDR, out float3 baseLinearColor, out float exposure)
			{
				// Optimization/adaptation of https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/GUI/ColorMutator.cs#L23 but skips weird photoshop stuff
				float maxColorComponent = max(linearColorHDR.r, max(linearColorHDR.g, linearColorHDR.b));
				bool isSDR = maxColorComponent <= 1.0;
				
				float scaleFactor = isSDR ? 1.0 : (1.0 / maxColorComponent);
				exposure = isSDR ? 0.0 : log(maxColorComponent) * 1.44269504089; // ln(2)
				
				baseLinearColor = scaleFactor * linearColorHDR;
			}
			
			float3 ApplyHDRExposure(float3 linearColor, float exposure)
			{
				return linearColor * pow(2, exposure);
			}
			
			// Transforms an RGB color using a matrix. Note that S and V are absolute values here
			float3 ModifyViaHSV(float3 color, float h, float s, float v)
			{
				float3 colorHSV = RGBtoHSV(color);
				colorHSV.x = frac(colorHSV.x + h);
				colorHSV.y = saturate(colorHSV.y + s);
				colorHSV.z = saturate(colorHSV.z + v);
				return HSVtoRGB(colorHSV);
			}
			
			float3 ModifyViaHSV(float3 color, float3 HSVMod)
			{
				return ModifyViaHSV(color, HSVMod.x, HSVMod.y, HSVMod.z);
			}
			
			float3 hueShift(float3 color, float hueOffset)
			{
				color = RGBtoHSV(color);
				color.x = frac(hueOffset +color.x);
				return HSVtoRGB(color);
			}
			
			// LCH
			float xyzF(float t)
			{
				return lerp(pow(t, 1. / 3.), 7.787037 * t + 0.139731, step(t, 0.00885645));
			}
			float xyzR(float t)
			{
				return lerp(t * t * t, 0.1284185 * (t - 0.139731), step(t, 0.20689655));
			}
			
			float4x4 poiRotationMatrixFromAngles(float x, float y, float z)
			{
				float angleX = radians(x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float4x4 poiRotationMatrixFromAngles(float3 angles)
			{
				float angleX = radians(angles.x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(angles.y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(angles.z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float3 getCameraPosition()
			{
				#ifdef USING_STEREO_MATRICES
				return lerp(unity_StereoWorldSpaceCameraPos[0], unity_StereoWorldSpaceCameraPos[1], 0.5);
				#endif
				return _WorldSpaceCameraPos;
			}
			
			half2 calcScreenUVs(half4 grabPos)
			{
				half2 uv = grabPos.xy / (grabPos.w + 0.0000000001);
				#if UNITY_SINGLE_PASS_STEREO
				uv.xy *= half2(_ScreenParams.x * 2, _ScreenParams.y);
				#else
				uv.xy *= _ScreenParams.xy;
				#endif
				
				return uv;
			}
			
			float CalcMipLevel(float2 texture_coord)
			{
				float2 dx = ddx(texture_coord);
				float2 dy = ddy(texture_coord);
				float delta_max_sqr = max(dot(dx, dx), dot(dy, dy));
				
				return 0.5 * log2(delta_max_sqr);
			}
			
			float inverseLerp(float A, float B, float T)
			{
				return (T - A) / (B - A);
			}
			
			float inverseLerp2(float2 a, float2 b, float2 value)
			{
				float2 AB = b - a;
				float2 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp3(float3 a, float3 b, float3 value)
			{
				float3 AB = b - a;
				float3 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp4(float4 a, float4 b, float4 value)
			{
				float4 AB = b - a;
				float4 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			/*
			MIT License
			
			Copyright (c) 2019 wraikny
			
			Permission is hereby granted, free of charge, to any person obtaining a copy
			of this software and associated documentation files (the "Software"), to deal
			in the Software without restriction, including without limitation the rights
			to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			copies of the Software, and to permit persons to whom the Software is
			furnished to do so, subject to the following conditions:
			
			The above copyright notice and this permission notice shall be included in all
			copies or substantial portions of the Software.
			
			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			SOFTWARE.
			
			VertexTransformShader is dependent on:
			*/
			
			float4 quaternion_conjugate(float4 v)
			{
				return float4(
				v.x, -v.yzw
				);
			}
			
			float4 quaternion_mul(float4 v1, float4 v2)
			{
				float4 result1 = (v1.x * v2 + v1 * v2.x);
				
				float4 result2 = float4(
				- dot(v1.yzw, v2.yzw),
				cross(v1.yzw, v2.yzw)
				);
				
				return float4(result1 + result2);
			}
			
			// angle : radians
			float4 get_quaternion_from_angle(float3 axis, float angle)
			{
				float sn = sin(angle * 0.5);
				float cs = cos(angle * 0.5);
				return float4(axis * sn, cs);
			}
			
			float4 quaternion_from_vector(float3 inVec)
			{
				return float4(0.0, inVec);
			}
			
			float degree_to_radius(float degree)
			{
				return (
				degree / 180.0 * PI
				);
			}
			
			float3 rotate_with_quaternion(float3 inVec, float3 rotation)
			{
				float4 qx = get_quaternion_from_angle(float3(1, 0, 0), radians(rotation.x));
				float4 qy = get_quaternion_from_angle(float3(0, 1, 0), radians(rotation.y));
				float4 qz = get_quaternion_from_angle(float3(0, 0, 1), radians(rotation.z));
				
				#define MUL3(A, B, C) quaternion_mul(quaternion_mul((A), (B)), (C))
				float4 quaternion = normalize(MUL3(qx, qy, qz));
				float4 conjugate = quaternion_conjugate(quaternion);
				
				float4 inVecQ = quaternion_from_vector(inVec);
				
				float3 rotated = (
				MUL3(quaternion, inVecQ, conjugate)
				).yzw;
				
				return rotated;
			}
			
			float4 transform(float4 input, float4 pos, float4 rotation, float4 scale)
			{
				input.rgb *= (scale.xyz * scale.w);
				input = float4(rotate_with_quaternion(input.xyz, rotation.xyz * rotation.w) + (pos.xyz * pos.w), input.w);
				return input;
			}
			
			float2 RotateUV(float2 _uv, float _radian, float2 _piv, float _time)
			{
				float RotateUV_ang = _radian;
				float RotateUV_cos = cos(_time * RotateUV_ang);
				float RotateUV_sin = sin(_time * RotateUV_ang);
				return (mul(_uv - _piv, float2x2(RotateUV_cos, -RotateUV_sin, RotateUV_sin, RotateUV_cos)) + _piv);
			}
			
			/*
			MIT END
			*/
			
			float3 poiThemeColor(in PoiMods poiMods, in float3 srcColor, in float themeIndex)
			{
				if (themeIndex == 0) return srcColor;
				themeIndex -= 1;
				
				if (themeIndex <= 3)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				#endif
				
				return srcColor;
			}
			
			float3 lilToneCorrection(float3 c, float4 hsvg)
			{
				// gamma
				c = pow(abs(c), hsvg.w);
				// rgb -> hsv
				float4 p = (c.b > c.g) ? float4(c.bg, -1.0, 2.0 / 3.0) : float4(c.gb, 0.0, -1.0 / 3.0);
				float4 q = (p.x > c.r) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
				float d = q.x - min(q.w, q.y);
				float e = 1.0e-10;
				float3 hsv = float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
				// shift
				hsv = float3(hsv.x + hsvg.x, saturate(hsv.y * hsvg.y), saturate(hsv.z * hsvg.z));
				// hsv -> rgb
				return hsv.z - hsv.z * hsv.y + hsv.z * hsv.y * saturate(abs(frac(hsv.x + float3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 1.0);
			}
			
			float lilIsIn0to1(float f)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, 1.0));
			}
			
			float lilIsIn0to1(float f, float nv)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, nv));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border)
			{
				return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
			}
			
			float3 poiEdgeLinearNoSaturate(float value, float3 border)
			{
				return float3(
				(value - border.x) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.y) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.z) / clamp(fwidth(value), 0.0001, 1.0)
				);
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur)
			{
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border)
			{
				//return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
				
				float fwidthValue = fwidth(value);
				return smoothstep(border - fwidthValue, border + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinear(float value, float border)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur, borderRange));
			}
			
			float poiEdgeLinear(float value, float border)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border));
			}
			
			float poiEdgeLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur, borderRange));
			}
			// From https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl
			float3 OpenLitLinearToSRGB(float3 col)
			{
				return LinearToGammaSpace(col);
			}
			
			float3 OpenLitSRGBToLinear(float3 col)
			{
				return GammaToLinearSpace(col);
			}
			
			float OpenLitLuminance(float3 rgb)
			{
				#if defined(UNITY_COLORSPACE_GAMMA)
				return dot(rgb, float3(0.22, 0.707, 0.071));
				#else
				return dot(rgb, float3(0.0396819152, 0.458021790, 0.00609653955));
				#endif
			}
			
			float OpenLitGray(float3 rgb)
			{
				return dot(rgb, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
			}
			
			void OpenLitShadeSH9ToonDouble(float3 lightDirection, out float3 shMax, out float3 shMin)
			{
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 N = lightDirection * 0.666666;
				float4 vB = N.xyzz * N.yzzx;
				// L0 L2
				float3 res = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				res.r += dot(unity_SHBr, vB);
				res.g += dot(unity_SHBg, vB);
				res.b += dot(unity_SHBb, vB);
				res += unity_SHC.rgb * (N.x * N.x - N.y * N.y);
				// L1
				float3 l1;
				l1.r = dot(unity_SHAr.rgb, N);
				l1.g = dot(unity_SHAg.rgb, N);
				l1.b = dot(unity_SHAb.rgb, N);
				shMax = res + l1;
				shMin = res - l1;
				#if defined(UNITY_COLORSPACE_GAMMA)
				shMax = OpenLitLinearToSRGB(shMax);
				shMin = OpenLitLinearToSRGB(shMin);
				#endif
				#else
				shMax = 0.0;
				shMin = 0.0;
				#endif
			}
			
			float3 OpenLitComputeCustomLightDirection(float4 lightDirectionOverride)
			{
				float3 customDir = length(lightDirectionOverride.xyz) * normalize(mul((float3x3)unity_ObjectToWorld, lightDirectionOverride.xyz));
				return lightDirectionOverride.w ? customDir : lightDirectionOverride.xyz; // .w isn't doc'd anywhere and is always 0 unless end user changes it
				
			}
			
			float3 OpenLitLightingDirectionForSH9()
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				
				float3 lightDirectionForSH9 = sh9Dir + mainDir;
				lightDirectionForSH9 = dot(lightDirectionForSH9, lightDirectionForSH9) < 0.000001 ? 0 : normalize(lightDirectionForSH9);
				return lightDirectionForSH9;
			}
			
			float3 OpenLitLightingDirection(float4 lightDirectionOverride)
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				float3 customDir = OpenLitComputeCustomLightDirection(lightDirectionOverride);
				
				return normalize(sh9DirAbs + mainDir + customDir);
			}
			
			float3 OpenLitLightingDirection()
			{
				float4 customDir = float4(0.001, 0.002, 0.001, 0.0);
				return OpenLitLightingDirection(customDir);
			}
			
			inline float4 CalculateFrustumCorrection()
			{
				float x1 = -UNITY_MATRIX_P._31 / (UNITY_MATRIX_P._11 * UNITY_MATRIX_P._34);
				float x2 = -UNITY_MATRIX_P._32 / (UNITY_MATRIX_P._22 * UNITY_MATRIX_P._34);
				return float4(x1, x2, 0, UNITY_MATRIX_P._33 / UNITY_MATRIX_P._34 + x1 * UNITY_MATRIX_P._13 + x2 * UNITY_MATRIX_P._23);
			}
			
			inline float CorrectedLinearEyeDepth(float z, float B)
			{
				return 1.0 / (z / UNITY_MATRIX_P._34 + B);
			}
			
			//Silent's code
			float2 sharpSample(float4 texelSize, float2 p)
			{
				p = p * texelSize.zw;
				float2 c = max(0.0, fwidth(p));
				p = floor(p) + saturate(frac(p) / c);
				p = (p - 0.5) * texelSize.xy;
				return p;
			}
			
			void applyToGlobalMask(inout PoiMods poiMods, int index, int blendType, float val)
			{
				float valBlended = saturate(maskBlend(poiMods.globalMask[index], val, blendType));
				switch(index)
				{
					case 0: poiMods.globalMask[0] = valBlended; break;
					case 1: poiMods.globalMask[1] = valBlended; break;
					case 2: poiMods.globalMask[2] = valBlended; break;
					case 3: poiMods.globalMask[3] = valBlended; break;
					case 4: poiMods.globalMask[4] = valBlended; break;
					case 5: poiMods.globalMask[5] = valBlended; break;
					case 6: poiMods.globalMask[6] = valBlended; break;
					case 7: poiMods.globalMask[7] = valBlended; break;
					case 8: poiMods.globalMask[8] = valBlended; break;
					case 9: poiMods.globalMask[9] = valBlended; break;
					case 10: poiMods.globalMask[10] = valBlended; break;
					case 11: poiMods.globalMask[11] = valBlended; break;
					case 12: poiMods.globalMask[12] = valBlended; break;
					case 13: poiMods.globalMask[13] = valBlended; break;
					case 14: poiMods.globalMask[14] = valBlended; break;
					case 15: poiMods.globalMask[15] = valBlended; break;
				}
			}
			
			void assignValueToVectorFromIndex(inout float4 vec, int index, float value)
			{
				switch(index)
				{
					case 0: vec[0] = value; break;
					case 1: vec[1] = value; break;
					case 2: vec[2] = value; break;
					case 3: vec[3] = value; break;
				}
			}
			
			// SNose
			float3 mod289(float3 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float2 mod289(float2 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float3 permute(float3 x)
			{
				return mod289(((x * 34.0) + 1.0) * x);
			}
			
			float snoise(float2 v)
			{
				const float4 C = float4(0.211324865405187, // (3.0-sqrt(3.0))/6.0
				0.366025403784439, // 0.5*(sqrt(3.0)-1.0)
				- 0.577350269189626, // -1.0 + 2.0 * C.x
				0.024390243902439); // 1.0 / 41.0
				float2 i = floor(v + dot(v, C.yy));
				float2 x0 = v - i + dot(i, C.xx);
				float2 i1;
				i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
				float4 x12 = x0.xyxy + C.xxzz;
				x12.xy -= i1;
				i = mod289(i); // Avoid truncation effects in permutation
				float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0))
				+ i.x + float3(0.0, i1.x, 1.0));
				
				float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
				m = m * m ;
				m = m * m ;
				float3 x = 2.0 * frac(p * C.www) - 1.0;
				float3 h = abs(x) - 0.5;
				float3 ox = floor(x + 0.5);
				float3 a0 = x - ox;
				m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
				float3 g;
				g.x = a0.x * x0.x + h.x * x0.y;
				g.yz = a0.yz * x12.xz + h.yz * x12.yw;
				return 130.0 * dot(m, g);
			}
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			
			// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.
			float4 AudioLinkDataMultiline(uint2 xycoord) { return AudioLinkData(uint2(xycoord.x % AUDIOLINK_WIDTH, xycoord.y + xycoord.x/AUDIOLINK_WIDTH)); }
			
			// Mechanism to sample between two adjacent pixels and lerp between them, like "linear" supesampling
			float4 AudioLinkLerp(float2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(xy+int2(1,0)), frac( xy.x ) ); }
			
			// Same as AudioLinkLerp but properly handles multiline reading.
			float4 AudioLinkLerpMultiline(float2 xy) { return lerp(AudioLinkDataMultiline(xy), AudioLinkDataMultiline(xy+float2(1,0)), frac(xy.x)); }
			
			//Tests to see if Audio Link texture is available
			bool AudioLinkIsAvailable()
			{
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				int width, height;
				_AudioTexture.GetDimensions(width, height);
				return width > 16;
				#else
				return _AudioTexture_TexelSize.z > 16;
				#endif
			}
			
			//Get version of audiolink present in the world, 0 if no audiolink is present
			float AudioLinkGetVersion()
			{
				int2 dims;
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				_AudioTexture.GetDimensions(dims.x, dims.y);
				#else
				dims = _AudioTexture_TexelSize.zw;
				#endif
				
				if (dims.x >= 128)
				return AudioLinkData(ALPASS_GENERALVU).x;
				else if (dims.x > 16)
				return 1;
				else
				return 0;
			}
			
			// This pulls data from this texture.
			#define AudioLinkGetSelfPixelData(xy) _SelfTexture2D[xy]
			
			// Extra utility functions for time.
			uint AudioLinkDecodeDataAsUInt(uint2 indexloc)
			{
				uint4 rpx = AudioLinkData(indexloc);
				return rpx.r + rpx.g*1024 + rpx.b * 1048576 + rpx.a * 1073741824;
			}
			
			//Note: This will truncate time to every 134,217.728 seconds (~1.5 days of an instance being up) to prevent floating point aliasing.
			// if your code will alias sooner, you will need to use a different function.  It should be safe to use this on all times.
			float AudioLinkDecodeDataAsSeconds(uint2 indexloc)
			{
				uint time = AudioLinkDecodeDataAsUInt(indexloc) & 0x7ffffff;
				//Can't just divide by float.  Bug in Unity's HLSL compiler.
				return float(time / 1000) + float( time % 1000 ) / 1000.;
			}
			
			#define ALDecodeDataAsSeconds( x ) AudioLinkDecodeDataAsSeconds( x )
			#define ALDecodeDataAsUInt( x ) AudioLinkDecodeDataAsUInt( x )
			
			float AudioLinkRemap(float t, float a, float b, float u, float v) { return ((t-a) / (b-a)) * (v-u) + u; }
			
			float3 AudioLinkHSVtoRGB(float3 HSV)
			{
				float3 RGB = 0;
				float C = HSV.z * HSV.y;
				float H = HSV.x * 6;
				float X = C * (1 - abs(fmod(H, 2) - 1));
				if (HSV.y != 0)
				{
					float I = floor(H);
					if (I == 0) { RGB = float3(C, X, 0); }
					else if (I == 1) { RGB = float3(X, C, 0); }
					else if (I == 2) { RGB = float3(0, C, X); }
					else if (I == 3) { RGB = float3(0, X, C); }
					else if (I == 4) { RGB = float3(X, 0, C); }
					else { RGB = float3(C, 0, X); }
				}
				float M = HSV.z - C;
				return RGB + M;
			}
			
			float3 AudioLinkCCtoRGB(float bin, float intensity, int rootNote)
			{
				float note = bin / AUDIOLINK_EXPBINS;
				
				float hue = 0.0;
				note *= 12.0;
				note = glsl_mod(4. - note + rootNote, 12.0);
				{
					if(note < 4.0)
					{
						//Needs to be YELLOW->RED
						hue = (note) / 24.0;
					}
					else if(note < 8.0)
					{
						//            [4]  [8]
						//Needs to be RED->BLUE
						hue = (note-2.0) / 12.0;
					}
					else
					{
						//             [8] [12]
						//Needs to be BLUE->YELLOW
						hue = (note - 4.0) / 8.0;
					}
				}
				float val = intensity - 0.1;
				return AudioLinkHSVtoRGB(float3(fmod(hue, 1.0), 1.0, clamp(val, 0.0, 1.0)));
			}
			
			// Sample the amplitude of a given frequency in the DFT, supports frequencies in [13.75; 14080].
			float4 AudioLinkGetAmplitudeAtFrequency(float hertz)
			{
				float note = AUDIOLINK_EXPBINS * log2(hertz / AUDIOLINK_BOTTOM_FREQUENCY);
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(note, 0));
			}
			
			// Sample the amplitude of a given semitone in an octave. Octave is in [0; 9] while note is [0; 11].
			float AudioLinkGetAmplitudeAtNote(float octave, float note)
			{
				float quarter = note * 2.0;
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(octave * AUDIOLINK_EXPBINS + quarter, 0));
			}
			
			// Get a reasonable drop-in replacement time value for _Time.y with the
			// given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTime(uint index, uint band)
			{
				return (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY + uint2(index, band))) / 100000.0;
			}
			
			// Get a chronotensity value in the interval [0; 1], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeNormalized(uint index, uint band, float speed)
			{
				return frac(AudioLinkGetChronoTime(index, band) * speed);
			}
			
			// Get a chronotensity value in the interval [0; interval], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeInterval(uint index, uint band, float speed, float interval)
			{
				return AudioLinkGetChronoTimeNormalized(index, band, speed) * interval;
			}
			
			float getBandAtTime(float band, float time, float size = 1.0f)
			{
				//return remap(UNITY_SAMPLE_TEX2D(_AudioTexture, float2(time * width, band/128.0)).r, min(size,.9999), 1);
				return remapClamped(min(size,.9999), 1, AudioLinkData(ALPASS_AUDIOBASS + uint2(time * AUDIOLINK_WIDTH,band)).r);
			}
			
			fixed3 maximize(fixed3 c) {
				if (c.x == 0 && c.y == 0 && c.z == 0)
				return fixed3(1.0, 1.0, 1.0);
				else
				return c / max(c.r, max(c.g, c.b));
			}
			
			bool LumaIsAvailable()
			{
				return LumaData(0.629, 0.511).r > 0.9;
			}
			
			float3 getLumaGradient(uint index, float offset) {
				return LumaData(0.57 + (index * 0.11) + lerp(0, 0.107, offset), 0.493);
			}
			
			void initPoiAudioLink(inout PoiMods poiMods)
			{
				if (!_AudioLinkAnimToggle) return;
				
				if (AudioLinkIsAvailable())
				{
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkVersion = AudioLinkGetVersion();
					poiMods.audioLink[0] = _AudioLinkSmoothingBass    == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 0))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingBass   ) * 15.95, 0))[0];
					poiMods.audioLink[1] = _AudioLinkSmoothingLowMid  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 1))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingLowMid ) * 15.95, 1))[0];
					poiMods.audioLink[2] = _AudioLinkSmoothingHighMid == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 2))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingHighMid) * 15.95, 2))[0];
					poiMods.audioLink[3] = _AudioLinkSmoothingTreble  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 3))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingTreble ) * 15.95, 3))[0];
					/*
					poiMods.globalColorTheme[4] = AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) );
					poiMods.globalColorTheme[5] = AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) );
					poiMods.globalColorTheme[6] = AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) );
					poiMods.globalColorTheme[7] = AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) );
					
					poiMods.globalColorTheme[4] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) )),1.0);
					poiMods.globalColorTheme[5] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) )),1.0);
					poiMods.globalColorTheme[6] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) )),1.0);
					poiMods.globalColorTheme[7] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) )),1.0);
					*/
					
					poiMods.globalColorTheme[4] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(2, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[5] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(3, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[6] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(4, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[7] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(5, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					
					poiMods.globalColorTheme[8] = AudioLinkData(ALPASS_THEME_COLOR0);
					poiMods.globalColorTheme[9] = AudioLinkData(ALPASS_THEME_COLOR1);
					poiMods.globalColorTheme[10] = AudioLinkData(ALPASS_THEME_COLOR2);
					poiMods.globalColorTheme[11] = AudioLinkData(ALPASS_THEME_COLOR3);
					return;
				}
				
				if (LumaIsAvailable())
				{
					// Gradients:
					// 0.570 - 0.677, 0.493
					// 0.680 - 0.788, 0.493
					// 0.791 - 0.898, 0.493
					float4 audioPixel = LumaData(0.578, 0.515);
					float audioLows = audioPixel.r;
					float audioHighs = audioPixel.g;
					float4 zone1 = LumaData(0.856, 0.522);
					float4 zone2 = LumaData(0.856, 0.507);
					float4 zone3 = LumaData(0.864, 0.522);
					float4 zone4 = LumaData(0.864, 0.507);
					// float4 lumaEnabledPixel = LumaData(0.629, 0.511);
					// float fakeLight = (lumaEnabledPixel.g > 0) ? 1 : (1 - lumaEnabledPixel.r);
					
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkViaLuma = true;
					poiMods.audioLink.xy = audioLows;
					poiMods.audioLink.zw = audioHighs;
					
					poiMods.globalColorTheme[8] = zone1;
					poiMods.globalColorTheme[9] = zone2;
					poiMods.globalColorTheme[10] = zone3;
					poiMods.globalColorTheme[11] = zone4;
				}
			}
			
			void DebugVisualizer(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods){
				if (_DebugWaveform){
					float waveform = AudioLinkLerpMultiline(ALPASS_WAVEFORM + float2( 500. * poiMesh.uv[0].x, 0)).r;
					poiFragData.emission += clamp(1 - 50 * abs(waveform - poiMesh.uv[0].y * 2. + 1), 0, 1);
				}
				if (_DebugDFT){
					poiFragData.emission += AudioLinkLerpMultiline(ALPASS_DFT + uint2(poiMesh.uv[0].x * AUDIOLINK_ETOTALBINS, 0)).rrr;
				}
				if (_DebugBass){
					poiFragData.emission += poiMods.audioLink.x;
				}
				if (_DebugLowMids){
					poiFragData.emission += poiMods.audioLink.y;
				}
				if (_DebugHighMids){
					poiFragData.emission += poiMods.audioLink.z;
				}
				if (_DebugTreble){
					poiFragData.emission += poiMods.audioLink.w;
				}
				if (_DebugCCColors){
					poiFragData.emission += AudioLinkData(ALPASS_CCCOLORS + uint2(3 + 1, 0));
				}
				if (_DebugCCStrip){
					poiFragData.emission += AudioLinkLerp(ALPASS_CCSTRIP + float2(poiMesh.uv[0].x * AUDIOLINK_WIDTH, 0));
				}
				if (_DebugCCLights){
					poiFragData.emission += AudioLinkData(ALPASS_CCLIGHTS + uint2(uint(poiMesh.uv[0].x * 8) + uint(poiMesh.uv[0].y * 16) * 8, 0));
				}
				if (_DebugAutocorrelator){
					poiFragData.emission += saturate(AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2((abs(1. - poiMesh.uv[0].x * 2.)) * AUDIOLINK_WIDTH, 0)).rrr);
				}
				if (_DebugChronotensity){
					poiFragData.emission += (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY  + uint2(1, 0)) % 1000000) / 1000000.0;
				}
			}
			
			void SetupAudioLink(inout PoiFragData poiFragData, inout PoiMods poiMods, in PoiMesh poiMesh){
				initPoiAudioLink(poiMods);
				DebugVisualizer(poiFragData, poiMesh, poiMods);
				
				if(_AudioLinkCCStripY)
				{
					poiFragData.emission += AudioLinkLerp( ALPASS_CCSTRIP + float2( poiMesh.uv[0].y * AUDIOLINK_WIDTH, 0 ) ).rgb * .5;
				}
			}
			
			#endif
			//endex
			
			VertexOut vert(
			#ifndef POI_TESSELLATED
			appdata v
			#else
			tessAppData v
			#endif
			)
			{
				UNITY_SETUP_INSTANCE_ID(v);
				VertexOut o;
				PoiInitStruct(VertexOut, o);
				UNITY_TRANSFER_INSTANCE_ID(v, o);
				#ifdef POI_TESSELLATED
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v);
				#endif
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
				
				//ifex _EnableUDIMDiscardOptions==0
				#ifdef POI_UDIMDISCARD
				UNITY_BRANCH
				if(_UDIMDiscardMode == 0) // Discard Vertices instead of just pixels
				{
					// Branchless (inspired by s-ilent)
					float2 udim = 0;
					// Select UV
					udim += (v.uv0.xy * (_UDIMDiscardUV == 0));
					udim += (v.uv1.xy * (_UDIMDiscardUV == 1));
					udim += (v.uv2.xy * (_UDIMDiscardUV == 2));
					udim += (v.uv3.xy * (_UDIMDiscardUV == 3));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 0, but not exactly 0
					const float threshold = 0.001;
					if(isDiscarded > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _VertexManipulationsEnabled==0
				#ifdef AUTO_EXPOSURE
				float4 audioLinkBands = 0;
				float3 ALrotation = 0;
				float3 ALLocalTranslation = 0;
				float3 CTALRotation = 0;
				float3 ALScale = 0;
				float3 ALWorldTranslation = 0;
				float ALHeight = 0;
				float ALRoundingAmount = 0;
				float4 ALSpectrumLocalOffset = float4(0, 0, 0, 0);
				#ifdef POI_AUDIOLINK
				if (AudioLinkIsAvailable() && _VertexAudioLinkEnabled && _AudioLinkAnimToggle)
				{
					audioLinkBands.x = AudioLinkData(ALPASS_AUDIOBASS).r;
					audioLinkBands.y = AudioLinkData(ALPASS_AUDIOLOWMIDS).r;
					audioLinkBands.z = AudioLinkData(ALPASS_AUDIOHIGHMIDS).r;
					audioLinkBands.w = AudioLinkData(ALPASS_AUDIOTREBLE).r;
					
					if (any(_VertexLocalTranslationALMin) || any(_VertexLocalTranslationALMax))
					{
						ALLocalTranslation = lerp(_VertexLocalTranslationALMin, _VertexLocalTranslationALMax, audioLinkBands[_VertexLocalTranslationALBand]);
					}
					if (any(_VertexLocalRotationAL))
					{
						ALrotation = audioLinkBands[_VertexLocalRotationALBand] * _VertexLocalRotationAL;
					}
					if (any(_VertexLocalRotationCTALSpeed))
					{
						CTALRotation.x = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeX, _VertexLocalRotationCTALBandX) * _VertexLocalRotationCTALSpeed.x * 360;
						CTALRotation.y = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeY, _VertexLocalRotationCTALBandY) * _VertexLocalRotationCTALSpeed.y * 360;
						CTALRotation.z = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeZ, _VertexLocalRotationCTALBandZ) * _VertexLocalRotationCTALSpeed.z * 360;
					}
					if (any(_VertexLocalScaleALMin) || any(_VertexLocalScaleALMax))
					{
						ALScale = lerp(_VertexLocalScaleALMin.xyz + _VertexLocalScaleALMin.w, _VertexLocalScaleALMax.xyz + _VertexLocalScaleALMax.w, audioLinkBands[_VertexLocalScaleALBand]);
					}
					if (any(_VertexWorldTranslationALMin) || any(_VertexWorldTranslationALMax))
					{
						ALWorldTranslation = lerp(_VertexWorldTranslationALMin, _VertexWorldTranslationALMax, audioLinkBands[_VertexWorldTranslationALBand]);
					}
					if (any(_VertexManipulationHeightAL))
					{
						ALHeight = lerp(_VertexManipulationHeightAL.x, _VertexManipulationHeightAL.y, audioLinkBands[_VertexManipulationHeightBand]);
					}
					if (any(_VertexRoundingRangeAL))
					{
						ALRoundingAmount = lerp(_VertexRoundingRangeAL.x, _VertexRoundingRangeAL.y, audioLinkBands[_VertexRoundingRangeBand]);
					}
					if (_VertexSpectrumMotion)
					{
						ALSpectrumLocalOffset.xyz = lerp(_VertexSpectrumOffsetMin.xyz, _VertexSpectrumOffsetMax.xyz, AudioLinkLerpMultiline(ALPASS_DFT + float2(vertexUV(v, _VertexSpectrumUV)[_VertexSpectrumUVDirection] * AUDIOLINK_ETOTALBINS, 0.)));
					}
				}
				#endif
				
				// Local Transformation
				float4 rotation = float4(_VertexManipulationLocalRotation.xyz + float3(180, 0, 0) + _VertexManipulationLocalRotationSpeed * _Time.x + ALrotation + CTALRotation, _VertexManipulationLocalRotation.w);
				v.normal = rotate_with_quaternion(v.normal, rotation.xyz);
				v.tangent.xyz = rotate_with_quaternion(v.tangent.xyz, rotation.xyz);
				v.vertex = transform(v.vertex, _VertexManipulationLocalTranslation + float4(ALLocalTranslation, 0) + ALSpectrumLocalOffset, rotation, _VertexManipulationLocalScale + float4(ALScale, 0));
				o.normal = UnityObjectToWorldNormal(v.normal);
				
				#if defined(PROP_VERTEXMANIPULATIONHEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float3 heightOffset = (tex2Dlod(_VertexManipulationHeightMask, float4(poiUV(vertexUV(v, _VertexManipulationHeightMaskUV), _VertexManipulationHeightMask_ST) + _VertexManipulationHeightMaskPan * _Time.x, 0, 0))[_VertexManipulationHeightMaskChannel] - _VertexManipulationHeightBias) * (_VertexManipulationHeight + ALHeight) * o.normal;
				#else
				float3 heightOffset = (_VertexManipulationHeight + ALHeight) * o.normal;
				#endif
				
				if (_VertexBarrelMode)
				{
					v.vertex.xz = lerp(v.vertex.xz, normalize(v.vertex.xz) * _VertexBarrelWidth + v.vertex.xz * _VertexBarrelHeight, _VertexBarrelAlpha);
				}
				
				if (_VertexSphereMode)
				{
					v.vertex.xyz = lerp(v.vertex.xyz, normalize(v.vertex.xyz + _VertexSphereCenter.xyz) * _VertexSphereRadius + v.vertex.xyz * _VertexSphereHeight, _VertexSphereAlpha);
				}
				
				v.vertex.xyz += mul(unity_WorldToObject, _VertexManipulationWorldTranslation.xyz + ALWorldTranslation + heightOffset).xyz;
				
				// rounding
				UNITY_BRANCH
				if (_VertexRoundingEnabled)
				{
					float divisionAmount = max(_VertexRoundingDivision + ALRoundingAmount, 0.0000001);
					float3 vertexPos = v.vertex.xyz;
					if (_VertexRoundingSpace == 0)
					{
						vertexPos = mul(unity_ObjectToWorld, v.vertex.xyz);
					}
					float3 worldRoundPosition = (ceil(vertexPos / divisionAmount) * divisionAmount) - divisionAmount * .5;
					v.vertex.xyz = worldRoundPosition;
					if (_VertexRoundingSpace == 0)
					{
						v.vertex.xyz = mul(unity_WorldToObject, worldRoundPosition);
					}
				}
				#endif
				//endex
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				UNITY_BRANCH
				if(_UVTileDissolveEnabled && _UVTileDissolveDiscardAtMax)
				{
					// Branchless (inspired by s-ilent)
					float2 dissolveUdim = 0;
					// Select UV
					dissolveUdim += (v.uv0.xy * (_UVTileDissolveUV == 0));
					dissolveUdim += (v.uv1.xy * (_UVTileDissolveUV == 1));
					dissolveUdim += (v.uv2.xy * (_UVTileDissolveUV == 2));
					dissolveUdim += (v.uv3.xy * (_UVTileDissolveUV == 3));
					
					float isDiscardedFromDissolve = 0;
					float4 xMaskDissolve = float4(  (dissolveUdim.x >= 0 && dissolveUdim.x < 1),
					(dissolveUdim.x >= 1 && dissolveUdim.x < 2),
					(dissolveUdim.x >= 2 && dissolveUdim.x < 3),
					(dissolveUdim.x >= 3 && dissolveUdim.x < 4));
					
					isDiscardedFromDissolve += (dissolveUdim.y >= 0 && dissolveUdim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 1 && dissolveUdim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 2 && dissolveUdim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 3 && dissolveUdim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMaskDissolve);
					
					isDiscardedFromDissolve *= any(float4(dissolveUdim.y >= 0, dissolveUdim.y < 4, dissolveUdim.x >= 0, dissolveUdim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 1, but not exactly 1
					const float threshold = 0.999;
					if(isDiscardedFromDissolve > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				float notVisible = 0;
				
				if (_VisibilityMode == 1) // VRC
				{
					float mirrorMode = VRCMirrorMode();
					float cameraMode = VRCCameraMode();
					
					notVisible += (!_VisibilityVRCRegular 		&& ((mirrorMode == 0) && (cameraMode == 0)));
					notVisible += (!_VisibilityVRCMirrorVR 		&&  (mirrorMode == 1));
					notVisible += (!_VisibilityVRCMirrorDesktop &&  (mirrorMode == 2));
					notVisible += (!_VisibilityVRCCameraVR			&& (cameraMode == 1));
					notVisible += (!_VisibilityVRCCameraDesktop 	&& (cameraMode == 2));
					notVisible += (!_VisibilityVRCCameraScreenshot 	&& (cameraMode == 3));
				}
				else if (_Mirror != 0) // Generic (CVR, etc)
				{
					notVisible += (_Mirror == 1) ^ IsInMirror();
				}
				
				if(notVisible) // Early Return skips rest of vertex shader
				{
					return (VertexOut)POI_NAN;
				}
				#endif
				//endex
				
				o.objectPos = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
				o.objNormal = v.normal;
				o.normal = UnityObjectToWorldNormal(v.normal);
				o.tangent = UnityObjectToWorldDir(v.tangent);
				
				o.binormal = cross(o.normal, o.tangent) * (v.tangent.w * unity_WorldTransformParams.w);
				o.vertexColor = v.color;
				
				o.uv[0] = v.uv0;
				o.uv[1] = v.uv1;
				o.uv[2] = v.uv2;
				o.uv[3] = v.uv3;
				
				#if defined(LIGHTMAP_ON)
				o.lightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
				#endif
				#ifdef DYNAMICLIGHTMAP_ON
				o.lightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
				#endif
				
				o.localPos = v.vertex;
				o.worldPos = mul(unity_ObjectToWorld, o.localPos);
				
				float3 localOffset = float3(0, 0, 0);
				float3 worldOffset = float3(0, 0, 0);
				
				//ifex _VertexGlitchingEnabled==0
				#if defined(POI_VERTEX_GLITCHING)
				
				bool canGlitch = true;
				if (_VertexGlitchMirrorEnable && _VertexGlitchMirror > 0)
				{
					bool inMirror = IsInMirror();
					if (_VertexGlitchMirror == 1 && !inMirror)	canGlitch = false;
					if (_VertexGlitchMirror == 2 && inMirror)	canGlitch = false;
				}
				if (canGlitch)
				{
					float3 forward = getCameraPosition() - mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
					forward.y = 0;
					forward = normalize(forward);
					float3 glitchDirection = normalize(cross(float3(0, 1, 0), forward));
					
					float glitchAmount = 0;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE)
					// if(_VertexGlitchingUseTexture)
					// {
					float uvl = o.worldPos.y * _VertexGlitchDensity + _Time.x * _VertexGlitchMapPanSpeed;
					float uvr = o.worldPos.y * _VertexGlitchDensity - _Time.x * _VertexGlitchMapPanSpeed;
					
					float3 glitchTextureL = 1;
					float3 glitchTextureR = 1;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE) || !defined(OPTIMIZER_ENABLED)
					glitchTextureL = tex2Dlod(_VertexGlitchMap, float4(uvl, uvl, 0, 0)).rgb;
					glitchTextureR = tex2Dlod(_VertexGlitchMap, float4(uvr, uvr, 0, 0)).rgb;
					#endif
					
					glitchAmount += (glitchTextureL.r - 0.5) * 2;
					glitchAmount += - (glitchTextureR.r - 0.5) * 2;
					
					glitchAmount += (glitchTextureL.g - 0.5) * 2;
					glitchAmount += - (glitchTextureR.b - 0.5) * 2;
					// } else {
					#else
					glitchAmount += frac(sin(dot(_Time.xy + o.worldPos.y, float2(12.9898, 78.233))) * 43758.5453123) * 2 - 1;
					// }
					#endif
					
					float time = _Time.y * _VertexGlitchFrequency;
					
					float randomGlitch = (sin(time) + sin(2.2 * time + 5.52) + sin(2.9 * time + 0.93) + sin(4.6 * time + 8.94)) / 4;
					float3 glitchOffset = 0;
					
					#ifdef POI_AUDIOLINK
					if (AudioLinkIsAvailable() && _VertexGlitchingAudioLinkEnabled)
					{
						// float4 audioLinkData = AudioLinkData(ALPASS_AUDIOBASS);
						
						float audioIntensity =
						AudioLinkData(ALPASS_AUDIOBASS).r 		* (_VertexGlitchingAudioLinkBand == 0) +
						AudioLinkData(ALPASS_AUDIOLOWMIDS).r 	* (_VertexGlitchingAudioLinkBand == 1) +
						AudioLinkData(ALPASS_AUDIOHIGHMIDS).r	* (_VertexGlitchingAudioLinkBand == 2) +
						AudioLinkData(ALPASS_AUDIOTREBLE).r 	* (_VertexGlitchingAudioLinkBand == 3) +
						AudioLinkData(ALPASS_FILTEREDVU_INTENSITY).r * (_VertexGlitchingAudioLinkBand == 4);
						
						if(_VertexGlitchingAudiolinkOverride)
						{
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
							// glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						} else {
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
							glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						}
					} else {
						glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					}
					#else
					glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					#endif
					
					localOffset += glitchOffset;
					worldOffset += mul(unity_ObjectToWorld, glitchOffset);
				}
				#endif
				//endex
				
				o.localPos.rgb += localOffset;
				o.worldPos.rgb += worldOffset;
				
				//ifex _EnableDepthBulge==0
				#if defined(POI_DEPTHBULGE) && (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				applyDepthBulgeFX(o);
				#endif
				//endex
				
				o.pos = UnityObjectToClipPos(o.localPos);
				
				#ifdef POI_PASS_OUTLINE
				#if defined(UNITY_REVERSED_Z)
				//DX
				o.pos.z += _Offset_Z * - 0.01;
				#else
				//OpenGL
				o.pos.z += _Offset_Z * 0.01;
				#endif
				#endif
				o.grabPos = ComputeGrabScreenPos(o.pos);
				
				#ifndef FORWARD_META_PASS
				#if !defined(UNITY_PASS_SHADOWCASTER)
				UNITY_TRANSFER_SHADOW(o, o.uv[0].xy);
				#else
				v.vertex.xyz = o.localPos.xyz;
				TRANSFER_SHADOW_CASTER_NOPOS(o, o.pos);
				#endif
				#endif
				
				UNITY_TRANSFER_FOG(o, o.pos);
				
				if (_RenderingReduceClipDistance)
				{
					if (o.pos.w < _ProjectionParams.y * 1.01 && o.pos.w > 0)
					{
						o.pos.z = o.pos.z * 0.0001 + o.pos.w * 0.999;
					}
				}
				
				#ifdef POI_PASS_META
				o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
				#endif
				
				#if defined(GRAIN)
				float4 worldDirection;
				
				worldDirection.xyz = o.worldPos.xyz - _WorldSpaceCameraPos;
				worldDirection.w = dot(o.pos, CalculateFrustumCorrection());
				o.worldDirection = worldDirection;
				#endif
				return o;
			}
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, uv) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan)) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			#if defined(_STOCHASTICMODE_HEXTILE)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, uv, false) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false, dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			#ifndef POI2D_SAMPLER_STOCHASTIC
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (POI2D_SAMPLER(tex, texSampler, uv))
			#endif
			#ifndef POI2D_SAMPLER_PAN_STOCHASTIC
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#endif
			#ifndef POI2D_SAMPLER_PANGRAD_STOCHASTIC
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_SAMPLER_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_SAMPLER_PAN_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// #define POI2D_MAINTEX_SAMPLER_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_MAINTEX_SAMPLER_PAN_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// Deliot, Heitz 2019 - Fast, but non-histogram-preserving (ends up looking a bit blurry and lower contrast)
			// https://eheitzresearch.wordpress.com/738-2/
			
			// Classic Magic Numbers fracsin
			#if !defined(_STOCHASTICMODE_NONE)
			float2 StochasticHash2D2D (float2 s)
			{
				return frac(sin(glsl_mod(float2(dot(s, float2(127.1,311.7)), dot(s, float2(269.5,183.3))), 3.14159)) * 43758.5453);
			}
			#endif
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			// UV Offsets and blend weights
			// UVBW[0...2].xy = UV Offsets
			// UVBW[0...2].z = Blend Weights
			float3x3 DeliotHeitzStochasticUVBW(float2 uv)
			{
				// UV transformed into triangular grid space with UV scaled by approximation of 2*sqrt(3)
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewUV = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticDeliotHeitzDensity);
				
				// Vertex IDs and barycentric coords
				float2 vxID = floor(skewUV);
				float3 bary = float3(frac(skewUV), 0);
				bary.z = 1.0 - bary.x - bary.y;
				
				float3x3 pos = float3x3(
				float3(vxID, 				bary.z),
				float3(vxID + float2(0, 1), bary.y),
				float3(vxID + float2(1, 0), bary.x)
				);
				
				float3x3 neg = float3x3(
				float3(vxID + float2(1, 1), 	 -bary.z),
				float3(vxID + float2(1, 0), 1.0 - bary.y),
				float3(vxID + float2(0, 1), 1.0 - bary.x)
				);
				
				return (bary.z > 0) ? pos : neg;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, float2 dx, float2 dy)
			{
				// UVBW[0...2].xy = UV Offsets
				// UVBW[0...2].z = Blend Weights
				float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
				
				//blend samples with calculated weights
				return 	mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv)
			{
				float2 dx = ddx(uv), dy = ddy(uv);
				return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
			}
			#endif // defined(_STOCHASTICMODE_DELIOT_HEITZ)
			
			#if defined(_STOCHASTICMODE_HEXTILE)
			// HexTiling: Slower, but histogram-preserving
			// SPDX-License-Idenfitier: MIT
			// Copyright (c) 2022 mmikk
			// https://github.com/mmikk/hextile-demo
			float2 HextileMakeCenUV(float2 vertex)
			{
				// 0.288675 ~= 1/(2*sqrt(3))
				const float2x2 stochasticInverseSkewedGrid = float2x2(1.0, 0.5, 0.0, 1.0/1.15470054);
				return mul(stochasticInverseSkewedGrid, vertex) * 0.288675;
			}
			
			float2x2 HextileLoadRot2x2(float2 idx, float rotStrength)
			{
				float angle = abs(idx.x * idx.y) + abs(idx.x + idx.y) + PI;
				
				// remap to +/-pi
				angle = glsl_mod(angle, 2 * PI);
				if(angle < 0)  angle += 2 * PI;
				if(angle > PI) angle -= 2 * PI;
				
				angle *= rotStrength;
				
				float cs = cos(angle), si = sin(angle);
				return float2x2(cs, -si, si, cs);
			}
			
			// UV Offsets and base blend weights
			// UVBWR[0...2].xy = UV Offsets
			// UVBWR[0...2].zw = rotation costh/sinth -> reconstruct rotation matrix with float2x2(UVBWR[n].z, -UVBWR[n].w, UVBWR[n].w, UVBWR[n].z)
			// UVBWR[3].xyz = Blend Weights (w unused) - needs luminance weighting
			float4x4 HextileUVBWR(float2 uv)
			{
				// Create Triangle Grid
				// Skew input space into simplex triangle grid (3.4641 ~= 2*sqrt(3))
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewedCoord = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticHexGridDensity);
				
				float2 baseId = float2(floor(skewedCoord));
				float3 temp = float3(frac(skewedCoord), 0);
				temp.z = 1 - temp.x - temp.y;
				
				float s = step(0.0, -temp.z);
				float s2 = 2 * s - 1;
				
				float3 weights = float3(-temp.z * s2, s - temp.y * s2, s - temp.x * s2);
				
				float2 vertex0 = baseId + float2(s, s);
				float2 vertex1 = baseId + float2(s, 1 - s);
				float2 vertex2 = baseId + float2(1 - s, s);
				
				float2 cen0 = HextileMakeCenUV(vertex0), cen1 = HextileMakeCenUV(vertex1), cen2 = HextileMakeCenUV(vertex2);
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = HextileLoadRot2x2(vertex0, _StochasticHexRotationStrength);
					rot1 = HextileLoadRot2x2(vertex1, _StochasticHexRotationStrength);
					rot2 = HextileLoadRot2x2(vertex2, _StochasticHexRotationStrength);
				}
				
				return float4x4(
				float4(mul(uv - cen0, rot0) + cen0 + StochasticHash2D2D(vertex0), rot0[0].x, -rot0[0].y),
				float4(mul(uv - cen1, rot1) + cen1 + StochasticHash2D2D(vertex1), rot1[0].x, -rot1[0].y),
				float4(mul(uv - cen2, rot2) + cen2 + StochasticHash2D2D(vertex2), rot2[0].x, -rot2[0].y),
				float4(weights, 0)
				);
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap, float2 dUVdx, float2 dUVdy)
			{
				// For some reason doing this instead of just calculating it directly prevents it from \
				// breaking after a certain number of textures use it. I don't understand why yet
				float4x4 UVBWR = HextileUVBWR(uv);
				
				// 2D Rotation Matrices for dUVdx/dy
				// Not sure if this constant folds during compiling when rot is locked at 0, so force it
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = float2x2(UVBWR[0].z, -UVBWR[0].w, UVBWR[0].w, UVBWR[0].z);
					rot1 = float2x2(UVBWR[1].z, -UVBWR[1].w, UVBWR[1].w, UVBWR[1].z);
					rot2 = float2x2(UVBWR[2].z, -UVBWR[2].w, UVBWR[2].w, UVBWR[2].z);
				}
				
				// Weights
				float3 W = UVBWR[3].xyz;
				
				// Sample texture
				// float3x4 c = float3x4(
				// 	tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0)),
				// 	tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1)),
				// 	tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2))
				// );
				
				float4 c0 = tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0));
				float4 c1 = tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1));
				float4 c2 = tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2));
				
				// Blend samples using luminance
				// This is technically incorrect for normal maps, but produces very similar
				// results to blending using normal map gradients (steepness)
				const float3 Lw = float3(0.299, 0.587, 0.114);
				float3 Dw = float3(dot(c0.xyz, Lw), dot(c1.xyz, Lw), dot(c2.xyz, Lw));
				
				Dw = lerp(1.0, Dw, _StochasticHexFallOffContrast);
				W = Dw * pow(W, _StochasticHexFallOffPower);
				// In the original hextiling there's a Gain3 step here, but it seems to slow things down \
				// and cause the UVs to break, so I've omitted it. Looks fine without
				
				W /= (W.x + W.y + W.z);
				return W.x * c0 + W.y * c1 + W.z * c2;
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap)
			{
				return HextileSampleTexture(tex, texSampler, uv, isNormalMap, ddx(uv), ddy(uv));
			}
			#endif // defined(_STOCHASTICMODE_HEXTILE)
			
			void applyAlphaOptions(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiMods poiMods)
			{
				poiFragData.alpha = saturate(poiFragData.alpha + _AlphaMod);
				
				if (_AlphaGlobalMask > 0)
				{
					poiFragData.alpha = maskBlend(poiFragData.alpha, poiMods.globalMask[_AlphaGlobalMask-1], _AlphaGlobalMaskBlendType);
				}
				
				//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
				if (_AlphaDistanceFade)
				{
					float3 position = _AlphaDistanceFadeType ? poiMesh.worldPos : poiMesh.objectPosition;
					float distanceFadeMultiplier = lerp(_AlphaDistanceFadeMinAlpha, _AlphaDistanceFadeMaxAlpha, smoothstep(_AlphaDistanceFadeMin, _AlphaDistanceFadeMax, distance(position, poiCam.worldPos)));
					if(_AlphaDistanceFadeGlobalMask > 0)
					{
						distanceFadeMultiplier = lerp(1, distanceFadeMultiplier, poiMods.globalMask[_AlphaDistanceFadeGlobalMask-1]);
					}
					poiFragData.alpha *= distanceFadeMultiplier;
				}
				//endex
				
				//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
				if (_AlphaFresnel)
				{
					float holoRim = saturate(1 - smoothstep(min(_AlphaFresnelSharpness, _AlphaFresnelWidth), _AlphaFresnelWidth, (poiCam.vDotN)));
					holoRim = abs(lerp(1, holoRim, _AlphaFresnelAlpha));
					holoRim = _AlphaFresnelInvert ? 1 - holoRim : holoRim;
					if(_AlphaFresnelGlobalMask > 0)
					{
						holoRim = lerp(1, holoRim, poiMods.globalMask[_AlphaFresnelGlobalMask-1]);
					}
					poiFragData.alpha *= holoRim;
				}
				//endex
				
				//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
				if (_AlphaAngular)
				{
					half cameraAngleMin = _CameraAngleMin / 180;
					half cameraAngleMax = _CameraAngleMax / 180;
					half modelAngleMin = _ModelAngleMin / 180;
					half modelAngleMax = _ModelAngleMax / 180;
					float3 pos = _AngleCompareTo == 0 ? poiMesh.objectPosition : poiMesh.worldPos;
					half3 cameraToModelDirection = normalize(pos - getCameraPosition());
					half3 modelForwardDirection = normalize(mul(unity_ObjectToWorld, normalize(_AngleForwardDirection.rgb)));
					half cameraLookAtModel = remapClamped(cameraAngleMax, cameraAngleMin, .5 * dot(cameraToModelDirection, getCameraForward()) + .5);
					half modelLookAtCamera = remapClamped(modelAngleMax, modelAngleMin, .5 * dot(-cameraToModelDirection, modelForwardDirection) + .5);
					float angularAlphaMod = 1;
					if (_AngleType == 0)
					{
						angularAlphaMod = max(cameraLookAtModel, _AngleMinAlpha);
					}
					else if (_AngleType == 1)
					{
						angularAlphaMod = max(modelLookAtCamera, _AngleMinAlpha);
					}
					else if (_AngleType == 2)
					{
						angularAlphaMod = max(cameraLookAtModel * modelLookAtCamera, _AngleMinAlpha);
					}
					if(_AlphaAngularGlobalMask > 0)
					{
						angularAlphaMod = lerp(1, angularAlphaMod, poiMods.globalMask[_AlphaAngularGlobalMask-1]);
					}
					poiFragData.alpha *= angularAlphaMod;
				}
				//endex
				
				//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && _AlphaAudioLinkEnabled)
				{
					poiFragData.alpha = saturate(poiFragData.alpha + lerp(_AlphaAudioLinkAddRange.x, _AlphaAudioLinkAddRange.y, poiMods.audioLink[_AlphaAudioLinkAddBand]));
				}
				#endif
				//endex
				
			}
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			inline half Dither8x8Bayer(int x, int y)
			{
				// Premultiplied by 1/64
				const half dither[ 64 ] = {
					0.015625, 0.765625, 0.203125, 0.953125, 0.06250, 0.81250, 0.25000, 1.00000,
					0.515625, 0.265625, 0.703125, 0.453125, 0.56250, 0.31250, 0.75000, 0.50000,
					0.140625, 0.890625, 0.078125, 0.828125, 0.18750, 0.93750, 0.12500, 0.87500,
					0.640625, 0.390625, 0.578125, 0.328125, 0.68750, 0.43750, 0.62500, 0.37500,
					0.046875, 0.796875, 0.234375, 0.984375, 0.03125, 0.78125, 0.21875, 0.96875,
					0.546875, 0.296875, 0.734375, 0.484375, 0.53125, 0.28125, 0.71875, 0.46875,
					0.171875, 0.921875, 0.109375, 0.859375, 0.15625, 0.90625, 0.09375, 0.84375,
					0.671875, 0.421875, 0.609375, 0.359375, 0.65625, 0.40625, 0.59375, 0.34375
				};
				int r = y * 8 + x;
				return dither[r];
			}
			
			half calcDither(half2 grabPos)
			{
				return Dither8x8Bayer(glsl_mod(grabPos.x, 8), glsl_mod(grabPos.y, 8));
			}
			
			void applyDithering(inout PoiFragData poiFragData, in PoiCam poiCam)
			{
				if (_AlphaDithering)
				{
					float dither = calcDither(poiCam.screenUV.xy) - _AlphaDitherBias;
					poiFragData.alpha = saturate(poiFragData.alpha - (dither * (1 - poiFragData.alpha) * _AlphaDitherGradient));
				}
			}
			//endex
			
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			void ApplyAlphaToCoverage(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				// Force Model Opacity to 1 if desired
				UNITY_BRANCH
				if (_Mode == 1)
				{
					UNITY_BRANCH
					if (_AlphaSharpenedA2C && _AlphaToCoverage)
					{
						// rescale alpha by mip level
						poiFragData.alpha *= 1 + max(0, CalcMipLevel(poiMesh.uv[0] * _MainTex_TexelSize.zw)) * _AlphaMipScale;
						// rescale alpha by partial derivative
						poiFragData.alpha = (poiFragData.alpha - _Cutoff) / max(fwidth(poiFragData.alpha), 0.0001) + _Cutoff;
						poiFragData.alpha = saturate(poiFragData.alpha);
					}
				}
			}
			//endex
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			void ApplyGlobalMaskTextures(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol0 = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0_ST), _GlobalMaskTexture0Pan);
				if (_GlobalMaskTexture0Split)
				{
					poiMods.globalMask[0] = gmcol0.r;
					poiMods.globalMask[1] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_G), _GlobalMaskTexture0SplitPan_G).g;
					poiMods.globalMask[2] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_B), _GlobalMaskTexture0SplitPan_B).b;
					poiMods.globalMask[3] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_A), _GlobalMaskTexture0SplitPan_A).a;
				} else {
					poiMods.globalMask[0] = gmcol0[0];
					poiMods.globalMask[1] = gmcol0[1];
					poiMods.globalMask[2] = gmcol0[2];
					poiMods.globalMask[3] = gmcol0[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol1 = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1_ST), _GlobalMaskTexture1Pan);
				if (_GlobalMaskTexture1Split)
				{
					poiMods.globalMask[4] = gmcol1.r;
					poiMods.globalMask[5] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_G), _GlobalMaskTexture1SplitPan_G).g;
					poiMods.globalMask[6] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_B), _GlobalMaskTexture1SplitPan_B).b;
					poiMods.globalMask[7] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_A), _GlobalMaskTexture1SplitPan_A).a;
				} else {
					poiMods.globalMask[4] = gmcol1[0];
					poiMods.globalMask[5] = gmcol1[1];
					poiMods.globalMask[6] = gmcol1[2];
					poiMods.globalMask[7] = gmcol1[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol2 = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2_ST), _GlobalMaskTexture2Pan);
				if (_GlobalMaskTexture2Split)
				{
					poiMods.globalMask[8] = gmcol2.r;
					poiMods.globalMask[9] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_G), _GlobalMaskTexture2SplitPan_G).g;
					poiMods.globalMask[10] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_B), _GlobalMaskTexture2SplitPan_B).b;
					poiMods.globalMask[11] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_A), _GlobalMaskTexture2SplitPan_A).a;
				} else {
					poiMods.globalMask[8] = gmcol2[0];
					poiMods.globalMask[9] = gmcol2[1];
					poiMods.globalMask[10] = gmcol2[2];
					poiMods.globalMask[11] = gmcol2[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol3 = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3_ST), _GlobalMaskTexture3Pan);
				if (_GlobalMaskTexture3Split)
				{
					poiMods.globalMask[12] = gmcol3.r;
					poiMods.globalMask[13] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_G), _GlobalMaskTexture3SplitPan_G).g;
					poiMods.globalMask[14] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_B), _GlobalMaskTexture3SplitPan_B).b;
					poiMods.globalMask[15] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_A), _GlobalMaskTexture3SplitPan_A).a;
				} else {
					poiMods.globalMask[12] = gmcol3[0];
					poiMods.globalMask[13] = gmcol3[1];
					poiMods.globalMask[14] = gmcol3[2];
					poiMods.globalMask[15] = gmcol3[3];
				}
				#endif
			}
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			void ApplyGlobalMaskOptions(inout PoiMods poiMods)
			{
				//ifex _GlobalMaskOptionsType!=0
				if (_GlobalMaskOptionsType == 0)
				{
					poiMods.globalMask[0]  = saturate(poiMods.globalMask[0]  + _GlobalMaskSlider_0);
					poiMods.globalMask[1]  = saturate(poiMods.globalMask[1]  + _GlobalMaskSlider_1);
					poiMods.globalMask[2]  = saturate(poiMods.globalMask[2]  + _GlobalMaskSlider_2);
					poiMods.globalMask[3]  = saturate(poiMods.globalMask[3]  + _GlobalMaskSlider_3);
					poiMods.globalMask[4]  = saturate(poiMods.globalMask[4]  + _GlobalMaskSlider_4);
					poiMods.globalMask[5]  = saturate(poiMods.globalMask[5]  + _GlobalMaskSlider_5);
					poiMods.globalMask[6]  = saturate(poiMods.globalMask[6]  + _GlobalMaskSlider_6);
					poiMods.globalMask[7]  = saturate(poiMods.globalMask[7]  + _GlobalMaskSlider_7);
					poiMods.globalMask[8]  = saturate(poiMods.globalMask[8]  + _GlobalMaskSlider_8);
					poiMods.globalMask[9]  = saturate(poiMods.globalMask[9]  + _GlobalMaskSlider_9);
					poiMods.globalMask[10] = saturate(poiMods.globalMask[10] + _GlobalMaskSlider_10);
					poiMods.globalMask[11] = saturate(poiMods.globalMask[11] + _GlobalMaskSlider_11);
					poiMods.globalMask[12] = saturate(poiMods.globalMask[12] + _GlobalMaskSlider_12);
					poiMods.globalMask[13] = saturate(poiMods.globalMask[13] + _GlobalMaskSlider_13);
					poiMods.globalMask[14] = saturate(poiMods.globalMask[14] + _GlobalMaskSlider_14);
					poiMods.globalMask[15] = saturate(poiMods.globalMask[15] + _GlobalMaskSlider_15);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=1
				if (_GlobalMaskOptionsType == 1)
				{
					poiMods.globalMask[0]  = lerp(_GlobalMaskMinMaxSlider_0.x,  _GlobalMaskMinMaxSlider_0.y,  poiMods.globalMask[0]);
					poiMods.globalMask[1]  = lerp(_GlobalMaskMinMaxSlider_1.x,  _GlobalMaskMinMaxSlider_1.y,  poiMods.globalMask[1]);
					poiMods.globalMask[2]  = lerp(_GlobalMaskMinMaxSlider_2.x,  _GlobalMaskMinMaxSlider_2.y,  poiMods.globalMask[2]);
					poiMods.globalMask[3]  = lerp(_GlobalMaskMinMaxSlider_3.x,  _GlobalMaskMinMaxSlider_3.y,  poiMods.globalMask[3]);
					poiMods.globalMask[4]  = lerp(_GlobalMaskMinMaxSlider_4.x,  _GlobalMaskMinMaxSlider_4.y,  poiMods.globalMask[4]);
					poiMods.globalMask[5]  = lerp(_GlobalMaskMinMaxSlider_5.x,  _GlobalMaskMinMaxSlider_5.y,  poiMods.globalMask[5]);
					poiMods.globalMask[6]  = lerp(_GlobalMaskMinMaxSlider_6.x,  _GlobalMaskMinMaxSlider_6.y,  poiMods.globalMask[6]);
					poiMods.globalMask[7]  = lerp(_GlobalMaskMinMaxSlider_7.x,  _GlobalMaskMinMaxSlider_7.y,  poiMods.globalMask[7]);
					poiMods.globalMask[8]  = lerp(_GlobalMaskMinMaxSlider_8.x,  _GlobalMaskMinMaxSlider_8.y,  poiMods.globalMask[8]);
					poiMods.globalMask[9]  = lerp(_GlobalMaskMinMaxSlider_9.x,  _GlobalMaskMinMaxSlider_9.y,  poiMods.globalMask[9]);
					poiMods.globalMask[10] = lerp(_GlobalMaskMinMaxSlider_10.x, _GlobalMaskMinMaxSlider_10.y, poiMods.globalMask[10]);
					poiMods.globalMask[11] = lerp(_GlobalMaskMinMaxSlider_11.x, _GlobalMaskMinMaxSlider_11.y, poiMods.globalMask[11]);
					poiMods.globalMask[12] = lerp(_GlobalMaskMinMaxSlider_12.x, _GlobalMaskMinMaxSlider_12.y, poiMods.globalMask[12]);
					poiMods.globalMask[13] = lerp(_GlobalMaskMinMaxSlider_13.x, _GlobalMaskMinMaxSlider_13.y, poiMods.globalMask[13]);
					poiMods.globalMask[14] = lerp(_GlobalMaskMinMaxSlider_14.x, _GlobalMaskMinMaxSlider_14.y, poiMods.globalMask[14]);
					poiMods.globalMask[15] = lerp(_GlobalMaskMinMaxSlider_15.x, _GlobalMaskMinMaxSlider_15.y, poiMods.globalMask[15]);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=2
				if (_GlobalMaskOptionsType == 2)
				{
					if (_GlobalMaskToggleOn_0)  poiMods.globalMask[0]  = 1;
					if (_GlobalMaskToggleOn_1)  poiMods.globalMask[1]  = 1;
					if (_GlobalMaskToggleOn_2)  poiMods.globalMask[2]  = 1;
					if (_GlobalMaskToggleOn_3)  poiMods.globalMask[3]  = 1;
					if (_GlobalMaskToggleOn_4)  poiMods.globalMask[4]  = 1;
					if (_GlobalMaskToggleOn_5)  poiMods.globalMask[5]  = 1;
					if (_GlobalMaskToggleOn_6)  poiMods.globalMask[6]  = 1;
					if (_GlobalMaskToggleOn_7)  poiMods.globalMask[7]  = 1;
					if (_GlobalMaskToggleOn_8)  poiMods.globalMask[8]  = 1;
					if (_GlobalMaskToggleOn_9)  poiMods.globalMask[9]  = 1;
					if (_GlobalMaskToggleOn_10) poiMods.globalMask[10] = 1;
					if (_GlobalMaskToggleOn_11) poiMods.globalMask[11] = 1;
					if (_GlobalMaskToggleOn_12) poiMods.globalMask[12] = 1;
					if (_GlobalMaskToggleOn_13) poiMods.globalMask[13] = 1;
					if (_GlobalMaskToggleOn_14) poiMods.globalMask[14] = 1;
					if (_GlobalMaskToggleOn_15) poiMods.globalMask[15] = 1;
					
					poiMods.globalMask[0]  *= (1-_GlobalMaskToggleOff_0);
					poiMods.globalMask[1]  *= (1-_GlobalMaskToggleOff_1);
					poiMods.globalMask[2]  *= (1-_GlobalMaskToggleOff_2);
					poiMods.globalMask[3]  *= (1-_GlobalMaskToggleOff_3);
					poiMods.globalMask[4]  *= (1-_GlobalMaskToggleOff_4);
					poiMods.globalMask[5]  *= (1-_GlobalMaskToggleOff_5);
					poiMods.globalMask[6]  *= (1-_GlobalMaskToggleOff_6);
					poiMods.globalMask[7]  *= (1-_GlobalMaskToggleOff_7);
					poiMods.globalMask[8]  *= (1-_GlobalMaskToggleOff_8);
					poiMods.globalMask[9]  *= (1-_GlobalMaskToggleOff_9);
					poiMods.globalMask[10] *= (1-_GlobalMaskToggleOff_10);
					poiMods.globalMask[11] *= (1-_GlobalMaskToggleOff_11);
					poiMods.globalMask[12] *= (1-_GlobalMaskToggleOff_12);
					poiMods.globalMask[13] *= (1-_GlobalMaskToggleOff_13);
					poiMods.globalMask[14] *= (1-_GlobalMaskToggleOff_14);
					poiMods.globalMask[15] *= (1-_GlobalMaskToggleOff_15);
				}
				//endex
			}
			//endex
			
			float customDistanceBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					default: return 0; break;
				}
			}
			
			void ApplyGlobalMaskModifiers(in PoiMesh poiMesh, inout PoiMods poiMods, in PoiCam poiCam)
			{
				//ifex _GlobalMaskModifiersBackfaceEnable==0
				if(_GlobalMaskModifiersBackfaceEnable)
				{
					float facingMode = saturate(poiMesh.isFrontFace) + 1;
					// _GlobalMaskBackface is 0 for ignore, 1 for back only, 2 for front only
					poiMods.globalMask[0]  *= _GlobalMaskBackface_0  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskBackface_1  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskBackface_2  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskBackface_3  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskBackface_4  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskBackface_5  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskBackface_6  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskBackface_7  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskBackface_8  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskBackface_9  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_9 ));
					poiMods.globalMask[10] *= _GlobalMaskBackface_10 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_10));
					poiMods.globalMask[11] *= _GlobalMaskBackface_11 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_11));
					poiMods.globalMask[12] *= _GlobalMaskBackface_12 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_12));
					poiMods.globalMask[13] *= _GlobalMaskBackface_13 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_13));
					poiMods.globalMask[14] *= _GlobalMaskBackface_14 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_14));
					poiMods.globalMask[15] *= _GlobalMaskBackface_15 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersMirrorEnable==0
				if(_GlobalMaskModifiersMirrorEnable)
				{
					float mirrorMode = 0;
					if (_GlobalMaskMirrorVisibilityMode == 1) // VRC
					mirrorMode = VRCMirrorMode() > 0;
					else // Generic (CVR, etc)
					mirrorMode = IsInMirror();
					
					mirrorMode += 1;
					// _GlobalMaskMirror is 0 for ignore, 1 for outside mirror only, 2 for in mirror only
					poiMods.globalMask[0]  *= _GlobalMaskMirror_0  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskMirror_1  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskMirror_2  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskMirror_3  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskMirror_4  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskMirror_5  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskMirror_6  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskMirror_7  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskMirror_8  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskMirror_9  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_9 ));
					poiMods.globalMask[10] *= _GlobalMaskMirror_10 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_10));
					poiMods.globalMask[11] *= _GlobalMaskMirror_11 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_11));
					poiMods.globalMask[12] *= _GlobalMaskMirror_12 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_12));
					poiMods.globalMask[13] *= _GlobalMaskMirror_13 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_13));
					poiMods.globalMask[14] *= _GlobalMaskMirror_14 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_14));
					poiMods.globalMask[15] *= _GlobalMaskMirror_15 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersCameraEnable==0
				if(_GlobalMaskModifiersCameraEnable)
				{
					float isCamera = VRCCameraMode() > 0;
					isCamera += 1;
					// _GlobalMaskCamera is 0 for ignore, 1 for outside camera only, 2 for in camera only
					poiMods.globalMask[0]  *= _GlobalMaskCamera_0  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskCamera_1  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskCamera_2  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskCamera_3  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskCamera_4  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskCamera_5  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskCamera_6  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskCamera_7  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskCamera_8  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskCamera_9  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_9 ));
					poiMods.globalMask[10] *= _GlobalMaskCamera_10 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_10));
					poiMods.globalMask[11] *= _GlobalMaskCamera_11 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_11));
					poiMods.globalMask[12] *= _GlobalMaskCamera_12 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_12));
					poiMods.globalMask[13] *= _GlobalMaskCamera_13 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_13));
					poiMods.globalMask[14] *= _GlobalMaskCamera_14 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_14));
					poiMods.globalMask[15] *= _GlobalMaskCamera_15 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_15));
				}
				//endex
				//ifex _GlobalMaskModifiersDistanceEnable==0
				if (_GlobalMaskModifiersDistanceEnable)
				{
					//ifex _GlobalMaskDistanceEnable_0==0
					if (_GlobalMaskDistanceEnable_0)
					{
						float3 position = _GlobalMaskDistanceType_0 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_0, _GlobalMaskDistanceMaxAlpha_0, smoothstep(_GlobalMaskDistanceMin_0, _GlobalMaskDistanceMax_0, distance(position, poiCam.worldPos)));
						poiMods.globalMask[0] = saturate(customDistanceBlend(poiMods.globalMask[0], val, _GlobalMaskDistanceBlendType_0));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_1==0
					if (_GlobalMaskDistanceEnable_1)
					{
						float3 position = _GlobalMaskDistanceType_1 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_1, _GlobalMaskDistanceMaxAlpha_1, smoothstep(_GlobalMaskDistanceMin_1, _GlobalMaskDistanceMax_1, distance(position, poiCam.worldPos)));
						poiMods.globalMask[1] = saturate(customDistanceBlend(poiMods.globalMask[1], val, _GlobalMaskDistanceBlendType_1));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_2==0
					if (_GlobalMaskDistanceEnable_2)
					{
						float3 position = _GlobalMaskDistanceType_2 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_2, _GlobalMaskDistanceMaxAlpha_2, smoothstep(_GlobalMaskDistanceMin_2, _GlobalMaskDistanceMax_2, distance(position, poiCam.worldPos)));
						poiMods.globalMask[2] = saturate(customDistanceBlend(poiMods.globalMask[2], val, _GlobalMaskDistanceBlendType_2));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_3==0
					if (_GlobalMaskDistanceEnable_3)
					{
						float3 position = _GlobalMaskDistanceType_3 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_3, _GlobalMaskDistanceMaxAlpha_3, smoothstep(_GlobalMaskDistanceMin_3, _GlobalMaskDistanceMax_3, distance(position, poiCam.worldPos)));
						poiMods.globalMask[3] = saturate(customDistanceBlend(poiMods.globalMask[3], val, _GlobalMaskDistanceBlendType_3));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_4==0
					if (_GlobalMaskDistanceEnable_4)
					{
						float3 position = _GlobalMaskDistanceType_4 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_4, _GlobalMaskDistanceMaxAlpha_4, smoothstep(_GlobalMaskDistanceMin_4, _GlobalMaskDistanceMax_4, distance(position, poiCam.worldPos)));
						poiMods.globalMask[4] = saturate(customDistanceBlend(poiMods.globalMask[4], val, _GlobalMaskDistanceBlendType_4));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_5==0
					if (_GlobalMaskDistanceEnable_5)
					{
						float3 position = _GlobalMaskDistanceType_5 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_5, _GlobalMaskDistanceMaxAlpha_5, smoothstep(_GlobalMaskDistanceMin_5, _GlobalMaskDistanceMax_5, distance(position, poiCam.worldPos)));
						poiMods.globalMask[5] = saturate(customDistanceBlend(poiMods.globalMask[5], val, _GlobalMaskDistanceBlendType_5));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_6==0
					if (_GlobalMaskDistanceEnable_6)
					{
						float3 position = _GlobalMaskDistanceType_6 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_6, _GlobalMaskDistanceMaxAlpha_6, smoothstep(_GlobalMaskDistanceMin_6, _GlobalMaskDistanceMax_6, distance(position, poiCam.worldPos)));
						poiMods.globalMask[6] = saturate(customDistanceBlend(poiMods.globalMask[6], val, _GlobalMaskDistanceBlendType_6));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_7==0
					if (_GlobalMaskDistanceEnable_7)
					{
						float3 position = _GlobalMaskDistanceType_7 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_7, _GlobalMaskDistanceMaxAlpha_7, smoothstep(_GlobalMaskDistanceMin_7, _GlobalMaskDistanceMax_7, distance(position, poiCam.worldPos)));
						poiMods.globalMask[7] = saturate(customDistanceBlend(poiMods.globalMask[7], val, _GlobalMaskDistanceBlendType_7));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_8==0
					if (_GlobalMaskDistanceEnable_8)
					{
						float3 position = _GlobalMaskDistanceType_8 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_8, _GlobalMaskDistanceMaxAlpha_8, smoothstep(_GlobalMaskDistanceMin_8, _GlobalMaskDistanceMax_8, distance(position, poiCam.worldPos)));
						poiMods.globalMask[8] = saturate(customDistanceBlend(poiMods.globalMask[8], val, _GlobalMaskDistanceBlendType_8));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_9==0
					if (_GlobalMaskDistanceEnable_9)
					{
						float3 position = _GlobalMaskDistanceType_9 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_9, _GlobalMaskDistanceMaxAlpha_9, smoothstep(_GlobalMaskDistanceMin_9, _GlobalMaskDistanceMax_9, distance(position, poiCam.worldPos)));
						poiMods.globalMask[9] = saturate(customDistanceBlend(poiMods.globalMask[9], val, _GlobalMaskDistanceBlendType_9));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_10==0
					if (_GlobalMaskDistanceEnable_10)
					{
						float3 position = _GlobalMaskDistanceType_10 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_10, _GlobalMaskDistanceMaxAlpha_10, smoothstep(_GlobalMaskDistanceMin_10, _GlobalMaskDistanceMax_10, distance(position, poiCam.worldPos)));
						poiMods.globalMask[10] = saturate(customDistanceBlend(poiMods.globalMask[10], val, _GlobalMaskDistanceBlendType_10));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_11==0
					if (_GlobalMaskDistanceEnable_11)
					{
						float3 position = _GlobalMaskDistanceType_11 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_11, _GlobalMaskDistanceMaxAlpha_11, smoothstep(_GlobalMaskDistanceMin_11, _GlobalMaskDistanceMax_11, distance(position, poiCam.worldPos)));
						poiMods.globalMask[11] = saturate(customDistanceBlend(poiMods.globalMask[11], val, _GlobalMaskDistanceBlendType_11));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_12==0
					if (_GlobalMaskDistanceEnable_12)
					{
						float3 position = _GlobalMaskDistanceType_12 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_12, _GlobalMaskDistanceMaxAlpha_12, smoothstep(_GlobalMaskDistanceMin_12, _GlobalMaskDistanceMax_12, distance(position, poiCam.worldPos)));
						poiMods.globalMask[12] = saturate(customDistanceBlend(poiMods.globalMask[12], val, _GlobalMaskDistanceBlendType_12));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_13==0
					if (_GlobalMaskDistanceEnable_13)
					{
						float3 position = _GlobalMaskDistanceType_13 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_13, _GlobalMaskDistanceMaxAlpha_13, smoothstep(_GlobalMaskDistanceMin_13, _GlobalMaskDistanceMax_13, distance(position, poiCam.worldPos)));
						poiMods.globalMask[13] = saturate(customDistanceBlend(poiMods.globalMask[13], val, _GlobalMaskDistanceBlendType_13));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_14==0
					if (_GlobalMaskDistanceEnable_14)
					{
						float3 position = _GlobalMaskDistanceType_14 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_14, _GlobalMaskDistanceMaxAlpha_14, smoothstep(_GlobalMaskDistanceMin_14, _GlobalMaskDistanceMax_14, distance(position, poiCam.worldPos)));
						poiMods.globalMask[14] = saturate(customDistanceBlend(poiMods.globalMask[14], val, _GlobalMaskDistanceBlendType_14));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_15==0
					if (_GlobalMaskDistanceEnable_15)
					{
						float3 position = _GlobalMaskDistanceType_15 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_15, _GlobalMaskDistanceMaxAlpha_15, smoothstep(_GlobalMaskDistanceMin_15, _GlobalMaskDistanceMax_15, distance(position, poiCam.worldPos)));
						poiMods.globalMask[15] = saturate(customDistanceBlend(poiMods.globalMask[15], val, _GlobalMaskDistanceBlendType_15));
					}
					//endex
				}
				//endex
			}
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			void applyUDIMDiscard(in VertexOut i)
			{
				if(_UDIMDiscardMode == 1) // Don't run if in vertex mode
				{
					float2 udim = floor(vertexUV(i, _UDIMDiscardUV));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					const float threshold = 0.001;
					clip(threshold - isDiscarded); // Clip if discarded
				}
				
				return;
			}
			#endif
			//endex
			
			float2 calculatePolarCoordinate(in PoiMesh poiMesh)
			{
				float2 delta = poiMesh.uv[_PolarUV] - _PolarCenter;
				float radius = length(delta) * 2 * _PolarRadialScale;
				float angle = atan2(delta.x, delta.y);
				float phi = angle / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				angle = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				angle *= _PolarLengthScale;
				
				return float2(radius, angle + distance(poiMesh.uv[_PolarUV], _PolarCenter) * _PolarSpiralPower);
			}
			
			float2 MonoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(1.0, 1.0 / UNITY_PI);
				sphereCoords = float2(1.0, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).zw;
			}
			
			float2 StereoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(0.5, 1.0 / UNITY_PI);
				sphereCoords = float2(0.5, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).zw;
			}
			
			float2 calculateWorldUV(in PoiMesh poiMesh)
			{
				return float2(_UVModWorldPos0 != 3 ? poiMesh.worldPos[ _UVModWorldPos0] : 0.0f, _UVModWorldPos1 != 3 ? poiMesh.worldPos[_UVModWorldPos1] : 0.0f);
			}
			
			float2 calculatelocalUV(in PoiMesh poiMesh)
			{
				float localUVs[8];
				localUVs[0] = poiMesh.localPos.x;
				localUVs[1] = poiMesh.localPos.y;
				localUVs[2] = poiMesh.localPos.z;
				localUVs[3] = 0;
				localUVs[4] = poiMesh.vertexColor.r;
				localUVs[5] = poiMesh.vertexColor.g;
				localUVs[6] = poiMesh.vertexColor.b;
				localUVs[7] = poiMesh.vertexColor.a;
				
				return float2(localUVs[_UVModLocalPos0],localUVs[_UVModLocalPos1]);
			}
			
			float2 calculatePanosphereUV(in PoiMesh poiMesh)
			{
				float3 viewDirection = normalize(lerp(getCameraPosition().xyz, _WorldSpaceCameraPos.xyz, _PanoUseBothEyes) - poiMesh.worldPos.xyz) * - 1;
				return lerp(MonoPanoProjection(viewDirection), StereoPanoProjection(viewDirection), _StereoEnabled);
			}
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			float2 distortedUV(in PoiMesh poiMesh)
			{
				#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector = POI2D_SAMPLER_PAN(_DistortionFlowTexture, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTextureUV], _DistortionFlowTexture_ST), _DistortionFlowTexturePan) * 2 - 1;
				#else
				float4 flowVector = -1;
				#endif
				
				#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector1 = POI2D_SAMPLER_PAN(_DistortionFlowTexture1, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTexture1UV], _DistortionFlowTexture1_ST), _DistortionFlowTexture1Pan) * 2 - 1;
				#else
				float4 flowVector1 = -1;
				#endif
				
				#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
				half distortionMask = POI2D_SAMPLER_PAN(_DistortionMask, _MainTex, poiMesh.uv[_DistortionMaskUV], _DistortionMaskPan)[_DistortionMaskChannel];
				#else
				half distortionMask = 1;
				#endif
				
				half distortionStrength = _DistortionStrength;
				half distortionStrength1 = _DistortionStrength1;
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (AudioLinkIsAvailable() && _EnableDistortionAudioLink && _AudioLinkAnimToggle)
				{
					distortionStrength += lerp(_DistortionStrengthAudioLink.x, _DistortionStrengthAudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrengthAudioLinkBand))).r);
					distortionStrength1 += lerp(_DistortionStrength1AudioLink.x, _DistortionStrength1AudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrength1AudioLinkBand))).r);
				}
				#endif
				
				flowVector *= distortionStrength;
				flowVector1 *= distortionStrength1;
				return poiMesh.uv[_DistortionUvToDistort] + ((flowVector.xy + flowVector1.xy) / 2) * distortionMask;
			}
			#endif
			//endex
			
			//ifex _PoiParallax==0
			#ifdef POI_PARALLAX
			inline float2 POM(in PoiLight poiLight, sampler2D heightMap, in PoiMesh poiMesh, float3 worldViewDir, float3 viewDirTan, int minSamples, int maxSamples, float parallax, float refPlane, float2 tilling, float2 curv)
			{
				#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float heightMask = POI2D_SAMPLER_PAN(_Heightmask, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmask_ST), _HeightmaskPan)[_HeightmaskChannel];
				if (_HeightmaskInvert)
				{
					heightMask = 1 - heightMask;
				}
				#else
				float heightMask = 1;
				#endif
				
				float2 uvs = poiUV(poiMesh.uv[_HeightMapUV], _HeightMap_ST);
				float2 dx = ddx(uvs);
				float2 dy = ddy(uvs);
				float3 result = 0;
				int stepIndex = 0;
				int numSteps = (int)lerp(maxSamples, minSamples, saturate(dot(poiMesh.normals[0], worldViewDir)));
				float layerHeight = 1.0 / numSteps;
				float2 plane = parallax * heightMask * (viewDirTan.xy / viewDirTan.z);
				uvs += refPlane * plane;
				float2 deltaTex = -plane * layerHeight;
				float2 prevTexOffset = 0;
				float prevRayZ = 1.0f;
				float prevHeight = 0.0f;
				float2 currTexOffset = deltaTex;
				float currRayZ = 1.0f - layerHeight;
				float currHeight = 0.0f;
				float intersection = 0;
				float2 finalTexOffset = 0;
				while (stepIndex < numSteps + 1)
				{
					result.z = dot(curv, currTexOffset * currTexOffset);
					currHeight = tex2Dgrad(heightMap, uvs + currTexOffset, dx, dy).r * (1 - result.z);
					if (currHeight > currRayZ)
					{
						stepIndex = numSteps + 1;
					}
					else
					{
						stepIndex++;
						prevTexOffset = currTexOffset;
						prevRayZ = currRayZ;
						prevHeight = currHeight;
						currTexOffset += deltaTex;
						currRayZ -= layerHeight * (1 - result.z) * (1 + _CurvFix);
					}
				}
				int sectionSteps = 10;
				int sectionIndex = 0;
				float newZ = 0;
				float newHeight = 0;
				while (sectionIndex < sectionSteps)
				{
					intersection = (prevHeight - prevRayZ) / (prevHeight - currHeight + currRayZ - prevRayZ);
					finalTexOffset = prevTexOffset +intersection * deltaTex;
					newZ = prevRayZ - intersection * layerHeight;
					newHeight = tex2Dgrad(heightMap, uvs + finalTexOffset, dx, dy).r;
					if (newHeight > newZ)
					{
						currTexOffset = finalTexOffset;
						currHeight = newHeight;
						currRayZ = newZ;
						deltaTex = intersection * deltaTex;
						layerHeight = intersection * layerHeight;
					}
					else
					{
						prevTexOffset = finalTexOffset;
						prevHeight = newHeight;
						prevRayZ = newZ;
						deltaTex = (1 - intersection) * deltaTex;
						layerHeight = (1 - intersection) * layerHeight;
					}
					sectionIndex++;
				}
				#ifdef UNITY_PASS_SHADOWCASTER
				if (unity_LightShadowBias.z == 0.0)
				{
					#endif
					if (result.z > 1)
					clip(-1);
					#ifdef UNITY_PASS_SHADOWCASTER
				}
				#endif
				
				return uvs + finalTexOffset;
			}
			/*
			float2 ParallaxOffsetMultiStep(float surfaceHeight, float strength, float2 uv, float3 tangentViewDir)
			{
				float2 uvOffset = 0;
				float2 prevUVOffset = 0;
				float stepSize = 1.0 / _HeightSteps;
				float stepHeight = 1;
				float2 uvDelta = tangentViewDir.xy * (stepSize * strength);
				float prevStepHeight = stepHeight;
				float prevSurfaceHeight = surfaceHeight;
				
				[unroll(20)]
				for (int j = 1; j <= _HeightSteps && stepHeight > surfaceHeight; j++)
				{
					prevUVOffset = uvOffset;
					prevStepHeight = stepHeight;
					prevSurfaceHeight = surfaceHeight;
					uvOffset -= uvDelta;
					stepHeight -= stepSize;
					surfaceHeight = POI2D_SAMPLER_PAN(_Heightmap, _MainTex, poiUV(uv + uvOffset, _Heightmap_ST), _HeightmapPan) + _HeightOffset;
				}
				
				[unroll(3)]
				for (int k = 0; k < 3; k++)
				{
					uvDelta *= 0.5;
					stepSize *= 0.5;
					
					if (stepHeight < surfaceHeight)
					{
						uvOffset += uvDelta;
						stepHeight += stepSize;
					}
					else
					{
						uvOffset -= uvDelta;
						stepHeight -= stepSize;
					}
					surfaceHeight = POI2D_SAMPLER_PAN(_Heightmap, _MainTex, poiUV(uv + uvOffset, _Heightmap_ST), _HeightmapPan) + _HeightOffset;
				}
				return uvOffset;
			}
			*/
			void applyParallax(inout PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam)
			{
				/*
				half h = POI2D_SAMPLER_PAN(_Heightmap, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmap_ST), _HeightmapPan).r + _HeightOffset;
				#if defined(PROP_HEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				half m = POI2D_SAMPLER_PAN(_Heightmask, _linear_repeat, poiUV(poiMesh.uv[_HeightmaskUV], _Heightmask_ST), _HeightmaskPan).r + _HeightOffset;
				#else
				half m = 1 + _HeightOffset;
				#endif
				h = clamp(h, 0, 0.999);
				m = lerp(m, 1 - m, _HeightmaskInvert);
				#if defined(OPTIMIZER_ENABLED)das
				poiMesh.uv[_ParallaxUV] += ParallaxOffsetMultiStep(h, _HeightStrength * m, poiMesh.uv[_HeightmapUV], tangentViewDir / tangentViewDir.z);
				#else
				float2 offset = ParallaxOffsetMultiStep(h, _HeightStrength * m, poiMesh.uv[_HeightmapUV], tangentViewDir / tangentViewDir.z);
				if (_ParallaxUV == 0)       poiMesh.uv[0] += offset;
				if (_ParallaxUV == 1)       poiMesh.uv[1] += offset;
				if (_ParallaxUV == 2)       poiMesh.uv[2] += offset;
				if (_ParallaxUV == 3)       poiMesh.uv[3] += offset;
				if (_ParallaxUV == 4)       poiMesh.uv[4] += offset;
				if (_ParallaxUV == 5)       poiMesh.uv[5] += offset;
				if (_ParallaxUV == 6)       poiMesh.uv[6] += offset;
				if (_ParallaxUV == 7)       poiMesh.uv[7] += offset;
				#endif
				*/
				
				#if defined(OPTIMIZER_ENABLED)
				poiMesh.uv[_ParallaxUV] = POM(poiLight, _HeightMap, poiMesh, poiCam.viewDir, poiCam.tangentViewDir, _HeightStepsMin, _HeightStepsMax, _HeightStrength, 0, _HeightMap_ST.xy, float2(_CurvatureU, _CurvatureV));
				#else
				float2 offset = POM(poiLight, _HeightMap, poiMesh, poiCam.viewDir, poiCam.tangentViewDir, _HeightStepsMin, _HeightStepsMax, _HeightStrength, 0, _HeightMap_ST.xy, float2(_CurvatureU, _CurvatureV));
				if (_ParallaxUV == 0)       poiMesh.uv[0] = offset;
				if (_ParallaxUV == 1)       poiMesh.uv[1] = offset;
				if (_ParallaxUV == 2)       poiMesh.uv[2] = offset;
				if (_ParallaxUV == 3)       poiMesh.uv[3] = offset;
				if (_ParallaxUV == 4)       poiMesh.uv[4] = offset;
				if (_ParallaxUV == 5)       poiMesh.uv[5] = offset;
				if (_ParallaxUV == 6)       poiMesh.uv[6] = offset;
				if (_ParallaxUV == 7)       poiMesh.uv[7] = offset;
				#endif
			}
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			void calculateBlackLightMasks(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#ifdef VERTEXLIGHT_ON
				for (int lightIndex = 0; lightIndex < 4; lightIndex ++)
				{
					float3 lightPos = float3(unity_4LightPosX0[lightIndex], unity_4LightPosY0[lightIndex], unity_4LightPosZ0[lightIndex]);
					if (!distance(unity_LightColor[lightIndex].rgb, float3(0, 0, 0)))
					{
						if (_BlackLightMasking0GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking0Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking0GlobalMaskIndex-1, _BlackLightMasking0GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking1GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking1Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking1GlobalMaskIndex-1, _BlackLightMasking1GlobalMaskBlendType, smoothstep(_BlackLightMasking1Range.y, _BlackLightMasking1Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking2GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking2Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking2GlobalMaskIndex-1, _BlackLightMasking2GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking3GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking3Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking3GlobalMaskIndex-1, _BlackLightMasking3GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
					}
				}
				#endif
			}
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			void applyVertexColor(inout PoiFragData poiFragData, PoiMesh poiMesh)
			{
				if (_MainVertexColoringEnabled)
				{
					#ifndef POI_PASS_OUTLINE
					float3 vertCol = lerp(poiMesh.vertexColor.rgb, GammaToLinearSpace(poiMesh.vertexColor.rgb), _MainVertexColoringLinearSpace);
					poiFragData.baseColor *= lerp(1, vertCol, _MainVertexColoring);
					#endif
					poiFragData.alpha *= lerp(1, poiMesh.vertexColor.a, _MainUseVertexColorAlpha);
				}
			}
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			void ApplyBackFaceColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				if (!poiMesh.isFrontFace)
				{
					float4 backFaceColor = _BackFaceColor;
					backFaceColor.rgb = poiThemeColor(poiMods, backFaceColor.rgb, _BackFaceColorThemeIndex);
					#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
					backFaceColor *= POI2D_SAMPLER_PAN(_BackFaceTexture, _MainTex, poiUV(poiMesh.uv[_BackFaceTextureUV], _BackFaceTexture_ST), _BackFaceTexturePan);
					#endif
					backFaceColor.rgb = hueShift(backFaceColor.rgb, frac(_BackFaceHueShift + _BackFaceHueShiftSpeed * _Time.x) * _BackFaceHueShiftEnabled);
					
					float backFaceMask = 1;
					#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
					backFaceMask *= POI2D_SAMPLER_PAN(_BackFaceMask, _MainTex, poiUV(poiMesh.uv[_BackFaceMaskUV], _BackFaceMask_ST), _BackFaceMaskPan)[_BackFaceMaskChannel];
					#endif
					if (!_BackFaceReplaceAlpha)
					{
						backFaceMask *= backFaceColor.a;
					}
					
					poiFragData.baseColor = lerp(poiFragData.baseColor, backFaceColor.rgb, backFaceMask);
					
					UNITY_BRANCH
					if (_BackFaceReplaceAlpha)
					{
						poiFragData.alpha = backFaceColor.a;
					}
					
					poiFragData.emission += backFaceColor.rgb * _BackFaceEmissionStrength * backFaceMask;
					poiMods.globalEmission = min(poiMods.globalEmission, _BackFaceEmissionLimiter);
				}
			}
			#endif
			//endex
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			void applyDissolve(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods, in PoiCam poiCam, in PoiLight poiLight)
			{
				#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
				float dissolveMask = POI2D_SAMPLER_PAN(_DissolveMask, _MainTex, poiUV(poiMesh.uv[_DissolveMaskUV], _DissolveMask_ST), _DissolveMaskPan).r;
				#else
				float dissolveMask = 1;
				#endif
				UNITY_BRANCH
				if (_DissolveUseVertexColors > 0)
				{
					// Vertex Color Imprecision hype
					dissolveMask = ceil(poiMesh.vertexColor[_DissolveUseVertexColors] * 100000) / 100000;
				}
				if (_DissolveMaskGlobalMask > 0)
				{
					dissolveMask = maskBlend(dissolveMask, poiMods.globalMask[_DissolveMaskGlobalMask-1], _DissolveMaskGlobalMaskBlendType);
				}
				
				#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
				dissolveToTexture = POI2D_SAMPLER_PAN(_DissolveToTexture, _MainTex, poiUV(poiMesh.uv[_DissolveToTextureUV], _DissolveToTexture_ST), _DissolveToTexturePan) * float4(poiThemeColor(poiMods, _DissolveTextureColor.rgb, _DissolveTextureColorThemeIndex), _DissolveTextureColor.a);
				#else
				dissolveToTexture = _DissolveTextureColor;
				#endif
				
				#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float dissolveNoiseTexture = POI2D_SAMPLER_PAN(_DissolveNoiseTexture, _MainTex, poiUV(poiMesh.uv[_DissolveNoiseTextureUV], _DissolveNoiseTexture_ST), _DissolveNoiseTexturePan).r;
				#else
				float dissolveNoiseTexture = 1;
				#endif
				
				float da = _DissolveAlpha
				+ _DissolveAlpha0
				+ _DissolveAlpha1
				+ _DissolveAlpha2
				+ _DissolveAlpha3
				+ _DissolveAlpha4
				+ _DissolveAlpha5
				+ _DissolveAlpha6
				+ _DissolveAlpha7
				+ _DissolveAlpha8
				+ _DissolveAlpha9;
				float dds = _DissolveDetailStrength;
				
				if(_UVTileDissolveEnabled)
				{
					float2 udim = floor(poiMesh.uv[(int)_UVTileDissolveUV]);
					
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					da += (udim.y >= 0 && udim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMask);
					da += (udim.y >= 1 && udim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMask);
					da += (udim.y >= 2 && udim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMask);
					da += (udim.y >= 3 && udim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMask);
				}
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (_EnableDissolveAudioLink && poiMods.audioLinkAvailable)
				{
					da += lerp(_AudioLinkDissolveAlpha.x, _AudioLinkDissolveAlpha.y, poiMods.audioLink[_AudioLinkDissolveAlphaBand]);
					dds += lerp(_AudioLinkDissolveDetail.x, _AudioLinkDissolveDetail.y, poiMods.audioLink[_AudioLinkDissolveDetailBand]);
				}
				#endif
				
				da = saturate(da);
				dds = saturate(dds);
				
				if (_DissolveMaskInvert)
				{
					dissolveMask = 1 - dissolveMask;
				}
				#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
				float dissolveDetailNoise = POI2D_SAMPLER_PAN(_DissolveDetailNoise, _MainTex, poiUV(poiMesh.uv[_DissolveDetailNoiseUV], _DissolveDetailNoise_ST), _DissolveDetailNoisePan);
				#else
				float dissolveDetailNoise = 0;
				#endif
				if (_DissolveInvertNoise)
				{
					dissolveNoiseTexture = 1 - dissolveNoiseTexture;
				}
				if (_DissolveInvertDetailNoise)
				{
					dissolveDetailNoise = 1 - dissolveDetailNoise;
				}
				if (_ContinuousDissolve != 0)
				{
					da = sin(_Time.x * _ContinuousDissolve) * .5 + .5;
				}
				da *= dissolveMask;
				dissolveAlpha = da;
				edgeAlpha = 0;
				
				[flatten]
				switch(_DissolveType)
				{
					default: // Basic (case 1)
					{
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						float noise = saturate(dissolveNoiseTexture - dissolveDetailNoise * dds);
						
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
					case 2: // Point to Point
					{
						float3 direction;
						float3 currentPos;
						float distanceTo = 0;
						direction = normalize(_DissolveEndPoint - _DissolveStartPoint);
						currentPos = lerp(_DissolveStartPoint, _DissolveEndPoint, dissolveAlpha);
						
						UNITY_BRANCH
						if (_DissolveP2PWorldLocal != 1)
						{
							float3 pos = _DissolveP2PWorldLocal == 0 ? poiMesh.localPos.rgb : poiMesh.vertexColor.rgb;
							distanceTo = dot(pos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = step(distanceTo, 0);
							edgeAlpha *= 1 - dissolveAlpha;
						}
						else
						{
							distanceTo = dot(poiMesh.worldPos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = (distanceTo < 0) ? 1 : 0;
							edgeAlpha *= 1 - dissolveAlpha;
						}
						
						if(_DissolveP2PClamp)
						{
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 3: // Spherical
					{
						if(_SphericalDissolveInvert)
						{
							da = remap(da, 1, 0, -_DissolveEdgeWidth, 1);
						} else {
							da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						}
						
						dissolveAlpha = da;
						dds *= smoothstep(0, 0.2*dds + 0.01, dissolveAlpha) * lerp(1, smoothstep(1, 1 - 0.2*dds - 0.01, dissolveAlpha), _DissolveDetailEdgeSmoothing);
						float currentDistance = lerp(0, _SphericalDissolveRadius, dissolveAlpha);
						float fragDistance = distance(_SphericalDissolveCenter, poiMesh.localPos.xyz);
						float normalizedDistance;
						normalizedDistance = (fragDistance - currentDistance) / (_SphericalDissolveRadius + 0.0001)  - dissolveDetailNoise * dds;
						
						if(_SphericalDissolveInvert)
						{
							dissolveAlpha = (normalizedDistance > 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, -normalizedDistance);
						} else {
							dissolveAlpha = (normalizedDistance < 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, normalizedDistance);
						}
						
						if(_SphericalDissolveClamp)
						{
							da = lerp(da, 1 - da, _SphericalDissolveInvert);
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 4: // CenterOut
					{
						float ramp = 0.5;
						float noise;
						
						[flatten]
						switch(_CenterOutDissolveMode)
						{
							case 1: // View Direction
							{
								ramp = saturate(lerp(poiLight.vertexNDotV, poiLight.nDotV, _CenterOutDissolveNormals));
								break;
							}
							case 2: // Custom Direction
							{
								ramp = dot(normalize(_CenterOutDissolveDirection), lerp(poiMesh.normals[0], poiMesh.normals[1], _CenterOutDissolveNormals));
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
							case 3: // Light Direction
							{
								ramp = lerp(poiLight.vertexNDotL, poiLight.nDotL, _CenterOutDissolveNormals);
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
						}
						
						if(_CenterOutDissolvePower != 1)
						{
							ramp = pow(ramp, _CenterOutDissolvePower);
						}
						
						if(!_CenterOutDissolveInvert)
						{
							ramp = 1 - ramp;
						}
						
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						
						noise = saturate(ramp - dissolveDetailNoise * dds);
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
				}
				
				#ifndef POI_SHADOW
				UNITY_BRANCH
				if (_DissolveHueShiftEnabled)
				{
					dissolveToTexture.rgb = hueShift(dissolveToTexture.rgb, _DissolveHueShift + _Time.x * _DissolveHueShiftSpeed);
				}
				#endif
				
				poiFragData.alpha = lerp(poiFragData.alpha, dissolveToTexture.a, dissolveAlpha * .999999);
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				poiFragData.baseColor = lerp(poiFragData.baseColor, dissolveToTexture.rgb, dissolveAlpha * .999999);
				
				UNITY_BRANCH
				if (_DissolveEdgeWidth || (_DissolveType == 2 && _DissolveP2PEdgeLength != 0))
				{
					edgeColor = tex2D(_DissolveEdgeGradient, poiUV(float2(edgeAlpha, edgeAlpha), _DissolveEdgeGradient_ST)) * float4(poiThemeColor(poiMods, _DissolveEdgeColor.rgb, _DissolveEdgeColorThemeIndex), _DissolveEdgeColor.a);
					#ifndef POI_SHADOW
					UNITY_BRANCH
					if (_DissolveEdgeHueShiftEnabled)
					{
						edgeColor.rgb = hueShift(edgeColor.rgb, _DissolveEdgeHueShift + _Time.x * _DissolveEdgeHueShiftSpeed);
					}
					#endif
					poiFragData.baseColor = lerp(poiFragData.baseColor, edgeColor.rgb, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				}
				
				poiFragData.emission += lerp(0, dissolveToTexture * _DissolveToEmissionStrength, dissolveAlpha) + lerp(0, edgeColor.rgb * _DissolveEdgeEmission, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				#endif
			}
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			void ApplyAudioLinkDecal(in PoiMesh poiMesh, inout PoiFragData poiFragData, in PoiMods poiMods)
			{
				float4 colorAndMask = float4(1, 1, 1, 1);
				#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
				colorAndMask = POI2D_SAMPLER_PAN(_ALDecalColorMask, _MainTex, poiUV(poiMesh.uv[_ALDecalColorMaskUV], _ALDecalColorMask_ST), _ALDecalColorMaskPan);
				#endif
				
				float2 uv = poiMesh.uv[_ALDecalUV];
				float2 decalCenter = _ALUVPosition;
				float theta = radians(_ALUVRotation + _Time.z * _ALUVRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
				uv = remap(uv, float2(0, 0) - _ALUVScale.xz / 2 + _ALUVPosition, _ALUVScale.yw / 2 + _ALUVPosition, float2(0, 0), float2(1, 1));
				
				// Mask
				float4 audioLinkMask = 1.0;
				
				// UV
				float2 aluv = uv;
				if (_ALDecalUVMode == 1)
				{
					float2 uvdir = uv * 2 - 1;
					aluv.x = frac(atan2(uvdir.y, uvdir.x) * UNITY_INV_TWO_PI);
					aluv.y = length(uvdir);
				}
				
				// Scale / Offset / Step
				float maskY = aluv.y;
				if (_ALDecalUVMode == 1)
				{
					maskY = remap(maskY, _ALDecaldCircleDimensions.x, _ALDecaldCircleDimensions.y, 0, 1);
				}
				float maskX = aluv.x;
				if (_ALDecalUVMode == 1)
				{
					maskX = remap(maskX, _ALDecaldCircleDimensions.z, _ALDecaldCircleDimensions.w, 0, 1);
				}
				
				float maskVolume = _ALDecalVolumeStep != 0.0 ? floor(maskY * _ALDecalVolumeStep) / _ALDecalVolumeStep : maskY;
				float maskBand = _ALDecalBandStep != 0.0 ? floor(maskX * _ALDecalBandStep) / _ALDecalBandStep : maskX;
				
				// Copy
				audioLinkMask.r = maskVolume;
				audioLinkMask.g = maskBand;
				
				// Clip
				audioLinkMask.b = maskVolume < _ALDecalVolumeClipMin || maskVolume > _ALDecalVolumeClipMax ? 0.0 : audioLinkMask.b;
				audioLinkMask.b = maskBand < _ALDecalBandClipMin || maskBand > _ALDecalBandClipMax ? 0.0 : audioLinkMask.b;
				
				// Shape Clip
				if (_ALDecalShapeClip)
				{
					float volumeth = _ALDecalShapeClipVolumeWidth;
					if (_ALDecalVolumeStep != 0.0) audioLinkMask.b = frac(maskY * _ALDecalVolumeStep) > volumeth ? 0.0 : audioLinkMask.b;
					
					float bandwidth = _ALDecalUVMode == 1 ? _ALDecalShapeClipBandWidth / aluv.y : _ALDecalShapeClipBandWidth;
					float bandth = 1.0 - bandwidth;
					if (_ALDecalBandStep != 0.0) audioLinkMask.b = frac(maskX * _ALDecalBandStep + bandth * 0.5) < bandth ? 0.0 : audioLinkMask.b;
				}
				
				// AudioLink
				float2 audioLinkUV = float2(frac(audioLinkMask.g * 2.0), 4.5 / 4.0 + floor(audioLinkMask.g * 2.0) / 4.0);
				audioLinkUV.y *= 0.0625;
				float4 audioTexture = _AudioTexture.Sample(sampler_linear_clamp, audioLinkUV);
				float audioVal = audioTexture.b * _ALDecalVolume * lerp(_ALDecalBaseBoost, _ALDecalTrebleBoost, audioLinkMask.g);
				float audioLinkValue = _ALDecalLineWidth < 1.0 ? abs(audioVal - audioLinkMask.r) < _ALDecalLineWidth : audioVal > audioLinkMask.r * 2.0;
				audioLinkValue = saturate(audioLinkValue) * audioLinkMask.b;
				//clip(audioLinkValue - .5);
				audioLinkValue *= colorAndMask.a;
				
				if (!poiMods.audioLinkAvailable)
				{
					audioLinkValue = 0;
				}
				
				float3 alColorChord = _AudioTexture.Sample(sampler_linear_clamp, float2(maskX, 24.5 / 64.0)).rgb;
				float volumeColorSrc = audioLinkMask.g;
				if (_ALDecalVolumeColorSource == 1) volumeColorSrc = audioLinkMask.r;
				if (_ALDecalVolumeColorSource == 2) volumeColorSrc = audioVal;
				
				float3 lowColor = _ALDecalVolumeColorLow.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorLow.rgb, _ALDecalVolumeColorLowThemeIndex);
				float3 midColor = _ALDecalVolumeColorMid.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorMid.rgb, _ALDecalVolumeColorMidThemeIndex);
				float3 highColor = _ALDecalVolumeColorHigh.rgb * poiThemeColor(poiMods, _ALDecalVolumeColorHigh.rgb, _ALDecalVolumeColorHighThemeIndex);
				
				float3 volumeColor = lerp(lowColor, midColor, saturate(volumeColorSrc * 2));
				volumeColor = lerp(volumeColor, highColor, saturate(volumeColorSrc * 2 - 1));
				
				float3 emissionColor = lerp(lowColor * _ALDecalLowEmission, midColor * _ALDecalMidEmission, saturate(volumeColorSrc * 2));
				emissionColor = lerp(emissionColor, highColor * _ALDecalHighEmission, saturate(volumeColorSrc * 2 - 1));
				
				//poiFragData.baseColor = lerp(poiFragData.baseColor, volumeColor, audioLinkValue);
				#if defined(POI_PASS_BASE) || defined(POI_PASS_ADD)
				poiFragData.emission += emissionColor * audioLinkValue;
				poiFragData.baseColor.rgb = lerp(poiFragData.baseColor, customBlend(poiFragData.baseColor, volumeColor * colorAndMask.rgb, _ALDecalBlendType), saturate(_ALDecalBlendAlpha * audioLinkValue));
				#endif
				poiFragData.alpha = lerp(poiFragData.alpha, poiFragData.alpha * audioLinkValue, _ALDecalControlsAlpha);
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			void applyFlipbook(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_FLIPBOOKTEXARRAY) || !defined(OPTIMIZER_ENABLED)
				float4 flipBookPixel = float4(0, 0, 0, 0);
				#if defined(PROP_FLIPBOOKMASK) || !defined(OPTIMIZER_ENABLED)
				float flipBookMask = POI2D_SAMPLER_PAN(_FlipbookMask, _MainTex, poiUV(poiMesh.uv[_FlipbookMaskUV], _FlipbookMask_ST), _FlipbookMaskPan)[_FlipbookMaskChannel];
				#else
				float flipBookMask = 1;
				#endif
				if (_FlipbookMaskGlobalMask > 0)
				{
					flipBookMask = maskBlend(flipBookMask, poiMods.globalMask[_FlipbookMaskGlobalMask-1], _FlipbookMaskGlobalMaskBlendType);
				}
				float4 flipbookScaleOffset = _FlipbookScaleOffset;
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookScaleOffset.xy += lerp(_AudioLinkFlipbookScale.xy, _AudioLinkFlipbookScale.zw, poiMods.audioLink[_AudioLinkFlipbookScaleBand]);
				}
				#endif
				
				flipbookScaleOffset.xy = 1 - flipbookScaleOffset.xy;
				float2 uv = frac(poiMesh.uv[_FlipbookTexArrayUV]);
				float theta = radians(_FlipbookRotation + _Time.z * _FlipbookRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				float2 spriteCenter = flipbookScaleOffset.zw + .5;
				// 2d rotation
				uv = float2((uv.x - spriteCenter.x) * cs - (uv.y - spriteCenter.y) * sn + spriteCenter.x, (uv.x - spriteCenter.x) * sn + (uv.y - spriteCenter.y) * cs + spriteCenter.y);
				float4 sideOffset = float4(-(_FlipbookSideOffset.x), _FlipbookSideOffset.y, -(_FlipbookSideOffset.z), _FlipbookSideOffset.w);
				float2 newUV = remap(uv, float2(0, 0) + flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.xz, float2(1, 1) - flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.yw, float2(0, 0), float2(1, 1));
				
				UNITY_BRANCH
				if (_FlipbookTiled == 0)
				{
					if (max(newUV.x, newUV.y) > 1 || min(newUV.x, newUV.y) < 0)
					{
						return;
					}
				}
				float currentFrame = 0;
				float width;
				float height;
				float totalFrames;
				_FlipbookTexArray.GetDimensions(width, height, totalFrames);
				
				if (_FlipbookStartAndEnd)
				{
					totalFrames -= (totalFrames - min(max(_FlipbookStartFrame, _FlipbookEndFrame), totalFrames));
					totalFrames -= max(0, _FlipbookStartFrame);
				}
				if (!_FlipbookManualFrameControl)
				{
					if (_FlipbookFPS != 0)
					{
						currentFrame = ((_Time.y / (1 / _FlipbookFPS)) + _FlipbookFrameOffset) % totalFrames;
						if (_FlipbookStartAndEnd)
						{
							currentFrame += _FlipbookStartFrame;
						}
					}
				}
				else
				{
					currentFrame = fmod(_FlipbookCurrentFrame, totalFrames);
				}
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					if (_FlipbookChronotensityEnabled)
					{
						currentFrame += AudioLinkGetChronoTime(_FlipbookChronoType, _FlipbookChronotensityBand) * _FlipbookChronotensitySpeed;
					}
					currentFrame += lerp(_AudioLinkFlipbookFrame.x, _AudioLinkFlipbookFrame.y, poiMods.audioLink[_AudioLinkFlipbookFrameBand]);
					float totalFramesAL = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesAL += max(0, _FlipbookStartFrame);
					}
					currentFrame %= totalFramesAL;
				}
				#endif
				flipBookPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor(currentFrame)));
				UNITY_BRANCH
				if (_FlipbookCrossfadeEnabled)
				{
					float totalFramesCF = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesCF += max(0, _FlipbookStartFrame);
					}
					float4 flipbookNextPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor((currentFrame + 1) % totalFramesCF)));
					flipBookPixel = lerp(flipBookPixel, flipbookNextPixel, smoothstep(_FlipbookCrossfadeRange.x, _FlipbookCrossfadeRange.y, frac(currentFrame)));
				}
				
				UNITY_BRANCH
				if (_FlipbookIntensityControlsAlpha)
				{
					flipBookPixel.a = poiMax(flipBookPixel.rgb);
				}
				UNITY_BRANCH
				if (_FlipbookColorReplaces)
				{
					flipBookPixel.rgb = poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				else
				{
					flipBookPixel.rgb *= poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				
				UNITY_BRANCH
				if (_FlipbookHueShiftEnabled)
				{
					flipBookPixel.rgb = hueShift(flipBookPixel.rgb, _FlipbookHueShift + _Time.x * _FlipbookHueShiftSpeed);
				}
				half flipbookAlpha = 1;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookAlpha += saturate(lerp(_AudioLinkFlipbookAlpha.x, _AudioLinkFlipbookAlpha.y, poiMods.audioLink[_AudioLinkFlipbookAlphaBand]));
				}
				#endif
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * _FlipbookReplace * flipBookMask * flipbookAlpha);
				poiFragData.baseColor = poiFragData.baseColor + flipBookPixel.rgb * _FlipbookAdd * flipBookMask * flipbookAlpha;
				poiFragData.baseColor = poiFragData.baseColor * lerp(1, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * flipBookMask * _FlipbookMultiply * flipbookAlpha);
				
				float flipbookEmissionStrength = _FlipbookEmissionStrength;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookEmissionStrength += max(lerp(_AudioLinkFlipbookEmission.x, _AudioLinkFlipbookEmission.y, poiMods.audioLink[_AudioLinkFlipbookEmissionBand]), 0);
				}
				#endif
				
				poiFragData.emission += lerp(0, flipBookPixel.rgb * flipbookEmissionStrength, flipBookPixel.a * _FlipbookColor.a * flipBookMask * flipbookAlpha);
				
				#endif
				
				UNITY_BRANCH
				if (_FlipbookAlphaControlsFinalAlpha)
				{
					poiFragData.alpha = lerp(poiFragData.alpha, flipBookPixel.a * _FlipbookColor.a, flipBookMask);
				}
				#endif
			}
			
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			void applyMirror(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float inMirror = 0;
				if (_VisibilityMode == 1) // VRC
				inMirror = VRCMirrorMode() > 0;
				else // Generic (CVR, etc)
				inMirror = IsInMirror();
				
				#if (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 mirrorTexture = POI2D_SAMPLER_PAN(_MirrorTexture, _MainTex, poiUV(poiMesh.uv[_MirrorTextureUV], _MirrorTexture_ST), _MirrorTexturePan);
				if (inMirror)
				{
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, mirrorTexture.rgb, _MirrorTextureBlendType), mirrorTexture.a * _MirrorColor.a);
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#else
				if (inMirror)
				{
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#endif
				#endif
			}
			#endif
			//endex
			
			//ifex _EnableTouchGlow==0
			#ifdef GRAIN
			void applyDepthFX(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float3 touchEmission = 0;
				
				float perspectiveDivide = 1.0f / poiCam.clipPos.w;
				float4 direction = poiCam.worldDirection * perspectiveDivide;
				float2 screenPos = poiCam.grabPos.xy * perspectiveDivide;
				float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, screenPos);
				
				#if UNITY_REVERSED_Z
				if (z == 0)
				#else
				if (z == 1)
				#endif
				return;
				
				float depth = CorrectedLinearEyeDepth(z, direction.w);
				float3 worldpos = direction * depth + _WorldSpaceCameraPos.xyz;
				/*
				finalColor.rgb = frac(worldpos);
				return;
				*/
				
				float diff = distance(worldpos, poiMesh.worldPos);
				//poiFragData.finalColor = diff;
				
				#if defined(PROP_DEPTHMASK) || !defined(OPTIMIZER_ENABLED)
				float depthMask = POI2D_SAMPLER_PAN(_DepthMask, _MainTex, poiUV(poiMesh.uv[_DepthMaskUV], _DepthMask_ST), _DepthMaskPan)[_DepthMaskChannel];
				#else
				float depthMask = 1;
				#endif
				
				if (_DepthMaskGlobalMask > 0)
				{
					depthMask = maskBlend(depthMask, poiMods.globalMask[_DepthMaskGlobalMask-1], _DepthMaskGlobalMaskBlendType);
				}
				
				if (_DepthColorToggle)
				{
					float colorBlendAlpha = lerp(_DepthColorMinValue, _DepthColorMaxValue, remapClamped(_DepthColorMinDepth, _DepthColorMaxDepth, diff));
					
					#if defined(PROP_DEPTHTEXTURE) || !defined(OPTIMIZER_ENABLED)
					float2 depthTextureUV = float2(0, 0);
					if (_DepthTextureUV == 8)
					{
						depthTextureUV = lerp(0, 1, remapClamped(_DepthColorMinDepth, _DepthColorMaxDepth, diff));
					}
					else
					{
						depthTextureUV = poiMesh.uv[_DepthTextureUV];
					}
					float3 depthColor = POI2D_SAMPLER_PAN(_DepthTexture, _MainTex, poiUV(depthTextureUV, _DepthTexture_ST), _DepthTexturePan).rgb * poiThemeColor(poiMods, _DepthColor, _DepthColorThemeIndex);
					#else
					float3 depthColor = poiThemeColor(poiMods, _DepthColor, _DepthColorThemeIndex);
					#endif
					
					switch(_DepthColorBlendMode)
					{
						case 0:
						{
							poiFragData.finalColor = lerp(poiFragData.finalColor, depthColor, colorBlendAlpha * depthMask);
							break;
						}
						case 1:
						{
							poiFragData.finalColor *= lerp(1, depthColor, colorBlendAlpha * depthMask);
							break;
						}
						case 2:
						{
							poiFragData.finalColor = saturate(poiFragData.finalColor + lerp(0, depthColor, colorBlendAlpha * depthMask));
							break;
						}
					}
					poiFragData.emission += depthColor * colorBlendAlpha * _DepthEmissionStrength * depthMask;
				}
				
				if (_DepthAlphaToggle)
				{
					poiFragData.alpha *= lerp(poiFragData.alpha, saturate(lerp(_DepthAlphaMinValue, _DepthAlphaMaxValue, remapClamped(_DepthAlphaMinDepth, _DepthAlphaMaxDepth, diff))), depthMask);
				}
			}
			#endif
			//endex
			
			// normal correct code from https://github.com/yoship1639/UniToon (MIT)
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			void applyNormalCorrect(inout VertexOut i)
			{
				float3 normalCorrectObject = i.localPos.xyz - _NormalCorrectOrigin;
				normalCorrectObject.y = 0;
				normalCorrectObject = normalize(normalCorrectObject);
				float3 normalCorrectWorld = UnityObjectToWorldDir(normalCorrectObject);
				i.normal.xyz = normalize(lerp(i.normal.xyz, normalCorrectWorld, _NormalCorrectAmount));
				i.objNormal.xyz = normalize(lerp(i.objNormal.xyz, normalCorrectObject, _NormalCorrectAmount));
			}
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float3 applyBacklight(float3 videoTexture, half backlightStrength)
			{
				return max(backlightStrength, videoTexture.rgb);
			}
			
			float3 applyViewAngleTN(float3 videoTexture, PoiCam poiCam, PoiMesh poiMesh)
			{
				float3 reflectionVector = normalize(reflect(poiCam.viewDir.rgb, poiMesh.normals[1].rgb));
				float upwardShift = dot(reflectionVector, poiMesh.binormal[0]);
				upwardShift = pow(upwardShift, 1);
				float sideShift = dot(reflectionVector, poiMesh.tangent[0]);
				sideShift *= pow(sideShift, 3);
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = LinearToGammaSpace(videoTexture);
				#endif
				videoTexture = saturate(lerp(half3(0.5, 0.5, 0.5), videoTexture, upwardShift + 1));
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = GammaToLinearSpace(videoTexture);
				#endif
				videoTexture = (lerp(videoTexture, videoTexture.gbr, sideShift));
				return videoTexture;
			}
			
			float calculateCRTPixelBrightness(float2 uv)
			{
				float totalPixels = _VideoResolution.x * _VideoResolution.y;
				float2 uvPixel = float2((floor((1 - uv.y) * _VideoResolution.y)) / _VideoResolution.y, (floor(uv.x * _VideoResolution.x)) / _VideoResolution.x);
				float currentPixelNumber = _VideoResolution.x * (_VideoResolution.y * uvPixel.x) + _VideoResolution.y * uvPixel.y;
				float currentPixelAlpha = currentPixelNumber / totalPixels;
				half electronBeamAlpha = frac(_Time.y * _VideoCRTRefreshRate);
				float electronBeamPixelNumber = totalPixels * electronBeamAlpha;
				
				float DistanceInPixelsFromCurrentElectronBeamPixel = 0;
				if (electronBeamPixelNumber >= currentPixelNumber)
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber - currentPixelNumber;
				}
				else
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber + (totalPixels - currentPixelNumber);
				}
				float CRTFrameTime = 1 / _VideoCRTRefreshRate;
				float timeSincecurrentPixelWasHitByElectronBeam = (DistanceInPixelsFromCurrentElectronBeamPixel / totalPixels);
				
				return saturate(_VideoCRTPixelEnergizedTime - timeSincecurrentPixelWasHitByElectronBeam);
			}
			
			void applyContrastSettings(inout float3 pixel)
			{
				#if !UNITY_COLORSPACE_GAMMA
				pixel = LinearToGammaSpace(pixel);
				#endif
				pixel = saturate(lerp(half3(0.5, 0.5, 0.5), pixel, _VideoContrast + 1));
				#if !UNITY_COLORSPACE_GAMMA
				pixel = GammaToLinearSpace(pixel);
				#endif
			}
			
			void applySaturationSettings(inout float3 pixel)
			{
				pixel = lerp(pixel.rgb, dot(pixel.rgb, float3(0.3, 0.59, 0.11)), -(_VideoSaturation));
			}
			
			void applyVideoSettings(inout float3 pixel)
			{
				applySaturationSettings(pixel);
				applyContrastSettings(pixel);
			}
			
			void calculateLCD(inout float4 videoTexture, float3 pixels)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateTN(inout float4 videoTexture, float3 pixels, PoiCam poiCam, PoiMesh poiMesh)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				videoTexture.rgb = applyViewAngleTN(videoTexture, poiCam, poiMesh);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateCRT(inout float4 videoTexture, float3 pixels, float2 uv)
			{
				float brightness = calculateCRTPixelBrightness(uv);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * brightness * _VideoBacklight;
			}
			void calculateOLED(inout float4 videoTexture, float3 pixels)
			{
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateGameboy(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				// half brightness = saturate((videoTexture.r + videoTexture.g + videoTexture.b) * .3333333);
				half brightness = LinearRgbToLuminance(LinearToGammaSpace(videoTexture.rgb));
				#if defined(PROP_VIDEOGAMEBOYRAMP) || !defined(OPTIMIZER_ENABLED)
				videoTexture.rgb = tex2Dlod(_VideoGameboyRamp, float4(brightness.xx, 0, 0));
				#else
				float3 dg = float3(0.00392156863, 0.0392156863, 0.00392156863);
				float3 lg = float3(0.333333333, 0.5, 0.00392156863);
				videoTexture.rgb = lerp(dg, lg, brightness);
				#endif
			}
			void calculateProjector(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				
				float3 projectorColor = videoTexture * _VideoBacklight;
				videoTexture.r = clamp(projectorColor.r, videoTexture.r, 1000);
				videoTexture.g = clamp(projectorColor.g, videoTexture.g, 1000);
				videoTexture.b = clamp(projectorColor.b, videoTexture.b, 1000);
			}
			
			void applyVideoEffectsMainTex(inout float4 mainTexture, in PoiMesh poiMesh)
			{
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					float2 originalUVs = uvs;
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
					mainTexture = _MainTex.SampleGrad(sampler_MainTex, uvs, ddx(originalUVs), ddy(originalUVs));
				}
			}
			void applyVideoEffects(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
			{
				#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float3 pixels = tex2D(_VideoPixelTexture, poiUV(poiMesh.uv[_VideoPixelTextureUV], _VideoPixelTexture_ST) * _VideoResolution);
				#else
				float3 pixels = 1;
				#endif
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				else
				{
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				float4 modifiedVideoTexture = 0;
				modifiedVideoTexture.rgb = poiFragData.baseColor;
				modifiedVideoTexture.a = poiFragData.alpha;
				
				// UNITY_BRANCH
				// if(_VideoRepeatVideoTexture == 1)
				// {
				// 	if(poiMesh.uv[_VideoUVNumber].x > 1 || poiMesh.uv[_VideoUVNumber].x < 0 || poiMesh.uv[_VideoUVNumber].y > 1 || poiMesh.uv[_VideoUVNumber].y < 0)
				// 	{
				// 		return;
				// 	}
				// }
				
				switch(_VideoType)
				{
					case 0: // LCD
					{
						calculateLCD(modifiedVideoTexture, pixels);
						break;
					}
					case 1: // TN
					{
						calculateTN(modifiedVideoTexture, pixels, poiCam, poiMesh);
						break;
					}
					case 2: // CRT
					{
						calculateCRT(modifiedVideoTexture, pixels, uvs);
						break;
					}
					case 3: // OLED
					{
						calculateOLED(modifiedVideoTexture, pixels);
						break;
					}
					case 4: // Gameboy
					{
						calculateGameboy(modifiedVideoTexture);
						break;
					}
					case 5: // Projector
					{
						calculateProjector(modifiedVideoTexture);
						break;
					}
				}
				#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float screenMask = POI2D_SAMPLER_PAN(_VideoMaskTexture, _MainTex, poiUV(poiMesh.uv[_VideoMaskTextureUV], _VideoMaskTexture_ST), _VideoMaskTexturePan)[_VideoMaskTextureChannel];
				#else
				float screenMask = 1;
				#endif
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, modifiedVideoTexture, screenMask);
				// UNITY_BRANCH
				if (_VideoEmissionEnabled)
				{
					poiFragData.emission += modifiedVideoTexture.rgb * screenMask;
				}
			}
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			void ApplyBacklight(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiCam poiCam, inout PoiMods poiMods)
			{
				
				// Color
				float3 backlightColor = _BacklightColor.rgb;
				#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				backlightColor *= POI2D_SAMPLER_PAN(_BacklightColorTex, _MainTex, poiUV(poiMesh.uv[_BacklightColorTexUV], _BacklightColorTex_ST), _BacklightColorTexPan).rgb;
				#endif
				
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], _BacklightNormalStrength);
				// Factor
				float3 headDir = normalize(getCameraPosition() - poiMesh.worldPos.xyz);
				float headDotLight = dot(headDir, poiLight.direction);
				float backlightFactor = pow(saturate(-headDotLight * 0.5 + 0.5), max(0, _BacklightDirectivity));
				float backlightLN = dot(normalize(-headDir * _BacklightViewStrength + poiLight.direction), normal) * 0.5 + 0.5;
				if(_BacklightReceiveShadow) backlightLN *= saturate(poiLight.attenuation);
				backlightLN = poiEdgeLinear(backlightLN, _BacklightBorder, _BacklightBlur);
				float backlight = saturate(backlightFactor * backlightLN);
				backlight = !poiMesh.isFrontFace && _BacklightBackfaceMask ? 0.0 : backlight;
				
				// Blend
				backlightColor = lerp(backlightColor, backlightColor * poiFragData.baseColor, _BacklightMainStrength);
				poiLight.finalLightAdd += backlight * backlightColor * poiLight.directColor;
			}
			#endif
			//endex
			
			float4 frag(VertexOut i, uint facing : SV_IsFrontFace) : SV_Target
			{
				//ifex _EnableDepthBulge==0
				#ifdef POI_DEPTHBULGE
				clip(-1);
				return 0;
				#endif
				//endex
				
				//ifex _EnableTouchGlow==0
				#ifdef GRAIN
				clip(-1);
				return 0;
				#endif
				//endex
				
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				
				PoiMesh poiMesh;
				PoiInitStruct(PoiMesh, poiMesh);
				
				PoiLight poiLight;
				PoiInitStruct(PoiLight, poiLight);
				
				PoiVertexLights poiVertexLights;
				PoiInitStruct(PoiVertexLights, poiVertexLights);
				
				PoiCam poiCam;
				PoiInitStruct(PoiCam, poiCam);
				
				PoiMods poiMods;
				PoiInitStruct(PoiMods, poiMods);
				poiMods.globalEmission = 1;
				poiMods.PBR = 1;
				
				PoiFragData poiFragData;
				poiFragData.emission = 0;
				poiFragData.baseColor = float3(0, 0, 0);
				poiFragData.finalColor = float3(0, 0, 0);
				poiFragData.alpha = 1;
				
				#ifdef POI_UDIMDISCARD
				applyUDIMDiscard(i);
				#endif
				
				//ifex _NormalCorrect==0
				#ifdef POI_NORMALCORRECT
				applyNormalCorrect(i);
				#endif
				//endex
				
				// Mesh Data
				poiMesh.objectPosition = i.objectPos;
				poiMesh.objNormal = i.objNormal;
				poiMesh.normals[0] = i.normal;
				poiMesh.tangent[0] = i.tangent;
				poiMesh.binormal[0] = i.binormal;
				poiMesh.worldPos = i.worldPos.xyz;
				poiMesh.localPos = i.localPos.xyz;
				poiMesh.vertexColor = i.vertexColor;
				poiMesh.isFrontFace = facing;
				
				#ifndef POI_PASS_OUTLINE
				if (!poiMesh.isFrontFace)
				{
					poiMesh.normals[0] *= -1;
					poiMesh.tangent[0] *= -1;
					poiMesh.binormal[0] *= -1;
				}
				#endif
				
				poiCam.viewDir = !IsOrthographicCamera() ? normalize(_WorldSpaceCameraPos - i.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 tanToWorld0 = float3(i.tangent.x, i.binormal.x, i.normal.x);
				float3 tanToWorld1 = float3(i.tangent.y, i.binormal.y, i.normal.y);
				float3 tanToWorld2 = float3(i.tangent.z, i.binormal.z, i.normal.z);
				float3 ase_tanViewDir = tanToWorld0 * poiCam.viewDir.x + tanToWorld1 * poiCam.viewDir.y + tanToWorld2 * poiCam.viewDir.z;
				poiCam.tangentViewDir = normalize(ase_tanViewDir);
				
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 6 Distorted UV
				#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
				poiMesh.lightmapUV = i.lightmapUV;
				#endif
				poiMesh.parallaxUV = poiCam.tangentViewDir.xy / max(poiCam.tangentViewDir.z, 0.0001);
				poiMesh.uv[0] = i.uv[0];
				poiMesh.uv[1] = i.uv[1];
				poiMesh.uv[2] = i.uv[2];
				poiMesh.uv[3] = i.uv[3];
				poiMesh.uv[4] = poiMesh.uv[0];
				poiMesh.uv[5] = poiMesh.uv[0];
				poiMesh.uv[6] = poiMesh.uv[0];
				poiMesh.uv[7] = poiMesh.uv[0];
				poiMesh.uv[8] = poiMesh.uv[0];
				
				poiMesh.uv[4] = calculatePanosphereUV(poiMesh);
				poiMesh.uv[5] = calculateWorldUV(poiMesh);
				poiMesh.uv[6] = calculatePolarCoordinate(poiMesh);
				poiMesh.uv[8] = calculatelocalUV(poiMesh);
				//ifex _EnableDistortion==0
				#ifdef USER_LUT
				poiMesh.uv[7] = distortedUV(poiMesh);
				#endif
				//endex
				/*
				half3 worldViewUp = normalize(half3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, half3(0, 1, 0)));
				half3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
				poiMesh[8] = half2(dot(worldViewRight, poiMesh.normals[_MatcapNormal]), dot(worldViewUp, poiMesh.normals[_MatcapNormal])) * _MatcapBorder + 0.5;
				*/
				
				//ifex _PoiParallax==0
				#ifdef POI_PARALLAX
				#ifndef POI_PASS_OUTLINE
				//return frac(i.tangentViewDir.x);
				//return float4(i.binormal.xyz,1);
				applyParallax(poiMesh, poiLight, poiCam);
				#endif
				#endif
				//endex
				
				poiMods.globalMask[0]  = 1;
				poiMods.globalMask[1]  = 1;
				poiMods.globalMask[2]  = 1;
				poiMods.globalMask[3]  = 1;
				poiMods.globalMask[4]  = 1;
				poiMods.globalMask[5]  = 1;
				poiMods.globalMask[6]  = 1;
				poiMods.globalMask[7]  = 1;
				poiMods.globalMask[8]  = 1;
				poiMods.globalMask[9]  = 1;
				poiMods.globalMask[10] = 1;
				poiMods.globalMask[11] = 1;
				poiMods.globalMask[12] = 1;
				poiMods.globalMask[13] = 1;
				poiMods.globalMask[14] = 1;
				poiMods.globalMask[15] = 1;
				//ifex _GlobalMaskTexturesEnable==0
				#ifdef POI_GLOBALMASK_TEXTURES
				ApplyGlobalMaskTextures(poiMesh, poiMods);
				#endif
				//endex
				ApplyGlobalMaskModifiers(poiMesh, poiMods, poiCam);
				//ifex _GlobalMaskOptionsEnable==0
				if(_GlobalMaskOptionsEnable)
				{
					ApplyGlobalMaskOptions(poiMods);
				}
				//endex
				
				float2 mainUV = poiMesh.uv[_MainTexUV].xy;
				
				if (_MainPixelMode)
				{
					mainUV = sharpSample(_MainTex_TexelSize, mainUV);
				}
				
				float4 mainTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_MainTex, _MainTex, poiUV(mainUV, _MainTex_ST), _MainTexPan, _MainTexStochastic);
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffectsMainTex(mainTexture, poiMesh);
				}
				//endex
				
				#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
				poiMesh.tangentSpaceNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_BumpMap, _MainTex, poiUV(poiMesh.uv[_BumpMapUV].xy, _BumpMap_ST), _BumpMapPan, _BumpMapStochastic), _BumpScale);
				#else
				poiMesh.tangentSpaceNormal = UnpackNormal(float4(0.5, 0.5, 1, 1));
				#endif
				
				//ifex _DetailEnabled==0
				#if defined(FINALPASS) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				ApplyDetailNormal(poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				//ifex _RgbNormalsEnabled==0
				#if defined(GEOM_TYPE_MESH) && defined(VIGNETTE) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				calculateRGBNormals(poiMesh, poiMods);
				#endif
				//endex
				//endex
				
				poiMesh.normals[1] = normalize(
				poiMesh.tangentSpaceNormal.x * poiMesh.tangent[0] +
				poiMesh.tangentSpaceNormal.y * poiMesh.binormal[0] +
				poiMesh.tangentSpaceNormal.z * poiMesh.normals[0]
				);
				
				poiMesh.tangent[1] = cross(poiMesh.binormal[0], -poiMesh.normals[1]);
				poiMesh.binormal[1] = cross(-poiMesh.normals[1], poiMesh.tangent[0]);
				
				// Camera data
				poiCam.forwardDir = getCameraForward();
				poiCam.worldPos = _WorldSpaceCameraPos;
				poiCam.reflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[1]);
				poiCam.vertexReflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[0]);
				//poiCam.distanceToModel = distance(poiMesh.modelPos, poiCam.worldPos);
				poiCam.distanceToVert = distance(poiMesh.worldPos, poiCam.worldPos);
				poiCam.grabPos = i.grabPos;
				poiCam.screenUV = calcScreenUVs(i.grabPos);
				poiCam.vDotN = abs(dot(poiCam.viewDir, poiMesh.normals[1]));
				poiCam.clipPos = i.pos;
				poiCam.worldDirection = i.worldDirection;
				
				//ifex _EnableAudioLink==0
				#ifdef POI_AUDIOLINK
				SetupAudioLink(poiFragData, poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _BlackLightMaskingEnabled==0
				#ifdef POI_BLACKLIGHTMASKING
				calculateBlackLightMasks(poiMesh, poiMods);
				#endif
				//endex
				
				poiFragData.baseColor = mainTexture.rgb * poiThemeColor(poiMods, _Color.rgb, _ColorThemeIndex);
				poiFragData.alpha = mainTexture.a * _Color.a;
				
				//ifex _MainColorAdjustToggle==0
				#ifdef COLOR_GRADING_HDR
				#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 hueShiftAlpha = POI2D_SAMPLER_PAN(_MainColorAdjustTexture, _MainTex, poiUV(poiMesh.uv[_MainColorAdjustTextureUV], _MainColorAdjustTexture_ST), _MainColorAdjustTexturePan);
				#else
				float4 hueShiftAlpha = 1;
				#endif
				
				if (_MainHueGlobalMask > 0)
				{
					hueShiftAlpha.r = maskBlend(hueShiftAlpha.r, poiMods.globalMask[_MainHueGlobalMask-1], _MainHueGlobalMaskBlendType);
				}
				if (_MainSaturationGlobalMask > 0)
				{
					hueShiftAlpha.b = maskBlend(hueShiftAlpha.b, poiMods.globalMask[_MainSaturationGlobalMask-1], _MainSaturationGlobalMaskBlendType);
				}
				if (_MainBrightnessGlobalMask > 0)
				{
					hueShiftAlpha.g = maskBlend(hueShiftAlpha.g, poiMods.globalMask[_MainBrightnessGlobalMask-1], _MainBrightnessGlobalMaskBlendType);
				}
				
				if (_MainHueShiftToggle)
				{
					float shift = _MainHueShift;
					#ifdef POI_AUDIOLINK
					//UNITY_BRANCH
					if (poiMods.audioLinkAvailable && _MainHueALCTEnabled)
					{
						shift += AudioLinkGetChronoTime(_MainALHueShiftCTIndex, _MainALHueShiftBand) * _MainHueALMotionSpeed;
					}
					#endif
					if (_MainHueShiftReplace)
					{
						poiFragData.baseColor = lerp(poiFragData.baseColor, hueShift(poiFragData.baseColor, shift + _MainHueShiftSpeed * _Time.x), hueShiftAlpha.r);
					}
					else
					{
						poiFragData.baseColor = hueShift(poiFragData.baseColor, frac((shift - (1 - hueShiftAlpha.r) + _MainHueShiftSpeed * _Time.x)));
					}
				}
				poiFragData.baseColor = lerp(poiFragData.baseColor, dot(poiFragData.baseColor, float3(0.3, 0.59, 0.11)), -(_Saturation) * hueShiftAlpha.b);
				poiFragData.baseColor = saturate(poiFragData.baseColor + _MainBrightness * hueShiftAlpha.g);
				#endif
				//endex
				
				#if defined(PROP_CLIPPINGMASK) || !defined(OPTIMIZER_ENABLED)
				float alphaMask = POI2D_SAMPLER_PAN(_ClippingMask, _MainTex, poiUV(poiMesh.uv[_ClippingMaskUV], _ClippingMask_ST), _ClippingMaskPan).r;
				if (_Inverse_Clipping)
				{
					alphaMask = 1 - alphaMask;
				}
				
				poiFragData.alpha *= alphaMask;
				#endif
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffects(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				}
				//endex
				
				applyAlphaOptions(poiFragData, poiMesh, poiCam, poiMods);
				
				//ifex _MainVertexColoringEnabled==0
				applyVertexColor(poiFragData, poiMesh);
				//endex
				
				//ifex _BackFaceEnabled!=1
				#ifdef POI_BACKFACE
				ApplyBackFaceColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				applyDissolve(poiFragData, poiMesh, poiMods, poiCam, poiLight);
				#endif
				//endex
				
				//ifex _EnableALDecal==0
				#ifdef POI_AUDIOLINK
				#ifdef POI_AL_DECAL
				ApplyAudioLinkDecal(poiMesh, poiFragData, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableFlipbook==0
				#ifdef _SUNDISK_HIGH_QUALITY
				applyFlipbook(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				applyMirror(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				poiFragData.finalColor = poiFragData.baseColor;
				
				//ifex _EnableTouchGlow==0
				#ifdef GRAIN
				applyDepthFX(poiFragData, poiCam, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _BacklightEnabled!=1
				#ifdef POI_BACKLIGHT
				ApplyBacklight(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				
				//UNITY_BRANCH
				if (_IgnoreFog == 0)
				{
					UNITY_APPLY_FOG(i.fogCoord, poiFragData.finalColor);
				}
				
				poiFragData.alpha = _AlphaForceOpaque ? 1 : poiFragData.alpha;
				
				//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
				ApplyAlphaToCoverage(poiFragData, poiMesh);
				//endex
				
				//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
				applyDithering(poiFragData, poiCam);
				//endex
				
				if (_Mode == POI_MODE_OPAQUE)
				{
					poiFragData.alpha = 1;
				}
				
				clip(poiFragData.alpha - _Cutoff);
				
				return float4(poiFragData.finalColor, poiFragData.alpha) + POI_SAFE_RGB0;
			}
			
			ENDCG
		}
		
		Pass
		{
			Tags { "LightMode" = "Meta" }
			
			ZWrite [_ZWrite]
			Cull [_Cull]
			AlphaToMask [_AlphaToCoverage]
			ZTest [_ZTest]
			ColorMask [_ColorMask]
			Offset [_OffsetFactor], [_OffsetUnits]
			
			BlendOp [_BlendOp], [_BlendOpAlpha]
			Blend [_SrcBlend] [_DstBlend], [_SrcBlendAlpha] [_DstBlendAlpha]
			
			CGPROGRAM
			/*
			// Disable warnings we aren't interested in
			#if defined(UNITY_COMPILER_HLSL)
			#pragma warning(disable : 3205) // conversion of larger type to smaller
			#pragma warning(disable : 3568) // unknown pragma ignored
			#pragma warning(disable : 3571) // "pow(f,e) will not work for negative f"; however in majority of our calls to pow we know f is not negative
			#pragma warning(disable : 3206) // implicit truncation of vector type
			#endif
			*/
			#pragma target 5.0
			
			#pragma shader_feature_local _STOCHASTICMODE_DELIOT_HEITZ _STOCHASTICMODE_HEXTILE _STOCHASTICMODE_NONE
			
			//ifex _MainColorAdjustToggle==0
			#pragma shader_feature COLOR_GRADING_HDR
			//endex
			
			//#pragma shader_feature KEYWORD
			
			//ifex _GlobalMaskTexturesEnable==0
			#pragma shader_feature_local POI_GLOBALMASK_TEXTURES
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#pragma shader_feature_local POI_UDIMDISCARD
			//endex
			
			//ifex _EnableDistortion==0
			#pragma shader_feature USER_LUT
			//endex
			
			//ifex _PoiParallax==0
			#pragma shader_feature_local POI_PARALLAX
			//endex
			
			//ifex _EnableAudioLink==0
			#pragma shader_feature_local POI_AUDIOLINK
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#pragma shader_feature_local POI_BLACKLIGHTMASKING
			//endex
			
			//ifex _DetailEnabled==0
			#pragma shader_feature FINALPASS
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#pragma shader_feature AUTO_EXPOSURE
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#pragma shader_feature_local POI_VERTEX_GLITCHING
			#pragma shader_feature_local POI_VERTEX_GLITCHING_TEXTURE
			//endex
			
			//ifex _EnableDepthBulge==0
			#pragma shader_feature_local POI_DEPTHBULGE
			//endex
			
			//ifex _BackFaceEnabled!=1
			#pragma shader_feature_local POI_BACKFACE
			//endex
			
			//ifex _RGBMaskEnabled==0
			#pragma shader_feature VIGNETTE
			#pragma shader_feature GEOM_TYPE_MESH
			//endex
			
			//ifex _DecalEnabled==0
			#pragma shader_feature GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#pragma shader_feature GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#pragma shader_feature GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#pragma shader_feature DEPTH_OF_FIELD_COC_VIEW
			//endex
			
			//ifex _EnableDissolve==0
			#pragma shader_feature DISTORT
			//endex
			
			//ifex _ShadingEnabled==0
			#pragma shader_feature_local VIGNETTE_MASKED
			#pragma shader_feature_local _LIGHTINGMODE_TEXTURERAMP _LIGHTINGMODE_MULTILAYER_MATH _LIGHTINGMODE_SHADEMAP _LIGHTINGMODE_REALISTIC _LIGHTINGMODE_WRAPPED _LIGHTINGMODE_SKIN _LIGHTINGMODE_FLAT _LIGHTINGMODE_CLOTH _LIGHTINGMODE_SDF
			//endex
			
			//ifex _EnableAniso==0
			#pragma shader_feature_local POI_ANISOTROPICS
			//endex
			
			//ifex _MatcapEnable==0
			#pragma shader_feature_local POI_MATCAP0
			#pragma shader_feature_local POI_MATCAP0_CUSTOM_NORMAL
			//endex
			//ifex _Matcap2Enable==0
			#pragma shader_feature COLOR_GRADING_HDR_3D
			#pragma shader_feature_local POI_MATCAP1_CUSTOM_NORMAL
			//endex
			//ifex _Matcap3Enable==0
			#pragma shader_feature_local POI_MATCAP2
			#pragma shader_feature_local POI_MATCAP2_CUSTOM_NORMAL
			//endex
			//ifex _Matcap4Enable==0
			#pragma shader_feature_local POI_MATCAP3
			#pragma shader_feature_local POI_MATCAP3_CUSTOM_NORMAL
			//endex
			
			//ifex _CubeMapEnabled==0
			#pragma shader_feature_local _CUBEMAP
			//endex
			
			//ifex _EnableALDecal==0
			#pragma shader_feature_local POI_AL_DECAL
			//endex
			
			//ifex _EnableVolumeColor==0
			#pragma shader_feature_local POI_AL_VOLUMECOLOR
			//endex
			
			//ifex _EnableFlipbook==0
			#pragma shader_feature _SUNDISK_HIGH_QUALITY
			//endex
			
			//ifex _EnableEmission==0
			#pragma shader_feature _EMISSION
			//endex
			//ifex _EnableEmission1==0
			#pragma shader_feature_local POI_EMISSION_1
			//endex
			//ifex _EnableEmission2==0
			#pragma shader_feature_local POI_EMISSION_2
			//endex
			//ifex _EnableEmission3==0
			#pragma shader_feature_local POI_EMISSION_3
			//endex
			
			//ifex _EnableRimLighting==0
			#pragma shader_feature_local _GLOSSYREFLECTIONS_OFF
			#pragma shader_feature_local _RIMSTYLE_POIYOMI _RIMSTYLE_UTS2 _RIMSTYLE_LILTOON
			//endex
			//ifex _EnableRim2Lighting==0
			#pragma shader_feature_local POI_RIM2
			#pragma shader_feature_local _RIM2STYLE_POIYOMI _RIM2STYLE_UTS2 _RIM2STYLE_LILTOON
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#pragma shader_feature_local _POI_DEPTH_RIMLIGHT
			//endex
			
			//ifex _GlitterEnable==0
			#pragma shader_feature _SUNDISK_SIMPLE
			//endex
			
			//ifex _SubsurfaceScattering==0
			#pragma shader_feature_local POI_SUBSURFACESCATTERING
			//endex
			
			//ifex _MochieBRDF==0
			#pragma shader_feature_local MOCHIE_PBR
			//endex
			//ifex _ClearCoatBRDF==0
			#pragma shader_feature_local POI_CLEARCOAT
			//endex
			
			//ifex _EnableEnvironmentalRim==0
			#pragma shader_feature_local POI_ENVIRORIM
			//endex
			
			//ifex _StylizedSpecular==0
			#pragma shader_feature_local POI_STYLIZED_StylizedSpecular
			//endex
			
			//ifex _EnablePathing==0
			#pragma shader_feature_local POI_PATHING
			//endex
			
			//ifex _EnableMirrorOptions==0
			#pragma shader_feature_local POI_MIRROR
			//endex
			
			//ifex _EnableTouchGlow==0
			#pragma shader_feature GRAIN
			//endex
			
			//ifex _EnableIridescence==0
			#pragma shader_feature_local POI_IRIDESCENCE
			//endex
			
			//ifex _TextEnabled==0
			#pragma shader_feature EFFECT_BUMP
			//endex
			
			//ifex _PostProcess==0
			#pragma shader_feature_local POSTPROCESS
			//endex
			
			//ifex _PoiInternalParallax==0
			#pragma shader_feature_local POI_INTERNALPARALLAX
			//endex
			
			//ifex _NormalCorrect==0
			#pragma shader_feature_local POI_NORMALCORRECT
			//endex
			
			//ifex _BacklightEnabled!=1
			#pragma shader_feature_local POI_BACKLIGHT
			//endex
			
			//#pragma multi_compile_fwdbase
			#pragma multi_compile_instancing
			#pragma multi_compile _ VERTEXLIGHT_ON
			#define POI_PASS_META
			
			#define POI_WORLD
			
			// UNITY Includes
			#include "UnityCG.cginc"
			#include "UnityStandardUtils.cginc"
			#include "AutoLight.cginc"
			#include "UnityLightingCommon.cginc"
			#include "UnityPBSLighting.cginc"
			#ifdef POI_PASS_META
			#include "UnityMetaPass.cginc"
			#endif
			#pragma vertex vert
			
			#pragma fragment frag
			
			#define DielectricSpec float4(0.04, 0.04, 0.04, 1.0 - 0.04)
			#define PI float(3.14159265359)
			
			#define POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex,samplertex,coord,dx,dy) tex.SampleGrad (sampler##samplertex,coord,dx,dy)
			
			#define POI_PAN_UV(uv, pan) (uv + _Time.x * pan)
			#define POI2D_SAMPLER_PAN(tex, texSampler, uv, pan) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, POI_PAN_UV(uv, pan)))
			#define POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, POI_PAN_UV(uv, pan), dx, dy))
			#define POI2D_SAMPLER(tex, texSampler, uv) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_GRAD(tex, texSampler, uv, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, uv, dx, dy))
			#define POI2D_PAN(tex, uv, pan) (tex2D(tex, POI_PAN_UV(uv, pan)))
			#define POI2D(tex, uv) (tex2D(tex, uv))
			#define POI_SAMPLE_TEX2D(tex, uv) (UNITY_SAMPLE_TEX2D(tex, uv))
			#define POI_SAMPLE_TEX2D_PAN(tex, uv, pan) (UNITY_SAMPLE_TEX2D(tex, POI_PAN_UV(uv, pan)))
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_MAINTEX_SAMPLER_PAN_INLINED(tex, poiMesh) (POI2D_SAMPLER_PAN(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan))
			
			#define POI_SAFE_RGB0 float4(mainTexture.rgb * .0001, 0)
			#define POI_SAFE_RGB1 float4(mainTexture.rgb * .0001, 1)
			#define POI_SAFE_RGBA mainTexture
			
			#if defined(UNITY_COMPILER_HLSL)
			#define PoiInitStruct(type, name) name = (type)0;
			#else
			#define PoiInitStruct(type, name)
			#endif
			
			#define POI_ERROR(poiMesh, gridSize) lerp(float3(1, 0, 1), float3(0, 0, 0), fmod(floor((poiMesh.worldPos.x) * gridSize) + floor((poiMesh.worldPos.y) * gridSize) + floor((poiMesh.worldPos.z) * gridSize), 2) == 0)
			#define POI_NAN (asfloat(-1))
			
			#define POI_MODE_OPAQUE 0
			#define POI_MODE_CUTOUT 1
			#define POI_MODE_FADE 2
			#define POI_MODE_TRANSPARENT 3
			#define POI_MODE_ADDITIVE 4
			#define POI_MODE_SOFTADDITIVE 5
			#define POI_MODE_MULTIPLICATIVE 6
			#define POI_MODE_2XMULTIPLICATIVE 7
			#define POI_MODE_TRANSCLIPPING 9
			
			/*
			Texture2D ;
			float4 _ST;
			float2 Pan;
			float UV;
			float Stochastic;
			
			[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3, Panosphere, 4, World Pos XZ, 5, Polar UV, 6, Distorted UV, 7 )]
			*/
			
			#define POI_DECLARETEX_ST_UV(tex) float4 tex##_ST; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV;
			#define POI_DECLARETEX_ST_UV_PAN_STOCHASTIC(tex) float4 tex##_ST; float2 tex##Pan; float tex##UV; float tex##Stochastic;
			//ifex _EnableAudioLink==0
			// Map of where features in AudioLink are.
			#define ALPASS_DFT                      uint2(0,4)   //Size: 128, 2
			#define ALPASS_WAVEFORM                 uint2(0,6)   //Size: 128, 16
			#define ALPASS_AUDIOLINK                uint2(0,0)   //Size: 128, 4
			#define ALPASS_AUDIOBASS                uint2(0,0)   //Size: 128, 1
			#define ALPASS_AUDIOLOWMIDS             uint2(0,1)   //Size: 128, 1
			#define ALPASS_AUDIOHIGHMIDS            uint2(0,2)   //Size: 128, 1
			#define ALPASS_AUDIOTREBLE              uint2(0,3)   //Size: 128, 1
			#define ALPASS_AUDIOLINKHISTORY         uint2(1,0)   //Size: 127, 4
			#define ALPASS_GENERALVU                uint2(0,22)  //Size: 12, 1
			#define ALPASS_CCINTERNAL               uint2(12,22) //Size: 12, 2
			#define ALPASS_CCCOLORS                 uint2(25,22) //Size: 11, 1
			#define ALPASS_CCSTRIP                  uint2(0,24)  //Size: 128, 1
			#define ALPASS_CCLIGHTS                 uint2(0,25)  //Size: 128, 2
			#define ALPASS_AUTOCORRELATOR           uint2(0,27)  //Size: 128, 1
			#define ALPASS_GENERALVU_INSTANCE_TIME  uint2(2,22)
			#define ALPASS_GENERALVU_LOCAL_TIME     uint2(3,22)
			#define ALPASS_GENERALVU_NETWORK_TIME   uint2(4,22)
			#define ALPASS_GENERALVU_PLAYERINFO     uint2(6,22)
			// Added in version 2.5
			#define ALPASS_FILTEREDAUDIOLINK        uint2(0,28)  //Size: 16, 4
			// Added in version 2.6
			#define ALPASS_CHRONOTENSITY            uint2(16,28) //Size: 8, 4
			#define ALPASS_THEME_COLOR0             uint2(0,23)
			#define ALPASS_THEME_COLOR1             uint2(1,23)
			#define ALPASS_THEME_COLOR2             uint2(2,23)
			#define ALPASS_THEME_COLOR3             uint2(3,23)
			#define ALPASS_FILTEREDVU               uint2(24,28) //Size: 4, 4
			#define ALPASS_FILTEREDVU_INTENSITY     uint2(24,28) //Size: 4, 1
			#define ALPASS_FILTEREDVU_MARKER        uint2(24,29) //Size: 4, 1
			
			// Some basic constants to use (Note, these should be compatible with
			// future version of AudioLink, but may change.
			#define AUDIOLINK_SAMPHIST              3069        // Internal use for algos, do not change.
			#define AUDIOLINK_SAMPLEDATA24          2046
			#define AUDIOLINK_EXPBINS               24
			#define AUDIOLINK_EXPOCT                10
			#define AUDIOLINK_ETOTALBINS (AUDIOLINK_EXPBINS * AUDIOLINK_EXPOCT)
			#define AUDIOLINK_WIDTH                 128
			#define AUDIOLINK_SPS                   48000       // Samples per second
			#define AUDIOLINK_ROOTNOTE              0
			#define AUDIOLINK_4BAND_FREQFLOOR       0.123
			#define AUDIOLINK_4BAND_FREQCEILING     1
			#define AUDIOLINK_BOTTOM_FREQUENCY      13.75
			#define AUDIOLINK_BASE_AMPLITUDE        2.5
			#define AUDIOLINK_DELAY_COEFFICIENT_MIN 0.3
			#define AUDIOLINK_DELAY_COEFFICIENT_MAX 0.9
			#define AUDIOLINK_DFT_Q                 4.0
			#define AUDIOLINK_TREBLE_CORRECTION     5.0
			
			// ColorChord constants
			#define COLORCHORD_EMAXBIN              192
			#define COLORCHORD_IIR_DECAY_1          0.90
			#define COLORCHORD_IIR_DECAY_2          0.85
			#define COLORCHORD_CONSTANT_DECAY_1     0.01
			#define COLORCHORD_CONSTANT_DECAY_2     0.0
			#define COLORCHORD_NOTE_CLOSEST         3.0
			#define COLORCHORD_NEW_NOTE_GAIN        8.0
			#define COLORCHORD_MAX_NOTES            10
			
			uniform float4               _AudioTexture_TexelSize;
			
			#ifdef SHADER_TARGET_SURFACE_ANALYSIS
			#define AUDIOLINK_STANDARD_INDEXING
			#endif
			
			// Mechanism to index into texture.
			#ifdef AUDIOLINK_STANDARD_INDEXING
			sampler2D _AudioTexture;
			#define AudioLinkData(xycoord) tex2Dlod(_AudioTexture, float4(uint2(xycoord) * _AudioTexture_TexelSize.xy, 0, 0))
			#else
			uniform Texture2D<float4> _AudioTexture;
			SamplerState sampler_AudioTexture;
			#define AudioLinkData(xycoord) _AudioTexture[uint2(xycoord)]
			#endif
			uniform sampler2D _Stored;
			uniform float4 _Stored_TexelSize;
			#define LumaData(x,y) tex2Dlod(_Stored, float4(x, y, 0, 0))
			//endex
			
			float _Mode;
			
			float _StochasticDeliotHeitzDensity;
			float _StochasticHexGridDensity;
			float _StochasticHexRotationStrength;
			float _StochasticHexFallOffContrast;
			float _StochasticHexFallOffPower;
			
			float _IgnoreFog;
			float _RenderingReduceClipDistance;
			float _AddBlendOp;
			
			float4 _Color;
			float _ColorThemeIndex;
			UNITY_DECLARE_TEX2D(_MainTex);
			UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);
			float _MainPixelMode;
			float4 _MainTex_ST;
			float2 _MainTexPan;
			float _MainTexUV;
			float4 _MainTex_TexelSize;
			float _MainTexStochastic;
			#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BumpMap;
			#endif
			float4 _BumpMap_ST;
			float2 _BumpMapPan;
			float _BumpMapUV;
			float _BumpScale;
			float _BumpMapStochastic;
			Texture2D _ClippingMask;
			float4 _ClippingMask_ST;
			float2 _ClippingMaskPan;
			float _ClippingMaskUV;
			float _Inverse_Clipping;
			float _Cutoff;
			//ifex _MainColorAdjustToggle==0
			float _MainColorAdjustToggle;
			#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MainColorAdjustTexture;
			#endif
			float4 _MainColorAdjustTexture_ST;
			float2 _MainColorAdjustTexturePan;
			float _MainColorAdjustTextureUV;
			float _MainHueShiftToggle;
			float _MainHueShiftReplace;
			float _MainHueShift;
			float _MainHueShiftSpeed;
			float _Saturation;
			float _MainBrightness;
			
			float _MainHueALCTEnabled;
			float _MainALHueShiftBand;
			float _MainALHueShiftCTIndex;
			float _MainHueALMotionSpeed;
			
			float _MainHueGlobalMask;
			float _MainHueGlobalMaskBlendType;
			float _MainSaturationGlobalMask;
			float _MainSaturationGlobalMaskBlendType;
			float _MainBrightnessGlobalMask;
			float _MainBrightnessGlobalMaskBlendType;
			//endex
			
			SamplerState sampler_linear_clamp;
			SamplerState sampler_linear_repeat;
			
			float _AlphaForceOpaque;
			float _AlphaMod;
			float _AlphaPremultiply;
			float _AlphaBoostFA;
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			float _AlphaToCoverage;
			float _AlphaSharpenedA2C;
			float _AlphaMipScale;
			//endex
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			float _AlphaDithering;
			float _AlphaDitherGradient;
			float _AlphaDitherBias;
			//endex
			
			//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
			float _AlphaDistanceFade;
			float _AlphaDistanceFadeType;
			float _AlphaDistanceFadeMinAlpha;
			float _AlphaDistanceFadeMaxAlpha;
			float _AlphaDistanceFadeMin;
			float _AlphaDistanceFadeMax;
			float _AlphaDistanceFadeGlobalMask;
			float _AlphaDistanceFadeGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
			float _AlphaFresnel;
			float _AlphaFresnelAlpha;
			float _AlphaFresnelSharpness;
			float _AlphaFresnelWidth;
			float _AlphaFresnelInvert;
			float _AlphaFresnelGlobalMask;
			float _AlphaFresnelGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
			float _AlphaAngular;
			float _AngleType;
			float _AngleCompareTo;
			float3 _AngleForwardDirection;
			float _CameraAngleMin;
			float _CameraAngleMax;
			float _ModelAngleMin;
			float _ModelAngleMax;
			float _AngleMinAlpha;
			float _AlphaAngularGlobalMask;
			float _AlphaAngularGlobalMaskBlendType;
			//endex
			
			//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
			float _AlphaAudioLinkEnabled;
			float2 _AlphaAudioLinkAddRange;
			float _AlphaAudioLinkAddBand;
			//endex
			
			float _AlphaGlobalMask;
			float _AlphaGlobalMaskBlendType;
			
			float _GIEmissionMultiplier;
			
			float4 _GlobalThemeColor0;
			float4 _GlobalThemeColor1;
			float4 _GlobalThemeColor2;
			float4 _GlobalThemeColor3;
			float _GlobalThemeHue0;
			float _GlobalThemeHue1;
			float _GlobalThemeHue2;
			float _GlobalThemeHue3;
			float _GlobalThemeHueSpeed0;
			float _GlobalThemeHueSpeed1;
			float _GlobalThemeHueSpeed2;
			float _GlobalThemeHueSpeed3;
			float _GlobalThemeSaturation0;
			float _GlobalThemeSaturation1;
			float _GlobalThemeSaturation2;
			float _GlobalThemeSaturation3;
			float _GlobalThemeValue0;
			float _GlobalThemeValue1;
			float _GlobalThemeValue2;
			float _GlobalThemeValue3;
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture0;
			#endif
			float4 _GlobalMaskTexture0_ST;
			float2 _GlobalMaskTexture0Pan;
			float _GlobalMaskTexture0UV;
			int _GlobalMaskTexture0Split;
			float4 _GlobalMaskTexture0SplitTilingOffset_G;
			float4 _GlobalMaskTexture0SplitPan_G;
			float4 _GlobalMaskTexture0SplitTilingOffset_B;
			float4 _GlobalMaskTexture0SplitPan_B;
			float4 _GlobalMaskTexture0SplitTilingOffset_A;
			float4 _GlobalMaskTexture0SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture1;
			#endif
			float4 _GlobalMaskTexture1_ST;
			float2 _GlobalMaskTexture1Pan;
			float _GlobalMaskTexture1UV;
			int _GlobalMaskTexture1Split;
			float4 _GlobalMaskTexture1SplitTilingOffset_G;
			float4 _GlobalMaskTexture1SplitPan_G;
			float4 _GlobalMaskTexture1SplitTilingOffset_B;
			float4 _GlobalMaskTexture1SplitPan_B;
			float4 _GlobalMaskTexture1SplitTilingOffset_A;
			float4 _GlobalMaskTexture1SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture2;
			#endif
			float4 _GlobalMaskTexture2_ST;
			float2 _GlobalMaskTexture2Pan;
			float _GlobalMaskTexture2UV;
			int _GlobalMaskTexture2Split;
			float4 _GlobalMaskTexture2SplitTilingOffset_G;
			float4 _GlobalMaskTexture2SplitPan_G;
			float4 _GlobalMaskTexture2SplitTilingOffset_B;
			float4 _GlobalMaskTexture2SplitPan_B;
			float4 _GlobalMaskTexture2SplitTilingOffset_A;
			float4 _GlobalMaskTexture2SplitPan_A;
			
			#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlobalMaskTexture3;
			#endif
			float4 _GlobalMaskTexture3_ST;
			float2 _GlobalMaskTexture3Pan;
			float _GlobalMaskTexture3UV;
			int _GlobalMaskTexture3Split;
			float4 _GlobalMaskTexture3SplitTilingOffset_G;
			float4 _GlobalMaskTexture3SplitPan_G;
			float4 _GlobalMaskTexture3SplitTilingOffset_B;
			float4 _GlobalMaskTexture3SplitPan_B;
			float4 _GlobalMaskTexture3SplitTilingOffset_A;
			float4 _GlobalMaskTexture3SplitPan_A;
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			float _GlobalMaskOptionsEnable;
			int _GlobalMaskOptionsType;
			
			//ifex _GlobalMaskOptionsType!=0
			float _GlobalMaskSlider_0;
			float _GlobalMaskSlider_1;
			float _GlobalMaskSlider_2;
			float _GlobalMaskSlider_3;
			float _GlobalMaskSlider_4;
			float _GlobalMaskSlider_5;
			float _GlobalMaskSlider_6;
			float _GlobalMaskSlider_7;
			float _GlobalMaskSlider_8;
			float _GlobalMaskSlider_9;
			float _GlobalMaskSlider_10;
			float _GlobalMaskSlider_11;
			float _GlobalMaskSlider_12;
			float _GlobalMaskSlider_13;
			float _GlobalMaskSlider_14;
			float _GlobalMaskSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=1
			float2 _GlobalMaskMinMaxSlider_0;
			float2 _GlobalMaskMinMaxSlider_1;
			float2 _GlobalMaskMinMaxSlider_2;
			float2 _GlobalMaskMinMaxSlider_3;
			float2 _GlobalMaskMinMaxSlider_4;
			float2 _GlobalMaskMinMaxSlider_5;
			float2 _GlobalMaskMinMaxSlider_6;
			float2 _GlobalMaskMinMaxSlider_7;
			float2 _GlobalMaskMinMaxSlider_8;
			float2 _GlobalMaskMinMaxSlider_9;
			float2 _GlobalMaskMinMaxSlider_10;
			float2 _GlobalMaskMinMaxSlider_11;
			float2 _GlobalMaskMinMaxSlider_12;
			float2 _GlobalMaskMinMaxSlider_13;
			float2 _GlobalMaskMinMaxSlider_14;
			float2 _GlobalMaskMinMaxSlider_15;
			//endex
			
			//ifex _GlobalMaskOptionsType!=2
			int  _GlobalMaskToggleOn_0;
			int _GlobalMaskToggleOff_0;
			int  _GlobalMaskToggleOn_1;
			int _GlobalMaskToggleOff_1;
			int  _GlobalMaskToggleOn_2;
			int _GlobalMaskToggleOff_2;
			int  _GlobalMaskToggleOn_3;
			int _GlobalMaskToggleOff_3;
			int  _GlobalMaskToggleOn_4;
			int _GlobalMaskToggleOff_4;
			int  _GlobalMaskToggleOn_5;
			int _GlobalMaskToggleOff_5;
			int  _GlobalMaskToggleOn_6;
			int _GlobalMaskToggleOff_6;
			int  _GlobalMaskToggleOn_7;
			int _GlobalMaskToggleOff_7;
			int  _GlobalMaskToggleOn_8;
			int _GlobalMaskToggleOff_8;
			int  _GlobalMaskToggleOn_9;
			int _GlobalMaskToggleOff_9;
			int  _GlobalMaskToggleOn_10;
			int _GlobalMaskToggleOff_10;
			int  _GlobalMaskToggleOn_11;
			int _GlobalMaskToggleOff_11;
			int  _GlobalMaskToggleOn_12;
			int _GlobalMaskToggleOff_12;
			int  _GlobalMaskToggleOn_13;
			int _GlobalMaskToggleOff_13;
			int  _GlobalMaskToggleOn_14;
			int _GlobalMaskToggleOff_14;
			int  _GlobalMaskToggleOn_15;
			int _GlobalMaskToggleOff_15;
			//endex
			//endex
			//ifex _GlobalMaskModifiersBackfaceEnable==0
			float _GlobalMaskModifiersBackfaceEnable;
			float _GlobalMaskBackface_0;
			float _GlobalMaskBackface_1;
			float _GlobalMaskBackface_2;
			float _GlobalMaskBackface_3;
			float _GlobalMaskBackface_4;
			float _GlobalMaskBackface_5;
			float _GlobalMaskBackface_6;
			float _GlobalMaskBackface_7;
			float _GlobalMaskBackface_8;
			float _GlobalMaskBackface_9;
			float _GlobalMaskBackface_10;
			float _GlobalMaskBackface_11;
			float _GlobalMaskBackface_12;
			float _GlobalMaskBackface_13;
			float _GlobalMaskBackface_14;
			float _GlobalMaskBackface_15;
			//endex
			
			//ifex _GlobalMaskModifiersMirrorEnable==0
			float _GlobalMaskModifiersMirrorEnable;
			float _GlobalMaskMirrorVisibilityMode;
			float _GlobalMaskMirror_0;
			float _GlobalMaskMirror_1;
			float _GlobalMaskMirror_2;
			float _GlobalMaskMirror_3;
			float _GlobalMaskMirror_4;
			float _GlobalMaskMirror_5;
			float _GlobalMaskMirror_6;
			float _GlobalMaskMirror_7;
			float _GlobalMaskMirror_8;
			float _GlobalMaskMirror_9;
			float _GlobalMaskMirror_10;
			float _GlobalMaskMirror_11;
			float _GlobalMaskMirror_12;
			float _GlobalMaskMirror_13;
			float _GlobalMaskMirror_14;
			float _GlobalMaskMirror_15;
			//endex
			
			//ifex _GlobalMaskModifiersCameraEnable==0
			float _GlobalMaskModifiersCameraEnable;
			float _GlobalMaskCamera_0;
			float _GlobalMaskCamera_1;
			float _GlobalMaskCamera_2;
			float _GlobalMaskCamera_3;
			float _GlobalMaskCamera_4;
			float _GlobalMaskCamera_5;
			float _GlobalMaskCamera_6;
			float _GlobalMaskCamera_7;
			float _GlobalMaskCamera_8;
			float _GlobalMaskCamera_9;
			float _GlobalMaskCamera_10;
			float _GlobalMaskCamera_11;
			float _GlobalMaskCamera_12;
			float _GlobalMaskCamera_13;
			float _GlobalMaskCamera_14;
			float _GlobalMaskCamera_15;
			//endex
			
			//ifex _GlobalMaskModifiersDistanceEnable==0
			int _GlobalMaskModifiersDistanceEnable;
			
			//ifex _GlobalMaskDistanceEnable_0==0
			int _GlobalMaskDistanceEnable_0;
			int _GlobalMaskDistanceType_0;
			float _GlobalMaskDistanceMin_0;
			float _GlobalMaskDistanceMax_0;
			float _GlobalMaskDistanceMinAlpha_0;
			float _GlobalMaskDistanceMaxAlpha_0;
			int _GlobalMaskDistanceBlendType_0;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_1==0
			int _GlobalMaskDistanceEnable_1;
			int _GlobalMaskDistanceType_1;
			float _GlobalMaskDistanceMin_1;
			float _GlobalMaskDistanceMax_1;
			float _GlobalMaskDistanceMinAlpha_1;
			float _GlobalMaskDistanceMaxAlpha_1;
			int _GlobalMaskDistanceBlendType_1;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_2==0
			int _GlobalMaskDistanceEnable_2;
			int _GlobalMaskDistanceType_2;
			float _GlobalMaskDistanceMin_2;
			float _GlobalMaskDistanceMax_2;
			float _GlobalMaskDistanceMinAlpha_2;
			float _GlobalMaskDistanceMaxAlpha_2;
			int _GlobalMaskDistanceBlendType_2;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_3==0
			int _GlobalMaskDistanceEnable_3;
			int _GlobalMaskDistanceType_3;
			float _GlobalMaskDistanceMin_3;
			float _GlobalMaskDistanceMax_3;
			float _GlobalMaskDistanceMinAlpha_3;
			float _GlobalMaskDistanceMaxAlpha_3;
			int _GlobalMaskDistanceBlendType_3;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_4==0
			int _GlobalMaskDistanceEnable_4;
			int _GlobalMaskDistanceType_4;
			float _GlobalMaskDistanceMin_4;
			float _GlobalMaskDistanceMax_4;
			float _GlobalMaskDistanceMinAlpha_4;
			float _GlobalMaskDistanceMaxAlpha_4;
			int _GlobalMaskDistanceBlendType_4;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_5==0
			int _GlobalMaskDistanceEnable_5;
			int _GlobalMaskDistanceType_5;
			float _GlobalMaskDistanceMin_5;
			float _GlobalMaskDistanceMax_5;
			float _GlobalMaskDistanceMinAlpha_5;
			float _GlobalMaskDistanceMaxAlpha_5;
			int _GlobalMaskDistanceBlendType_5;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_6==0
			int _GlobalMaskDistanceEnable_6;
			int _GlobalMaskDistanceType_6;
			float _GlobalMaskDistanceMin_6;
			float _GlobalMaskDistanceMax_6;
			float _GlobalMaskDistanceMinAlpha_6;
			float _GlobalMaskDistanceMaxAlpha_6;
			int _GlobalMaskDistanceBlendType_6;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_7==0
			int _GlobalMaskDistanceEnable_7;
			int _GlobalMaskDistanceType_7;
			float _GlobalMaskDistanceMin_7;
			float _GlobalMaskDistanceMax_7;
			float _GlobalMaskDistanceMinAlpha_7;
			float _GlobalMaskDistanceMaxAlpha_7;
			int _GlobalMaskDistanceBlendType_7;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_8==0
			int _GlobalMaskDistanceEnable_8;
			int _GlobalMaskDistanceType_8;
			float _GlobalMaskDistanceMin_8;
			float _GlobalMaskDistanceMax_8;
			float _GlobalMaskDistanceMinAlpha_8;
			float _GlobalMaskDistanceMaxAlpha_8;
			int _GlobalMaskDistanceBlendType_8;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_9==0
			int _GlobalMaskDistanceEnable_9;
			int _GlobalMaskDistanceType_9;
			float _GlobalMaskDistanceMin_9;
			float _GlobalMaskDistanceMax_9;
			float _GlobalMaskDistanceMinAlpha_9;
			float _GlobalMaskDistanceMaxAlpha_9;
			int _GlobalMaskDistanceBlendType_9;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_10==0
			int _GlobalMaskDistanceEnable_10;
			int _GlobalMaskDistanceType_10;
			float _GlobalMaskDistanceMin_10;
			float _GlobalMaskDistanceMax_10;
			float _GlobalMaskDistanceMinAlpha_10;
			float _GlobalMaskDistanceMaxAlpha_10;
			int _GlobalMaskDistanceBlendType_10;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_11==0
			int _GlobalMaskDistanceEnable_11;
			int _GlobalMaskDistanceType_11;
			float _GlobalMaskDistanceMin_11;
			float _GlobalMaskDistanceMax_11;
			float _GlobalMaskDistanceMinAlpha_11;
			float _GlobalMaskDistanceMaxAlpha_11;
			int _GlobalMaskDistanceBlendType_11;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_12==0
			int _GlobalMaskDistanceEnable_12;
			int _GlobalMaskDistanceType_12;
			float _GlobalMaskDistanceMin_12;
			float _GlobalMaskDistanceMax_12;
			float _GlobalMaskDistanceMinAlpha_12;
			float _GlobalMaskDistanceMaxAlpha_12;
			int _GlobalMaskDistanceBlendType_12;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_13==0
			int _GlobalMaskDistanceEnable_13;
			int _GlobalMaskDistanceType_13;
			float _GlobalMaskDistanceMin_13;
			float _GlobalMaskDistanceMax_13;
			float _GlobalMaskDistanceMinAlpha_13;
			float _GlobalMaskDistanceMaxAlpha_13;
			int _GlobalMaskDistanceBlendType_13;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_14==0
			int _GlobalMaskDistanceEnable_14;
			int _GlobalMaskDistanceType_14;
			float _GlobalMaskDistanceMin_14;
			float _GlobalMaskDistanceMax_14;
			float _GlobalMaskDistanceMinAlpha_14;
			float _GlobalMaskDistanceMaxAlpha_14;
			int _GlobalMaskDistanceBlendType_14;
			//endex
			
			//ifex _GlobalMaskDistanceEnable_15==0
			int _GlobalMaskDistanceEnable_15;
			int _GlobalMaskDistanceType_15;
			float _GlobalMaskDistanceMin_15;
			float _GlobalMaskDistanceMax_15;
			float _GlobalMaskDistanceMinAlpha_15;
			float _GlobalMaskDistanceMaxAlpha_15;
			int _GlobalMaskDistanceBlendType_15;
			//endex
			//endex
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			float _UDIMDiscardMode;
			float _UDIMDiscardUV;
			float _UDIMDiscardRow3_0;
			float _UDIMDiscardRow3_1;
			float _UDIMDiscardRow3_2;
			float _UDIMDiscardRow3_3;
			float _UDIMDiscardRow2_0;
			float _UDIMDiscardRow2_1;
			float _UDIMDiscardRow2_2;
			float _UDIMDiscardRow2_3;
			float _UDIMDiscardRow1_0;
			float _UDIMDiscardRow1_1;
			float _UDIMDiscardRow1_2;
			float _UDIMDiscardRow1_3;
			float _UDIMDiscardRow0_0;
			float _UDIMDiscardRow0_1;
			float _UDIMDiscardRow0_2;
			float _UDIMDiscardRow0_3;
			#endif
			//endex
			
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture;
			float4 _DistortionFlowTexture_ST;
			float2 _DistortionFlowTexturePan;
			float _DistortionFlowTextureUV;
			#endif
			
			#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionFlowTexture1;
			float4 _DistortionFlowTexture1_ST;
			float2 _DistortionFlowTexture1Pan;
			float _DistortionFlowTexture1UV;
			#endif
			
			#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DistortionMask;
			float4 _DistortionMask_ST;
			float2 _DistortionMaskPan;
			float _DistortionMaskUV;
			float _DistortionMaskChannel;
			#endif
			
			float _DistortionUvToDistort;
			float _DistortionStrength;
			float _DistortionStrength1;
			
			#ifdef POI_AUDIOLINK
			half _EnableDistortionAudioLink;
			half2 _DistortionStrengthAudioLink;
			half _DistortionStrengthAudioLinkBand;
			half2 _DistortionStrength1AudioLink;
			half _DistortionStrength1AudioLinkBand;
			#endif
			#endif
			//endex
			float _StereoEnabled;
			float _PolarUV;
			float2 _PolarCenter;
			float _PolarRadialScale;
			float _PolarLengthScale;
			float _PolarSpiralPower;
			float _PanoUseBothEyes;
			
			float _UVModWorldPos0;
			float _UVModWorldPos1;
			float _UVModLocalPos0;
			float _UVModLocalPos1;
			
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			float _AudioLinkDelay;
			float _AudioLinkAnimToggle;
			
			float _AudioLinkSmoothingBass;
			float _AudioLinkSmoothingLowMid;
			float _AudioLinkSmoothingHighMid;
			float _AudioLinkSmoothingTreble;
			
			float _DebugWaveform;
			float _DebugDFT;
			float _DebugBass;
			float _DebugLowMids;
			float _DebugHighMids;
			float _DebugTreble;
			float _DebugCCColors;
			float _DebugCCStrip;
			float _DebugCCLights;
			float _DebugAutocorrelator;
			float _DebugChronotensity;
			float _AudioLinkCCStripY;
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			float _BlackLightMasking0Key;
			float2 _BlackLightMasking0Range;
			float _BlackLightMasking0GlobalMaskIndex;
			float _BlackLightMasking0GlobalMaskBlendType;
			
			float _BlackLightMasking1Key;
			float2 _BlackLightMasking1Range;
			float _BlackLightMasking1GlobalMaskIndex;
			float _BlackLightMasking1GlobalMaskBlendType;
			
			float _BlackLightMasking2Key;
			float2 _BlackLightMasking2Range;
			float _BlackLightMasking2GlobalMaskIndex;
			float _BlackLightMasking2GlobalMaskBlendType;
			
			float _BlackLightMasking3Key;
			float2 _BlackLightMasking3Range;
			float _BlackLightMasking3GlobalMaskIndex;
			float _BlackLightMasking3GlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _DetailEnabled==0
			#ifdef FINALPASS
			#if defined(PROP_DETAILMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailMask;
			#endif
			float4 _DetailMask_ST;
			float2 _DetailMaskPan;
			float _DetailMaskUV;
			float _DetailMaskStochastic;
			
			#if defined(PROP_DETAILNORMALMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailNormalMap;
			#endif
			float4 _DetailNormalMap_ST;
			float2 _DetailNormalMapPan;
			float _DetailNormalMapUV;
			float _DetailNormalMapScale;
			float _DetailNormalMapStochastic;
			float _DetailNormalGlobalMask;
			float _DetailNormalGlobalMaskBlendType;
			
			#if defined(PROP_DETAILTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DetailTex;
			#endif
			float4 _DetailTex_ST;
			float2 _DetailTexPan;
			float _DetailTexUV;
			float _DetailTexStochastic;
			
			float3 _DetailTint;
			float _DetailTintThemeIndex;
			float _DetailTexIntensity;
			float _DetailBrightness;
			float _DetailTexGlobalMask;
			float _DetailTexGlobalMaskBlendType;
			#endif
			//endex
			
			//ifex _VertexManipulationsEnabled==0
			#ifdef AUTO_EXPOSURE
			float4 _VertexManipulationLocalTranslation;
			float4 _VertexManipulationLocalRotation;
			float3 _VertexManipulationLocalRotationSpeed;
			float4 _VertexManipulationLocalScale;
			float4 _VertexManipulationWorldTranslation;
			float _VertexManipulationHeight;
			sampler2D _VertexManipulationHeightMask;
			float4 _VertexManipulationHeightMask_ST;
			float2 _VertexManipulationHeightMaskPan;
			float _VertexManipulationHeightMaskUV;
			float _VertexManipulationHeightMaskChannel;
			float _VertexManipulationHeightBias;
			float _VertexRoundingEnabled;
			int _VertexRoundingSpace;
			float _VertexRoundingDivision;
			
			//AL
			float _VertexAudioLinkEnabled;
			float3 _VertexLocalTranslationALMin;
			float3 _VertexLocalTranslationALMax;
			float _VertexLocalTranslationALBand;
			
			float3 _VertexLocalRotationAL;
			float _VertexLocalRotationALBand;
			
			float3 _VertexLocalRotationCTALSpeed;
			float _VertexLocalRotationCTALBandX;
			float _VertexLocalRotationCTALBandY;
			float _VertexLocalRotationCTALBandZ;
			float _VertexLocalRotationCTALTypeX;
			float _VertexLocalRotationCTALTypeY;
			float _VertexLocalRotationCTALTypeZ;
			
			float4 _VertexLocalScaleALMin;
			float4 _VertexLocalScaleALMax;
			float _VertexLocalScaleALBand;
			
			float3 _VertexWorldTranslationALMin;
			float3 _VertexWorldTranslationALMax;
			float _VertexWorldTranslationALBand;
			
			float2 _VertexManipulationHeightAL;
			float _VertexManipulationHeightBand;
			
			float2 _VertexRoundingRangeAL;
			float _VertexRoundingRangeBand;
			
			float _VertexBarrelMode;
			float _VertexBarrelWidth;
			float _VertexBarrelAlpha;
			float _VertexBarrelHeight;
			
			float _VertexSphereMode;
			float _VertexSphereRadius;
			float _VertexSphereHeight;
			float _VertexSphereAlpha;
			float4 _VertexSphereCenter;
			
			float _VertexSpectrumMotion;
			float3 _VertexSpectrumOffsetMin;
			float3 _VertexSpectrumOffsetMax;
			float _VertexSpectrumUV;
			float _VertexSpectrumUVDirection;
			#endif
			//endex
			
			//ifex _VertexGlitchingEnabled==0
			#ifdef POI_VERTEX_GLITCHING
			//Vertex Glitching
			#if defined(POI_VERTEX_GLITCHING_TEXTURE)
			float _VertexGlitchingUseTexture;
			sampler2D _VertexGlitchMap;
			float4 _VertexGlitchMap_ST;
			#endif
			float _VertexGlitchThreshold;
			float _VertexGlitchFrequency;
			float _VertexGlitchStrength;
			float _VertexGlitchDensity;
			
			float _VertexGlitchMirrorEnable;
			float _VertexGlitchMirror;
			
			float _VertexGlitchMapPanSpeed;
			float _VertexGlitchingAudioLinkEnabled;
			float _VertexGlitchingAudioLinkBand;
			float _VertexGlitchingAudiolinkOverride;
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			float _MainVertexColoringEnabled;
			float _MainVertexColoringLinearSpace;
			float _MainVertexColoring;
			float _MainUseVertexColorAlpha;
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			float _BackFaceEnabled;
			float _BackFaceDetailIntensity;
			float _BackFaceEmissionStrength;
			float2 _BackFacePanning;
			float4 _BackFaceColor;
			float _BackFaceColorThemeIndex;
			float _BackFaceReplaceAlpha;
			
			#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceTexture;
			#endif
			float4 _BackFaceTexture_ST;
			float2 _BackFaceTexturePan;
			float _BackFaceTextureUV;
			
			#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BackFaceMask;
			#endif
			float4 _BackFaceMask_ST;
			float2 _BackFaceMaskPan;
			float _BackFaceMaskUV;
			float _BackFaceMaskChannel;
			
			float _BackFaceHueShiftEnabled;
			float _BackFaceHueShift;
			float _BackFaceHueShiftSpeed;
			float _BackFaceEmissionLimiter;
			#endif
			
			//TODO detail strength stuff
			//endex
			
			//ifex _RGBMaskEnabled==0
			#ifdef VIGNETTE
			#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RGBMask;
			#endif
			float4 _RGBMask_ST;
			float2 _RGBMaskPan;
			float _RGBMaskUV;
			
			#if defined(PROP_REDTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RedTexture;
			#endif
			float4 _RedTexture_ST;
			float2 _RedTexturePan;
			float _RedTextureUV;
			float _RedAlphaAdd;
			float _RedTextureStochastic;
			float _RgbRedMaskChannel;
			float _RgbRedGlobalMaskChannel;
			float _RgbRedGlobalMaskBlendType;
			
			#if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GreenTexture;
			#endif
			float4 _GreenTexture_ST;
			float2 _GreenTexturePan;
			float _GreenTextureUV;
			float _GreenAlphaAdd;
			float _GreenTextureStochastic;
			float _RgbGreenMaskChannel;
			float _RgbGreenGlobalMaskChannel;
			float _RgbGreenGlobalMaskBlendType;
			
			#if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BlueTexture;
			#endif
			float4 _BlueTexture_ST;
			float2 _BlueTexturePan;
			float _BlueTextureUV;
			float _BlueAlphaAdd;
			float _BlueTextureStochastic;
			float _RgbBlueMaskChannel;
			float _RgbBlueGlobalMaskChannel;
			float _RgbBlueGlobalMaskBlendType;
			
			#if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AlphaTexture;
			#endif
			float4 _AlphaTexture_ST;
			float2 _AlphaTexturePan;
			float _AlphaTextureUV;
			float _AlphaAlphaAdd;
			float _AlphaTextureStochastic;
			float _RgbAlphaMaskChannel;
			float _RgbAlphaGlobalMaskChannel;
			float _RgbAlphaGlobalMaskBlendType;
			
			//ifex _RgbNormalsEnabled==0
			#ifdef GEOM_TYPE_MESH
			#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalR;
			#endif
			float4 _RgbNormalR_ST;
			float2 _RgbNormalRPan;
			float _RgbNormalRUV;
			float _RgbNormalRScale;
			float _RgbNormalRStochastic;
			float _RgbNormalRMaskChannel;
			float _RgbNormalRGlobalMaskChannel;
			float _RgbNormalRGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalG;
			#endif
			float4 _RgbNormalG_ST;
			float2 _RgbNormalGPan;
			float _RgbNormalGUV;
			float _RgbNormalGScale;
			float _RgbNormalGStochastic;
			float _RgbNormalGMaskChannel;
			float _RgbNormalGGlobalMaskChannel;
			float _RgbNormalGGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalB;
			#endif
			float4 _RgbNormalB_ST;
			float2 _RgbNormalBPan;
			float _RgbNormalBUV;
			float _RgbNormalBScale;
			float _RgbNormalBStochastic;
			float _RgbNormalBMaskChannel;
			float _RgbNormalBGlobalMaskChannel;
			float _RgbNormalBGlobalMaskBlendType;
			
			#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RgbNormalA;
			#endif
			float4 _RgbNormalA_ST;
			float2 _RgbNormalAPan;
			float _RgbNormalAUV;
			float _RgbNormalAScale;
			float _RgbNormalAStochastic;
			float _RgbNormalAMaskChannel;
			float _RgbNormalAGlobalMaskChannel;
			float _RgbNormalAGlobalMaskBlendType;
			
			float _RgbNormalsEnabled;
			#endif
			//endex
			
			float4 _RedColor;
			float4 _GreenColor;
			float4 _BlueColor;
			float4 _AlphaColor;
			
			float _RedColorThemeIndex;
			float _GreenColorThemeIndex;
			float _BlueColorThemeIndex;
			float _AlphaColorThemeIndex;
			
			float _RGBBlendMultiplicative;
			float _RGBUseVertexColors;
			float _RGBNormalBlend;
			#endif
			//endex
			
			//ifex _DecalEnabled==0 && _DecalEnabled1==0 && _DecalEnabled2==0 && _DecalEnabled3==0
			#if defined(PROP_DECALMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DecalMask;
			float4 _DecalMask_ST;
			float2 _DecalMaskPan;
			float _DecalMaskUV;
			#endif
			float _DecalTPSDepthMaskEnabled;
			float _Decal0TPSMaskStrength;
			float _Decal1TPSMaskStrength;
			float _Decal2TPSMaskStrength;
			float _Decal3TPSMaskStrength;
			#ifdef POI_AUDIOLINK
			//ifex _DecalEnabled==0
			#ifdef GEOM_TYPE_BRANCH
			// Audio Link
			half _AudioLinkDecal0ScaleBand;
			float4 _AudioLinkDecal0Scale;
			half _AudioLinkDecal0RotationBand;
			float2 _AudioLinkDecal0Rotation;
			half _AudioLinkDecal0AlphaBand;
			float2 _AudioLinkDecal0Alpha;
			half _AudioLinkDecal0EmissionBand;
			float2 _AudioLinkDecal0Emission;
			float _DecalRotationCTALBand0;
			float _DecalRotationCTALSpeed0;
			float _DecalRotationCTALType0;
			float _AudioLinkDecalCC0;
			float _AudioLinkDecal0SideBand;
			float4 _AudioLinkDecal0SideMin;
			float4 _AudioLinkDecal0SideMax;
			float2 _AudioLinkDecal0ChannelSeparation;
			float _AudioLinkDecal0ChannelSeparationBand;
			#endif //GEOM_TYPE_BRANCH
			//endex
			//ifex _DecalEnabled1==0
			#ifdef GEOM_TYPE_BRANCH_DETAIL
			half _AudioLinkDecal1ScaleBand;
			float4 _AudioLinkDecal1Scale;
			half _AudioLinkDecal1RotationBand;
			float2 _AudioLinkDecal1Rotation;
			half _AudioLinkDecal1AlphaBand;
			float2 _AudioLinkDecal1Alpha;
			half _AudioLinkDecal1EmissionBand;
			float2 _AudioLinkDecal1Emission;
			float _DecalRotationCTALBand1;
			float _DecalRotationCTALSpeed1;
			float _DecalRotationCTALType1;
			float _AudioLinkDecalCC1;
			float _AudioLinkDecal1SideBand;
			float4 _AudioLinkDecal1SideMin;
			float4 _AudioLinkDecal1SideMax;
			float2 _AudioLinkDecal1ChannelSeparation;
			float _AudioLinkDecal1ChannelSeparationBand;
			#endif //GEOM_TYPE_BRANCH_DETAIL
			//endex
			//ifex _DecalEnabled2==0
			#ifdef GEOM_TYPE_FROND
			half _AudioLinkDecal2ScaleBand;
			float4 _AudioLinkDecal2Scale;
			half _AudioLinkDecal2RotationBand;
			float2 _AudioLinkDecal2Rotation;
			half _AudioLinkDecal2AlphaBand;
			float2 _AudioLinkDecal2Alpha;
			half _AudioLinkDecal2EmissionBand;
			float2 _AudioLinkDecal2Emission;
			float _DecalRotationCTALBand2;
			float _DecalRotationCTALSpeed2;
			float _DecalRotationCTALType2;
			float _AudioLinkDecalCC2;
			float _AudioLinkDecal2SideBand;
			float4 _AudioLinkDecal2SideMin;
			float4 _AudioLinkDecal2SideMax;
			float2 _AudioLinkDecal2ChannelSeparation;
			float _AudioLinkDecal2ChannelSeparationBand;
			#endif //GEOM_TYPE_FROND
			//endex
			//ifex _DecalEnabled3==0
			#ifdef DEPTH_OF_FIELD_COC_VIEW
			half _AudioLinkDecal3ScaleBand;
			float4 _AudioLinkDecal3Scale;
			half _AudioLinkDecal3RotationBand;
			float2 _AudioLinkDecal3Rotation;
			half _AudioLinkDecal3AlphaBand;
			float2 _AudioLinkDecal3Alpha;
			half _AudioLinkDecal3EmissionBand;
			float2 _AudioLinkDecal3Emission;
			float _DecalRotationCTALBand3;
			float _DecalRotationCTALSpeed3;
			float _DecalRotationCTALType3;
			float _AudioLinkDecalCC3;
			float _AudioLinkDecal3SideBand;
			float4 _AudioLinkDecal3SideMin;
			float4 _AudioLinkDecal3SideMax;
			float2 _AudioLinkDecal3ChannelSeparation;
			float _AudioLinkDecal3ChannelSeparationBand;
			#endif //DEPTH_OF_FIELD_COC_VIEW
			//endex
			#endif
			//endex
			//ifex _DecalEnabled==0
			#ifdef GEOM_TYPE_BRANCH
			sampler2D _DecalTexture;
			
			float _Decal0MaskChannel;
			float _Decal0GlobalMask;
			float _Decal0GlobalMaskBlendType;
			float _Decal0ApplyGlobalMaskIndex;
			float _Decal0ApplyGlobalMaskBlendType;
			float4 _DecalTexture_ST;
			float2 _DecalTexturePan;
			float _DecalTextureUV;
			float4 _DecalColor;
			float _DecalColorThemeIndex;
			float _DecalTiled;
			float _DecalBlendType;
			half _DecalRotation;
			half2 _DecalScale;
			float4 _DecalSideOffset;
			half2 _DecalPosition;
			half _DecalRotationSpeed;
			float _DecalEmissionStrength;
			float _DecalBlendAlpha;
			float _DecalOverrideAlpha;
			float _DecalHueShiftEnabled;
			float _DecalHueShift;
			float _DecalHueShiftSpeed;
			float _Decal0Depth;
			float _Decal0HueAngleStrength;
			float _Decal0ChannelSeparationEnable;
			float _Decal0ChannelSeparation;
			float _Decal0ChannelSeparationPremultiply;
			float _Decal0ChannelSeparationHue;
			float _Decal0ChannelSeparationVertical;
			float _Decal0ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled1==0
			#ifdef GEOM_TYPE_BRANCH_DETAIL
			sampler2D _DecalTexture1;
			
			float _Decal1MaskChannel;
			float _Decal1GlobalMask;
			float _Decal1GlobalMaskBlendType;
			float _Decal1ApplyGlobalMaskIndex;
			float _Decal1ApplyGlobalMaskBlendType;
			float4 _DecalTexture1_ST;
			float2 _DecalTexture1Pan;
			float _DecalTexture1UV;
			float4 _DecalColor1;
			float _DecalColor1ThemeIndex;
			fixed _DecalTiled1;
			float _DecalBlendType1;
			half _DecalRotation1;
			half2 _DecalScale1;
			float4 _DecalSideOffset1;
			half2 _DecalPosition1;
			half _DecalRotationSpeed1;
			float _DecalEmissionStrength1;
			float _DecalBlendAlpha1;
			float _DecalOverrideAlpha1;
			float _DecalHueShiftEnabled1;
			float _DecalHueShift1;
			float _DecalHueShiftSpeed1;
			float _Decal1Depth;
			float _Decal1HueAngleStrength;
			float _Decal1ChannelSeparationEnable;
			float _Decal1ChannelSeparation;
			float _Decal1ChannelSeparationPremultiply;
			float _Decal1ChannelSeparationHue;
			float _Decal1ChannelSeparationVertical;
			float _Decal1ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled2==0
			#ifdef GEOM_TYPE_FROND
			sampler2D _DecalTexture2;
			
			float _Decal2MaskChannel;
			float _Decal2GlobalMask;
			float _Decal2GlobalMaskBlendType;
			float _Decal2ApplyGlobalMaskIndex;
			float _Decal2ApplyGlobalMaskBlendType;
			float4 _DecalTexture2_ST;
			float2 _DecalTexture2Pan;
			float _DecalTexture2UV;
			float4 _DecalColor2;
			float _DecalColor2ThemeIndex;
			fixed _DecalTiled2;
			float _DecalBlendType2;
			half _DecalRotation2;
			half2 _DecalScale2;
			float4 _DecalSideOffset2;
			half2 _DecalPosition2;
			half _DecalRotationSpeed2;
			float _DecalEmissionStrength2;
			float _DecalBlendAlpha2;
			float _DecalOverrideAlpha2;
			float _DecalHueShiftEnabled2;
			float _DecalHueShift2;
			float _DecalHueShiftSpeed2;
			float _Decal2Depth;
			float _Decal2HueAngleStrength;
			float _Decal2ChannelSeparationEnable;
			float _Decal2ChannelSeparation;
			float _Decal2ChannelSeparationPremultiply;
			float _Decal2ChannelSeparationHue;
			float _Decal2ChannelSeparationVertical;
			float _Decal2ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _DecalEnabled3==0
			#ifdef DEPTH_OF_FIELD_COC_VIEW
			sampler2D _DecalTexture3;
			
			float _Decal3MaskChannel;
			float _Decal3GlobalMask;
			float _Decal3GlobalMaskBlendType;
			float _Decal3ApplyGlobalMaskIndex;
			float _Decal3ApplyGlobalMaskBlendType;
			float4 _DecalTexture3_ST;
			float2 _DecalTexture3Pan;
			float _DecalTexture3UV;
			float4 _DecalColor3;
			float _DecalColor3ThemeIndex;
			fixed _DecalTiled3;
			float _DecalBlendType3;
			half _DecalRotation3;
			half2 _DecalScale3;
			float4 _DecalSideOffset3;
			half2 _DecalPosition3;
			half _DecalRotationSpeed3;
			float _DecalEmissionStrength3;
			float _DecalBlendAlpha3;
			float _DecalOverrideAlpha3;
			float _DecalHueShiftEnabled3;
			float _DecalHueShift3;
			float _DecalHueShiftSpeed3;
			float _Decal3Depth;
			float _Decal3HueAngleStrength;
			float _Decal3ChannelSeparationEnable;
			float _Decal3ChannelSeparation;
			float _Decal3ChannelSeparationPremultiply;
			float _Decal3ChannelSeparationHue;
			float _Decal3ChannelSeparationVertical;
			float _Decal3ChannelSeparationAngleStrength;
			#endif
			//endex
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			float _DissolveType;
			float _DissolveEdgeWidth;
			float4 _DissolveEdgeColor;
			sampler2D _DissolveEdgeGradient;
			float4 _DissolveEdgeGradient_ST;
			float2 _DissolveEdgeGradientPan;
			float _DissolveEdgeGradientUV;
			float _DissolveEdgeEmission;
			float4 _DissolveTextureColor;
			float _DissolveEdgeColorThemeIndex;
			float _DissolveTextureColorThemeIndex;
			
			#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveToTexture;
			#endif
			float4 _DissolveToTexture_ST;
			float2 _DissolveToTexturePan;
			float _DissolveToTextureUV;
			
			#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveNoiseTexture;
			#endif
			float4 _DissolveNoiseTexture_ST;
			float2 _DissolveNoiseTexturePan;
			float _DissolveNoiseTextureUV;
			
			#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveDetailNoise;
			#endif
			float4 _DissolveDetailNoise_ST;
			float2 _DissolveDetailNoisePan;
			float _DissolveDetailNoiseUV;
			
			#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _DissolveMask;
			#endif
			float4 _DissolveMask_ST;
			float2 _DissolveMaskPan;
			float _DissolveMaskUV;
			
			float _DissolveMaskGlobalMask;
			float _DissolveMaskGlobalMaskBlendType;
			float _DissolveMaskInvert;
			float _DissolveAlpha;
			float _ContinuousDissolve;
			float _DissolveDetailStrength;
			float _DissolveDetailEdgeSmoothing;
			float _DissolveEdgeHardness;
			float _DissolveInvertNoise;
			float _DissolveInvertDetailNoise;
			float _DissolveToEmissionStrength;
			
			// Point to Point
			float _DissolveP2PWorldLocal;
			float _DissolveP2PEdgeLength;
			float _DissolveP2PClamp;
			float4 _DissolveStartPoint;
			float4 _DissolveEndPoint;
			
			// Spherical
			float3 _SphericalDissolveCenter;
			float _SphericalDissolveRadius;
			float _SphericalDissolveInvert;
			float _SphericalDissolveClamp;
			
			// CenterOut
			float _CenterOutDissolveMode;
			float3 _CenterOutDissolveDirection;
			float _CenterOutDissolveInvert;
			float _CenterOutDissolveNormals;
			float _CenterOutDissolvePower;
			
			// World Dissolve
			float _DissolveWorldShape;
			float4 _DissolveShapePosition;
			float4 _DissolveShapeRotation;
			float _DissolveShapeScale;
			float _DissolveInvertShape;
			float _DissolveShapeEdgeLength;
			
			// UV Tile Dissolve
			float _UVTileDissolveEnabled;
			float _UVTileDissolveDiscardAtMax;
			float _UVTileDissolveUV;
			
			float _UVTileDissolveAlpha_Row3_0;
			float _UVTileDissolveAlpha_Row3_1;
			float _UVTileDissolveAlpha_Row3_2;
			float _UVTileDissolveAlpha_Row3_3;
			float _UVTileDissolveAlpha_Row2_0;
			float _UVTileDissolveAlpha_Row2_1;
			float _UVTileDissolveAlpha_Row2_2;
			float _UVTileDissolveAlpha_Row2_3;
			float _UVTileDissolveAlpha_Row1_0;
			float _UVTileDissolveAlpha_Row1_1;
			float _UVTileDissolveAlpha_Row1_2;
			float _UVTileDissolveAlpha_Row1_3;
			float _UVTileDissolveAlpha_Row0_0;
			float _UVTileDissolveAlpha_Row0_1;
			float _UVTileDissolveAlpha_Row0_2;
			float _UVTileDissolveAlpha_Row0_3;
			
			float _DissolveAlpha0;
			float _DissolveAlpha1;
			float _DissolveAlpha2;
			float _DissolveAlpha3;
			float _DissolveAlpha4;
			float _DissolveAlpha5;
			float _DissolveAlpha6;
			float _DissolveAlpha7;
			float _DissolveAlpha8;
			float _DissolveAlpha9;
			// Masking
			float _DissolveEmissionSide;
			float _DissolveEmission1Side;
			float _DissolveUseVertexColors;
			
			float4 edgeColor;
			float edgeAlpha;
			float dissolveAlpha;
			float4 dissolveToTexture;
			
			float _DissolveHueShiftEnabled;
			float _DissolveHueShiftSpeed;
			float _DissolveHueShift;
			float _DissolveEdgeHueShiftEnabled;
			float _DissolveEdgeHueShiftSpeed;
			float _DissolveEdgeHueShift;
			
			// Audio Link
			#ifdef POI_AUDIOLINK
			fixed _EnableDissolveAudioLink;
			half _AudioLinkDissolveAlphaBand;
			float2 _AudioLinkDissolveAlpha;
			half _AudioLinkDissolveDetailBand;
			float2 _AudioLinkDissolveDetail;
			#endif
			#endif
			//endex
			
			//ifex _EnableAniso==0
			#ifdef POI_ANISOTROPICS
			
			#if defined(PROP_ANISOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AnisoColorMap;
			float4 _AnisoColorMap_ST;
			float2 _AnisoColorMapPan;
			float _AnisoColorMapUV;
			#endif
			/*
			#if defined(PROP_ANISONOISEMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _AnisoNoiseMap;
			float4 _AnisoNoiseMap_ST;
			float2 _AnisoNoiseMapPan;
			float _AnisoNoiseMapUV;
			#endif
			*/
			float _AnisoHideInShadow;
			float _AnisoReplace;
			float _AnisoAdd;
			float _AnisoUseBaseColor;
			float _AnisoUseLightColor;
			
			float _Aniso0Strength;
			float _Aniso0Power;
			float _Aniso0Offset;
			float _Aniso0SwitchDirection;
			float4 _Aniso0Tint;
			float _Aniso0TintIndex;
			float _Aniso0OffsetMapStrength;
			float _Aniso0ToonMode;
			float _Aniso0Edge;
			float _Aniso0Blur;
			
			float _Aniso1Strength;
			float _Aniso1Power;
			float _Aniso1Offset;
			float _Aniso1SwitchDirection;
			float4 _Aniso1Tint;
			float _Aniso1TintIndex;
			float _Aniso1OffsetMapStrength;
			float _Aniso1ToonMode;
			float _Aniso1Edge;
			float _Aniso1Blur;
			
			float _AnisoDebugToggle;
			float _AnisoDebugMode;
			#endif
			//endex
			
			//ifex _EnableALDecal==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_DECAL
			float _ALDecalUV;
			float4 _ALUVScale;
			float2 _ALUVPosition;
			float _ALUVRotation;
			float _ALUVRotationSpeed;
			float4 _ALDecaldCircleDimensions;
			
			float _ALDecalUVMode;
			
			float _ALDecalVolumeStep;
			float _ALDecalVolumeClipMin;
			float _ALDecalVolumeClipMax;
			
			float _ALDecalBandStep;
			float _ALDecalBandClipMin;
			float _ALDecalBandClipMax;
			
			float _ALDecalShapeClip;
			float _ALDecalShapeClipVolumeWidth;
			float _ALDecalShapeClipBandWidth;
			
			#if defined(PROP_ALDECALCOLORMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _ALDecalColorMask;
			float4 _ALDecalColorMask_ST;
			float2 _ALDecalColorMaskPan;
			float _ALDecalColorMaskUV;
			#endif
			
			float _ALDecalVolume;
			float _ALDecalBaseBoost;
			float _ALDecalTrebleBoost;
			float _ALDecalLineWidth;
			float _ALDecalVolumeColorSource;
			float3 _ALDecalVolumeColorLow;
			float _ALDecalVolumeColorLowThemeIndex;
			float3 _ALDecalVolumeColorMid;
			float _ALDecalVolumeColorMidThemeIndex;
			float3 _ALDecalVolumeColorHigh;
			float _ALDecalVolumeColorHighThemeIndex;
			float _ALDecalLowEmission;
			float _ALDecalMidEmission;
			float _ALDecalHighEmission;
			float _ALDecalBlendType;
			float _ALDecalBlendAlpha;
			float _ALDecalControlsAlpha;
			#endif
			#endif
			//endex
			
			//ifex _EnableVolumeColor==0
			#ifdef POI_AUDIOLINK
			#ifdef POI_AL_VOLUMECOLOR
			float _ALVolumeColorUV;
			float _ALVolumeColorDirection;
			float _ALVolumeColorBlendType;
			float _ALVolumeColorBlendAlpha;
			float3 _ALVolumeColorLow;
			float _ALVolumeColorLowThemeIndex;
			float3 _ALVolumeColorMid;
			float _ALVolumeColorMidThemeIndex;
			float3 _ALVolumeColorHigh;
			float _ALVolumeColorHighThemeIndex;
			float _ALLowEmission;
			float _ALMidEmission;
			float _ALHighEmission;
			#endif
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			UNITY_DECLARE_TEX2DARRAY(_FlipbookTexArray);
			float4 _FlipbookTexArray_ST;
			
			float4 _FlipbookColor;
			float _FlipbookColorThemeIndex;
			float _FlipbookFPS;
			// float _FlipbookTotalFrames;
			float4 _FlipbookScaleOffset;
			float4 _FlipbookSideOffset;
			float _FlipbookTiled;
			float _FlipbookManualFrameControl;
			float _FlipbookCurrentFrame;
			float _FlipbookStartAndEnd;
			float _FlipbookStartFrame;
			float _FlipbookEndFrame;
			float _FlipbookEmissionStrength;
			float _FlipbookRotation;
			float _EnableFlipbook;
			float _FlipbookTexArrayUV;
			float _FlipbookAlphaControlsFinalAlpha;
			float _FlipbookRotationSpeed;
			float _FlipbookIntensityControlsAlpha;
			float _FlipbookColorReplaces;
			float2 _FlipbookTexArrayPan;
			float _FlipbookFrameOffset;
			// blending
			float _FlipbookReplace;
			float _FlipbookMultiply;
			float _FlipbookAdd;
			
			#if defined(PROP_FLIPBOOKMASSK) || !defined(OPTIMIZED_ENABLED)
			Texture2D _FlipbookMask;
			#endif
			float4 _FlipbookMask_ST;
			float2 _FlipbookMaskPan;
			float _FlipbookMaskUV;
			float _FlipbookMaskChannel;
			float _FlipbookMaskGlobalMask;
			float _FlipbookMaskGlobalMaskBlendType;
			
			// anim
			float _FlipbookMovementType;
			float4 _FlipbookStartEndOffset;
			float _FlipbookMovementSpeed;
			
			// Crossfade
			float _FlipbookCrossfadeEnabled;
			float2 _FlipbookCrossfadeRange;
			
			// Hueshift
			float _FlipbookHueShiftEnabled;
			float _FlipbookHueShiftSpeed;
			float _FlipbookHueShift;
			
			#ifdef POI_AUDIOLINK
			float _FlipbookChronotensityEnabled;
			float _FlipbookChronotensityBand;
			float _FlipbookChronotensitySpeed;
			float _FlipbookChronoType;
			half _AudioLinkFlipbookScaleBand;
			half4 _AudioLinkFlipbookScale;
			half _AudioLinkFlipbookAlphaBand;
			half2 _AudioLinkFlipbookAlpha;
			half _AudioLinkFlipbookEmissionBand;
			half2 _AudioLinkFlipbookEmission;
			half _AudioLinkFlipbookFrameBand;
			half2 _AudioLinkFlipbookFrame;
			#endif
			#endif
			//endex
			
			//ifex _EnableEmission==0
			#ifdef _EMISSION
			#if defined(PROP_EMISSIONMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap;
			#endif
			float4 _EmissionMap_ST;
			float2 _EmissionMapPan;
			float _EmissionMapUV;
			#if defined(PROP_EMISSIONMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask;
			#endif
			float4 _EmissionMask_ST;
			float2 _EmissionMaskPan;
			float _EmissionMaskUV;
			float _EmissionMaskInvert;
			float _EmissionMaskChannel;
			float _EmissionMask0GlobalMask;
			float _EmissionMask0GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve;
			#endif
			float4 _EmissionScrollingCurve_ST;
			
			float4 _EmissionColor;
			float _EmissionBaseColorAsMap;
			float _EmissionStrength;
			float _EmissionHueShiftEnabled;
			float _EmissionHueShift;
			float _EmissionHueShiftSpeed;
			float _EmissionCenterOutEnabled;
			float _EmissionCenterOutSpeed;
			float _EnableGITDEmission;
			float _GITDEWorldOrMesh;
			float _GITDEMinEmissionMultiplier;
			float _GITDEMaxEmissionMultiplier;
			float _GITDEMinLight;
			float _GITDEMaxLight;
			float _EmissionBlinkingEnabled;
			float _EmissiveBlink_Min;
			float _EmissiveBlink_Max;
			float _EmissiveBlink_Velocity;
			float _EmissionBlinkingOffset;
			float _ScrollingEmission;
			float4 _EmissiveScroll_Direction;
			float _EmissiveScroll_Width;
			float _EmissiveScroll_Velocity;
			float _EmissiveScroll_Interval;
			float _EmissionScrollingOffset;
			
			float _EmissionReplace0;
			float _EmissionScrollingVertexColor;
			float _EmissionScrollingUseCurve;
			float _EmissionColorThemeIndex;
			
			// Audio Link
			float _EmissionAL0Enabled;
			float2 _EmissionAL0StrengthMod;
			float _EmissionAL0StrengthBand;
			float2 _AudioLinkEmission0CenterOut;
			float _AudioLinkEmission0CenterOutSize;
			float _AudioLinkEmission0CenterOutBand;
			float _AudioLinkEmission0CenterOutDuration;
			float2 _EmissionAL0Multipliers;
			float _EmissionAL0MultipliersBand;
			#endif
			//endex
			//ifex _EnableEmission1==0
			#ifdef POI_EMISSION_1
			
			#if defined(PROP_EMISSIONMAP1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap1;
			#endif
			float4 _EmissionMap1_ST;
			float2 _EmissionMap1Pan;
			float _EmissionMap1UV;
			#if defined(PROP_EMISSIONMASK1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask1;
			#endif
			float4 _EmissionMask1_ST;
			float2 _EmissionMask1Pan;
			float _EmissionMask1UV;
			float _EmissionMask1Channel;
			float _EmissionMaskInvert1;
			float _EmissionMask1GlobalMask;
			float _EmissionMask1GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE1) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve1;
			#endif
			float4 _EmissionScrollingCurve1_ST;
			
			float4 _EmissionColor1;
			float _EmissionBaseColorAsMap1;
			float _EmissionStrength1;
			float _EnableEmission1;
			float _EmissionHueShift1;
			float _EmissionHueShiftSpeed1;
			float4 _EmissiveScroll_Direction1;
			float _EmissiveScroll_Width1;
			float _EmissiveScroll_Velocity1;
			float _EmissiveScroll_Interval1;
			float _EmissionBlinkingEnabled1;
			float _EmissiveBlink_Min1;
			float _EmissiveBlink_Max1;
			float _EmissiveBlink_Velocity1;
			float _ScrollingEmission1;
			float _EnableGITDEmission1;
			float _GITDEMinEmissionMultiplier1;
			float _GITDEMaxEmissionMultiplier1;
			float _GITDEMinLight1;
			float _GITDEMaxLight1;
			float _GITDEWorldOrMesh1;
			float _EmissionCenterOutEnabled1;
			float _EmissionCenterOutSpeed1;
			float _EmissionHueShiftEnabled1;
			float _EmissionBlinkingOffset1;
			float _EmissionScrollingOffset1;
			float _EmissionScrollingVertexColor1;
			float _EmissionScrollingUseCurve1;
			float _EmissionReplace1;
			float _EmissionColor1ThemeIndex;
			
			// Audio Link
			float _EmissionAL1Enabled;
			float2 _EmissionAL1StrengthMod;
			float _EmissionAL1StrengthBand;
			float2 _AudioLinkEmission1CenterOut;
			float _AudioLinkEmission1CenterOutSize;
			float _AudioLinkEmission1CenterOutBand;
			float _AudioLinkEmission1CenterOutDuration;
			float2 _EmissionAL1Multipliers;
			float _EmissionAL1MultipliersBand;
			#endif
			//endex
			//ifex _EnableEmission2==0
			#ifdef POI_EMISSION_2
			
			#if defined(PROP_EMISSIONMAP2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap2;
			#endif
			float4 _EmissionMap2_ST;
			float2 _EmissionMap2Pan;
			float _EmissionMap2UV;
			#if defined(PROP_EMISSIONMASK2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask2;
			#endif
			float4 _EmissionMask2_ST;
			float2 _EmissionMask2Pan;
			float _EmissionMask2UV;
			float _EmissionMask2Channel;
			float _EmissionMaskInvert2;
			float _EmissionMask2GlobalMask;
			float _EmissionMask2GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE2) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve2;
			#endif
			float4 _EmissionScrollingCurve2_ST;
			
			float4 _EmissionColor2;
			float _EmissionBaseColorAsMap2;
			float _EmissionStrength2;
			float _EnableEmission2;
			float _EmissionHueShift2;
			float _EmissionHueShiftSpeed2;
			float4 _EmissiveScroll_Direction2;
			float _EmissiveScroll_Width2;
			float _EmissiveScroll_Velocity2;
			float _EmissiveScroll_Interval2;
			float _EmissionBlinkingEnabled2;
			float _EmissiveBlink_Min2;
			float _EmissiveBlink_Max2;
			float _EmissiveBlink_Velocity2;
			float _ScrollingEmission2;
			float _EnableGITDEmission2;
			float _GITDEMinEmissionMultiplier2;
			float _GITDEMaxEmissionMultiplier2;
			float _GITDEMinLight2;
			float _GITDEMaxLight2;
			float _GITDEWorldOrMesh2;
			float _EmissionCenterOutEnabled2;
			float _EmissionCenterOutSpeed2;
			float _EmissionHueShiftEnabled2;
			float _EmissionBlinkingOffset2;
			float _EmissionScrollingOffset2;
			float _EmissionScrollingVertexColor2;
			float _EmissionScrollingUseCurve2;
			float _EmissionReplace2;
			float _EmissionColor2ThemeIndex;
			
			// Audio Link
			float _EmissionAL2Enabled;
			float2 _EmissionAL2StrengthMod;
			float _EmissionAL2StrengthBand;
			float2 _AudioLinkEmission2CenterOut;
			float _AudioLinkEmission2CenterOutSize;
			float _AudioLinkEmission2CenterOutBand;
			float _AudioLinkEmission2CenterOutDuration;
			float2 _EmissionAL2Multipliers;
			float _EmissionAL2MultipliersBand;
			#endif
			//endex
			//ifex _EnableEmission3==0
			#ifdef POI_EMISSION_3
			
			#if defined(PROP_EMISSIONMAP3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMap3;
			#endif
			float4 _EmissionMap3_ST;
			float2 _EmissionMap3Pan;
			float _EmissionMap3UV;
			#if defined(PROP_EMISSIONMASK3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionMask3;
			#endif
			float4 _EmissionMask3_ST;
			float2 _EmissionMask3Pan;
			float _EmissionMask3UV;
			float _EmissionMask3Channel;
			float _EmissionMaskInvert3;
			float _EmissionMask3GlobalMask;
			float _EmissionMask3GlobalMaskBlendType;
			#if defined(PROP_EMISSIONSCROLLINGCURVE3) || !defined(OPTIMIZER_ENABLED)
			Texture2D _EmissionScrollingCurve3;
			#endif
			float4 _EmissionScrollingCurve3_ST;
			
			float4 _EmissionColor3;
			float _EmissionBaseColorAsMap3;
			float _EmissionStrength3;
			float _EnableEmission3;
			float _EmissionHueShift3;
			float _EmissionHueShiftSpeed3;
			float4 _EmissiveScroll_Direction3;
			float _EmissiveScroll_Width3;
			float _EmissiveScroll_Velocity3;
			float _EmissiveScroll_Interval3;
			float _EmissionBlinkingEnabled3;
			float _EmissiveBlink_Min3;
			float _EmissiveBlink_Max3;
			float _EmissiveBlink_Velocity3;
			float _ScrollingEmission3;
			float _EnableGITDEmission3;
			float _GITDEMinEmissionMultiplier3;
			float _GITDEMaxEmissionMultiplier3;
			float _GITDEMinLight3;
			float _GITDEMaxLight3;
			float _GITDEWorldOrMesh3;
			float _EmissionCenterOutEnabled3;
			float _EmissionCenterOutSpeed3;
			float _EmissionHueShiftEnabled3;
			float _EmissionBlinkingOffset3;
			float _EmissionScrollingOffset3;
			float _EmissionScrollingVertexColor3;
			float _EmissionScrollingUseCurve3;
			float _EmissionReplace3;
			float _EmissionColor3ThemeIndex;
			
			// Audio Link
			float _EmissionAL3Enabled;
			float2 _EmissionAL3StrengthMod;
			float _EmissionAL3StrengthBand;
			float2 _AudioLinkEmission3CenterOut;
			float _AudioLinkEmission3CenterOutSize;
			float _AudioLinkEmission3CenterOutBand;
			float _AudioLinkEmission3CenterOutDuration;
			float2 _EmissionAL3Multipliers;
			float _EmissionAL3MultipliersBand;
			#endif
			//endex
			
			//ifex _EnableRimLighting==0
			#ifdef _GLOSSYREFLECTIONS_OFF
			float _Is_NormalMapToRimLight;
			float4 _RimLightColor;
			float _RimLightColorThemeIndex;
			float _RimClamp;
			#ifdef _RIMSTYLE_POIYOMI
			float _RimLightingInvert;
			float _RimWidth;
			float _RimStrength;
			float _RimSharpness;
			float _RimBaseColorMix;
			float _EnableRimLighting;
			float _RimWidthNoiseStrength;
			float4 _RimShadowAlpha;
			float _RimShadowWidth;
			float _RimBlendStrength;
			float _RimBlendMode;
			float _RimShadowToggle;
			float _RimPower;
			float _RimShadowMaskStrength;
			float _RimShadowMaskRampType;
			float _RimShadowMaskInvert;
			float _RimBrightness;
			#if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimTex;
			#endif
			float4 _RimTex_ST;
			float2 _RimTexPan;
			float _RimTexUV;
			#if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimMask;
			#endif
			float4 _RimMask_ST;
			float2 _RimMaskPan;
			float _RimMaskUV;
			float _RimMaskChannel;
			float _RimMaskInvert;
			float _RimBiasIntensity;
			#ifdef POI_AUDIOLINK
			half _AudioLinkRimWidthBand;
			float2 _AudioLinkRimWidthAdd;
			half _AudioLinkRimEmissionBand;
			float2 _AudioLinkRimEmissionAdd;
			half _AudioLinkRimBrightnessBand;
			float2 _AudioLinkRimBrightnessAdd;
			#endif
			#endif
			
			#ifdef _RIMSTYLE_UTS2
			float _RimLight;
			float _Is_LightColor_RimLight;
			float _RimLight_Power;
			float _RimLight_InsideMask;
			float _RimLight_FeatherOff;
			float _LightDirection_MaskOn;
			float _Tweak_LightDirection_MaskLevel;
			float _Add_Antipodean_RimLight;
			float4 _Ap_RimLightColor;
			float _RimApColorThemeIndex;
			float _Is_LightColor_Ap_RimLight;
			float _Ap_RimLight_Power;
			float _Ap_RimLight_FeatherOff;
			#if defined(PROP_SET_RIMLIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_RimLightMask;
			float4 _Set_RimLightMask_ST;
			float2 _Set_RimLightMaskPan;
			float _Set_RimLightMaskUV;
			float _Set_RimLightMaskChannel;
			#endif
			float _Tweak_RimLightMaskLevel;
			#endif
			
			#ifdef _RIMSTYLE_LILTOON
			float4 _RimColor;
			#if defined(PROP_RIMCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _RimColorTex;
			float4 _RimColorTex_ST;
			float2 _RimColorTexPan;
			float _RimColorTexUV;
			#endif
			float _RimMainStrength;
			float _RimNormalStrength;
			float _RimBorder;
			float _RimBlur;
			float _RimFresnelPower;
			float _RimEnableLighting;
			float _RimShadowMask;
			int _RimBackfaceMask;
			float _RimVRParallaxStrength;
			float _RimDirStrength;
			float _RimDirRange;
			float _RimIndirRange;
			float4 _RimIndirColor;
			float _RimIndirBorder;
			float _RimIndirBlur;
			#endif
			
			float _RimGlobalMask;
			float _RimGlobalMaskBlendType;
			float _RimApplyGlobalMaskIndex;
			float _RimApplyGlobalMaskBlendType;
			
			float _RimHueShiftEnabled;
			float _RimHueShiftSpeed;
			float _RimHueShift;
			#endif
			//endex
			//ifex _EnableRim2Lighting==0
			#ifdef POI_RIM2
			float _Is_NormalMapToRim2Light;
			float4 _Rim2LightColor;
			float _Rim2LightColorThemeIndex;
			float _Rim2Clamp;
			
			#ifdef _RIM2STYLE_POIYOMI
			float _Rim2LightingInvert;
			float _Rim2Width;
			float _Rim2Strength;
			float _Rim2Sharpness;
			float _Rim2BaseColorMix;
			float _EnableRim2Lighting;
			float _Rim2WidthNoiseStrength;
			float4 _Rim2ShadowAlpha;
			float _Rim2ShadowWidth;
			float _Rim2BlendStrength;
			float _Rim2BlendMode;
			float _Rim2ShadowToggle;
			float _Rim2Power;
			float _Rim2ShadowMaskStrength;
			float _Rim2ShadowMaskRampType;
			float _Rim2ShadowMaskInvert;
			float _Rim2Brightness;
			#if defined(PROP_RIM2TEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2Tex;
			#endif
			float4 _Rim2Tex_ST;
			float2 _Rim2TexPan;
			float _Rim2TexUV;
			#if defined(PROP_RIM2MASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2Mask;
			#endif
			float4 _Rim2Mask_ST;
			float2 _Rim2MaskPan;
			float _Rim2MaskUV;
			float _Rim2MaskChannel;
			float _Rim2MaskInvert;
			float _Rim2BiasIntensity;
			#if defined(PROP_RIM2WIDTHNOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2WidthNoiseTexture;
			#endif
			#ifdef POI_AUDIOLINK
			half _AudioLinkRim2WidthBand;
			float2 _AudioLinkRim2WidthAdd;
			half _AudioLinkRim2EmissionBand;
			float2 _AudioLinkRim2EmissionAdd;
			half _AudioLinkRim2BrightnessBand;
			float2 _AudioLinkRim2BrightnessAdd;
			#endif
			#endif
			
			#ifdef _RIM2STYLE_UTS2
			float _Rim2Light;
			float _Is_LightColor_Rim2Light;
			float _Rim2Light_Power;
			float _Rim2Light_InsideMask;
			float _Rim2Light_FeatherOff;
			float _LightDirection_MaskOn2;
			float _Tweak_LightDirection_MaskLevel2;
			float _Add_Antipodean_Rim2Light;
			float4 _Ap_Rim2LightColor;
			float _Rim2ApColorThemeIndex;
			float _Is_LightColor_Ap_Rim2Light;
			float _Ap_Rim2Light_Power;
			float _Ap_Rim2Light_FeatherOff;
			#if defined(PROP_SET_RIM2LIGHTMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Set_Rim2LightMask;
			float4 _Set_Rim2LightMask_ST;
			float2 _Set_Rim2LightMaskPan;
			float _Set_Rim2LightMaskUV;
			float _Set_Rim2LightMaskChannel;
			#endif
			float _Tweak_Rim2LightMaskLevel;
			#endif
			
			#ifdef _RIM2STYLE_LILTOON
			float4 _Rim2Color;
			#if defined(PROP_RIM2COLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _Rim2ColorTex;
			float4 _Rim2ColorTex_ST;
			float2 _Rim2ColorTexPan;
			float _Rim2ColorTexUV;
			#endif
			float _Rim2MainStrength;
			float _Rim2NormalStrength;
			float _Rim2Border;
			float _Rim2Blur;
			float _Rim2FresnelPower;
			float _Rim2EnableLighting;
			float _Rim2ShadowMask;
			int _Rim2BackfaceMask;
			float _Rim2VRParallaxStrength;
			// int _Rim2ApplyTransparency;
			float _Rim2DirStrength;
			float _Rim2DirRange;
			float _Rim2IndirRange;
			float4 _Rim2IndirColor;
			float _Rim2IndirBorder;
			float _Rim2IndirBlur;
			#endif
			
			float _Rim2GlobalMask;
			float _Rim2GlobalMaskBlendType;
			float _Rim2ApplyGlobalMaskIndex;
			float _Rim2ApplyGlobalMaskBlendType;
			
			float _Rim2HueShiftEnabled;
			float _Rim2HueShiftSpeed;
			float _Rim2HueShift;
			#endif
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#ifdef _POI_DEPTH_RIMLIGHT
			float _DepthRimNormalToUse;
			float _DepthRimWidth;
			float _DepthRimSharpness;
			float _DepthRimHideInShadow;
			float4 _DepthRimColor;
			float _DepthRimColorThemeIndex;
			float _DepthRimMixBaseColor;
			float _DepthRimEmission;
			float _DepthRimReplace;
			float _DepthRimAdd;
			float _DepthRimMultiply;
			float _DepthRimAdditiveLighting;
			float _DepthRimMixLightColor;
			float _DepthRimType;
			float _DepthRimBrightness;
			
			static float2 sobelSamplePoints[9] = {
				float2(-1, 1), float2(0, 1), float2(1, 1),
				float2(-1, 0), float2(0, 0), float2(1, 01),
				float2(-1, -1), float2(0, -1), float2(1, -1)
			};
			
			static float sobelXMatrix[9] = {
				1, 0, -1,
				2, 0, -2,
				1, 0, -1
			};
			static float sobelYMatrix[9] = {
				1, 2, 1,
				0, 0, 0,
				- 1, -2, -1
			};
			#endif
			//endex
			
			//ifex _GlitterEnable==0
			#ifdef _SUNDISK_SIMPLE
			float _GlitterUseNormals;
			float _GlitterUV;
			half3 _GlitterColor;
			float _GlitterColorThemeIndex;
			float2 _GlitterPan;
			half _GlitterSpeed;
			half _GlitterBrightness;
			float _GlitterFrequency;
			float _GlitterJitter;
			half _GlitterSize;
			half _GlitterContrast;
			half _GlitterAngleRange;
			half _GlitterMinBrightness;
			half _GlitterBias;
			fixed _GlitterUseSurfaceColor;
			float _GlitterBlendType;
			float _GlitterMode;
			float _GlitterShape;
			float _GlitterCenterSize;
			float _glitterFrequencyLinearEmissive;
			float _GlitterJaggyFix;
			float _GlitterTextureRotation;
			float2 _GlitterUVPanning;
			
			float _GlitterHueShiftEnabled;
			float _GlitterHueShiftSpeed;
			float _GlitterHueShift;
			float _GlitterHideInShadow;
			
			float _GlitterRandomColors;
			float2 _GlitterMinMaxSaturation;
			float2 _GlitterMinMaxBrightness;
			float _GlitterRandomSize;
			float4 _GlitterMinMaxSize;
			float _GlitterRandomRotation;
			
			#if defined(PROP_GLITTERMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterMask;
			#endif
			float4 _GlitterMask_ST;
			float2 _GlitterMaskPan;
			float _GlitterMaskUV;
			float _GlitterMaskChannel;
			float _GlitterMaskGlobalMask;
			float _GlitterMaskGlobalMaskBlendType;
			#if defined(PROP_GLITTERCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterColorMap;
			#endif
			float4 _GlitterColorMap_ST;
			float2 _GlitterColorMapPan;
			float _GlitterColorMapUV;
			#if defined(PROP_GLITTERTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _GlitterTexture;
			#endif
			float4 _GlitterTexture_ST;
			float2 _GlitterTexturePan;
			float _GlitterTextureUV;
			#endif
			//endex
			
			//ifex _EnablePathing==0
			#ifdef POI_PATHING
			
			#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PathingMap;
			SamplerState SmpRepeatPoint;
			#endif
			float4 _PathingMap_ST;
			float2 _PathingMapPan;
			float _PathingMapUV;
			
			#if defined(PROP_PATHINGCOLORMAP) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PathingColorMap;
			#endif
			float4 _PathingColorMap_ST;
			float2 _PathingColorMapPan;
			float _PathingColorMapUV;
			float _PathingOverrideAlpha;
			// Fill, 0, Path, 1, Loop, 2
			float _PathTypeR;
			float _PathTypeG;
			float _PathTypeB;
			float _PathTypeA;
			float _PathGradientType;
			half4 _PathWidth;
			float4 _PathTime;
			float4 _PathOffset;
			float4 _PathSpeed;
			float4 _PathColorR;
			float4 _PathColorG;
			float4 _PathColorB;
			float4 _PathColorA;
			float4 _PathEmissionStrength;
			float4 _PathSoftness;
			float4 _PathSegments;
			
			float _PathColorRThemeIndex;
			float _PathColorGThemeIndex;
			float _PathColorBThemeIndex;
			float _PathColorAThemeIndex;
			
			#ifdef POI_AUDIOLINK
			float _PathALAutoCorrelator;
			float _PathALAutoCorrelatorMode;
			float _PathALAutoCorrelatorR;
			float2 _PathALAutoCorrelatorRangeR;
			float _PathALAutoCorrelatorG;
			float2 _PathALAutoCorrelatorRangeG;
			float _PathALAutoCorrelatorB;
			float2 _PathALAutoCorrelatorRangeB;
			float _PathALAutoCorrelatorA;
			float2 _PathALAutoCorrelatorRangeA;
			
			float _PathALHistory;
			float _PathALHistoryMode;
			float _PathALHistoryBandR;
			float2 _PathALHistoryRangeR;
			float _PathALHistoryR;
			float _PathALHistoryBandG;
			float2 _PathALHistoryRangeG;
			float _PathALHistoryG;
			float _PathALHistoryBandB;
			float2 _PathALHistoryRangeB;
			float _PathALHistoryB;
			float _PathALHistoryBandA;
			float2 _PathALHistoryRangeA;
			float _PathALHistoryA;
			
			float _PathALColorChord;
			float _PathALCCR;
			float _PathALCCG;
			float _PathALCCB;
			float _PathALCCA;
			
			// Time Offset
			float _PathALTimeOffset;
			half _AudioLinkPathTimeOffsetBandR;
			half2 _AudioLinkPathTimeOffsetR;
			half _AudioLinkPathTimeOffsetBandG;
			half2 _AudioLinkPathTimeOffsetG;
			half _AudioLinkPathTimeOffsetBandB;
			half2 _AudioLinkPathTimeOffsetB;
			half _AudioLinkPathTimeOffsetBandA;
			half2 _AudioLinkPathTimeOffsetA;
			
			// Emission Offset
			float _PathALEmissionOffset;
			half _AudioLinkPathEmissionAddBandR;
			half2 _AudioLinkPathEmissionAddR;
			half _AudioLinkPathEmissionAddBandG;
			half2 _AudioLinkPathEmissionAddG;
			half _AudioLinkPathEmissionAddBandB;
			half2 _AudioLinkPathEmissionAddB;
			half _AudioLinkPathEmissionAddBandA;
			half2 _AudioLinkPathEmissionAddA;
			
			// Length Offset
			float _PathALWidthOffset;
			half _AudioLinkPathWidthOffsetBandR;
			half2 _AudioLinkPathWidthOffsetR;
			half _AudioLinkPathWidthOffsetBandG;
			half2 _AudioLinkPathWidthOffsetG;
			half _AudioLinkPathWidthOffsetBandB;
			half2 _AudioLinkPathWidthOffsetB;
			half _AudioLinkPathWidthOffsetBandA;
			half2 _AudioLinkPathWidthOffsetA;
			
			// Chrono Time
			float _PathALChrono;
			float _PathChronoBandR;
			float _PathChronoTypeR;
			float _PathChronoSpeedR;
			float _PathChronoBandG;
			float _PathChronoTypeG;
			float _PathChronoSpeedG;
			float _PathChronoBandB;
			float _PathChronoTypeB;
			float _PathChronoSpeedB;
			float _PathChronoBandA;
			float _PathChronoTypeA;
			float _PathChronoSpeedA;
			#endif
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			float _VisibilityMode;
			float _Mirror;
			#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _MirrorTexture;
			#endif
			float4 _MirrorColor;
			float _MirrorColorThemeIndex;
			float _MirrorTextureBlendType;
			float4 _MirrorTexture_ST;
			float2 _MirrorTexturePan;
			float _MirrorTextureUV;
			
			float _VisibilityVRCRegular;
			float _VisibilityVRCMirrorVR;
			float _VisibilityVRCMirrorDesktop;
			float _VisibilityVRCCameraVR;
			float _VisibilityVRCCameraDesktop;
			float _VisibilityVRCCameraScreenshot;
			#endif
			//endex
			
			//ifex _PostProcess==0
			#ifdef POSTPROCESS
			#if defined(PROP_PPMASK) || !defined(OPTIMIZER_ENABLED)
			Texture2D _PPMask;
			#endif
			float4 _PPMask_ST;
			float2 _PPMaskPan;
			float _PPMaskUV;
			float _PPMaskChannel;
			float _PPMaskInvert;
			
			float3 _PPTint;
			float3 _PPRGB;
			float _PPHue;
			float _PPContrast;
			float _PPSaturation;
			float _PPBrightness;
			float _PPLightness;
			float _PPHDR;
			
			float _PPPosterization;
			float _PPPosterizationAmount;
			const static float COLORS = 32;
			
			#endif
			//endex
			
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			float _NormalCorrectAmount;
			float3 _NormalCorrectOrigin;
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float _VideoEffectsEnable;
			#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
			sampler2D _VideoPixelTexture;
			float4 _VideoPixelTexture_ST;
			float _VideoPixelTextureUV;
			#endif
			#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
			Texture2D _VideoMaskTexture;
			float4 _VideoMaskTexture_ST;
			float2 _VideoMaskTexturePan;
			float _VideoMaskTextureUV;
			float _VideoMaskTextureChannel;
			#endif
			
			float _VideoType;
			float2 _VideoResolution;
			sampler2D _VideoGameboyRamp;
			float _VideoBacklight;
			float _VideoCRTRefreshRate;
			float _VideoCRTPixelEnergizedTime;
			float _VideoRepeatVideoTexture;
			float _VideoPixelateToResolution;
			float2 _VideoMaskPanning;
			
			float _VideoSaturation;
			float _VideoContrast;
			float _VideoEmissionEnabled;
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			float4 _BacklightColor;
			#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
			Texture2D _BacklightColorTex;
			float4 _BacklightColorTex_ST;
			float2 _BacklightColorTexPan;
			float _BacklightColorTexUV;
			#endif
			float _BacklightMainStrength;
			float _BacklightNormalStrength;
			float _BacklightBorder;
			float _BacklightBlur;
			float _BacklightDirectivity;
			float _BacklightViewStrength;
			int _BacklightReceiveShadow;
			int _BacklightBackfaceMask;
			#endif
			//endex
			
			struct appdata
			{
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
				float4 color : COLOR;
				float2 uv0 : TEXCOORD0;
				float2 uv1 : TEXCOORD1;
				float2 uv2 : TEXCOORD2;
				float2 uv3 : TEXCOORD3;
				uint vertexId : SV_VertexID;
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};
			
			struct VertexOut
			{
				float4 pos : SV_POSITION;
				float2 uv[4] : TEXCOORD0;
				float3 objNormal : TEXCOORD4;
				float3 normal : TEXCOORD5;
				float3 tangent : TEXCOORD6;
				float3 binormal : TEXCOORD7;
				float4 worldPos : TEXCOORD8;
				float4 localPos : TEXCOORD9;
				float3 objectPos : TEXCOORD10;
				float4 vertexColor : TEXCOORD11;
				float4 lightmapUV : TEXCOORD12;
				float4 grabPos: TEXCOORD13;
				float4 worldDirection: TEXCOORD14;
				float4 extra: TEXCOORD15;
				UNITY_SHADOW_COORDS(16)
				UNITY_FOG_COORDS(17)
				
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};
			
			struct PoiMesh
			{
				
				// 0 Vertex normal
				// 1 Fragment normal
				float3 normals[2];
				float3 objNormal;
				float3 tangentSpaceNormal;
				float3 binormal[2];
				float3 tangent[2];
				float3 worldPos;
				float3 localPos;
				float3 objectPosition;
				float isFrontFace;
				float4 vertexColor;
				float4 lightmapUV;
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 7 Distorted UV
				float2 uv[9];
				float2 parallaxUV;
			};
			
			struct PoiCam
			{
				float3 viewDir;
				float3 forwardDir;
				float3 worldPos;
				float distanceToVert;
				float4 clipPos;
				float3 reflectionDir;
				float3 vertexReflectionDir;
				float3 tangentViewDir;
				float4 grabPos;
				float2 screenUV;
				float vDotN;
				float4 worldDirection;
				
			};
			
			struct PoiMods
			{
				float4 PBR; // smoothness, metallic, smoothness mask, metallic mask
				float4 Mask;
				float4 audioLink;
				float audioLinkAvailable;
				float audioLinkVersion;
				float4 audioLinkTexture;
				float audioLinkViaLuma;
				float2 detailMask;
				float2 backFaceDetailIntensity;
				float globalEmission;
				float4 globalColorTheme[12];
				float globalMask[16];
				float ALTime[8];
			};
			
			struct PoiLight
			{
				
				float3 direction;
				float attenuation;
				float attenuationStrength;
				float3 directColor;
				float3 indirectColor;
				float occlusion;
				float shadowMask;
				float detailShadow;
				float3 halfDir;
				float lightMap;
				float lightMapNoAttenuation;
				float3 rampedLightMap;
				float vertexNDotL;
				float nDotL;
				float nDotV;
				float vertexNDotV;
				float nDotH;
				float vertexNDotH;
				float lDotv;
				float lDotH;
				float nDotLSaturated;
				float nDotLNormalized;
				#ifdef POI_PASS_ADD
				float additiveShadow;
				#endif
				float3 finalLighting;
				float3 finalLightAdd;
				
				#if defined(VERTEXLIGHT_ON)
				// Non Important Lights
				float4 vDotNL;
				float4 vertexVDotNL;
				float3 vColor[4];
				float4 vCorrectedDotNL;
				float4 vAttenuation;
				float4 vAttenuationDotNL;
				float3 vPosition[4];
				float3 vDirection[4];
				float3 vFinalLighting;
				float3 vHalfDir[4];
				half4 vDotNH;
				half4 vertexVDotNH;
				half4 vDotLH;
				#endif
				
			};
			
			struct PoiVertexLights
			{
				
				float3 direction;
				float3 color;
				float attenuation;
			};
			
			struct PoiFragData
			{
				float3 baseColor;
				float3 finalColor;
				float alpha;
				float3 emission;
			};
			
			// glsl_mod behaves better on negative numbers, and
			// in some situations actually outperforms HLSL's fmod()
			#ifndef glsl_mod
			#define glsl_mod(x, y) (((x) - (y) * floor((x) / (y))))
			#endif
			
			uniform float random_uniform_float_only_used_to_stop_compiler_warnings = 0.0f;
			
			float2 poiUV(float2 uv, float4 tex_st)
			{
				return uv * tex_st.xy + tex_st.zw;
			}
			
			float2 vertexUV(in VertexOut o, int index)
			{
				switch(index)
				{
					case 0:
					return o.uv[0];
					case 1:
					return o.uv[1];
					case 2:
					return o.uv[2];
					case 3:
					return o.uv[3];
					default:
					return o.uv[0];
				}
			}
			
			float2 vertexUV(in appdata v, int index)
			{
				switch(index)
				{
					case 0:
					return v.uv0;
					case 1:
					return v.uv1;
					case 2:
					return v.uv2;
					case 3:
					return v.uv3;
					default:
					return v.uv0;
				}
			}
			
			//Lighting Helpers
			float calculateluminance(float3 color)
			{
				return color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
			}
			
			// Set by VRChat (as of open beta 1245)
			// _VRChatCameraMode: 0 => Normal, 1 => VR HandCam, 2 => Desktop Handcam, 3 => Screenshot/Photo
			// _VRChatMirrorMode: 0 => Normal, 1 => Mirror (VR), 2 => Mirror (Deskie)
			float _VRChatCameraMode;
			float _VRChatMirrorMode;
			
			float VRCCameraMode()
			{
				return _VRChatCameraMode;
			}
			
			float VRCMirrorMode()
			{
				return _VRChatMirrorMode;
			}
			
			bool IsInMirror()
			{
				return unity_CameraProjection[2][0] != 0.f || unity_CameraProjection[2][1] != 0.f;
			}
			
			bool IsOrthographicCamera()
			{
				return unity_OrthoParams.w == 1 || UNITY_MATRIX_P[3][3] == 1;
			}
			
			float shEvaluateDiffuseL1Geomerics_local(float L0, float3 L1, float3 n)
			{
				// average energy
				float R0 = max(0, L0);
				
				// avg direction of incoming light
				float3 R1 = 0.5f * L1;
				
				// directional brightness
				float lenR1 = length(R1);
				
				// linear angle between normal and direction 0-1
				//float q = 0.5f * (1.0f + dot(R1 / lenR1, n));
				//float q = dot(R1 / lenR1, n) * 0.5 + 0.5;
				float q = dot(normalize(R1), n) * 0.5 + 0.5;
				q = saturate(q); // Thanks to ScruffyRuffles for the bug identity.
				
				// power for q
				// lerps from 1 (linear) to 3 (cubic) based on directionality
				float p = 1.0f + 2.0f * lenR1 / R0;
				
				// dynamic range constant
				// should vary between 4 (highly directional) and 0 (ambient)
				float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);
				
				return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));
			}
			
			half3 BetterSH9(half4 normal)
			{
				float3 indirect;
				float3 L0 = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w) + float3(unity_SHBr.z, unity_SHBg.z, unity_SHBb.z) / 3.0;
				indirect.r = shEvaluateDiffuseL1Geomerics_local(L0.r, unity_SHAr.xyz, normal.xyz);
				indirect.g = shEvaluateDiffuseL1Geomerics_local(L0.g, unity_SHAg.xyz, normal.xyz);
				indirect.b = shEvaluateDiffuseL1Geomerics_local(L0.b, unity_SHAb.xyz, normal.xyz);
				indirect = max(0, indirect);
				indirect += SHEvalLinearL2(normal);
				return indirect;
			}
			
			// Silent's code ends here
			
			float3 getCameraForward()
			{
				#if UNITY_SINGLE_PASS_STEREO
				float3 p1 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 1, 1));
				float3 p2 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 0, 1));
				#else
				float3 p1 = mul(unity_CameraToWorld, float4(0, 0, 1, 1)).xyz;
				float3 p2 = mul(unity_CameraToWorld, float4(0, 0, 0, 1)).xyz;
				#endif
				return normalize(p2 - p1);
			}
			
			half3 GetSHLength()
			{
				half3 x, x1;
				x.r = length(unity_SHAr);
				x.g = length(unity_SHAg);
				x.b = length(unity_SHAb);
				x1.r = length(unity_SHBr);
				x1.g = length(unity_SHBg);
				x1.b = length(unity_SHBb);
				return x + x1;
			}
			
			float3 BoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
			{
				#if UNITY_SPECCUBE_BOX_PROJECTION
				//UNITY_BRANCH
				if (cubemapPosition.w > 0)
				{
					float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
					float scalar = min(min(factors.x, factors.y), factors.z);
					direction = direction * scalar + (position - cubemapPosition.xyz);
				}
				#endif
				return direction;
			}
			
			float poiMax(float2 i)
			{
				return max(i.x, i.y);
			}
			
			float poiMax(float3 i)
			{
				return max(max(i.x, i.y), i.z);
			}
			
			float poiMax(float4 i)
			{
				return max(max(max(i.x, i.y), i.z), i.w);
			}
			
			float3 calculateNormal(in float3 baseNormal, in PoiMesh poiMesh, in Texture2D normalTexture, in float4 normal_ST, in float2 normalPan, in float normalUV, in float normalIntensity)
			{
				float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
				return normalize(
				normal.x * poiMesh.tangent[0] +
				normal.y * poiMesh.binormal[0] +
				normal.z * baseNormal
				);
			}
			
			float remap(float x, float minOld, float maxOld, float minNew = 0, float maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float2 remap(float2 x, float2 minOld, float2 maxOld, float2 minNew = 0, float2 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float3 remap(float3 x, float3 minOld, float3 maxOld, float3 minNew = 0, float3 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float4 remap(float4 x, float4 minOld, float4 maxOld, float4 minNew = 0, float4 maxNew = 1)
			{
				return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
			}
			
			float remapClamped(float minOld, float maxOld, float x, float minNew = 0, float maxNew = 1)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float2 remapClamped(float2 minOld, float2 maxOld, float2 x, float2 minNew, float2 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float3 remapClamped(float3 minOld, float3 maxOld, float3 x, float3 minNew, float3 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			
			float4 remapClamped(float4 minOld, float4 maxOld, float4 x, float4 minNew, float4 maxNew)
			{
				return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
			}
			float2 calcParallax(in float height, in PoiCam poiCam)
			{
				return ((height * - 1) + 1) * (poiCam.tangentViewDir.xy / poiCam.tangentViewDir.z);
			}
			
			/*
			0: Zero	                float4(0.0, 0.0, 0.0, 0.0),
			1: One	                float4(1.0, 1.0, 1.0, 1.0),
			2: DstColor	            destinationColor,
			3: SrcColor	            sourceColor,
			4: OneMinusDstColor	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
			5: SrcAlpha	            sourceColor.aaaa,
			6: OneMinusSrcColor	    float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
			7: DstAlpha	            destinationColor.aaaa,
			8: OneMinusDstAlpha	    float4(1.0, 1.0, 1.0, 1.0) - destinationColor.,
			9: SrcAlphaSaturate     saturate(sourceColor.aaaa),
			10: OneMinusSrcAlpha	float4(1.0, 1.0, 1.0, 1.0) - sourceColor.aaaa,
			*/
			
			float4 poiBlend(const float sourceFactor, const  float4 sourceColor, const  float destinationFactor, const  float4 destinationColor, const float4 blendFactor)
			{
				float4 sA = 1 - blendFactor;
				const float4 blendData[11] = {
					float4(0.0, 0.0, 0.0, 0.0),
					float4(1.0, 1.0, 1.0, 1.0),
					destinationColor,
					sourceColor,
					float4(1.0, 1.0, 1.0, 1.0) - destinationColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sourceColor,
					sA,
					float4(1.0, 1.0, 1.0, 1.0) - sA,
					saturate(sourceColor.aaaa),
					1 - sA,
				};
				
				return lerp(blendData[sourceFactor] * sourceColor + blendData[destinationFactor] * destinationColor, sourceColor, sA);
			}
			
			// Average
			float blendAverage(float base, float blend)
			{
				return (base + blend) / 2.0;
			}
			float3 blendAverage(float3 base, float3 blend)
			{
				return (base + blend) / 2.0;
			}
			
			// Color burn
			float blendColorBurn(float base, float blend)
			{
				return (blend == 0.0) ? blend : max((1.0 - ((1.0 - base) * rcp(random_uniform_float_only_used_to_stop_compiler_warnings + blend))), 0.0);
			}
			
			float3 blendColorBurn(float3 base, float3 blend)
			{
				return float3(blendColorBurn(base.r, blend.r), blendColorBurn(base.g, blend.g), blendColorBurn(base.b, blend.b));
			}
			
			// Color Dodge
			float blendColorDodge(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0);
			}
			
			float3 blendColorDodge(float3 base, float3 blend)
			{
				return float3(blendColorDodge(base.r, blend.r), blendColorDodge(base.g, blend.g), blendColorDodge(base.b, blend.b));
			}
			
			// Darken
			float blendDarken(float base, float blend)
			{
				return min(blend, base);
			}
			
			float3 blendDarken(float3 base, float3 blend)
			{
				return float3(blendDarken(base.r, blend.r), blendDarken(base.g, blend.g), blendDarken(base.b, blend.b));
			}
			
			// Exclusion
			float blendExclusion(float base, float blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			float3 blendExclusion(float3 base, float3 blend)
			{
				return base + blend - 2.0 * base * blend;
			}
			
			// Reflect
			float blendReflect(float base, float blend)
			{
				return (blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0);
			}
			
			float3 blendReflect(float3 base, float3 blend)
			{
				return float3(blendReflect(base.r, blend.r), blendReflect(base.g, blend.g), blendReflect(base.b, blend.b));
			}
			
			// Glow
			float blendGlow(float base, float blend)
			{
				return blendReflect(blend, base);
			}
			float3 blendGlow(float3 base, float3 blend)
			{
				return blendReflect(blend, base);
			}
			
			// Overlay
			float blendOverlay(float base, float blend)
			{
				return base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend));
			}
			
			float3 blendOverlay(float3 base, float3 blend)
			{
				return float3(blendOverlay(base.r, blend.r), blendOverlay(base.g, blend.g), blendOverlay(base.b, blend.b));
			}
			
			// Hard Light
			float blendHardLight(float base, float blend)
			{
				return blendOverlay(blend, base);
			}
			float3 blendHardLight(float3 base, float3 blend)
			{
				return blendOverlay(blend, base);
			}
			
			// Vivid light
			float blendVividLight(float base, float blend)
			{
				return (blend < 0.5) ? blendColorBurn(base, (2.0 * blend)) : blendColorDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendVividLight(float3 base, float3 blend)
			{
				return float3(blendVividLight(base.r, blend.r), blendVividLight(base.g, blend.g), blendVividLight(base.b, blend.b));
			}
			
			// Hard mix
			float blendHardMix(float base, float blend)
			{
				return (blendVividLight(base, blend) < 0.5) ? 0.0 : 1.0;
			}
			
			float3 blendHardMix(float3 base, float3 blend)
			{
				return float3(blendHardMix(base.r, blend.r), blendHardMix(base.g, blend.g), blendHardMix(base.b, blend.b));
			}
			
			// Lighten
			float blendLighten(float base, float blend)
			{
				return max(blend, base);
			}
			
			float3 blendLighten(float3 base, float3 blend)
			{
				return float3(blendLighten(base.r, blend.r), blendLighten(base.g, blend.g), blendLighten(base.b, blend.b));
			}
			
			// Linear Burn
			float blendLinearBurn(float base, float blend)
			{
				// Note : Same implementation as BlendSubtractf
				return max(base + blend - 1.0, 0.0);
			}
			
			float3 blendLinearBurn(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendSubtract
				return max(base + blend - float3(1.0, 1.0, 1.0), float3(0.0, 0.0, 0.0));
			}
			
			// Linear Dodge
			float blendLinearDodge(float base, float blend)
			{
				// Note : Same implementation as BlendAddf
				return min(base + blend, 1.0);
			}
			
			float3 blendLinearDodge(float3 base, float3 blend)
			{
				// Note : Same implementation as BlendAdd
				return min(base + blend, float3(1.0, 1.0, 1.0));
			}
			
			// Linear light
			float blendLinearLight(float base, float blend)
			{
				return blend < 0.5 ? blendLinearBurn(base, (2.0 * blend)) : blendLinearDodge(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendLinearLight(float3 base, float3 blend)
			{
				return float3(blendLinearLight(base.r, blend.r), blendLinearLight(base.g, blend.g), blendLinearLight(base.b, blend.b));
			}
			
			// Multiply
			float blendMultiply(float base, float blend)
			{
				return base * blend;
			}
			float3 blendMultiply(float3 base, float3 blend)
			{
				return base * blend;
			}
			
			// Negation
			float blendNegation(float base, float blend)
			{
				return 1.0 - abs(1.0 - base - blend);
			}
			float3 blendNegation(float3 base, float3 blend)
			{
				return float3(1.0, 1.0, 1.0) - abs(float3(1.0, 1.0, 1.0) - base - blend);
			}
			
			// Normal
			float blendNormal(float base, float blend)
			{
				return blend;
			}
			float3 blendNormal(float3 base, float3 blend)
			{
				return blend;
			}
			
			// Phoenix
			float blendPhoenix(float base, float blend)
			{
				return min(base, blend) - max(base, blend) + 1.0;
			}
			float3 blendPhoenix(float3 base, float3 blend)
			{
				return min(base, blend) - max(base, blend) + float3(1.0, 1.0, 1.0);
			}
			
			// Pin light
			float blendPinLight(float base, float blend)
			{
				return (blend < 0.5) ? blendDarken(base, (2.0 * blend)) : blendLighten(base, (2.0 * (blend - 0.5)));
			}
			
			float3 blendPinLight(float3 base, float3 blend)
			{
				return float3(blendPinLight(base.r, blend.r), blendPinLight(base.g, blend.g), blendPinLight(base.b, blend.b));
			}
			
			// Screen
			float blendScreen(float base, float blend)
			{
				return 1.0 - ((1.0 - base) * (1.0 - blend));
			}
			
			float3 blendScreen(float3 base, float3 blend)
			{
				return float3(blendScreen(base.r, blend.r), blendScreen(base.g, blend.g), blendScreen(base.b, blend.b));
			}
			
			// Soft Light
			float blendSoftLight(float base, float blend)
			{
				return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
			}
			
			float3 blendSoftLight(float3 base, float3 blend)
			{
				return float3(blendSoftLight(base.r, blend.r), blendSoftLight(base.g, blend.g), blendSoftLight(base.b, blend.b));
			}
			
			// Subtract
			float blendSubtract(float base, float blend)
			{
				return max(base - blend, 0.0);
			}
			
			float3 blendSubtract(float3 base, float3 blend)
			{
				return max(base - blend, 0.0);
			}
			
			// Difference
			float blendDifference(float base, float blend)
			{
				return abs(base - blend);
			}
			
			float3 blendDifference(float3 base, float3 blend)
			{
				return abs(base - blend);
			}
			
			// Divide
			float blendDivide(float base, float blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float3 blendDivide(float3 base, float3 blend)
			{
				return base / max(blend, 0.0001);
			}
			
			float blendMixed(float base, float blend)
			{
				return base + base * blend;
			}
			
			float3 blendMixed(float3 base, float3 blend)
			{
				return base + base * blend;
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float customBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					case 6: return blendScreen(base, blend); break;
					case 8: return blendLinearDodge(base, blend); break;
					case 9: return blendOverlay(base, blend); break;
					case 20: return blendMixed(base, blend); break;
					default: return 0; break;
				}
			}
			
			float3 customBlend(float3 base, float3 blend, float blendType, float alpha)
			{
				float3 output = base;
				switch(blendType)
				{
					case 0: output = lerp(base, blend, alpha); break;
					case 2: output = base * lerp(1, blend, alpha); break;
					case 6: output = lerp(base, blendScreen(base, blend), alpha); break;
					case 8: output = lerp(base, blendLinearDodge(base, blend), alpha); break;
					case 9: output = lerp(base, blendOverlay(base, blend), alpha); break;
					case 20: output = lerp(base, blendMixed(base, blend), alpha); break;
					default: output = 0; break;
				}
				return output;
			}
			
			#define REPLACE 0
			#define SUBSTRACT 1
			#define MULTIPLY 2
			#define DIVIDE 3
			#define MIN 4
			#define MAX 5
			#define AVERAGE 6
			#define ADD 7
			
			float maskBlend(float baseMask, float blendMask, float blendType)
			{
				float output = 0;
				switch(blendType)
				{
					case REPLACE: output = blendMask; break;
					case SUBSTRACT: output = baseMask - blendMask; break;
					case MULTIPLY: output = baseMask * blendMask; break;
					case DIVIDE: output = baseMask / blendMask; break;
					case MIN: output = min(baseMask, blendMask); break;
					case MAX: output = max(baseMask, blendMask); break;
					case AVERAGE: output = (baseMask + blendMask) * 0.5; break;
					case ADD: output = baseMask + blendMask; break;
				}
				return saturate(output);
			}
			
			float random(float2 p)
			{
				return frac(sin(dot(p, float2(12.9898, 78.2383))) * 43758.5453123);
			}
			
			float2 random2(float2 p)
			{
				return frac(sin(float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)))) * 43758.5453);
			}
			
			float3 random3(float2 p)
			{
				return frac(sin(float3(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)), dot(p, float2(248.3, 315.9)))) * 43758.5453);
			}
			
			float3 random3(float3 p)
			{
				return frac(sin(float3(dot(p, float3(127.1, 311.7, 248.6)), dot(p, float3(269.5, 183.3, 423.3)), dot(p, float3(248.3, 315.9, 184.2)))) * 43758.5453);
			}
			
			float3 randomFloat3(float2 Seed, float maximum)
			{
				return (.5 + float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed), float2(12.9898, 78.233))) * 43758.5453)
				) * .5) * (maximum);
			}
			
			float3 randomFloat3Range(float2 Seed, float Range)
			{
				return (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1) * Range;
			}
			
			float3 randomFloat3WiggleRange(float2 Seed, float Range, float wiggleSpeed)
			{
				float3 rando = (float3(
				frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453),
				frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453)
				) * 2 - 1);
				float speed = 1 + wiggleSpeed;
				return float3(sin((_Time.x + rando.x * PI) * speed), sin((_Time.x + rando.y * PI) * speed), sin((_Time.x + rando.z * PI) * speed)) * Range;
			}
			
			void poiDither(float4 In, float4 ScreenPosition, out float4 Out)
			{
				float2 uv = ScreenPosition.xy * _ScreenParams.xy;
				float DITHER_THRESHOLDS[16] = {
					1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0,
					13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0,
					4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0,
					16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0
				};
				uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4;
				Out = In - DITHER_THRESHOLDS[index];
			}
			
			static const float Epsilon = 1e-10;
			// The weights of RGB contributions to luminance.
			// Should sum to unity.
			static const float3 HCYwts = float3(0.299, 0.587, 0.114);
			static const float HCLgamma = 3;
			static const float HCLy0 = 100;
			static const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
			static const float3 wref = float3(1.0, 1.0, 1.0);
			#define TAU 6.28318531
			
			float3 HUEtoRGB(in float H)
			{
				float R = abs(H * 6 - 3) - 1;
				float G = 2 - abs(H * 6 - 2);
				float B = 2 - abs(H * 6 - 4);
				return saturate(float3(R, G, B));
			}
			
			float3 RGBtoHCV(in float3 RGB)
			{
				// Based on work by Sam Hocevar and Emil Persson
				float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
				float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
				float C = Q.x - min(Q.w, Q.y);
				float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
				return float3(H, C, Q.x);
			}
			
			float3 HSVtoRGB(in float3 HSV)
			{
				float3 RGB = HUEtoRGB(HSV.x);
				return ((RGB - 1) * HSV.y + 1) * HSV.z;
			}
			
			float3 RGBtoHSV(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float S = HCV.y / (HCV.z + Epsilon);
				return float3(HCV.x, S, HCV.z);
			}
			
			float3 HSLtoRGB(in float3 HSL)
			{
				float3 RGB = HUEtoRGB(HSL.x);
				float C = (1 - abs(2 * HSL.z - 1)) * HSL.y;
				return (RGB - 0.5) * C + HSL.z;
			}
			
			float3 RGBtoHSL(in float3 RGB)
			{
				float3 HCV = RGBtoHCV(RGB);
				float L = HCV.z - HCV.y * 0.5;
				float S = HCV.y / (1 - abs(L * 2 - 1) + Epsilon);
				return float3(HCV.x, S, L);
			}
			
			void DecomposeHDRColor(in float3 linearColorHDR, out float3 baseLinearColor, out float exposure)
			{
				// Optimization/adaptation of https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/GUI/ColorMutator.cs#L23 but skips weird photoshop stuff
				float maxColorComponent = max(linearColorHDR.r, max(linearColorHDR.g, linearColorHDR.b));
				bool isSDR = maxColorComponent <= 1.0;
				
				float scaleFactor = isSDR ? 1.0 : (1.0 / maxColorComponent);
				exposure = isSDR ? 0.0 : log(maxColorComponent) * 1.44269504089; // ln(2)
				
				baseLinearColor = scaleFactor * linearColorHDR;
			}
			
			float3 ApplyHDRExposure(float3 linearColor, float exposure)
			{
				return linearColor * pow(2, exposure);
			}
			
			// Transforms an RGB color using a matrix. Note that S and V are absolute values here
			float3 ModifyViaHSV(float3 color, float h, float s, float v)
			{
				float3 colorHSV = RGBtoHSV(color);
				colorHSV.x = frac(colorHSV.x + h);
				colorHSV.y = saturate(colorHSV.y + s);
				colorHSV.z = saturate(colorHSV.z + v);
				return HSVtoRGB(colorHSV);
			}
			
			float3 ModifyViaHSV(float3 color, float3 HSVMod)
			{
				return ModifyViaHSV(color, HSVMod.x, HSVMod.y, HSVMod.z);
			}
			
			float3 hueShift(float3 color, float hueOffset)
			{
				color = RGBtoHSV(color);
				color.x = frac(hueOffset +color.x);
				return HSVtoRGB(color);
			}
			
			// LCH
			float xyzF(float t)
			{
				return lerp(pow(t, 1. / 3.), 7.787037 * t + 0.139731, step(t, 0.00885645));
			}
			float xyzR(float t)
			{
				return lerp(t * t * t, 0.1284185 * (t - 0.139731), step(t, 0.20689655));
			}
			
			float4x4 poiRotationMatrixFromAngles(float x, float y, float z)
			{
				float angleX = radians(x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float4x4 poiRotationMatrixFromAngles(float3 angles)
			{
				float angleX = radians(angles.x);
				float c = cos(angleX);
				float s = sin(angleX);
				float4x4 rotateXMatrix = float4x4(1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1);
				
				float angleY = radians(angles.y);
				c = cos(angleY);
				s = sin(angleY);
				float4x4 rotateYMatrix = float4x4(c, 0, s, 0,
				0, 1, 0, 0,
				- s, 0, c, 0,
				0, 0, 0, 1);
				
				float angleZ = radians(angles.z);
				c = cos(angleZ);
				s = sin(angleZ);
				float4x4 rotateZMatrix = float4x4(c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1);
				
				return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
			}
			
			float3 getCameraPosition()
			{
				#ifdef USING_STEREO_MATRICES
				return lerp(unity_StereoWorldSpaceCameraPos[0], unity_StereoWorldSpaceCameraPos[1], 0.5);
				#endif
				return _WorldSpaceCameraPos;
			}
			
			half2 calcScreenUVs(half4 grabPos)
			{
				half2 uv = grabPos.xy / (grabPos.w + 0.0000000001);
				#if UNITY_SINGLE_PASS_STEREO
				uv.xy *= half2(_ScreenParams.x * 2, _ScreenParams.y);
				#else
				uv.xy *= _ScreenParams.xy;
				#endif
				
				return uv;
			}
			
			float CalcMipLevel(float2 texture_coord)
			{
				float2 dx = ddx(texture_coord);
				float2 dy = ddy(texture_coord);
				float delta_max_sqr = max(dot(dx, dx), dot(dy, dy));
				
				return 0.5 * log2(delta_max_sqr);
			}
			
			float inverseLerp(float A, float B, float T)
			{
				return (T - A) / (B - A);
			}
			
			float inverseLerp2(float2 a, float2 b, float2 value)
			{
				float2 AB = b - a;
				float2 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp3(float3 a, float3 b, float3 value)
			{
				float3 AB = b - a;
				float3 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			float inverseLerp4(float4 a, float4 b, float4 value)
			{
				float4 AB = b - a;
				float4 AV = value - a;
				return dot(AV, AB) / dot(AB, AB);
			}
			
			/*
			MIT License
			
			Copyright (c) 2019 wraikny
			
			Permission is hereby granted, free of charge, to any person obtaining a copy
			of this software and associated documentation files (the "Software"), to deal
			in the Software without restriction, including without limitation the rights
			to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			copies of the Software, and to permit persons to whom the Software is
			furnished to do so, subject to the following conditions:
			
			The above copyright notice and this permission notice shall be included in all
			copies or substantial portions of the Software.
			
			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			SOFTWARE.
			
			VertexTransformShader is dependent on:
			*/
			
			float4 quaternion_conjugate(float4 v)
			{
				return float4(
				v.x, -v.yzw
				);
			}
			
			float4 quaternion_mul(float4 v1, float4 v2)
			{
				float4 result1 = (v1.x * v2 + v1 * v2.x);
				
				float4 result2 = float4(
				- dot(v1.yzw, v2.yzw),
				cross(v1.yzw, v2.yzw)
				);
				
				return float4(result1 + result2);
			}
			
			// angle : radians
			float4 get_quaternion_from_angle(float3 axis, float angle)
			{
				float sn = sin(angle * 0.5);
				float cs = cos(angle * 0.5);
				return float4(axis * sn, cs);
			}
			
			float4 quaternion_from_vector(float3 inVec)
			{
				return float4(0.0, inVec);
			}
			
			float degree_to_radius(float degree)
			{
				return (
				degree / 180.0 * PI
				);
			}
			
			float3 rotate_with_quaternion(float3 inVec, float3 rotation)
			{
				float4 qx = get_quaternion_from_angle(float3(1, 0, 0), radians(rotation.x));
				float4 qy = get_quaternion_from_angle(float3(0, 1, 0), radians(rotation.y));
				float4 qz = get_quaternion_from_angle(float3(0, 0, 1), radians(rotation.z));
				
				#define MUL3(A, B, C) quaternion_mul(quaternion_mul((A), (B)), (C))
				float4 quaternion = normalize(MUL3(qx, qy, qz));
				float4 conjugate = quaternion_conjugate(quaternion);
				
				float4 inVecQ = quaternion_from_vector(inVec);
				
				float3 rotated = (
				MUL3(quaternion, inVecQ, conjugate)
				).yzw;
				
				return rotated;
			}
			
			float4 transform(float4 input, float4 pos, float4 rotation, float4 scale)
			{
				input.rgb *= (scale.xyz * scale.w);
				input = float4(rotate_with_quaternion(input.xyz, rotation.xyz * rotation.w) + (pos.xyz * pos.w), input.w);
				return input;
			}
			
			float2 RotateUV(float2 _uv, float _radian, float2 _piv, float _time)
			{
				float RotateUV_ang = _radian;
				float RotateUV_cos = cos(_time * RotateUV_ang);
				float RotateUV_sin = sin(_time * RotateUV_ang);
				return (mul(_uv - _piv, float2x2(RotateUV_cos, -RotateUV_sin, RotateUV_sin, RotateUV_cos)) + _piv);
			}
			
			/*
			MIT END
			*/
			
			float3 poiThemeColor(in PoiMods poiMods, in float3 srcColor, in float themeIndex)
			{
				if (themeIndex == 0) return srcColor;
				themeIndex -= 1;
				
				if (themeIndex <= 3)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					return poiMods.globalColorTheme[themeIndex];
				}
				#endif
				
				return srcColor;
			}
			
			float3 lilToneCorrection(float3 c, float4 hsvg)
			{
				// gamma
				c = pow(abs(c), hsvg.w);
				// rgb -> hsv
				float4 p = (c.b > c.g) ? float4(c.bg, -1.0, 2.0 / 3.0) : float4(c.gb, 0.0, -1.0 / 3.0);
				float4 q = (p.x > c.r) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
				float d = q.x - min(q.w, q.y);
				float e = 1.0e-10;
				float3 hsv = float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
				// shift
				hsv = float3(hsv.x + hsvg.x, saturate(hsv.y * hsvg.y), saturate(hsv.z * hsvg.z));
				// hsv -> rgb
				return hsv.z - hsv.z * hsv.y + hsv.z * hsv.y * saturate(abs(frac(hsv.x + float3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 1.0);
			}
			
			float lilIsIn0to1(float f)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, 1.0));
			}
			
			float lilIsIn0to1(float f, float nv)
			{
				float value = 0.5 - abs(f - 0.5);
				return saturate(value / clamp(fwidth(value), 0.0001, nv));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border)
			{
				return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
			}
			
			float3 poiEdgeLinearNoSaturate(float value, float3 border)
			{
				return float3(
				(value - border.x) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.y) / clamp(fwidth(value), 0.0001, 1.0),
				(value - border.z) / clamp(fwidth(value), 0.0001, 1.0)
				);
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur)
			{
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return (value - borderMin) / saturate(borderMax - borderMin + fwidth(value));
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border)
			{
				//return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
				
				float fwidthValue = fwidth(value);
				return smoothstep(border - fwidthValue, border + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinearNoSaturate(float value, float border, float blur, float borderRange)
			{
				float fwidthValue = fwidth(value);
				float borderMin = saturate(border - blur * 0.5 - borderRange);
				float borderMax = saturate(border + blur * 0.5);
				return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
			}
			
			float poiEdgeNonLinear(float value, float border)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeNonLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeNonLinearNoSaturate(value, border, blur, borderRange));
			}
			
			float poiEdgeLinear(float value, float border)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border));
			}
			
			float poiEdgeLinear(float value, float border, float blur)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur));
			}
			
			float poiEdgeLinear(float value, float border, float blur, float borderRange)
			{
				return saturate(poiEdgeLinearNoSaturate(value, border, blur, borderRange));
			}
			// From https://github.com/lilxyzw/OpenLit/blob/main/Assets/OpenLit/core.hlsl
			float3 OpenLitLinearToSRGB(float3 col)
			{
				return LinearToGammaSpace(col);
			}
			
			float3 OpenLitSRGBToLinear(float3 col)
			{
				return GammaToLinearSpace(col);
			}
			
			float OpenLitLuminance(float3 rgb)
			{
				#if defined(UNITY_COLORSPACE_GAMMA)
				return dot(rgb, float3(0.22, 0.707, 0.071));
				#else
				return dot(rgb, float3(0.0396819152, 0.458021790, 0.00609653955));
				#endif
			}
			
			float OpenLitGray(float3 rgb)
			{
				return dot(rgb, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
			}
			
			void OpenLitShadeSH9ToonDouble(float3 lightDirection, out float3 shMax, out float3 shMin)
			{
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 N = lightDirection * 0.666666;
				float4 vB = N.xyzz * N.yzzx;
				// L0 L2
				float3 res = float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
				res.r += dot(unity_SHBr, vB);
				res.g += dot(unity_SHBg, vB);
				res.b += dot(unity_SHBb, vB);
				res += unity_SHC.rgb * (N.x * N.x - N.y * N.y);
				// L1
				float3 l1;
				l1.r = dot(unity_SHAr.rgb, N);
				l1.g = dot(unity_SHAg.rgb, N);
				l1.b = dot(unity_SHAb.rgb, N);
				shMax = res + l1;
				shMin = res - l1;
				#if defined(UNITY_COLORSPACE_GAMMA)
				shMax = OpenLitLinearToSRGB(shMax);
				shMin = OpenLitLinearToSRGB(shMin);
				#endif
				#else
				shMax = 0.0;
				shMin = 0.0;
				#endif
			}
			
			float3 OpenLitComputeCustomLightDirection(float4 lightDirectionOverride)
			{
				float3 customDir = length(lightDirectionOverride.xyz) * normalize(mul((float3x3)unity_ObjectToWorld, lightDirectionOverride.xyz));
				return lightDirectionOverride.w ? customDir : lightDirectionOverride.xyz; // .w isn't doc'd anywhere and is always 0 unless end user changes it
				
			}
			
			float3 OpenLitLightingDirectionForSH9()
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				
				float3 lightDirectionForSH9 = sh9Dir + mainDir;
				lightDirectionForSH9 = dot(lightDirectionForSH9, lightDirectionForSH9) < 0.000001 ? 0 : normalize(lightDirectionForSH9);
				return lightDirectionForSH9;
			}
			
			float3 OpenLitLightingDirection(float4 lightDirectionOverride)
			{
				float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
				#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
				float3 sh9Dir = unity_SHAr.xyz * 0.333333 + unity_SHAg.xyz * 0.333333 + unity_SHAb.xyz * 0.333333;
				float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
				#else
				float3 sh9Dir = 0;
				float3 sh9DirAbs = 0;
				#endif
				float3 customDir = OpenLitComputeCustomLightDirection(lightDirectionOverride);
				
				return normalize(sh9DirAbs + mainDir + customDir);
			}
			
			float3 OpenLitLightingDirection()
			{
				float4 customDir = float4(0.001, 0.002, 0.001, 0.0);
				return OpenLitLightingDirection(customDir);
			}
			
			inline float4 CalculateFrustumCorrection()
			{
				float x1 = -UNITY_MATRIX_P._31 / (UNITY_MATRIX_P._11 * UNITY_MATRIX_P._34);
				float x2 = -UNITY_MATRIX_P._32 / (UNITY_MATRIX_P._22 * UNITY_MATRIX_P._34);
				return float4(x1, x2, 0, UNITY_MATRIX_P._33 / UNITY_MATRIX_P._34 + x1 * UNITY_MATRIX_P._13 + x2 * UNITY_MATRIX_P._23);
			}
			
			inline float CorrectedLinearEyeDepth(float z, float B)
			{
				return 1.0 / (z / UNITY_MATRIX_P._34 + B);
			}
			
			//Silent's code
			float2 sharpSample(float4 texelSize, float2 p)
			{
				p = p * texelSize.zw;
				float2 c = max(0.0, fwidth(p));
				p = floor(p) + saturate(frac(p) / c);
				p = (p - 0.5) * texelSize.xy;
				return p;
			}
			
			void applyToGlobalMask(inout PoiMods poiMods, int index, int blendType, float val)
			{
				float valBlended = saturate(maskBlend(poiMods.globalMask[index], val, blendType));
				switch(index)
				{
					case 0: poiMods.globalMask[0] = valBlended; break;
					case 1: poiMods.globalMask[1] = valBlended; break;
					case 2: poiMods.globalMask[2] = valBlended; break;
					case 3: poiMods.globalMask[3] = valBlended; break;
					case 4: poiMods.globalMask[4] = valBlended; break;
					case 5: poiMods.globalMask[5] = valBlended; break;
					case 6: poiMods.globalMask[6] = valBlended; break;
					case 7: poiMods.globalMask[7] = valBlended; break;
					case 8: poiMods.globalMask[8] = valBlended; break;
					case 9: poiMods.globalMask[9] = valBlended; break;
					case 10: poiMods.globalMask[10] = valBlended; break;
					case 11: poiMods.globalMask[11] = valBlended; break;
					case 12: poiMods.globalMask[12] = valBlended; break;
					case 13: poiMods.globalMask[13] = valBlended; break;
					case 14: poiMods.globalMask[14] = valBlended; break;
					case 15: poiMods.globalMask[15] = valBlended; break;
				}
			}
			
			void assignValueToVectorFromIndex(inout float4 vec, int index, float value)
			{
				switch(index)
				{
					case 0: vec[0] = value; break;
					case 1: vec[1] = value; break;
					case 2: vec[2] = value; break;
					case 3: vec[3] = value; break;
				}
			}
			
			// SNose
			float3 mod289(float3 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float2 mod289(float2 x)
			{
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}
			float3 permute(float3 x)
			{
				return mod289(((x * 34.0) + 1.0) * x);
			}
			
			float snoise(float2 v)
			{
				const float4 C = float4(0.211324865405187, // (3.0-sqrt(3.0))/6.0
				0.366025403784439, // 0.5*(sqrt(3.0)-1.0)
				- 0.577350269189626, // -1.0 + 2.0 * C.x
				0.024390243902439); // 1.0 / 41.0
				float2 i = floor(v + dot(v, C.yy));
				float2 x0 = v - i + dot(i, C.xx);
				float2 i1;
				i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
				float4 x12 = x0.xyxy + C.xxzz;
				x12.xy -= i1;
				i = mod289(i); // Avoid truncation effects in permutation
				float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0))
				+ i.x + float3(0.0, i1.x, 1.0));
				
				float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
				m = m * m ;
				m = m * m ;
				float3 x = 2.0 * frac(p * C.www) - 1.0;
				float3 h = abs(x) - 0.5;
				float3 ox = floor(x + 0.5);
				float3 a0 = x - ox;
				m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
				float3 g;
				g.x = a0.x * x0.x + h.x * x0.y;
				g.yz = a0.yz * x12.xz + h.yz * x12.yw;
				return 130.0 * dot(m, g);
			}
			//ifex _EnableAudioLink==0
			#ifdef POI_AUDIOLINK
			
			// Convenient mechanism to read from the AudioLink texture that handles reading off the end of one line and onto the next above it.
			float4 AudioLinkDataMultiline(uint2 xycoord) { return AudioLinkData(uint2(xycoord.x % AUDIOLINK_WIDTH, xycoord.y + xycoord.x/AUDIOLINK_WIDTH)); }
			
			// Mechanism to sample between two adjacent pixels and lerp between them, like "linear" supesampling
			float4 AudioLinkLerp(float2 xy) { return lerp( AudioLinkData(xy), AudioLinkData(xy+int2(1,0)), frac( xy.x ) ); }
			
			// Same as AudioLinkLerp but properly handles multiline reading.
			float4 AudioLinkLerpMultiline(float2 xy) { return lerp(AudioLinkDataMultiline(xy), AudioLinkDataMultiline(xy+float2(1,0)), frac(xy.x)); }
			
			//Tests to see if Audio Link texture is available
			bool AudioLinkIsAvailable()
			{
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				int width, height;
				_AudioTexture.GetDimensions(width, height);
				return width > 16;
				#else
				return _AudioTexture_TexelSize.z > 16;
				#endif
			}
			
			//Get version of audiolink present in the world, 0 if no audiolink is present
			float AudioLinkGetVersion()
			{
				int2 dims;
				#if !defined(AUDIOLINK_STANDARD_INDEXING)
				_AudioTexture.GetDimensions(dims.x, dims.y);
				#else
				dims = _AudioTexture_TexelSize.zw;
				#endif
				
				if (dims.x >= 128)
				return AudioLinkData(ALPASS_GENERALVU).x;
				else if (dims.x > 16)
				return 1;
				else
				return 0;
			}
			
			// This pulls data from this texture.
			#define AudioLinkGetSelfPixelData(xy) _SelfTexture2D[xy]
			
			// Extra utility functions for time.
			uint AudioLinkDecodeDataAsUInt(uint2 indexloc)
			{
				uint4 rpx = AudioLinkData(indexloc);
				return rpx.r + rpx.g*1024 + rpx.b * 1048576 + rpx.a * 1073741824;
			}
			
			//Note: This will truncate time to every 134,217.728 seconds (~1.5 days of an instance being up) to prevent floating point aliasing.
			// if your code will alias sooner, you will need to use a different function.  It should be safe to use this on all times.
			float AudioLinkDecodeDataAsSeconds(uint2 indexloc)
			{
				uint time = AudioLinkDecodeDataAsUInt(indexloc) & 0x7ffffff;
				//Can't just divide by float.  Bug in Unity's HLSL compiler.
				return float(time / 1000) + float( time % 1000 ) / 1000.;
			}
			
			#define ALDecodeDataAsSeconds( x ) AudioLinkDecodeDataAsSeconds( x )
			#define ALDecodeDataAsUInt( x ) AudioLinkDecodeDataAsUInt( x )
			
			float AudioLinkRemap(float t, float a, float b, float u, float v) { return ((t-a) / (b-a)) * (v-u) + u; }
			
			float3 AudioLinkHSVtoRGB(float3 HSV)
			{
				float3 RGB = 0;
				float C = HSV.z * HSV.y;
				float H = HSV.x * 6;
				float X = C * (1 - abs(fmod(H, 2) - 1));
				if (HSV.y != 0)
				{
					float I = floor(H);
					if (I == 0) { RGB = float3(C, X, 0); }
					else if (I == 1) { RGB = float3(X, C, 0); }
					else if (I == 2) { RGB = float3(0, C, X); }
					else if (I == 3) { RGB = float3(0, X, C); }
					else if (I == 4) { RGB = float3(X, 0, C); }
					else { RGB = float3(C, 0, X); }
				}
				float M = HSV.z - C;
				return RGB + M;
			}
			
			float3 AudioLinkCCtoRGB(float bin, float intensity, int rootNote)
			{
				float note = bin / AUDIOLINK_EXPBINS;
				
				float hue = 0.0;
				note *= 12.0;
				note = glsl_mod(4. - note + rootNote, 12.0);
				{
					if(note < 4.0)
					{
						//Needs to be YELLOW->RED
						hue = (note) / 24.0;
					}
					else if(note < 8.0)
					{
						//            [4]  [8]
						//Needs to be RED->BLUE
						hue = (note-2.0) / 12.0;
					}
					else
					{
						//             [8] [12]
						//Needs to be BLUE->YELLOW
						hue = (note - 4.0) / 8.0;
					}
				}
				float val = intensity - 0.1;
				return AudioLinkHSVtoRGB(float3(fmod(hue, 1.0), 1.0, clamp(val, 0.0, 1.0)));
			}
			
			// Sample the amplitude of a given frequency in the DFT, supports frequencies in [13.75; 14080].
			float4 AudioLinkGetAmplitudeAtFrequency(float hertz)
			{
				float note = AUDIOLINK_EXPBINS * log2(hertz / AUDIOLINK_BOTTOM_FREQUENCY);
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(note, 0));
			}
			
			// Sample the amplitude of a given semitone in an octave. Octave is in [0; 9] while note is [0; 11].
			float AudioLinkGetAmplitudeAtNote(float octave, float note)
			{
				float quarter = note * 2.0;
				return AudioLinkLerpMultiline(ALPASS_DFT + float2(octave * AUDIOLINK_EXPBINS + quarter, 0));
			}
			
			// Get a reasonable drop-in replacement time value for _Time.y with the
			// given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTime(uint index, uint band)
			{
				return (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY + uint2(index, band))) / 100000.0;
			}
			
			// Get a chronotensity value in the interval [0; 1], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeNormalized(uint index, uint band, float speed)
			{
				return frac(AudioLinkGetChronoTime(index, band) * speed);
			}
			
			// Get a chronotensity value in the interval [0; interval], modulated by the speed input,
			// with the given chronotensity index [0; 7] and AudioLink band [0; 3].
			float AudioLinkGetChronoTimeInterval(uint index, uint band, float speed, float interval)
			{
				return AudioLinkGetChronoTimeNormalized(index, band, speed) * interval;
			}
			
			float getBandAtTime(float band, float time, float size = 1.0f)
			{
				//return remap(UNITY_SAMPLE_TEX2D(_AudioTexture, float2(time * width, band/128.0)).r, min(size,.9999), 1);
				return remapClamped(min(size,.9999), 1, AudioLinkData(ALPASS_AUDIOBASS + uint2(time * AUDIOLINK_WIDTH,band)).r);
			}
			
			fixed3 maximize(fixed3 c) {
				if (c.x == 0 && c.y == 0 && c.z == 0)
				return fixed3(1.0, 1.0, 1.0);
				else
				return c / max(c.r, max(c.g, c.b));
			}
			
			bool LumaIsAvailable()
			{
				return LumaData(0.629, 0.511).r > 0.9;
			}
			
			float3 getLumaGradient(uint index, float offset) {
				return LumaData(0.57 + (index * 0.11) + lerp(0, 0.107, offset), 0.493);
			}
			
			void initPoiAudioLink(inout PoiMods poiMods)
			{
				if (!_AudioLinkAnimToggle) return;
				
				if (AudioLinkIsAvailable())
				{
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkVersion = AudioLinkGetVersion();
					poiMods.audioLink[0] = _AudioLinkSmoothingBass    == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 0))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingBass   ) * 15.95, 0))[0];
					poiMods.audioLink[1] = _AudioLinkSmoothingLowMid  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 1))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingLowMid ) * 15.95, 1))[0];
					poiMods.audioLink[2] = _AudioLinkSmoothingHighMid == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 2))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingHighMid) * 15.95, 2))[0];
					poiMods.audioLink[3] = _AudioLinkSmoothingTreble  == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 3))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - _AudioLinkSmoothingTreble ) * 15.95, 3))[0];
					/*
					poiMods.globalColorTheme[4] = AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) );
					poiMods.globalColorTheme[5] = AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) );
					poiMods.globalColorTheme[6] = AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) );
					poiMods.globalColorTheme[7] = AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) );
					
					poiMods.globalColorTheme[4] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 0, 0 ) )),1.0);
					poiMods.globalColorTheme[5] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 1, 0 ) )),1.0);
					poiMods.globalColorTheme[6] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 2, 0 ) )),1.0);
					poiMods.globalColorTheme[7] =  float4(maximize(AudioLinkData( ALPASS_CCCOLORS + uint2( 3, 0 ) )),1.0);
					*/
					
					poiMods.globalColorTheme[4] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(2, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[5] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(3, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[6] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(4, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					poiMods.globalColorTheme[7] =  float4(AudioLinkCCtoRGB(glsl_mod(AudioLinkData(ALPASS_CCINTERNAL + uint2(5, 0))[0], AUDIOLINK_EXPBINS), 1, AUDIOLINK_ROOTNOTE), 1.0);
					
					poiMods.globalColorTheme[8] = AudioLinkData(ALPASS_THEME_COLOR0);
					poiMods.globalColorTheme[9] = AudioLinkData(ALPASS_THEME_COLOR1);
					poiMods.globalColorTheme[10] = AudioLinkData(ALPASS_THEME_COLOR2);
					poiMods.globalColorTheme[11] = AudioLinkData(ALPASS_THEME_COLOR3);
					return;
				}
				
				if (LumaIsAvailable())
				{
					// Gradients:
					// 0.570 - 0.677, 0.493
					// 0.680 - 0.788, 0.493
					// 0.791 - 0.898, 0.493
					float4 audioPixel = LumaData(0.578, 0.515);
					float audioLows = audioPixel.r;
					float audioHighs = audioPixel.g;
					float4 zone1 = LumaData(0.856, 0.522);
					float4 zone2 = LumaData(0.856, 0.507);
					float4 zone3 = LumaData(0.864, 0.522);
					float4 zone4 = LumaData(0.864, 0.507);
					// float4 lumaEnabledPixel = LumaData(0.629, 0.511);
					// float fakeLight = (lumaEnabledPixel.g > 0) ? 1 : (1 - lumaEnabledPixel.r);
					
					poiMods.audioLinkAvailable = true;
					poiMods.audioLinkViaLuma = true;
					poiMods.audioLink.xy = audioLows;
					poiMods.audioLink.zw = audioHighs;
					
					poiMods.globalColorTheme[8] = zone1;
					poiMods.globalColorTheme[9] = zone2;
					poiMods.globalColorTheme[10] = zone3;
					poiMods.globalColorTheme[11] = zone4;
				}
			}
			
			void DebugVisualizer(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods){
				if (_DebugWaveform){
					float waveform = AudioLinkLerpMultiline(ALPASS_WAVEFORM + float2( 500. * poiMesh.uv[0].x, 0)).r;
					poiFragData.emission += clamp(1 - 50 * abs(waveform - poiMesh.uv[0].y * 2. + 1), 0, 1);
				}
				if (_DebugDFT){
					poiFragData.emission += AudioLinkLerpMultiline(ALPASS_DFT + uint2(poiMesh.uv[0].x * AUDIOLINK_ETOTALBINS, 0)).rrr;
				}
				if (_DebugBass){
					poiFragData.emission += poiMods.audioLink.x;
				}
				if (_DebugLowMids){
					poiFragData.emission += poiMods.audioLink.y;
				}
				if (_DebugHighMids){
					poiFragData.emission += poiMods.audioLink.z;
				}
				if (_DebugTreble){
					poiFragData.emission += poiMods.audioLink.w;
				}
				if (_DebugCCColors){
					poiFragData.emission += AudioLinkData(ALPASS_CCCOLORS + uint2(3 + 1, 0));
				}
				if (_DebugCCStrip){
					poiFragData.emission += AudioLinkLerp(ALPASS_CCSTRIP + float2(poiMesh.uv[0].x * AUDIOLINK_WIDTH, 0));
				}
				if (_DebugCCLights){
					poiFragData.emission += AudioLinkData(ALPASS_CCLIGHTS + uint2(uint(poiMesh.uv[0].x * 8) + uint(poiMesh.uv[0].y * 16) * 8, 0));
				}
				if (_DebugAutocorrelator){
					poiFragData.emission += saturate(AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2((abs(1. - poiMesh.uv[0].x * 2.)) * AUDIOLINK_WIDTH, 0)).rrr);
				}
				if (_DebugChronotensity){
					poiFragData.emission += (AudioLinkDecodeDataAsUInt(ALPASS_CHRONOTENSITY  + uint2(1, 0)) % 1000000) / 1000000.0;
				}
			}
			
			void SetupAudioLink(inout PoiFragData poiFragData, inout PoiMods poiMods, in PoiMesh poiMesh){
				initPoiAudioLink(poiMods);
				DebugVisualizer(poiFragData, poiMesh, poiMods);
				
				if(_AudioLinkCCStripY)
				{
					poiFragData.emission += AudioLinkLerp( ALPASS_CCSTRIP + float2( poiMesh.uv[0].y * AUDIOLINK_WIDTH, 0 ) ).rgb * .5;
				}
			}
			
			#endif
			//endex
			
			VertexOut vert(
			#ifndef POI_TESSELLATED
			appdata v
			#else
			tessAppData v
			#endif
			)
			{
				UNITY_SETUP_INSTANCE_ID(v);
				VertexOut o;
				PoiInitStruct(VertexOut, o);
				UNITY_TRANSFER_INSTANCE_ID(v, o);
				#ifdef POI_TESSELLATED
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v);
				#endif
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
				
				//ifex _EnableUDIMDiscardOptions==0
				#ifdef POI_UDIMDISCARD
				UNITY_BRANCH
				if(_UDIMDiscardMode == 0) // Discard Vertices instead of just pixels
				{
					// Branchless (inspired by s-ilent)
					float2 udim = 0;
					// Select UV
					udim += (v.uv0.xy * (_UDIMDiscardUV == 0));
					udim += (v.uv1.xy * (_UDIMDiscardUV == 1));
					udim += (v.uv2.xy * (_UDIMDiscardUV == 2));
					udim += (v.uv3.xy * (_UDIMDiscardUV == 3));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 0, but not exactly 0
					const float threshold = 0.001;
					if(isDiscarded > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _VertexManipulationsEnabled==0
				#ifdef AUTO_EXPOSURE
				float4 audioLinkBands = 0;
				float3 ALrotation = 0;
				float3 ALLocalTranslation = 0;
				float3 CTALRotation = 0;
				float3 ALScale = 0;
				float3 ALWorldTranslation = 0;
				float ALHeight = 0;
				float ALRoundingAmount = 0;
				float4 ALSpectrumLocalOffset = float4(0, 0, 0, 0);
				#ifdef POI_AUDIOLINK
				if (AudioLinkIsAvailable() && _VertexAudioLinkEnabled && _AudioLinkAnimToggle)
				{
					audioLinkBands.x = AudioLinkData(ALPASS_AUDIOBASS).r;
					audioLinkBands.y = AudioLinkData(ALPASS_AUDIOLOWMIDS).r;
					audioLinkBands.z = AudioLinkData(ALPASS_AUDIOHIGHMIDS).r;
					audioLinkBands.w = AudioLinkData(ALPASS_AUDIOTREBLE).r;
					
					if (any(_VertexLocalTranslationALMin) || any(_VertexLocalTranslationALMax))
					{
						ALLocalTranslation = lerp(_VertexLocalTranslationALMin, _VertexLocalTranslationALMax, audioLinkBands[_VertexLocalTranslationALBand]);
					}
					if (any(_VertexLocalRotationAL))
					{
						ALrotation = audioLinkBands[_VertexLocalRotationALBand] * _VertexLocalRotationAL;
					}
					if (any(_VertexLocalRotationCTALSpeed))
					{
						CTALRotation.x = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeX, _VertexLocalRotationCTALBandX) * _VertexLocalRotationCTALSpeed.x * 360;
						CTALRotation.y = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeY, _VertexLocalRotationCTALBandY) * _VertexLocalRotationCTALSpeed.y * 360;
						CTALRotation.z = AudioLinkGetChronoTime(_VertexLocalRotationCTALTypeZ, _VertexLocalRotationCTALBandZ) * _VertexLocalRotationCTALSpeed.z * 360;
					}
					if (any(_VertexLocalScaleALMin) || any(_VertexLocalScaleALMax))
					{
						ALScale = lerp(_VertexLocalScaleALMin.xyz + _VertexLocalScaleALMin.w, _VertexLocalScaleALMax.xyz + _VertexLocalScaleALMax.w, audioLinkBands[_VertexLocalScaleALBand]);
					}
					if (any(_VertexWorldTranslationALMin) || any(_VertexWorldTranslationALMax))
					{
						ALWorldTranslation = lerp(_VertexWorldTranslationALMin, _VertexWorldTranslationALMax, audioLinkBands[_VertexWorldTranslationALBand]);
					}
					if (any(_VertexManipulationHeightAL))
					{
						ALHeight = lerp(_VertexManipulationHeightAL.x, _VertexManipulationHeightAL.y, audioLinkBands[_VertexManipulationHeightBand]);
					}
					if (any(_VertexRoundingRangeAL))
					{
						ALRoundingAmount = lerp(_VertexRoundingRangeAL.x, _VertexRoundingRangeAL.y, audioLinkBands[_VertexRoundingRangeBand]);
					}
					if (_VertexSpectrumMotion)
					{
						ALSpectrumLocalOffset.xyz = lerp(_VertexSpectrumOffsetMin.xyz, _VertexSpectrumOffsetMax.xyz, AudioLinkLerpMultiline(ALPASS_DFT + float2(vertexUV(v, _VertexSpectrumUV)[_VertexSpectrumUVDirection] * AUDIOLINK_ETOTALBINS, 0.)));
					}
				}
				#endif
				
				// Local Transformation
				float4 rotation = float4(_VertexManipulationLocalRotation.xyz + float3(180, 0, 0) + _VertexManipulationLocalRotationSpeed * _Time.x + ALrotation + CTALRotation, _VertexManipulationLocalRotation.w);
				v.normal = rotate_with_quaternion(v.normal, rotation.xyz);
				v.tangent.xyz = rotate_with_quaternion(v.tangent.xyz, rotation.xyz);
				v.vertex = transform(v.vertex, _VertexManipulationLocalTranslation + float4(ALLocalTranslation, 0) + ALSpectrumLocalOffset, rotation, _VertexManipulationLocalScale + float4(ALScale, 0));
				o.normal = UnityObjectToWorldNormal(v.normal);
				
				#if defined(PROP_VERTEXMANIPULATIONHEIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float3 heightOffset = (tex2Dlod(_VertexManipulationHeightMask, float4(poiUV(vertexUV(v, _VertexManipulationHeightMaskUV), _VertexManipulationHeightMask_ST) + _VertexManipulationHeightMaskPan * _Time.x, 0, 0))[_VertexManipulationHeightMaskChannel] - _VertexManipulationHeightBias) * (_VertexManipulationHeight + ALHeight) * o.normal;
				#else
				float3 heightOffset = (_VertexManipulationHeight + ALHeight) * o.normal;
				#endif
				
				if (_VertexBarrelMode)
				{
					v.vertex.xz = lerp(v.vertex.xz, normalize(v.vertex.xz) * _VertexBarrelWidth + v.vertex.xz * _VertexBarrelHeight, _VertexBarrelAlpha);
				}
				
				if (_VertexSphereMode)
				{
					v.vertex.xyz = lerp(v.vertex.xyz, normalize(v.vertex.xyz + _VertexSphereCenter.xyz) * _VertexSphereRadius + v.vertex.xyz * _VertexSphereHeight, _VertexSphereAlpha);
				}
				
				v.vertex.xyz += mul(unity_WorldToObject, _VertexManipulationWorldTranslation.xyz + ALWorldTranslation + heightOffset).xyz;
				
				// rounding
				UNITY_BRANCH
				if (_VertexRoundingEnabled)
				{
					float divisionAmount = max(_VertexRoundingDivision + ALRoundingAmount, 0.0000001);
					float3 vertexPos = v.vertex.xyz;
					if (_VertexRoundingSpace == 0)
					{
						vertexPos = mul(unity_ObjectToWorld, v.vertex.xyz);
					}
					float3 worldRoundPosition = (ceil(vertexPos / divisionAmount) * divisionAmount) - divisionAmount * .5;
					v.vertex.xyz = worldRoundPosition;
					if (_VertexRoundingSpace == 0)
					{
						v.vertex.xyz = mul(unity_WorldToObject, worldRoundPosition);
					}
				}
				#endif
				//endex
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				UNITY_BRANCH
				if(_UVTileDissolveEnabled && _UVTileDissolveDiscardAtMax)
				{
					// Branchless (inspired by s-ilent)
					float2 dissolveUdim = 0;
					// Select UV
					dissolveUdim += (v.uv0.xy * (_UVTileDissolveUV == 0));
					dissolveUdim += (v.uv1.xy * (_UVTileDissolveUV == 1));
					dissolveUdim += (v.uv2.xy * (_UVTileDissolveUV == 2));
					dissolveUdim += (v.uv3.xy * (_UVTileDissolveUV == 3));
					
					float isDiscardedFromDissolve = 0;
					float4 xMaskDissolve = float4(  (dissolveUdim.x >= 0 && dissolveUdim.x < 1),
					(dissolveUdim.x >= 1 && dissolveUdim.x < 2),
					(dissolveUdim.x >= 2 && dissolveUdim.x < 3),
					(dissolveUdim.x >= 3 && dissolveUdim.x < 4));
					
					isDiscardedFromDissolve += (dissolveUdim.y >= 0 && dissolveUdim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 1 && dissolveUdim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 2 && dissolveUdim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMaskDissolve);
					isDiscardedFromDissolve += (dissolveUdim.y >= 3 && dissolveUdim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMaskDissolve);
					
					isDiscardedFromDissolve *= any(float4(dissolveUdim.y >= 0, dissolveUdim.y < 4, dissolveUdim.x >= 0, dissolveUdim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					// Use a threshold so that there's some room for animations to be close to 1, but not exactly 1
					const float threshold = 0.999;
					if(isDiscardedFromDissolve > threshold) // Early Return skips rest of vertex shader
					{
						return (VertexOut)POI_NAN;
					}
				}
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				float notVisible = 0;
				
				if (_VisibilityMode == 1) // VRC
				{
					float mirrorMode = VRCMirrorMode();
					float cameraMode = VRCCameraMode();
					
					notVisible += (!_VisibilityVRCRegular 		&& ((mirrorMode == 0) && (cameraMode == 0)));
					notVisible += (!_VisibilityVRCMirrorVR 		&&  (mirrorMode == 1));
					notVisible += (!_VisibilityVRCMirrorDesktop &&  (mirrorMode == 2));
					notVisible += (!_VisibilityVRCCameraVR			&& (cameraMode == 1));
					notVisible += (!_VisibilityVRCCameraDesktop 	&& (cameraMode == 2));
					notVisible += (!_VisibilityVRCCameraScreenshot 	&& (cameraMode == 3));
				}
				else if (_Mirror != 0) // Generic (CVR, etc)
				{
					notVisible += (_Mirror == 1) ^ IsInMirror();
				}
				
				if(notVisible) // Early Return skips rest of vertex shader
				{
					return (VertexOut)POI_NAN;
				}
				#endif
				//endex
				
				o.objectPos = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
				o.objNormal = v.normal;
				o.normal = UnityObjectToWorldNormal(v.normal);
				o.tangent = UnityObjectToWorldDir(v.tangent);
				
				o.binormal = cross(o.normal, o.tangent) * (v.tangent.w * unity_WorldTransformParams.w);
				o.vertexColor = v.color;
				
				o.uv[0] = v.uv0;
				o.uv[1] = v.uv1;
				o.uv[2] = v.uv2;
				o.uv[3] = v.uv3;
				
				#if defined(LIGHTMAP_ON)
				o.lightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
				#endif
				#ifdef DYNAMICLIGHTMAP_ON
				o.lightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
				#endif
				
				o.localPos = v.vertex;
				o.worldPos = mul(unity_ObjectToWorld, o.localPos);
				
				float3 localOffset = float3(0, 0, 0);
				float3 worldOffset = float3(0, 0, 0);
				
				//ifex _VertexGlitchingEnabled==0
				#if defined(POI_VERTEX_GLITCHING)
				
				bool canGlitch = true;
				if (_VertexGlitchMirrorEnable && _VertexGlitchMirror > 0)
				{
					bool inMirror = IsInMirror();
					if (_VertexGlitchMirror == 1 && !inMirror)	canGlitch = false;
					if (_VertexGlitchMirror == 2 && inMirror)	canGlitch = false;
				}
				if (canGlitch)
				{
					float3 forward = getCameraPosition() - mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
					forward.y = 0;
					forward = normalize(forward);
					float3 glitchDirection = normalize(cross(float3(0, 1, 0), forward));
					
					float glitchAmount = 0;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE)
					// if(_VertexGlitchingUseTexture)
					// {
					float uvl = o.worldPos.y * _VertexGlitchDensity + _Time.x * _VertexGlitchMapPanSpeed;
					float uvr = o.worldPos.y * _VertexGlitchDensity - _Time.x * _VertexGlitchMapPanSpeed;
					
					float3 glitchTextureL = 1;
					float3 glitchTextureR = 1;
					
					#if defined(POI_VERTEX_GLITCHING_TEXTURE) || !defined(OPTIMIZER_ENABLED)
					glitchTextureL = tex2Dlod(_VertexGlitchMap, float4(uvl, uvl, 0, 0)).rgb;
					glitchTextureR = tex2Dlod(_VertexGlitchMap, float4(uvr, uvr, 0, 0)).rgb;
					#endif
					
					glitchAmount += (glitchTextureL.r - 0.5) * 2;
					glitchAmount += - (glitchTextureR.r - 0.5) * 2;
					
					glitchAmount += (glitchTextureL.g - 0.5) * 2;
					glitchAmount += - (glitchTextureR.b - 0.5) * 2;
					// } else {
					#else
					glitchAmount += frac(sin(dot(_Time.xy + o.worldPos.y, float2(12.9898, 78.233))) * 43758.5453123) * 2 - 1;
					// }
					#endif
					
					float time = _Time.y * _VertexGlitchFrequency;
					
					float randomGlitch = (sin(time) + sin(2.2 * time + 5.52) + sin(2.9 * time + 0.93) + sin(4.6 * time + 8.94)) / 4;
					float3 glitchOffset = 0;
					
					#ifdef POI_AUDIOLINK
					if (AudioLinkIsAvailable() && _VertexGlitchingAudioLinkEnabled)
					{
						// float4 audioLinkData = AudioLinkData(ALPASS_AUDIOBASS);
						
						float audioIntensity =
						AudioLinkData(ALPASS_AUDIOBASS).r 		* (_VertexGlitchingAudioLinkBand == 0) +
						AudioLinkData(ALPASS_AUDIOLOWMIDS).r 	* (_VertexGlitchingAudioLinkBand == 1) +
						AudioLinkData(ALPASS_AUDIOHIGHMIDS).r	* (_VertexGlitchingAudioLinkBand == 2) +
						AudioLinkData(ALPASS_AUDIOTREBLE).r 	* (_VertexGlitchingAudioLinkBand == 3) +
						AudioLinkData(ALPASS_FILTEREDVU_INTENSITY).r * (_VertexGlitchingAudioLinkBand == 4);
						
						if(_VertexGlitchingAudiolinkOverride)
						{
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
							// glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						} else {
							glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
							glitchOffset += glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * audioIntensity;
						}
					} else {
						glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					}
					#else
					glitchOffset = glitchAmount * glitchDirection * (_VertexGlitchStrength * .01) * step(_VertexGlitchThreshold, randomGlitch);
					#endif
					
					localOffset += glitchOffset;
					worldOffset += mul(unity_ObjectToWorld, glitchOffset);
				}
				#endif
				//endex
				
				o.localPos.rgb += localOffset;
				o.worldPos.rgb += worldOffset;
				
				//ifex _EnableDepthBulge==0
				#if defined(POI_DEPTHBULGE) && (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				applyDepthBulgeFX(o);
				#endif
				//endex
				
				o.pos = UnityObjectToClipPos(o.localPos);
				
				#ifdef POI_PASS_OUTLINE
				#if defined(UNITY_REVERSED_Z)
				//DX
				o.pos.z += _Offset_Z * - 0.01;
				#else
				//OpenGL
				o.pos.z += _Offset_Z * 0.01;
				#endif
				#endif
				o.grabPos = ComputeGrabScreenPos(o.pos);
				
				#ifndef FORWARD_META_PASS
				#if !defined(UNITY_PASS_SHADOWCASTER)
				UNITY_TRANSFER_SHADOW(o, o.uv[0].xy);
				#else
				v.vertex.xyz = o.localPos.xyz;
				TRANSFER_SHADOW_CASTER_NOPOS(o, o.pos);
				#endif
				#endif
				
				UNITY_TRANSFER_FOG(o, o.pos);
				
				if (_RenderingReduceClipDistance)
				{
					if (o.pos.w < _ProjectionParams.y * 1.01 && o.pos.w > 0)
					{
						o.pos.z = o.pos.z * 0.0001 + o.pos.w * 0.999;
					}
				}
				
				#ifdef POI_PASS_META
				o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
				#endif
				
				#if defined(GRAIN)
				float4 worldDirection;
				
				worldDirection.xyz = o.worldPos.xyz - _WorldSpaceCameraPos;
				worldDirection.w = dot(o.pos, CalculateFrustumCorrection());
				o.worldDirection = worldDirection;
				#endif
				return o;
			}
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, uv) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan)) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			#if defined(_STOCHASTICMODE_HEXTILE)
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, uv, false) : POI2D_SAMPLER(tex, texSampler, uv))
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? HextileSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), false, dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			#ifndef POI2D_SAMPLER_STOCHASTIC
			#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (POI2D_SAMPLER(tex, texSampler, uv))
			#endif
			#ifndef POI2D_SAMPLER_PAN_STOCHASTIC
			#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
			#endif
			#ifndef POI2D_SAMPLER_PANGRAD_STOCHASTIC
			#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
			#endif
			
			// When using, properties won't properly lock at optimize time; needs macro evaluation implemented
			// #define POI2D_SAMPLER_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_SAMPLER_PAN_STOCHASTIC_INLINED(tex, texSampler) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// #define POI2D_MAINTEX_SAMPLER_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Stochastic))
			// #define POI2D_MAINTEX_SAMPLER_PAN_STOCHASTIC_INLINED(tex) (POI2D_SAMPLER_PAN_STOCHASTIC(tex, _MainTex, poiUV(poiMesh.uv[tex##UV], tex##_ST), tex##Pan, tex##Stochastic))
			
			// Deliot, Heitz 2019 - Fast, but non-histogram-preserving (ends up looking a bit blurry and lower contrast)
			// https://eheitzresearch.wordpress.com/738-2/
			
			// Classic Magic Numbers fracsin
			#if !defined(_STOCHASTICMODE_NONE)
			float2 StochasticHash2D2D (float2 s)
			{
				return frac(sin(glsl_mod(float2(dot(s, float2(127.1,311.7)), dot(s, float2(269.5,183.3))), 3.14159)) * 43758.5453);
			}
			#endif
			
			#if defined(_STOCHASTICMODE_DELIOT_HEITZ)
			// UV Offsets and blend weights
			// UVBW[0...2].xy = UV Offsets
			// UVBW[0...2].z = Blend Weights
			float3x3 DeliotHeitzStochasticUVBW(float2 uv)
			{
				// UV transformed into triangular grid space with UV scaled by approximation of 2*sqrt(3)
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewUV = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticDeliotHeitzDensity);
				
				// Vertex IDs and barycentric coords
				float2 vxID = floor(skewUV);
				float3 bary = float3(frac(skewUV), 0);
				bary.z = 1.0 - bary.x - bary.y;
				
				float3x3 pos = float3x3(
				float3(vxID, 				bary.z),
				float3(vxID + float2(0, 1), bary.y),
				float3(vxID + float2(1, 0), bary.x)
				);
				
				float3x3 neg = float3x3(
				float3(vxID + float2(1, 1), 	 -bary.z),
				float3(vxID + float2(1, 0), 1.0 - bary.y),
				float3(vxID + float2(0, 1), 1.0 - bary.x)
				);
				
				return (bary.z > 0) ? pos : neg;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, float2 dx, float2 dy)
			{
				// UVBW[0...2].xy = UV Offsets
				// UVBW[0...2].z = Blend Weights
				float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
				
				//blend samples with calculated weights
				return 	mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) +
				mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
			}
			
			float4 DeliotHeitzSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv)
			{
				float2 dx = ddx(uv), dy = ddy(uv);
				return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
			}
			#endif // defined(_STOCHASTICMODE_DELIOT_HEITZ)
			
			#if defined(_STOCHASTICMODE_HEXTILE)
			// HexTiling: Slower, but histogram-preserving
			// SPDX-License-Idenfitier: MIT
			// Copyright (c) 2022 mmikk
			// https://github.com/mmikk/hextile-demo
			float2 HextileMakeCenUV(float2 vertex)
			{
				// 0.288675 ~= 1/(2*sqrt(3))
				const float2x2 stochasticInverseSkewedGrid = float2x2(1.0, 0.5, 0.0, 1.0/1.15470054);
				return mul(stochasticInverseSkewedGrid, vertex) * 0.288675;
			}
			
			float2x2 HextileLoadRot2x2(float2 idx, float rotStrength)
			{
				float angle = abs(idx.x * idx.y) + abs(idx.x + idx.y) + PI;
				
				// remap to +/-pi
				angle = glsl_mod(angle, 2 * PI);
				if(angle < 0)  angle += 2 * PI;
				if(angle > PI) angle -= 2 * PI;
				
				angle *= rotStrength;
				
				float cs = cos(angle), si = sin(angle);
				return float2x2(cs, -si, si, cs);
			}
			
			// UV Offsets and base blend weights
			// UVBWR[0...2].xy = UV Offsets
			// UVBWR[0...2].zw = rotation costh/sinth -> reconstruct rotation matrix with float2x2(UVBWR[n].z, -UVBWR[n].w, UVBWR[n].w, UVBWR[n].z)
			// UVBWR[3].xyz = Blend Weights (w unused) - needs luminance weighting
			float4x4 HextileUVBWR(float2 uv)
			{
				// Create Triangle Grid
				// Skew input space into simplex triangle grid (3.4641 ~= 2*sqrt(3))
				const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
				float2 skewedCoord = mul(stochasticSkewedGrid, uv * 3.4641 * _StochasticHexGridDensity);
				
				float2 baseId = float2(floor(skewedCoord));
				float3 temp = float3(frac(skewedCoord), 0);
				temp.z = 1 - temp.x - temp.y;
				
				float s = step(0.0, -temp.z);
				float s2 = 2 * s - 1;
				
				float3 weights = float3(-temp.z * s2, s - temp.y * s2, s - temp.x * s2);
				
				float2 vertex0 = baseId + float2(s, s);
				float2 vertex1 = baseId + float2(s, 1 - s);
				float2 vertex2 = baseId + float2(1 - s, s);
				
				float2 cen0 = HextileMakeCenUV(vertex0), cen1 = HextileMakeCenUV(vertex1), cen2 = HextileMakeCenUV(vertex2);
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = HextileLoadRot2x2(vertex0, _StochasticHexRotationStrength);
					rot1 = HextileLoadRot2x2(vertex1, _StochasticHexRotationStrength);
					rot2 = HextileLoadRot2x2(vertex2, _StochasticHexRotationStrength);
				}
				
				return float4x4(
				float4(mul(uv - cen0, rot0) + cen0 + StochasticHash2D2D(vertex0), rot0[0].x, -rot0[0].y),
				float4(mul(uv - cen1, rot1) + cen1 + StochasticHash2D2D(vertex1), rot1[0].x, -rot1[0].y),
				float4(mul(uv - cen2, rot2) + cen2 + StochasticHash2D2D(vertex2), rot2[0].x, -rot2[0].y),
				float4(weights, 0)
				);
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap, float2 dUVdx, float2 dUVdy)
			{
				// For some reason doing this instead of just calculating it directly prevents it from \
				// breaking after a certain number of textures use it. I don't understand why yet
				float4x4 UVBWR = HextileUVBWR(uv);
				
				// 2D Rotation Matrices for dUVdx/dy
				// Not sure if this constant folds during compiling when rot is locked at 0, so force it
				float2x2 rot0 = float2x2(1, 0, 0, 1), rot1 = float2x2(1, 0, 0, 1), rot2 = float2x2(1, 0, 0, 1);
				
				if(_StochasticHexRotationStrength > 0)
				{
					rot0 = float2x2(UVBWR[0].z, -UVBWR[0].w, UVBWR[0].w, UVBWR[0].z);
					rot1 = float2x2(UVBWR[1].z, -UVBWR[1].w, UVBWR[1].w, UVBWR[1].z);
					rot2 = float2x2(UVBWR[2].z, -UVBWR[2].w, UVBWR[2].w, UVBWR[2].z);
				}
				
				// Weights
				float3 W = UVBWR[3].xyz;
				
				// Sample texture
				// float3x4 c = float3x4(
				// 	tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0)),
				// 	tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1)),
				// 	tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2))
				// );
				
				float4 c0 = tex.SampleGrad(texSampler, UVBWR[0].xy, mul(dUVdx, rot0), mul(dUVdy, rot0));
				float4 c1 = tex.SampleGrad(texSampler, UVBWR[1].xy, mul(dUVdx, rot1), mul(dUVdy, rot1));
				float4 c2 = tex.SampleGrad(texSampler, UVBWR[2].xy, mul(dUVdx, rot2), mul(dUVdy, rot2));
				
				// Blend samples using luminance
				// This is technically incorrect for normal maps, but produces very similar
				// results to blending using normal map gradients (steepness)
				const float3 Lw = float3(0.299, 0.587, 0.114);
				float3 Dw = float3(dot(c0.xyz, Lw), dot(c1.xyz, Lw), dot(c2.xyz, Lw));
				
				Dw = lerp(1.0, Dw, _StochasticHexFallOffContrast);
				W = Dw * pow(W, _StochasticHexFallOffPower);
				// In the original hextiling there's a Gain3 step here, but it seems to slow things down \
				// and cause the UVs to break, so I've omitted it. Looks fine without
				
				W /= (W.x + W.y + W.z);
				return W.x * c0 + W.y * c1 + W.z * c2;
			}
			
			float4 HextileSampleTexture(Texture2D tex, SamplerState texSampler, float2 uv, bool isNormalMap)
			{
				return HextileSampleTexture(tex, texSampler, uv, isNormalMap, ddx(uv), ddy(uv));
			}
			#endif // defined(_STOCHASTICMODE_HEXTILE)
			
			void applyAlphaOptions(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiMods poiMods)
			{
				poiFragData.alpha = saturate(poiFragData.alpha + _AlphaMod);
				
				if (_AlphaGlobalMask > 0)
				{
					poiFragData.alpha = maskBlend(poiFragData.alpha, poiMods.globalMask[_AlphaGlobalMask-1], _AlphaGlobalMaskBlendType);
				}
				
				//ifex _AlphaDistanceFade==0 && isNotAnimated(_AlphaDistanceFade)
				if (_AlphaDistanceFade)
				{
					float3 position = _AlphaDistanceFadeType ? poiMesh.worldPos : poiMesh.objectPosition;
					float distanceFadeMultiplier = lerp(_AlphaDistanceFadeMinAlpha, _AlphaDistanceFadeMaxAlpha, smoothstep(_AlphaDistanceFadeMin, _AlphaDistanceFadeMax, distance(position, poiCam.worldPos)));
					if(_AlphaDistanceFadeGlobalMask > 0)
					{
						distanceFadeMultiplier = lerp(1, distanceFadeMultiplier, poiMods.globalMask[_AlphaDistanceFadeGlobalMask-1]);
					}
					poiFragData.alpha *= distanceFadeMultiplier;
				}
				//endex
				
				//ifex _AlphaFresnel==0 && isNotAnimated(_AlphaFresnel)
				if (_AlphaFresnel)
				{
					float holoRim = saturate(1 - smoothstep(min(_AlphaFresnelSharpness, _AlphaFresnelWidth), _AlphaFresnelWidth, (poiCam.vDotN)));
					holoRim = abs(lerp(1, holoRim, _AlphaFresnelAlpha));
					holoRim = _AlphaFresnelInvert ? 1 - holoRim : holoRim;
					if(_AlphaFresnelGlobalMask > 0)
					{
						holoRim = lerp(1, holoRim, poiMods.globalMask[_AlphaFresnelGlobalMask-1]);
					}
					poiFragData.alpha *= holoRim;
				}
				//endex
				
				//ifex _AlphaAngular==0 && isNotAnimated(_AlphaAngular)
				if (_AlphaAngular)
				{
					half cameraAngleMin = _CameraAngleMin / 180;
					half cameraAngleMax = _CameraAngleMax / 180;
					half modelAngleMin = _ModelAngleMin / 180;
					half modelAngleMax = _ModelAngleMax / 180;
					float3 pos = _AngleCompareTo == 0 ? poiMesh.objectPosition : poiMesh.worldPos;
					half3 cameraToModelDirection = normalize(pos - getCameraPosition());
					half3 modelForwardDirection = normalize(mul(unity_ObjectToWorld, normalize(_AngleForwardDirection.rgb)));
					half cameraLookAtModel = remapClamped(cameraAngleMax, cameraAngleMin, .5 * dot(cameraToModelDirection, getCameraForward()) + .5);
					half modelLookAtCamera = remapClamped(modelAngleMax, modelAngleMin, .5 * dot(-cameraToModelDirection, modelForwardDirection) + .5);
					float angularAlphaMod = 1;
					if (_AngleType == 0)
					{
						angularAlphaMod = max(cameraLookAtModel, _AngleMinAlpha);
					}
					else if (_AngleType == 1)
					{
						angularAlphaMod = max(modelLookAtCamera, _AngleMinAlpha);
					}
					else if (_AngleType == 2)
					{
						angularAlphaMod = max(cameraLookAtModel * modelLookAtCamera, _AngleMinAlpha);
					}
					if(_AlphaAngularGlobalMask > 0)
					{
						angularAlphaMod = lerp(1, angularAlphaMod, poiMods.globalMask[_AlphaAngularGlobalMask-1]);
					}
					poiFragData.alpha *= angularAlphaMod;
				}
				//endex
				
				//ifex _AlphaAudioLinkEnabled==0 && isNotAnimated(_AlphaAudioLinkEnabled)
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && _AlphaAudioLinkEnabled)
				{
					poiFragData.alpha = saturate(poiFragData.alpha + lerp(_AlphaAudioLinkAddRange.x, _AlphaAudioLinkAddRange.y, poiMods.audioLink[_AlphaAudioLinkAddBand]));
				}
				#endif
				//endex
				
			}
			
			//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
			inline half Dither8x8Bayer(int x, int y)
			{
				// Premultiplied by 1/64
				const half dither[ 64 ] = {
					0.015625, 0.765625, 0.203125, 0.953125, 0.06250, 0.81250, 0.25000, 1.00000,
					0.515625, 0.265625, 0.703125, 0.453125, 0.56250, 0.31250, 0.75000, 0.50000,
					0.140625, 0.890625, 0.078125, 0.828125, 0.18750, 0.93750, 0.12500, 0.87500,
					0.640625, 0.390625, 0.578125, 0.328125, 0.68750, 0.43750, 0.62500, 0.37500,
					0.046875, 0.796875, 0.234375, 0.984375, 0.03125, 0.78125, 0.21875, 0.96875,
					0.546875, 0.296875, 0.734375, 0.484375, 0.53125, 0.28125, 0.71875, 0.46875,
					0.171875, 0.921875, 0.109375, 0.859375, 0.15625, 0.90625, 0.09375, 0.84375,
					0.671875, 0.421875, 0.609375, 0.359375, 0.65625, 0.40625, 0.59375, 0.34375
				};
				int r = y * 8 + x;
				return dither[r];
			}
			
			half calcDither(half2 grabPos)
			{
				return Dither8x8Bayer(glsl_mod(grabPos.x, 8), glsl_mod(grabPos.y, 8));
			}
			
			void applyDithering(inout PoiFragData poiFragData, in PoiCam poiCam)
			{
				if (_AlphaDithering)
				{
					float dither = calcDither(poiCam.screenUV.xy) - _AlphaDitherBias;
					poiFragData.alpha = saturate(poiFragData.alpha - (dither * (1 - poiFragData.alpha) * _AlphaDitherGradient));
				}
			}
			//endex
			
			//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
			void ApplyAlphaToCoverage(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				// Force Model Opacity to 1 if desired
				UNITY_BRANCH
				if (_Mode == 1)
				{
					UNITY_BRANCH
					if (_AlphaSharpenedA2C && _AlphaToCoverage)
					{
						// rescale alpha by mip level
						poiFragData.alpha *= 1 + max(0, CalcMipLevel(poiMesh.uv[0] * _MainTex_TexelSize.zw)) * _AlphaMipScale;
						// rescale alpha by partial derivative
						poiFragData.alpha = (poiFragData.alpha - _Cutoff) / max(fwidth(poiFragData.alpha), 0.0001) + _Cutoff;
						poiFragData.alpha = saturate(poiFragData.alpha);
					}
				}
			}
			//endex
			
			void calculateGlobalThemes(inout PoiMods poiMods)
			{
				// Theme colors are defined as HDR; convert to SDR and do the HSV adjustment, then re-apply exposure
				float4 themeColorExposures = 0;
				float4 themeColor0, themeColor1, themeColor2, themeColor3 = 0;
				
				DecomposeHDRColor(_GlobalThemeColor0.rgb, themeColor0.rgb, themeColorExposures.x);
				DecomposeHDRColor(_GlobalThemeColor1.rgb, themeColor1.rgb, themeColorExposures.y);
				DecomposeHDRColor(_GlobalThemeColor2.rgb, themeColor2.rgb, themeColorExposures.z);
				DecomposeHDRColor(_GlobalThemeColor3.rgb, themeColor3.rgb, themeColorExposures.w);
				
				poiMods.globalColorTheme[0] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor0.rgb, frac(_GlobalThemeHue0 + _GlobalThemeHueSpeed0 * _Time.x), _GlobalThemeSaturation0, _GlobalThemeValue0), themeColorExposures.x), _GlobalThemeColor0.a);
				poiMods.globalColorTheme[1] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor1.rgb, frac(_GlobalThemeHue1 + _GlobalThemeHueSpeed1 * _Time.x), _GlobalThemeSaturation1, _GlobalThemeValue1), themeColorExposures.y), _GlobalThemeColor1.a);
				poiMods.globalColorTheme[2] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor2.rgb, frac(_GlobalThemeHue2 + _GlobalThemeHueSpeed2 * _Time.x), _GlobalThemeSaturation2, _GlobalThemeValue2), themeColorExposures.z), _GlobalThemeColor2.a);
				poiMods.globalColorTheme[3] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor3.rgb, frac(_GlobalThemeHue3 + _GlobalThemeHueSpeed3 * _Time.x), _GlobalThemeSaturation3, _GlobalThemeValue3), themeColorExposures.w), _GlobalThemeColor3.a);
			}
			
			//ifex _GlobalMaskTexturesEnable==0
			#ifdef POI_GLOBALMASK_TEXTURES
			void ApplyGlobalMaskTextures(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#if defined(PROP_GLOBALMASKTEXTURE0) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol0 = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0_ST), _GlobalMaskTexture0Pan);
				if (_GlobalMaskTexture0Split)
				{
					poiMods.globalMask[0] = gmcol0.r;
					poiMods.globalMask[1] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_G), _GlobalMaskTexture0SplitPan_G).g;
					poiMods.globalMask[2] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_B), _GlobalMaskTexture0SplitPan_B).b;
					poiMods.globalMask[3] = POI2D_SAMPLER_PAN(_GlobalMaskTexture0, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture0UV], _GlobalMaskTexture0SplitTilingOffset_A), _GlobalMaskTexture0SplitPan_A).a;
				} else {
					poiMods.globalMask[0] = gmcol0[0];
					poiMods.globalMask[1] = gmcol0[1];
					poiMods.globalMask[2] = gmcol0[2];
					poiMods.globalMask[3] = gmcol0[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol1 = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1_ST), _GlobalMaskTexture1Pan);
				if (_GlobalMaskTexture1Split)
				{
					poiMods.globalMask[4] = gmcol1.r;
					poiMods.globalMask[5] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_G), _GlobalMaskTexture1SplitPan_G).g;
					poiMods.globalMask[6] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_B), _GlobalMaskTexture1SplitPan_B).b;
					poiMods.globalMask[7] = POI2D_SAMPLER_PAN(_GlobalMaskTexture1, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture1UV], _GlobalMaskTexture1SplitTilingOffset_A), _GlobalMaskTexture1SplitPan_A).a;
				} else {
					poiMods.globalMask[4] = gmcol1[0];
					poiMods.globalMask[5] = gmcol1[1];
					poiMods.globalMask[6] = gmcol1[2];
					poiMods.globalMask[7] = gmcol1[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol2 = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2_ST), _GlobalMaskTexture2Pan);
				if (_GlobalMaskTexture2Split)
				{
					poiMods.globalMask[8] = gmcol2.r;
					poiMods.globalMask[9] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_G), _GlobalMaskTexture2SplitPan_G).g;
					poiMods.globalMask[10] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_B), _GlobalMaskTexture2SplitPan_B).b;
					poiMods.globalMask[11] = POI2D_SAMPLER_PAN(_GlobalMaskTexture2, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture2UV], _GlobalMaskTexture2SplitTilingOffset_A), _GlobalMaskTexture2SplitPan_A).a;
				} else {
					poiMods.globalMask[8] = gmcol2[0];
					poiMods.globalMask[9] = gmcol2[1];
					poiMods.globalMask[10] = gmcol2[2];
					poiMods.globalMask[11] = gmcol2[3];
				}
				#endif
				
				#if defined(PROP_GLOBALMASKTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				float4 gmcol3 = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3_ST), _GlobalMaskTexture3Pan);
				if (_GlobalMaskTexture3Split)
				{
					poiMods.globalMask[12] = gmcol3.r;
					poiMods.globalMask[13] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_G), _GlobalMaskTexture3SplitPan_G).g;
					poiMods.globalMask[14] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_B), _GlobalMaskTexture3SplitPan_B).b;
					poiMods.globalMask[15] = POI2D_SAMPLER_PAN(_GlobalMaskTexture3, _MainTex, poiUV(poiMesh.uv[_GlobalMaskTexture3UV], _GlobalMaskTexture3SplitTilingOffset_A), _GlobalMaskTexture3SplitPan_A).a;
				} else {
					poiMods.globalMask[12] = gmcol3[0];
					poiMods.globalMask[13] = gmcol3[1];
					poiMods.globalMask[14] = gmcol3[2];
					poiMods.globalMask[15] = gmcol3[3];
				}
				#endif
			}
			#endif
			//endex
			//ifex _GlobalMaskOptionsEnable==0
			void ApplyGlobalMaskOptions(inout PoiMods poiMods)
			{
				//ifex _GlobalMaskOptionsType!=0
				if (_GlobalMaskOptionsType == 0)
				{
					poiMods.globalMask[0]  = saturate(poiMods.globalMask[0]  + _GlobalMaskSlider_0);
					poiMods.globalMask[1]  = saturate(poiMods.globalMask[1]  + _GlobalMaskSlider_1);
					poiMods.globalMask[2]  = saturate(poiMods.globalMask[2]  + _GlobalMaskSlider_2);
					poiMods.globalMask[3]  = saturate(poiMods.globalMask[3]  + _GlobalMaskSlider_3);
					poiMods.globalMask[4]  = saturate(poiMods.globalMask[4]  + _GlobalMaskSlider_4);
					poiMods.globalMask[5]  = saturate(poiMods.globalMask[5]  + _GlobalMaskSlider_5);
					poiMods.globalMask[6]  = saturate(poiMods.globalMask[6]  + _GlobalMaskSlider_6);
					poiMods.globalMask[7]  = saturate(poiMods.globalMask[7]  + _GlobalMaskSlider_7);
					poiMods.globalMask[8]  = saturate(poiMods.globalMask[8]  + _GlobalMaskSlider_8);
					poiMods.globalMask[9]  = saturate(poiMods.globalMask[9]  + _GlobalMaskSlider_9);
					poiMods.globalMask[10] = saturate(poiMods.globalMask[10] + _GlobalMaskSlider_10);
					poiMods.globalMask[11] = saturate(poiMods.globalMask[11] + _GlobalMaskSlider_11);
					poiMods.globalMask[12] = saturate(poiMods.globalMask[12] + _GlobalMaskSlider_12);
					poiMods.globalMask[13] = saturate(poiMods.globalMask[13] + _GlobalMaskSlider_13);
					poiMods.globalMask[14] = saturate(poiMods.globalMask[14] + _GlobalMaskSlider_14);
					poiMods.globalMask[15] = saturate(poiMods.globalMask[15] + _GlobalMaskSlider_15);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=1
				if (_GlobalMaskOptionsType == 1)
				{
					poiMods.globalMask[0]  = lerp(_GlobalMaskMinMaxSlider_0.x,  _GlobalMaskMinMaxSlider_0.y,  poiMods.globalMask[0]);
					poiMods.globalMask[1]  = lerp(_GlobalMaskMinMaxSlider_1.x,  _GlobalMaskMinMaxSlider_1.y,  poiMods.globalMask[1]);
					poiMods.globalMask[2]  = lerp(_GlobalMaskMinMaxSlider_2.x,  _GlobalMaskMinMaxSlider_2.y,  poiMods.globalMask[2]);
					poiMods.globalMask[3]  = lerp(_GlobalMaskMinMaxSlider_3.x,  _GlobalMaskMinMaxSlider_3.y,  poiMods.globalMask[3]);
					poiMods.globalMask[4]  = lerp(_GlobalMaskMinMaxSlider_4.x,  _GlobalMaskMinMaxSlider_4.y,  poiMods.globalMask[4]);
					poiMods.globalMask[5]  = lerp(_GlobalMaskMinMaxSlider_5.x,  _GlobalMaskMinMaxSlider_5.y,  poiMods.globalMask[5]);
					poiMods.globalMask[6]  = lerp(_GlobalMaskMinMaxSlider_6.x,  _GlobalMaskMinMaxSlider_6.y,  poiMods.globalMask[6]);
					poiMods.globalMask[7]  = lerp(_GlobalMaskMinMaxSlider_7.x,  _GlobalMaskMinMaxSlider_7.y,  poiMods.globalMask[7]);
					poiMods.globalMask[8]  = lerp(_GlobalMaskMinMaxSlider_8.x,  _GlobalMaskMinMaxSlider_8.y,  poiMods.globalMask[8]);
					poiMods.globalMask[9]  = lerp(_GlobalMaskMinMaxSlider_9.x,  _GlobalMaskMinMaxSlider_9.y,  poiMods.globalMask[9]);
					poiMods.globalMask[10] = lerp(_GlobalMaskMinMaxSlider_10.x, _GlobalMaskMinMaxSlider_10.y, poiMods.globalMask[10]);
					poiMods.globalMask[11] = lerp(_GlobalMaskMinMaxSlider_11.x, _GlobalMaskMinMaxSlider_11.y, poiMods.globalMask[11]);
					poiMods.globalMask[12] = lerp(_GlobalMaskMinMaxSlider_12.x, _GlobalMaskMinMaxSlider_12.y, poiMods.globalMask[12]);
					poiMods.globalMask[13] = lerp(_GlobalMaskMinMaxSlider_13.x, _GlobalMaskMinMaxSlider_13.y, poiMods.globalMask[13]);
					poiMods.globalMask[14] = lerp(_GlobalMaskMinMaxSlider_14.x, _GlobalMaskMinMaxSlider_14.y, poiMods.globalMask[14]);
					poiMods.globalMask[15] = lerp(_GlobalMaskMinMaxSlider_15.x, _GlobalMaskMinMaxSlider_15.y, poiMods.globalMask[15]);
				}
				//endex
				//ifex _GlobalMaskOptionsType!=2
				if (_GlobalMaskOptionsType == 2)
				{
					if (_GlobalMaskToggleOn_0)  poiMods.globalMask[0]  = 1;
					if (_GlobalMaskToggleOn_1)  poiMods.globalMask[1]  = 1;
					if (_GlobalMaskToggleOn_2)  poiMods.globalMask[2]  = 1;
					if (_GlobalMaskToggleOn_3)  poiMods.globalMask[3]  = 1;
					if (_GlobalMaskToggleOn_4)  poiMods.globalMask[4]  = 1;
					if (_GlobalMaskToggleOn_5)  poiMods.globalMask[5]  = 1;
					if (_GlobalMaskToggleOn_6)  poiMods.globalMask[6]  = 1;
					if (_GlobalMaskToggleOn_7)  poiMods.globalMask[7]  = 1;
					if (_GlobalMaskToggleOn_8)  poiMods.globalMask[8]  = 1;
					if (_GlobalMaskToggleOn_9)  poiMods.globalMask[9]  = 1;
					if (_GlobalMaskToggleOn_10) poiMods.globalMask[10] = 1;
					if (_GlobalMaskToggleOn_11) poiMods.globalMask[11] = 1;
					if (_GlobalMaskToggleOn_12) poiMods.globalMask[12] = 1;
					if (_GlobalMaskToggleOn_13) poiMods.globalMask[13] = 1;
					if (_GlobalMaskToggleOn_14) poiMods.globalMask[14] = 1;
					if (_GlobalMaskToggleOn_15) poiMods.globalMask[15] = 1;
					
					poiMods.globalMask[0]  *= (1-_GlobalMaskToggleOff_0);
					poiMods.globalMask[1]  *= (1-_GlobalMaskToggleOff_1);
					poiMods.globalMask[2]  *= (1-_GlobalMaskToggleOff_2);
					poiMods.globalMask[3]  *= (1-_GlobalMaskToggleOff_3);
					poiMods.globalMask[4]  *= (1-_GlobalMaskToggleOff_4);
					poiMods.globalMask[5]  *= (1-_GlobalMaskToggleOff_5);
					poiMods.globalMask[6]  *= (1-_GlobalMaskToggleOff_6);
					poiMods.globalMask[7]  *= (1-_GlobalMaskToggleOff_7);
					poiMods.globalMask[8]  *= (1-_GlobalMaskToggleOff_8);
					poiMods.globalMask[9]  *= (1-_GlobalMaskToggleOff_9);
					poiMods.globalMask[10] *= (1-_GlobalMaskToggleOff_10);
					poiMods.globalMask[11] *= (1-_GlobalMaskToggleOff_11);
					poiMods.globalMask[12] *= (1-_GlobalMaskToggleOff_12);
					poiMods.globalMask[13] *= (1-_GlobalMaskToggleOff_13);
					poiMods.globalMask[14] *= (1-_GlobalMaskToggleOff_14);
					poiMods.globalMask[15] *= (1-_GlobalMaskToggleOff_15);
				}
				//endex
			}
			//endex
			
			float customDistanceBlend(float base, float blend, float blendType)
			{
				switch(blendType)
				{
					case 0: return blendNormal(base, blend); break;
					case 2: return blendMultiply(base, blend); break;
					default: return 0; break;
				}
			}
			
			void ApplyGlobalMaskModifiers(in PoiMesh poiMesh, inout PoiMods poiMods, in PoiCam poiCam)
			{
				//ifex _GlobalMaskModifiersBackfaceEnable==0
				if(_GlobalMaskModifiersBackfaceEnable)
				{
					float facingMode = saturate(poiMesh.isFrontFace) + 1;
					// _GlobalMaskBackface is 0 for ignore, 1 for back only, 2 for front only
					poiMods.globalMask[0]  *= _GlobalMaskBackface_0  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskBackface_1  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskBackface_2  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskBackface_3  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskBackface_4  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskBackface_5  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskBackface_6  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskBackface_7  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskBackface_8  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskBackface_9  == 0 ? 1 : (facingMode == (_GlobalMaskBackface_9 ));
					poiMods.globalMask[10] *= _GlobalMaskBackface_10 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_10));
					poiMods.globalMask[11] *= _GlobalMaskBackface_11 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_11));
					poiMods.globalMask[12] *= _GlobalMaskBackface_12 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_12));
					poiMods.globalMask[13] *= _GlobalMaskBackface_13 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_13));
					poiMods.globalMask[14] *= _GlobalMaskBackface_14 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_14));
					poiMods.globalMask[15] *= _GlobalMaskBackface_15 == 0 ? 1 : (facingMode == (_GlobalMaskBackface_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersMirrorEnable==0
				if(_GlobalMaskModifiersMirrorEnable)
				{
					float mirrorMode = 0;
					if (_GlobalMaskMirrorVisibilityMode == 1) // VRC
					mirrorMode = VRCMirrorMode() > 0;
					else // Generic (CVR, etc)
					mirrorMode = IsInMirror();
					
					mirrorMode += 1;
					// _GlobalMaskMirror is 0 for ignore, 1 for outside mirror only, 2 for in mirror only
					poiMods.globalMask[0]  *= _GlobalMaskMirror_0  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskMirror_1  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskMirror_2  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskMirror_3  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskMirror_4  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskMirror_5  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskMirror_6  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskMirror_7  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskMirror_8  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskMirror_9  == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_9 ));
					poiMods.globalMask[10] *= _GlobalMaskMirror_10 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_10));
					poiMods.globalMask[11] *= _GlobalMaskMirror_11 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_11));
					poiMods.globalMask[12] *= _GlobalMaskMirror_12 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_12));
					poiMods.globalMask[13] *= _GlobalMaskMirror_13 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_13));
					poiMods.globalMask[14] *= _GlobalMaskMirror_14 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_14));
					poiMods.globalMask[15] *= _GlobalMaskMirror_15 == 0 ? 1 : (mirrorMode == (_GlobalMaskMirror_15));
				}
				//endex
				
				//ifex _GlobalMaskModifiersCameraEnable==0
				if(_GlobalMaskModifiersCameraEnable)
				{
					float isCamera = VRCCameraMode() > 0;
					isCamera += 1;
					// _GlobalMaskCamera is 0 for ignore, 1 for outside camera only, 2 for in camera only
					poiMods.globalMask[0]  *= _GlobalMaskCamera_0  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_0 ));
					poiMods.globalMask[1]  *= _GlobalMaskCamera_1  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_1 ));
					poiMods.globalMask[2]  *= _GlobalMaskCamera_2  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_2 ));
					poiMods.globalMask[3]  *= _GlobalMaskCamera_3  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_3 ));
					poiMods.globalMask[4]  *= _GlobalMaskCamera_4  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_4 ));
					poiMods.globalMask[5]  *= _GlobalMaskCamera_5  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_5 ));
					poiMods.globalMask[6]  *= _GlobalMaskCamera_6  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_6 ));
					poiMods.globalMask[7]  *= _GlobalMaskCamera_7  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_7 ));
					poiMods.globalMask[8]  *= _GlobalMaskCamera_8  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_8 ));
					poiMods.globalMask[9]  *= _GlobalMaskCamera_9  == 0 ? 1 : (isCamera == (_GlobalMaskCamera_9 ));
					poiMods.globalMask[10] *= _GlobalMaskCamera_10 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_10));
					poiMods.globalMask[11] *= _GlobalMaskCamera_11 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_11));
					poiMods.globalMask[12] *= _GlobalMaskCamera_12 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_12));
					poiMods.globalMask[13] *= _GlobalMaskCamera_13 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_13));
					poiMods.globalMask[14] *= _GlobalMaskCamera_14 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_14));
					poiMods.globalMask[15] *= _GlobalMaskCamera_15 == 0 ? 1 : (isCamera == (_GlobalMaskCamera_15));
				}
				//endex
				//ifex _GlobalMaskModifiersDistanceEnable==0
				if (_GlobalMaskModifiersDistanceEnable)
				{
					//ifex _GlobalMaskDistanceEnable_0==0
					if (_GlobalMaskDistanceEnable_0)
					{
						float3 position = _GlobalMaskDistanceType_0 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_0, _GlobalMaskDistanceMaxAlpha_0, smoothstep(_GlobalMaskDistanceMin_0, _GlobalMaskDistanceMax_0, distance(position, poiCam.worldPos)));
						poiMods.globalMask[0] = saturate(customDistanceBlend(poiMods.globalMask[0], val, _GlobalMaskDistanceBlendType_0));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_1==0
					if (_GlobalMaskDistanceEnable_1)
					{
						float3 position = _GlobalMaskDistanceType_1 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_1, _GlobalMaskDistanceMaxAlpha_1, smoothstep(_GlobalMaskDistanceMin_1, _GlobalMaskDistanceMax_1, distance(position, poiCam.worldPos)));
						poiMods.globalMask[1] = saturate(customDistanceBlend(poiMods.globalMask[1], val, _GlobalMaskDistanceBlendType_1));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_2==0
					if (_GlobalMaskDistanceEnable_2)
					{
						float3 position = _GlobalMaskDistanceType_2 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_2, _GlobalMaskDistanceMaxAlpha_2, smoothstep(_GlobalMaskDistanceMin_2, _GlobalMaskDistanceMax_2, distance(position, poiCam.worldPos)));
						poiMods.globalMask[2] = saturate(customDistanceBlend(poiMods.globalMask[2], val, _GlobalMaskDistanceBlendType_2));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_3==0
					if (_GlobalMaskDistanceEnable_3)
					{
						float3 position = _GlobalMaskDistanceType_3 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_3, _GlobalMaskDistanceMaxAlpha_3, smoothstep(_GlobalMaskDistanceMin_3, _GlobalMaskDistanceMax_3, distance(position, poiCam.worldPos)));
						poiMods.globalMask[3] = saturate(customDistanceBlend(poiMods.globalMask[3], val, _GlobalMaskDistanceBlendType_3));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_4==0
					if (_GlobalMaskDistanceEnable_4)
					{
						float3 position = _GlobalMaskDistanceType_4 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_4, _GlobalMaskDistanceMaxAlpha_4, smoothstep(_GlobalMaskDistanceMin_4, _GlobalMaskDistanceMax_4, distance(position, poiCam.worldPos)));
						poiMods.globalMask[4] = saturate(customDistanceBlend(poiMods.globalMask[4], val, _GlobalMaskDistanceBlendType_4));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_5==0
					if (_GlobalMaskDistanceEnable_5)
					{
						float3 position = _GlobalMaskDistanceType_5 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_5, _GlobalMaskDistanceMaxAlpha_5, smoothstep(_GlobalMaskDistanceMin_5, _GlobalMaskDistanceMax_5, distance(position, poiCam.worldPos)));
						poiMods.globalMask[5] = saturate(customDistanceBlend(poiMods.globalMask[5], val, _GlobalMaskDistanceBlendType_5));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_6==0
					if (_GlobalMaskDistanceEnable_6)
					{
						float3 position = _GlobalMaskDistanceType_6 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_6, _GlobalMaskDistanceMaxAlpha_6, smoothstep(_GlobalMaskDistanceMin_6, _GlobalMaskDistanceMax_6, distance(position, poiCam.worldPos)));
						poiMods.globalMask[6] = saturate(customDistanceBlend(poiMods.globalMask[6], val, _GlobalMaskDistanceBlendType_6));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_7==0
					if (_GlobalMaskDistanceEnable_7)
					{
						float3 position = _GlobalMaskDistanceType_7 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_7, _GlobalMaskDistanceMaxAlpha_7, smoothstep(_GlobalMaskDistanceMin_7, _GlobalMaskDistanceMax_7, distance(position, poiCam.worldPos)));
						poiMods.globalMask[7] = saturate(customDistanceBlend(poiMods.globalMask[7], val, _GlobalMaskDistanceBlendType_7));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_8==0
					if (_GlobalMaskDistanceEnable_8)
					{
						float3 position = _GlobalMaskDistanceType_8 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_8, _GlobalMaskDistanceMaxAlpha_8, smoothstep(_GlobalMaskDistanceMin_8, _GlobalMaskDistanceMax_8, distance(position, poiCam.worldPos)));
						poiMods.globalMask[8] = saturate(customDistanceBlend(poiMods.globalMask[8], val, _GlobalMaskDistanceBlendType_8));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_9==0
					if (_GlobalMaskDistanceEnable_9)
					{
						float3 position = _GlobalMaskDistanceType_9 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_9, _GlobalMaskDistanceMaxAlpha_9, smoothstep(_GlobalMaskDistanceMin_9, _GlobalMaskDistanceMax_9, distance(position, poiCam.worldPos)));
						poiMods.globalMask[9] = saturate(customDistanceBlend(poiMods.globalMask[9], val, _GlobalMaskDistanceBlendType_9));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_10==0
					if (_GlobalMaskDistanceEnable_10)
					{
						float3 position = _GlobalMaskDistanceType_10 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_10, _GlobalMaskDistanceMaxAlpha_10, smoothstep(_GlobalMaskDistanceMin_10, _GlobalMaskDistanceMax_10, distance(position, poiCam.worldPos)));
						poiMods.globalMask[10] = saturate(customDistanceBlend(poiMods.globalMask[10], val, _GlobalMaskDistanceBlendType_10));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_11==0
					if (_GlobalMaskDistanceEnable_11)
					{
						float3 position = _GlobalMaskDistanceType_11 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_11, _GlobalMaskDistanceMaxAlpha_11, smoothstep(_GlobalMaskDistanceMin_11, _GlobalMaskDistanceMax_11, distance(position, poiCam.worldPos)));
						poiMods.globalMask[11] = saturate(customDistanceBlend(poiMods.globalMask[11], val, _GlobalMaskDistanceBlendType_11));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_12==0
					if (_GlobalMaskDistanceEnable_12)
					{
						float3 position = _GlobalMaskDistanceType_12 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_12, _GlobalMaskDistanceMaxAlpha_12, smoothstep(_GlobalMaskDistanceMin_12, _GlobalMaskDistanceMax_12, distance(position, poiCam.worldPos)));
						poiMods.globalMask[12] = saturate(customDistanceBlend(poiMods.globalMask[12], val, _GlobalMaskDistanceBlendType_12));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_13==0
					if (_GlobalMaskDistanceEnable_13)
					{
						float3 position = _GlobalMaskDistanceType_13 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_13, _GlobalMaskDistanceMaxAlpha_13, smoothstep(_GlobalMaskDistanceMin_13, _GlobalMaskDistanceMax_13, distance(position, poiCam.worldPos)));
						poiMods.globalMask[13] = saturate(customDistanceBlend(poiMods.globalMask[13], val, _GlobalMaskDistanceBlendType_13));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_14==0
					if (_GlobalMaskDistanceEnable_14)
					{
						float3 position = _GlobalMaskDistanceType_14 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_14, _GlobalMaskDistanceMaxAlpha_14, smoothstep(_GlobalMaskDistanceMin_14, _GlobalMaskDistanceMax_14, distance(position, poiCam.worldPos)));
						poiMods.globalMask[14] = saturate(customDistanceBlend(poiMods.globalMask[14], val, _GlobalMaskDistanceBlendType_14));
					}
					//endex
					//ifex _GlobalMaskDistanceEnable_15==0
					if (_GlobalMaskDistanceEnable_15)
					{
						float3 position = _GlobalMaskDistanceType_15 ? poiMesh.worldPos : poiMesh.objectPosition;
						float val = lerp(_GlobalMaskDistanceMinAlpha_15, _GlobalMaskDistanceMaxAlpha_15, smoothstep(_GlobalMaskDistanceMin_15, _GlobalMaskDistanceMax_15, distance(position, poiCam.worldPos)));
						poiMods.globalMask[15] = saturate(customDistanceBlend(poiMods.globalMask[15], val, _GlobalMaskDistanceBlendType_15));
					}
					//endex
				}
				//endex
			}
			
			//ifex _EnableUDIMDiscardOptions==0
			#ifdef POI_UDIMDISCARD
			void applyUDIMDiscard(in VertexOut i)
			{
				if(_UDIMDiscardMode == 1) // Don't run if in vertex mode
				{
					float2 udim = floor(vertexUV(i, _UDIMDiscardUV));
					
					float isDiscarded = 0;
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					isDiscarded += (udim.y >= 0 && udim.y < 1) * dot(float4(_UDIMDiscardRow0_0, _UDIMDiscardRow0_1, _UDIMDiscardRow0_2, _UDIMDiscardRow0_3), xMask);
					isDiscarded += (udim.y >= 1 && udim.y < 2) * dot(float4(_UDIMDiscardRow1_0, _UDIMDiscardRow1_1, _UDIMDiscardRow1_2, _UDIMDiscardRow1_3), xMask);
					isDiscarded += (udim.y >= 2 && udim.y < 3) * dot(float4(_UDIMDiscardRow2_0, _UDIMDiscardRow2_1, _UDIMDiscardRow2_2, _UDIMDiscardRow2_3), xMask);
					isDiscarded += (udim.y >= 3 && udim.y < 4) * dot(float4(_UDIMDiscardRow3_0, _UDIMDiscardRow3_1, _UDIMDiscardRow3_2, _UDIMDiscardRow3_3), xMask);
					
					isDiscarded *= any(float4(udim.y >= 0, udim.y < 4, udim.x >= 0, udim.x < 4)); // never discard outside 4x4 grid in pos coords
					
					const float threshold = 0.001;
					clip(threshold - isDiscarded); // Clip if discarded
				}
				
				return;
			}
			#endif
			//endex
			
			float2 calculatePolarCoordinate(in PoiMesh poiMesh)
			{
				float2 delta = poiMesh.uv[_PolarUV] - _PolarCenter;
				float radius = length(delta) * 2 * _PolarRadialScale;
				float angle = atan2(delta.x, delta.y);
				float phi = angle / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				angle = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				angle *= _PolarLengthScale;
				
				return float2(radius, angle + distance(poiMesh.uv[_PolarUV], _PolarCenter) * _PolarSpiralPower);
			}
			
			float2 MonoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(1.0, 1.0 / UNITY_PI);
				sphereCoords = float2(1.0, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).zw;
			}
			
			float2 StereoPanoProjection(float3 coords)
			{
				float3 normalizedCoords = normalize(coords);
				float latitude = acos(normalizedCoords.y);
				float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
				float phi = longitude / (UNITY_PI * 2.0);
				float phi_frac = frac(phi);
				longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
				longitude *= 2;
				float2 sphereCoords = float2(longitude, latitude) * float2(0.5, 1.0 / UNITY_PI);
				sphereCoords = float2(0.5, 1.0) - sphereCoords;
				return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).zw;
			}
			
			float2 calculateWorldUV(in PoiMesh poiMesh)
			{
				return float2(_UVModWorldPos0 != 3 ? poiMesh.worldPos[ _UVModWorldPos0] : 0.0f, _UVModWorldPos1 != 3 ? poiMesh.worldPos[_UVModWorldPos1] : 0.0f);
			}
			
			float2 calculatelocalUV(in PoiMesh poiMesh)
			{
				float localUVs[8];
				localUVs[0] = poiMesh.localPos.x;
				localUVs[1] = poiMesh.localPos.y;
				localUVs[2] = poiMesh.localPos.z;
				localUVs[3] = 0;
				localUVs[4] = poiMesh.vertexColor.r;
				localUVs[5] = poiMesh.vertexColor.g;
				localUVs[6] = poiMesh.vertexColor.b;
				localUVs[7] = poiMesh.vertexColor.a;
				
				return float2(localUVs[_UVModLocalPos0],localUVs[_UVModLocalPos1]);
			}
			
			float2 calculatePanosphereUV(in PoiMesh poiMesh)
			{
				float3 viewDirection = normalize(lerp(getCameraPosition().xyz, _WorldSpaceCameraPos.xyz, _PanoUseBothEyes) - poiMesh.worldPos.xyz) * - 1;
				return lerp(MonoPanoProjection(viewDirection), StereoPanoProjection(viewDirection), _StereoEnabled);
			}
			//ifex _EnableDistortion==0
			#ifdef USER_LUT
			float2 distortedUV(in PoiMesh poiMesh)
			{
				#if defined(PROP_DISTORTIONFLOWTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector = POI2D_SAMPLER_PAN(_DistortionFlowTexture, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTextureUV], _DistortionFlowTexture_ST), _DistortionFlowTexturePan) * 2 - 1;
				#else
				float4 flowVector = -1;
				#endif
				
				#if defined(PROP_DISTORTIONFLOWTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				float4 flowVector1 = POI2D_SAMPLER_PAN(_DistortionFlowTexture1, _MainTex, poiUV(poiMesh.uv[_DistortionFlowTexture1UV], _DistortionFlowTexture1_ST), _DistortionFlowTexture1Pan) * 2 - 1;
				#else
				float4 flowVector1 = -1;
				#endif
				
				#if defined(PROP_DISTORTIONMASK) || !defined(OPTIMIZER_ENABLED)
				half distortionMask = POI2D_SAMPLER_PAN(_DistortionMask, _MainTex, poiMesh.uv[_DistortionMaskUV], _DistortionMaskPan)[_DistortionMaskChannel];
				#else
				half distortionMask = 1;
				#endif
				
				half distortionStrength = _DistortionStrength;
				half distortionStrength1 = _DistortionStrength1;
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (AudioLinkIsAvailable() && _EnableDistortionAudioLink && _AudioLinkAnimToggle)
				{
					distortionStrength += lerp(_DistortionStrengthAudioLink.x, _DistortionStrengthAudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrengthAudioLinkBand))).r);
					distortionStrength1 += lerp(_DistortionStrength1AudioLink.x, _DistortionStrength1AudioLink.y, AudioLinkData(uint2(0, uint(_DistortionStrength1AudioLinkBand))).r);
				}
				#endif
				
				flowVector *= distortionStrength;
				flowVector1 *= distortionStrength1;
				return poiMesh.uv[_DistortionUvToDistort] + ((flowVector.xy + flowVector1.xy) / 2) * distortionMask;
			}
			#endif
			//endex
			
			//ifex _BlackLightMaskingEnabled==0
			#ifdef POI_BLACKLIGHTMASKING
			void calculateBlackLightMasks(in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				#ifdef VERTEXLIGHT_ON
				for (int lightIndex = 0; lightIndex < 4; lightIndex ++)
				{
					float3 lightPos = float3(unity_4LightPosX0[lightIndex], unity_4LightPosY0[lightIndex], unity_4LightPosZ0[lightIndex]);
					if (!distance(unity_LightColor[lightIndex].rgb, float3(0, 0, 0)))
					{
						if (_BlackLightMasking0GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking0Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking0GlobalMaskIndex-1, _BlackLightMasking0GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking1GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking1Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking1GlobalMaskIndex-1, _BlackLightMasking1GlobalMaskBlendType, smoothstep(_BlackLightMasking1Range.y, _BlackLightMasking1Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking2GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking2Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking2GlobalMaskIndex-1, _BlackLightMasking2GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
						
						if (_BlackLightMasking3GlobalMaskIndex > 0)
						{
							if(unity_LightColor[lightIndex].a == _BlackLightMasking3Key)
							{
								applyToGlobalMask(poiMods, _BlackLightMasking3GlobalMaskIndex-1, _BlackLightMasking3GlobalMaskBlendType, smoothstep(_BlackLightMasking0Range.y, _BlackLightMasking0Range.x, distance(poiMesh.worldPos, lightPos)));
							}
						}
					}
				}
				#endif
			}
			#endif
			//endex
			
			//ifex _DetailEnabled==0
			#ifdef FINALPASS
			void ApplyDetailColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_DETAILTEX) || !defined(OPTIMIZER_ENABLED)
				half3 detailTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_DetailTex, _MainTex, poiUV(poiMesh.uv[_DetailTexUV], _DetailTex_ST), _DetailTexPan, _DetailTexStochastic).rgb * poiThemeColor(poiMods, _DetailTint, _DetailTintThemeIndex);
				#else
				half3 detailTexture = 0.21763764082 * poiThemeColor(poiMods, _DetailTint, _DetailTintThemeIndex);
				#endif
				
				poiFragData.baseColor.rgb *= LerpWhiteTo(detailTexture * _DetailBrightness * unity_ColorSpaceDouble.rgb, poiMods.detailMask.r * _DetailTexIntensity);
			}
			
			void ApplyDetailNormal(inout PoiMods poiMods, inout PoiMesh poiMesh)
			{
				#if defined(PROP_DETAILMASK) || !defined(OPTIMIZER_ENABLED)
				poiMods.detailMask = POI2D_SAMPLER_PAN_STOCHASTIC(_DetailMask, _MainTex, poiUV(poiMesh.uv[_DetailMaskUV], _DetailMask_ST), _DetailMaskPan, _DetailMaskStochastic).rg;
				#else
				poiMods.detailMask = 1;
				#endif
				
				#ifdef POI_BACKFACE
				if (!poiMesh.isFrontFace)
				{
					poiMods.detailMask.rg *= _BackFaceDetailIntensity;
				}
				#endif
				
				if (_DetailTexGlobalMask > 0)
				{
					poiMods.detailMask.r = maskBlend(poiMods.detailMask.r, poiMods.globalMask[_DetailTexGlobalMask-1], _DetailTexGlobalMaskBlendType);
				}
				if (_DetailNormalGlobalMask > 0)
				{
					poiMods.detailMask.g = maskBlend(poiMods.detailMask.g, poiMods.globalMask[_DetailNormalGlobalMask-1], _DetailNormalGlobalMaskBlendType);
				}
				
				#if defined(PROP_DETAILNORMALMAP) || !defined(OPTIMIZER_ENABLED)
				half3 detailNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_DetailNormalMap, _MainTex, poiUV(poiMesh.uv[_DetailNormalMapUV], _DetailNormalMap_ST), _DetailNormalMapPan, _DetailNormalMapStochastic), _DetailNormalMapScale * poiMods.detailMask.g);
				poiMesh.tangentSpaceNormal = BlendNormals(detailNormal, poiMesh.tangentSpaceNormal);
				#endif
			}
			#endif
			//endex
			
			//ifex _MainVertexColoringEnabled==0
			void applyVertexColor(inout PoiFragData poiFragData, PoiMesh poiMesh)
			{
				if (_MainVertexColoringEnabled)
				{
					#ifndef POI_PASS_OUTLINE
					float3 vertCol = lerp(poiMesh.vertexColor.rgb, GammaToLinearSpace(poiMesh.vertexColor.rgb), _MainVertexColoringLinearSpace);
					poiFragData.baseColor *= lerp(1, vertCol, _MainVertexColoring);
					#endif
					poiFragData.alpha *= lerp(1, poiMesh.vertexColor.a, _MainUseVertexColorAlpha);
				}
			}
			//endex
			
			//ifex _BackFaceEnabled!=1
			#ifdef POI_BACKFACE
			void ApplyBackFaceColor(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiMods poiMods)
			{
				if (!poiMesh.isFrontFace)
				{
					float4 backFaceColor = _BackFaceColor;
					backFaceColor.rgb = poiThemeColor(poiMods, backFaceColor.rgb, _BackFaceColorThemeIndex);
					#if defined(PROP_BACKFACETEXTURE) || !defined(OPTIMIZER_ENABLED)
					backFaceColor *= POI2D_SAMPLER_PAN(_BackFaceTexture, _MainTex, poiUV(poiMesh.uv[_BackFaceTextureUV], _BackFaceTexture_ST), _BackFaceTexturePan);
					#endif
					backFaceColor.rgb = hueShift(backFaceColor.rgb, frac(_BackFaceHueShift + _BackFaceHueShiftSpeed * _Time.x) * _BackFaceHueShiftEnabled);
					
					float backFaceMask = 1;
					#if defined(PROP_BACKFACEMASK) || !defined(OPTIMIZER_ENABLED)
					backFaceMask *= POI2D_SAMPLER_PAN(_BackFaceMask, _MainTex, poiUV(poiMesh.uv[_BackFaceMaskUV], _BackFaceMask_ST), _BackFaceMaskPan)[_BackFaceMaskChannel];
					#endif
					if (!_BackFaceReplaceAlpha)
					{
						backFaceMask *= backFaceColor.a;
					}
					
					poiFragData.baseColor = lerp(poiFragData.baseColor, backFaceColor.rgb, backFaceMask);
					
					UNITY_BRANCH
					if (_BackFaceReplaceAlpha)
					{
						poiFragData.alpha = backFaceColor.a;
					}
					
					poiFragData.emission += backFaceColor.rgb * _BackFaceEmissionStrength * backFaceMask;
					poiMods.globalEmission = min(poiMods.globalEmission, _BackFaceEmissionLimiter);
				}
			}
			#endif
			//endex
			
			//ifex _RGBMaskEnabled==0
			#ifdef VIGNETTE
			//ifex _RgbNormalsEnabled==0
			#if defined(GEOM_TYPE_MESH) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
			void calculateRGBNormals(inout PoiMesh poiMesh, inout PoiMods poiMods)
			{
				// Only define this if we actually have any normal map textures. Can't do the same in color textures because users can tint
				#if defined(PROP_RGBNORMALR) || defined(PROP_RGBNORMALG) || defined(PROP_RGBNORMALB) || defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
				float4 rgbMask;
				
				if (_RGBUseVertexColors)
				{
					rgbMask = poiMesh.vertexColor;
				}
				else
				{
					#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
					rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
					#else
					rgbMask = 1;
					#endif
				}
				
				float4 maskFinal = 1;
				maskFinal.r = rgbMask[_RgbNormalRMaskChannel];
				maskFinal.g = rgbMask[_RgbNormalGMaskChannel];
				maskFinal.b = rgbMask[_RgbNormalBMaskChannel];
				maskFinal.a = rgbMask[_RgbNormalAMaskChannel];
				
				if (_RgbNormalRGlobalMaskChannel > 0) maskFinal.r = customBlend(maskFinal.r, poiMods.globalMask[_RgbNormalRGlobalMaskChannel-1], _RgbNormalRGlobalMaskBlendType);
				if (_RgbNormalGGlobalMaskChannel > 0) maskFinal.g = customBlend(maskFinal.g, poiMods.globalMask[_RgbNormalGGlobalMaskChannel-1], _RgbNormalGGlobalMaskBlendType);
				if (_RgbNormalBGlobalMaskChannel > 0) maskFinal.b = customBlend(maskFinal.b, poiMods.globalMask[_RgbNormalBGlobalMaskChannel-1], _RgbNormalBGlobalMaskBlendType);
				if (_RgbNormalAGlobalMaskChannel > 0) maskFinal.a = customBlend(maskFinal.a, poiMods.globalMask[_RgbNormalAGlobalMaskChannel-1], _RgbNormalAGlobalMaskBlendType);
				
				if (_RGBNormalBlend == 0)
				{
					#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalRScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan, _RgbNormalRStochastic), _RgbNormalRScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.r);
					}
					#endif
					#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalGScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan, _RgbNormalGStochastic), _RgbNormalGScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.g);
					}
					#endif
					#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalBScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan, _RgbNormalBStochastic), _RgbNormalBScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.b);
					}
					#endif
					#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
					if (_RgbNormalAScale > 0)
					{
						half3 normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan, _RgbNormalAStochastic), _RgbNormalAScale);
						poiMesh.tangentSpaceNormal = lerp(poiMesh.tangentSpaceNormal, normalToBlendWith, maskFinal.a);
					}
					#endif
				}
				else
				{
					half3 newNormal = half3(0, 0, 1);
					half3 normalToBlendWith = half3(0, 0, 1);
					#if defined(PROP_RGBNORMALR) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalR, _MainTex, poiUV(poiMesh.uv[_RgbNormalRUV], _RgbNormalR_ST), _RgbNormalRPan, _RgbNormalRStochastic), _RgbNormalRScale * maskFinal.r);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALG) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalG, _MainTex, poiUV(poiMesh.uv[_RgbNormalGUV], _RgbNormalG_ST), _RgbNormalGPan, _RgbNormalGStochastic), _RgbNormalGScale * maskFinal.g);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALB) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalB, _MainTex, poiUV(poiMesh.uv[_RgbNormalBUV], _RgbNormalB_ST), _RgbNormalBPan, _RgbNormalBStochastic), _RgbNormalBScale * maskFinal.b);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					#if defined(PROP_RGBNORMALA) || !defined(OPTIMIZER_ENABLED)
					normalToBlendWith = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_RgbNormalA, _MainTex, poiUV(poiMesh.uv[_RgbNormalAUV], _RgbNormalA_ST), _RgbNormalAPan, _RgbNormalAStochastic), _RgbNormalAScale * maskFinal.a);
					newNormal = BlendNormals(newNormal, normalToBlendWith);
					#endif
					poiMesh.tangentSpaceNormal = BlendNormals(newNormal, poiMesh.tangentSpaceNormal);
				}
				#endif
			}
			#endif
			//endex
			void calculateRGBMask(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				//If RGB normals are in use this data will already exist
				float4 rgbMask = float4(1, 1, 1, 1);
				//UNITY_BRANCH
				if (_RGBUseVertexColors)
				{
					rgbMask = poiMesh.vertexColor;
				}
				else
				{
					#if defined(PROP_RGBMASK) || !defined(OPTIMIZER_ENABLED)
					rgbMask = POI2D_SAMPLER_PAN(_RGBMask, _MainTex, poiUV(poiMesh.uv[_RGBMaskUV], _RGBMask_ST), _RGBMaskPan);
					#else
					rgbMask = 1;
					#endif
				}
				
				#if defined(PROP_REDTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 red = POI2D_SAMPLER_PAN_STOCHASTIC(_RedTexture, _MainTex, poiUV(poiMesh.uv[_RedTextureUV], _RedTexture_ST), _RedTexturePan, _RedTextureStochastic);
				#else
				float4 red = 1;
				#endif
				#if defined(PROP_GREENTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 green = POI2D_SAMPLER_PAN_STOCHASTIC(_GreenTexture, _MainTex, poiUV(poiMesh.uv[_GreenTextureUV], _GreenTexture_ST), _GreenTexturePan, _GreenTextureStochastic);
				#else
				float4 green = 1;
				#endif
				#if defined(PROP_BLUETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 blue = POI2D_SAMPLER_PAN_STOCHASTIC(_BlueTexture, _MainTex, poiUV(poiMesh.uv[_BlueTextureUV], _BlueTexture_ST), _BlueTexturePan, _BlueTextureStochastic);
				#else
				float4 blue = 1;
				#endif
				#if defined(PROP_ALPHATEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 alpha = POI2D_SAMPLER_PAN_STOCHASTIC(_AlphaTexture, _MainTex, poiUV(poiMesh.uv[_AlphaTextureUV], _AlphaTexture_ST), _AlphaTexturePan, _AlphaTextureStochastic);
				#else
				float4 alpha = 1;
				#endif
				
				float4 maskFinal = 1;
				maskFinal.r = red.a   * saturate((rgbMask[_RgbRedMaskChannel  ] * _RedColor.a  ) + _RedAlphaAdd  );
				maskFinal.g = green.a * saturate((rgbMask[_RgbGreenMaskChannel] * _GreenColor.a) + _GreenAlphaAdd);
				maskFinal.b = blue.a  * saturate((rgbMask[_RgbBlueMaskChannel ] * _BlueColor.a ) + _BlueAlphaAdd );
				maskFinal.a = alpha.a * saturate((rgbMask[_RgbAlphaMaskChannel] * _AlphaColor.a) + _AlphaAlphaAdd);
				
				if (_RgbRedGlobalMaskChannel   > 0) maskFinal.r = customBlend(maskFinal.r, poiMods.globalMask[_RgbRedGlobalMaskChannel-1],   _RgbRedGlobalMaskBlendType  );
				if (_RgbGreenGlobalMaskChannel > 0) maskFinal.g = customBlend(maskFinal.g, poiMods.globalMask[_RgbGreenGlobalMaskChannel-1], _RgbGreenGlobalMaskBlendType);
				if (_RgbBlueGlobalMaskChannel  > 0) maskFinal.b = customBlend(maskFinal.b, poiMods.globalMask[_RgbBlueGlobalMaskChannel-1],  _RgbBlueGlobalMaskBlendType );
				if (_RgbAlphaGlobalMaskChannel > 0) maskFinal.a = customBlend(maskFinal.a, poiMods.globalMask[_RgbAlphaGlobalMaskChannel-1], _RgbAlphaGlobalMaskBlendType);
				
				//UNITY_BRANCH
				if (_RGBBlendMultiplicative)
				{
					float3 RGBColor = 1;
					RGBColor = lerp(RGBColor, red.rgb * poiThemeColor(poiMods, _RedColor.rgb, _RedColorThemeIndex), maskFinal.r);
					RGBColor = lerp(RGBColor, green.rgb * poiThemeColor(poiMods, _GreenColor.rgb, _GreenColorThemeIndex), maskFinal.g);
					RGBColor = lerp(RGBColor, blue.rgb * poiThemeColor(poiMods, _BlueColor.rgb, _BlueColorThemeIndex), maskFinal.b);
					RGBColor = lerp(RGBColor, alpha.rgb * poiThemeColor(poiMods, _AlphaColor.rgb, _AlphaColorThemeIndex), maskFinal.a);
					
					poiFragData.baseColor *= RGBColor;
				}
				else
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, red.rgb * poiThemeColor(poiMods, _RedColor.rgb, _RedColorThemeIndex), maskFinal.r);
					poiFragData.baseColor = lerp(poiFragData.baseColor, green.rgb * poiThemeColor(poiMods, _GreenColor.rgb, _GreenColorThemeIndex), maskFinal.g);
					poiFragData.baseColor = lerp(poiFragData.baseColor, blue.rgb * poiThemeColor(poiMods, _BlueColor.rgb, _BlueColorThemeIndex), maskFinal.b);
					poiFragData.baseColor = lerp(poiFragData.baseColor, alpha.rgb * poiThemeColor(poiMods, _AlphaColor.rgb, _AlphaColorThemeIndex), maskFinal.a);
				}
			}
			#endif
			//endex
			
			#if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_BRANCH_DETAIL) || defined(GEOM_TYPE_FROND) || defined(DEPTH_OF_FIELD_COC_VIEW)
			float2 decalUV(float uvNumber, float2 position, half rotation, half rotationSpeed, half2 scale, float4 scaleOffset, float depth, in PoiMesh poiMesh, in PoiCam poiCam)
			{
				scaleOffset = float4(-scaleOffset.x, scaleOffset.y, -scaleOffset.z, scaleOffset.w);
				float2 centerOffset = float2((scaleOffset.x + scaleOffset.y)/2, (scaleOffset.z + scaleOffset.w)/2);
				float2 uv = poiMesh.uv[uvNumber] + calcParallax(depth + 1, poiCam);
				float2 decalCenter = position + centerOffset;
				float theta = radians(rotation + _Time.z * rotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
				uv = remap(uv, float2(0, 0) - scale / 2 + position + scaleOffset.xz, scale / 2 + position + scaleOffset.yw, float2(0, 0), float2(1, 1));
				return uv;
			}
			
			inline float3 decalHueShift(float enabled, float3 color, float shift, float shiftSpeed)
			{
				//UNITY_BRANCH
				if (enabled)
				{
					color = hueShift(color, shift + _Time.x * shiftSpeed);
				}
				return color;
			}
			
			inline float applyTilingClipping(float enabled, float2 uv)
			{
				float ret = 1;
				//UNITY_BRANCH
				if (!enabled)
				{
					if (uv.x > 1 || uv.y > 1 || uv.x < 0 || uv.y < 0)
					{
						ret = 0;
					}
				}
				return ret;
			}
			
			struct PoiDecal
			{
				float m_DecalMaskChannel;
				float m_DecalGlobalMask;
				float m_DecalGlobalMaskBlendType;
				float m_DecalApplyGlobalMaskIndex;
				float m_DecalApplyGlobalMaskBlendType;
				float4 m_DecalTexture_ST;
				float2 m_DecalTexturePan;
				float m_DecalTextureUV;
				float4 m_DecalColor;
				float m_DecalColorThemeIndex;
				fixed m_DecalTiled;
				float m_DecalBlendType;
				half m_DecalRotation;
				half2 m_DecalScale;
				float4 m_DecalSideOffset;
				half2 m_DecalPosition;
				half m_DecalRotationSpeed;
				float m_DecalEmissionStrength;
				float m_DecalBlendAlpha;
				float m_DecalOverrideAlpha;
				float m_DecalHueShiftEnabled;
				float m_DecalHueShift;
				float m_DecalHueShiftSpeed;
				float m_DecalDepth;
				float m_DecalHueAngleStrength;
				float m_DecalChannelSeparationEnable;
				float m_DecalChannelSeparation;
				float m_DecalChannelSeparationPremultiply;
				float m_DecalChannelSeparationHue;
				float m_DecalChannelSeparationVertical;
				float m_DecalChannelSeparationAngleStrength;
				
				#if defined(POI_AUDIOLINK)
				half m_AudioLinkDecalScaleBand;
				float4 m_AudioLinkDecalScale;
				half m_AudioLinkDecalRotationBand;
				float2 m_AudioLinkDecalRotation;
				half m_AudioLinkDecalAlphaBand;
				float2 m_AudioLinkDecalAlpha;
				half m_AudioLinkDecalEmissionBand;
				float2 m_AudioLinkDecalEmission;
				float m_DecalRotationCTALBand;
				float m_DecalRotationCTALSpeed;
				float m_DecalRotationCTALType;
				float m_AudioLinkDecalColorChord;
				float m_AudioLinkDecalSideBand;
				float4 m_AudioLinkDecalSideMin;
				float4 m_AudioLinkDecalSideMax;
				float2 m_AudioLinkDecalChannelSeparation;
				float m_AudioLinkDecalChannelSeparationBand;
				#endif
				
				float4 decalColor;
				float2 decalScale;
				float decalRotation;
				float2 uv;
				float4 dduv;
				float4 sideMod;
				float decalChannelOffset;
				float4 decalMask;
				
				void Init(in float4 DecalMask)
				{
					decalMask = DecalMask;
					decalScale = m_DecalScale;
				}
				
				void InitAudiolink(in PoiMods poiMods)
				{
					#ifdef POI_AUDIOLINK
					if (poiMods.audioLinkAvailable)
					{
						decalScale += lerp(m_AudioLinkDecalScale.xy, m_AudioLinkDecalScale.zw, poiMods.audioLink[m_AudioLinkDecalScaleBand]);
						sideMod += lerp(m_AudioLinkDecalSideMin, m_AudioLinkDecalSideMax, poiMods.audioLink[m_AudioLinkDecalSideBand]);
						decalRotation += lerp(m_AudioLinkDecalRotation.x, m_AudioLinkDecalRotation.y, poiMods.audioLink[m_AudioLinkDecalRotationBand]);
						decalRotation += AudioLinkGetChronoTime(m_DecalRotationCTALType, m_DecalRotationCTALBand) * m_DecalRotationCTALSpeed * 360;
						decalChannelOffset += lerp(m_AudioLinkDecalChannelSeparation[0], m_AudioLinkDecalChannelSeparation[1], poiMods.audioLink[m_AudioLinkDecalChannelSeparationBand]);
					}
					#endif
				}
				
				void SampleDecalNoTexture(in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					decalColor = float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
				}
				
				void SampleDecal(sampler2D decalTexture, in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					// Adjust derivatives for _ST of decal texture
					float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
					decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
				}
				
				void SampleDecalChannelSeparation(sampler2D decalTexture, in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
				{
					decalColor = 0;
					decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
					float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
					float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, poiMesh, poiCam);
					
					float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
					float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
					
					float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
					
					sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed);
					
					float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
					
					if (m_DecalChannelSeparationPremultiply)
					{
						decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
					}
					else
					{
						decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
					}
					decalColor.a = 0.5 * (sample0.a + sample1.a);
					decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
				}
				
				void Apply(inout float alphaOverride, inout float decalAlpha, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
				{
					if (m_DecalGlobalMask > 0)
					{
						decalColor.a = maskBlend(decalColor.a, poiMods.globalMask[m_DecalGlobalMask - 1], m_DecalGlobalMaskBlendType);
					}
					
					float audioLinkDecalAlpha = 0;
					float audioLinkDecalEmission = 0;
					#ifdef POI_AUDIOLINK
					audioLinkDecalEmission = lerp(m_AudioLinkDecalEmission.x, m_AudioLinkDecalEmission.y, poiMods.audioLink[m_AudioLinkDecalEmissionBand]) * poiMods.audioLinkAvailable;
					
					if (m_AudioLinkDecalColorChord)
					{
						if (poiMods.audioLinkAvailable)
						{
							decalColor.rgb *= AudioLinkLerp(ALPASS_CCSTRIP + float2(uv.x * AUDIOLINK_WIDTH, 0)).rgb;
						}
						else
						{
							decalAlpha = 0;
						}
					}
					audioLinkDecalAlpha = lerp(m_AudioLinkDecalAlpha.x, m_AudioLinkDecalAlpha.y, poiMods.audioLink[m_AudioLinkDecalAlphaBand]) * poiMods.audioLinkAvailable;
					#endif
					
					if (m_DecalOverrideAlpha)
					{
						alphaOverride += 1;
						decalAlpha = lerp(decalAlpha, min(decalAlpha, decalColor.a), decalMask[m_DecalMaskChannel]);
					}
					
					float decalAlphaMixed = decalColor.a * saturate(m_DecalBlendAlpha + audioLinkDecalAlpha);
					
					if (m_DecalApplyGlobalMaskIndex > 0)
					{
						applyToGlobalMask(poiMods, m_DecalApplyGlobalMaskIndex - 1, m_DecalApplyGlobalMaskBlendType, decalAlphaMixed);
					}
					
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, decalColor.rgb, m_DecalBlendType), decalAlphaMixed);
					poiFragData.emission += decalColor.rgb * decalColor.a * max(m_DecalEmissionStrength + audioLinkDecalEmission, 0);
				}
			};
			
			void applyDecals(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
			{
				float decalAlpha = 1;
				float alphaOverride = 0;
				#if defined(PROP_DECALMASK) || !defined(OPTIMIZER_ENABLED)
				float4 decalMask = POI2D_SAMPLER_PAN(_DecalMask, _MainTex, poiUV(poiMesh.uv[_DecalMaskUV], _DecalMask_ST), _DecalMaskPan);
				#else
				float4 decalMask = 1;
				#endif
				
				#ifdef TPS_Penetrator
				if (_DecalTPSDepthMaskEnabled)
				{
					decalMask.r = lerp(0, decalMask.r * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal0TPSMaskStrength);
					decalMask.g = lerp(0, decalMask.g * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal1TPSMaskStrength);
					decalMask.b = lerp(0, decalMask.b * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal2TPSMaskStrength);
					decalMask.a = lerp(0, decalMask.a * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), _Decal3TPSMaskStrength);
				}
				#endif
				float4 decalColor = 1;
				float2 uv = 0;
				
				// yaes
				
				//ifex _DecalEnabled==0
				#ifdef GEOM_TYPE_BRANCH
				PoiDecal Decal0;
				PoiInitStruct(PoiDecal, Decal0)
				
				Decal0.m_DecalMaskChannel = _Decal0MaskChannel;
				Decal0.m_DecalGlobalMask = _Decal0GlobalMask;
				Decal0.m_DecalGlobalMaskBlendType = _Decal0GlobalMaskBlendType;
				Decal0.m_DecalApplyGlobalMaskIndex = _Decal0ApplyGlobalMaskIndex;
				Decal0.m_DecalApplyGlobalMaskBlendType = _Decal0ApplyGlobalMaskBlendType;
				Decal0.m_DecalTexture_ST = _DecalTexture_ST;
				Decal0.m_DecalTexturePan = _DecalTexturePan;
				Decal0.m_DecalTextureUV = _DecalTextureUV;
				Decal0.m_DecalColor = _DecalColor;
				Decal0.m_DecalColorThemeIndex = _DecalColorThemeIndex;
				Decal0.m_DecalTiled = _DecalTiled;
				Decal0.m_DecalBlendType = _DecalBlendType;
				Decal0.m_DecalRotation = _DecalRotation;
				Decal0.m_DecalScale = _DecalScale;
				Decal0.m_DecalSideOffset = _DecalSideOffset;
				Decal0.m_DecalPosition = _DecalPosition;
				Decal0.m_DecalRotationSpeed = _DecalRotationSpeed;
				Decal0.m_DecalEmissionStrength = _DecalEmissionStrength;
				Decal0.m_DecalBlendAlpha = _DecalBlendAlpha;
				Decal0.m_DecalOverrideAlpha = _DecalOverrideAlpha;
				Decal0.m_DecalHueShiftEnabled = _DecalHueShiftEnabled;
				Decal0.m_DecalHueShift = _DecalHueShift;
				Decal0.m_DecalHueShiftSpeed = _DecalHueShiftSpeed;
				Decal0.m_DecalDepth = _Decal0Depth;
				Decal0.m_DecalHueAngleStrength = _Decal0HueAngleStrength;
				Decal0.m_DecalChannelSeparationEnable = _Decal0ChannelSeparationEnable;
				Decal0.m_DecalChannelSeparation = _Decal0ChannelSeparation;
				Decal0.m_DecalChannelSeparationPremultiply = _Decal0ChannelSeparationPremultiply;
				Decal0.m_DecalChannelSeparationHue = _Decal0ChannelSeparationHue;
				Decal0.m_DecalChannelSeparationVertical = _Decal0ChannelSeparationVertical;
				Decal0.m_DecalChannelSeparationAngleStrength = _Decal0ChannelSeparationAngleStrength;
				
				Decal0.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal0.m_AudioLinkDecalScaleBand = _AudioLinkDecal0ScaleBand;
				Decal0.m_AudioLinkDecalScale = _AudioLinkDecal0Scale;
				Decal0.m_AudioLinkDecalRotationBand = _AudioLinkDecal0RotationBand;
				Decal0.m_AudioLinkDecalRotation = _AudioLinkDecal0Rotation;
				Decal0.m_AudioLinkDecalAlphaBand = _AudioLinkDecal0AlphaBand;
				Decal0.m_AudioLinkDecalAlpha = _AudioLinkDecal0Alpha;
				Decal0.m_AudioLinkDecalEmissionBand = _AudioLinkDecal0EmissionBand;
				Decal0.m_AudioLinkDecalEmission = _AudioLinkDecal0Emission;
				Decal0.m_DecalRotationCTALBand = _DecalRotationCTALBand0;
				Decal0.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed0;
				Decal0.m_DecalRotationCTALType = _DecalRotationCTALType0;
				Decal0.m_AudioLinkDecalColorChord = _AudioLinkDecalCC0;
				Decal0.m_AudioLinkDecalSideBand = _AudioLinkDecal0SideBand;
				Decal0.m_AudioLinkDecalSideMin = _AudioLinkDecal0SideMin;
				Decal0.m_AudioLinkDecalSideMax = _AudioLinkDecal0SideMax;
				Decal0.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal0ChannelSeparation;
				Decal0.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal0ChannelSeparationBand;
				
				Decal0.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal0ChannelSeparationEnable==0
				if (_Decal0ChannelSeparationEnable)
				{
					Decal0.SampleDecalChannelSeparation(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal0ChannelSeparationEnable==1
				if (!_Decal0ChannelSeparationEnable)
				{
					Decal0.SampleDecal(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal0.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal0.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled1==0
				#ifdef GEOM_TYPE_BRANCH_DETAIL
				PoiDecal Decal1;
				PoiInitStruct(PoiDecal, Decal1)
				
				Decal1.m_DecalMaskChannel = _Decal1MaskChannel;
				Decal1.m_DecalGlobalMask = _Decal1GlobalMask;
				Decal1.m_DecalGlobalMaskBlendType = _Decal1GlobalMaskBlendType;
				Decal1.m_DecalApplyGlobalMaskIndex = _Decal1ApplyGlobalMaskIndex;
				Decal1.m_DecalApplyGlobalMaskBlendType = _Decal1ApplyGlobalMaskBlendType;
				Decal1.m_DecalTexture_ST = _DecalTexture1_ST;
				Decal1.m_DecalTexturePan = _DecalTexture1Pan;
				Decal1.m_DecalTextureUV = _DecalTexture1UV;
				Decal1.m_DecalColor = _DecalColor1;
				Decal1.m_DecalColorThemeIndex = _DecalColor1ThemeIndex;
				Decal1.m_DecalTiled = _DecalTiled1;
				Decal1.m_DecalBlendType = _DecalBlendType1;
				Decal1.m_DecalRotation = _DecalRotation1;
				Decal1.m_DecalScale = _DecalScale1;
				Decal1.m_DecalSideOffset = _DecalSideOffset1;
				Decal1.m_DecalPosition = _DecalPosition1;
				Decal1.m_DecalRotationSpeed = _DecalRotationSpeed1;
				Decal1.m_DecalEmissionStrength = _DecalEmissionStrength1;
				Decal1.m_DecalBlendAlpha = _DecalBlendAlpha1;
				Decal1.m_DecalOverrideAlpha = _DecalOverrideAlpha1;
				Decal1.m_DecalHueShiftEnabled = _DecalHueShiftEnabled1;
				Decal1.m_DecalHueShift = _DecalHueShift1;
				Decal1.m_DecalHueShiftSpeed = _DecalHueShiftSpeed1;
				Decal1.m_DecalDepth = _Decal1Depth;
				Decal1.m_DecalHueAngleStrength = _Decal1HueAngleStrength;
				Decal1.m_DecalChannelSeparationEnable = _Decal1ChannelSeparationEnable;
				Decal1.m_DecalChannelSeparation = _Decal1ChannelSeparation;
				Decal1.m_DecalChannelSeparationPremultiply = _Decal1ChannelSeparationPremultiply;
				Decal1.m_DecalChannelSeparationHue = _Decal1ChannelSeparationHue;
				Decal1.m_DecalChannelSeparationVertical = _Decal1ChannelSeparationVertical;
				Decal1.m_DecalChannelSeparationAngleStrength = _Decal1ChannelSeparationAngleStrength;
				
				Decal1.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal1.m_AudioLinkDecalScaleBand = _AudioLinkDecal1ScaleBand;
				Decal1.m_AudioLinkDecalScale = _AudioLinkDecal1Scale;
				Decal1.m_AudioLinkDecalRotationBand = _AudioLinkDecal1RotationBand;
				Decal1.m_AudioLinkDecalRotation = _AudioLinkDecal1Rotation;
				Decal1.m_AudioLinkDecalAlphaBand = _AudioLinkDecal1AlphaBand;
				Decal1.m_AudioLinkDecalAlpha = _AudioLinkDecal1Alpha;
				Decal1.m_AudioLinkDecalEmissionBand = _AudioLinkDecal1EmissionBand;
				Decal1.m_AudioLinkDecalEmission = _AudioLinkDecal1Emission;
				Decal1.m_DecalRotationCTALBand = _DecalRotationCTALBand1;
				Decal1.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed1;
				Decal1.m_DecalRotationCTALType = _DecalRotationCTALType1;
				Decal1.m_AudioLinkDecalColorChord = _AudioLinkDecalCC1;
				Decal1.m_AudioLinkDecalSideBand = _AudioLinkDecal1SideBand;
				Decal1.m_AudioLinkDecalSideMin = _AudioLinkDecal1SideMin;
				Decal1.m_AudioLinkDecalSideMax = _AudioLinkDecal1SideMax;
				Decal1.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal1ChannelSeparation;
				Decal1.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal1ChannelSeparationBand;
				
				Decal1.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE1) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal1ChannelSeparationEnable==0
				if (_Decal1ChannelSeparationEnable)
				{
					Decal1.SampleDecalChannelSeparation(_DecalTexture1, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal1ChannelSeparationEnable==1
				if (!_Decal1ChannelSeparationEnable)
				{
					Decal1.SampleDecal(_DecalTexture1, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal1.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal1.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled2==0
				#ifdef GEOM_TYPE_FROND
				PoiDecal Decal2;
				PoiInitStruct(PoiDecal, Decal2)
				
				Decal2.m_DecalMaskChannel = _Decal2MaskChannel;
				Decal2.m_DecalGlobalMask = _Decal2GlobalMask;
				Decal2.m_DecalGlobalMaskBlendType = _Decal2GlobalMaskBlendType;
				Decal2.m_DecalApplyGlobalMaskIndex = _Decal2ApplyGlobalMaskIndex;
				Decal2.m_DecalApplyGlobalMaskBlendType = _Decal2ApplyGlobalMaskBlendType;
				Decal2.m_DecalTexture_ST = _DecalTexture2_ST;
				Decal2.m_DecalTexturePan = _DecalTexture2Pan;
				Decal2.m_DecalTextureUV = _DecalTexture2UV;
				Decal2.m_DecalColor = _DecalColor2;
				Decal2.m_DecalColorThemeIndex = _DecalColor2ThemeIndex;
				Decal2.m_DecalTiled = _DecalTiled2;
				Decal2.m_DecalBlendType = _DecalBlendType2;
				Decal2.m_DecalRotation = _DecalRotation2;
				Decal2.m_DecalScale = _DecalScale2;
				Decal2.m_DecalSideOffset = _DecalSideOffset2;
				Decal2.m_DecalPosition = _DecalPosition2;
				Decal2.m_DecalRotationSpeed = _DecalRotationSpeed2;
				Decal2.m_DecalEmissionStrength = _DecalEmissionStrength2;
				Decal2.m_DecalBlendAlpha = _DecalBlendAlpha2;
				Decal2.m_DecalOverrideAlpha = _DecalOverrideAlpha2;
				Decal2.m_DecalHueShiftEnabled = _DecalHueShiftEnabled2;
				Decal2.m_DecalHueShift = _DecalHueShift2;
				Decal2.m_DecalHueShiftSpeed = _DecalHueShiftSpeed2;
				Decal2.m_DecalDepth = _Decal2Depth;
				Decal2.m_DecalHueAngleStrength = _Decal2HueAngleStrength;
				Decal2.m_DecalChannelSeparationEnable = _Decal2ChannelSeparationEnable;
				Decal2.m_DecalChannelSeparation = _Decal2ChannelSeparation;
				Decal2.m_DecalChannelSeparationPremultiply = _Decal2ChannelSeparationPremultiply;
				Decal2.m_DecalChannelSeparationHue = _Decal2ChannelSeparationHue;
				Decal2.m_DecalChannelSeparationVertical = _Decal2ChannelSeparationVertical;
				Decal2.m_DecalChannelSeparationAngleStrength = _Decal2ChannelSeparationAngleStrength;
				
				Decal2.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal2.m_AudioLinkDecalScaleBand = _AudioLinkDecal2ScaleBand;
				Decal2.m_AudioLinkDecalScale = _AudioLinkDecal2Scale;
				Decal2.m_AudioLinkDecalRotationBand = _AudioLinkDecal2RotationBand;
				Decal2.m_AudioLinkDecalRotation = _AudioLinkDecal2Rotation;
				Decal2.m_AudioLinkDecalAlphaBand = _AudioLinkDecal2AlphaBand;
				Decal2.m_AudioLinkDecalAlpha = _AudioLinkDecal2Alpha;
				Decal2.m_AudioLinkDecalEmissionBand = _AudioLinkDecal2EmissionBand;
				Decal2.m_AudioLinkDecalEmission = _AudioLinkDecal2Emission;
				Decal2.m_DecalRotationCTALBand = _DecalRotationCTALBand2;
				Decal2.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed2;
				Decal2.m_DecalRotationCTALType = _DecalRotationCTALType2;
				Decal2.m_AudioLinkDecalColorChord = _AudioLinkDecalCC2;
				Decal2.m_AudioLinkDecalSideBand = _AudioLinkDecal2SideBand;
				Decal2.m_AudioLinkDecalSideMin = _AudioLinkDecal2SideMin;
				Decal2.m_AudioLinkDecalSideMax = _AudioLinkDecal2SideMax;
				Decal2.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal2ChannelSeparation;
				Decal2.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal2ChannelSeparationBand;
				
				Decal2.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE2) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal2ChannelSeparationEnable==0
				if (_Decal2ChannelSeparationEnable)
				{
					Decal2.SampleDecalChannelSeparation(_DecalTexture2, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal2ChannelSeparationEnable==1
				if (!_Decal2ChannelSeparationEnable)
				{
					Decal2.SampleDecal(_DecalTexture2, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal2.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal2.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				
				//ifex _DecalEnabled3==0
				#ifdef DEPTH_OF_FIELD_COC_VIEW
				PoiDecal Decal3;
				PoiInitStruct(PoiDecal, Decal3)
				
				Decal3.m_DecalMaskChannel = _Decal3MaskChannel;
				Decal3.m_DecalGlobalMask = _Decal3GlobalMask;
				Decal3.m_DecalGlobalMaskBlendType = _Decal3GlobalMaskBlendType;
				Decal3.m_DecalApplyGlobalMaskIndex = _Decal3ApplyGlobalMaskIndex;
				Decal3.m_DecalApplyGlobalMaskBlendType = _Decal3ApplyGlobalMaskBlendType;
				Decal3.m_DecalTexture_ST = _DecalTexture3_ST;
				Decal3.m_DecalTexturePan = _DecalTexture3Pan;
				Decal3.m_DecalTextureUV = _DecalTexture3UV;
				Decal3.m_DecalColor = _DecalColor3;
				Decal3.m_DecalColorThemeIndex = _DecalColor3ThemeIndex;
				Decal3.m_DecalTiled = _DecalTiled3;
				Decal3.m_DecalBlendType = _DecalBlendType3;
				Decal3.m_DecalRotation = _DecalRotation3;
				Decal3.m_DecalScale = _DecalScale3;
				Decal3.m_DecalSideOffset = _DecalSideOffset3;
				Decal3.m_DecalPosition = _DecalPosition3;
				Decal3.m_DecalRotationSpeed = _DecalRotationSpeed3;
				Decal3.m_DecalEmissionStrength = _DecalEmissionStrength3;
				Decal3.m_DecalBlendAlpha = _DecalBlendAlpha3;
				Decal3.m_DecalOverrideAlpha = _DecalOverrideAlpha3;
				Decal3.m_DecalHueShiftEnabled = _DecalHueShiftEnabled3;
				Decal3.m_DecalHueShift = _DecalHueShift3;
				Decal3.m_DecalHueShiftSpeed = _DecalHueShiftSpeed3;
				Decal3.m_DecalDepth = _Decal3Depth;
				Decal3.m_DecalHueAngleStrength = _Decal3HueAngleStrength;
				Decal3.m_DecalChannelSeparationEnable = _Decal3ChannelSeparationEnable;
				Decal3.m_DecalChannelSeparation = _Decal3ChannelSeparation;
				Decal3.m_DecalChannelSeparationPremultiply = _Decal3ChannelSeparationPremultiply;
				Decal3.m_DecalChannelSeparationHue = _Decal3ChannelSeparationHue;
				Decal3.m_DecalChannelSeparationVertical = _Decal3ChannelSeparationVertical;
				Decal3.m_DecalChannelSeparationAngleStrength = _Decal3ChannelSeparationAngleStrength;
				
				Decal3.Init(decalMask);
				
				#if defined(POI_AUDIOLINK)
				Decal3.m_AudioLinkDecalScaleBand = _AudioLinkDecal3ScaleBand;
				Decal3.m_AudioLinkDecalScale = _AudioLinkDecal3Scale;
				Decal3.m_AudioLinkDecalRotationBand = _AudioLinkDecal3RotationBand;
				Decal3.m_AudioLinkDecalRotation = _AudioLinkDecal3Rotation;
				Decal3.m_AudioLinkDecalAlphaBand = _AudioLinkDecal3AlphaBand;
				Decal3.m_AudioLinkDecalAlpha = _AudioLinkDecal3Alpha;
				Decal3.m_AudioLinkDecalEmissionBand = _AudioLinkDecal3EmissionBand;
				Decal3.m_AudioLinkDecalEmission = _AudioLinkDecal3Emission;
				Decal3.m_DecalRotationCTALBand = _DecalRotationCTALBand3;
				Decal3.m_DecalRotationCTALSpeed = _DecalRotationCTALSpeed3;
				Decal3.m_DecalRotationCTALType = _DecalRotationCTALType3;
				Decal3.m_AudioLinkDecalColorChord = _AudioLinkDecalCC3;
				Decal3.m_AudioLinkDecalSideBand = _AudioLinkDecal3SideBand;
				Decal3.m_AudioLinkDecalSideMin = _AudioLinkDecal3SideMin;
				Decal3.m_AudioLinkDecalSideMax = _AudioLinkDecal3SideMax;
				Decal3.m_AudioLinkDecalChannelSeparation = _AudioLinkDecal3ChannelSeparation;
				Decal3.m_AudioLinkDecalChannelSeparationBand = _AudioLinkDecal3ChannelSeparationBand;
				
				Decal3.InitAudiolink(poiMods);
				#endif
				
				#if defined(PROP_DECALTEXTURE3) || !defined(OPTIMIZER_ENABLED)
				//ifex _Decal3ChannelSeparationEnable==0
				if (_Decal3ChannelSeparationEnable)
				{
					Decal3.SampleDecalChannelSeparation(_DecalTexture3, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				//ifex _Decal3ChannelSeparationEnable==1
				if (!_Decal3ChannelSeparationEnable)
				{
					Decal3.SampleDecal(_DecalTexture3, poiMods, poiLight, poiMesh, poiCam);
				}
				//endex
				#else
				Decal3.SampleDecalNoTexture(poiMods, poiLight, poiMesh, poiCam);
				#endif
				Decal3.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				//endex
				if (alphaOverride)
				{
					poiFragData.alpha *= decalAlpha;
				}
				poiFragData.baseColor = saturate(poiFragData.baseColor);
			}
			#endif
			
			//ifex _EnableDissolve==0
			#ifdef DISTORT
			void applyDissolve(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods, in PoiCam poiCam, in PoiLight poiLight)
			{
				#if defined(PROP_DISSOLVEMASK) || !defined(OPTIMIZER_ENABLED)
				float dissolveMask = POI2D_SAMPLER_PAN(_DissolveMask, _MainTex, poiUV(poiMesh.uv[_DissolveMaskUV], _DissolveMask_ST), _DissolveMaskPan).r;
				#else
				float dissolveMask = 1;
				#endif
				UNITY_BRANCH
				if (_DissolveUseVertexColors > 0)
				{
					// Vertex Color Imprecision hype
					dissolveMask = ceil(poiMesh.vertexColor[_DissolveUseVertexColors] * 100000) / 100000;
				}
				if (_DissolveMaskGlobalMask > 0)
				{
					dissolveMask = maskBlend(dissolveMask, poiMods.globalMask[_DissolveMaskGlobalMask-1], _DissolveMaskGlobalMaskBlendType);
				}
				
				#if defined(PROP_DISSOLVETOTEXTURE) || !defined(OPTIMIZER_ENABLED)
				dissolveToTexture = POI2D_SAMPLER_PAN(_DissolveToTexture, _MainTex, poiUV(poiMesh.uv[_DissolveToTextureUV], _DissolveToTexture_ST), _DissolveToTexturePan) * float4(poiThemeColor(poiMods, _DissolveTextureColor.rgb, _DissolveTextureColorThemeIndex), _DissolveTextureColor.a);
				#else
				dissolveToTexture = _DissolveTextureColor;
				#endif
				
				#if defined(PROP_DISSOLVENOISETEXTURE) || !defined(OPTIMIZER_ENABLED)
				float dissolveNoiseTexture = POI2D_SAMPLER_PAN(_DissolveNoiseTexture, _MainTex, poiUV(poiMesh.uv[_DissolveNoiseTextureUV], _DissolveNoiseTexture_ST), _DissolveNoiseTexturePan).r;
				#else
				float dissolveNoiseTexture = 1;
				#endif
				
				float da = _DissolveAlpha
				+ _DissolveAlpha0
				+ _DissolveAlpha1
				+ _DissolveAlpha2
				+ _DissolveAlpha3
				+ _DissolveAlpha4
				+ _DissolveAlpha5
				+ _DissolveAlpha6
				+ _DissolveAlpha7
				+ _DissolveAlpha8
				+ _DissolveAlpha9;
				float dds = _DissolveDetailStrength;
				
				if(_UVTileDissolveEnabled)
				{
					float2 udim = floor(poiMesh.uv[(int)_UVTileDissolveUV]);
					
					float4 xMask = float4(  (udim.x >= 0 && udim.x < 1),
					(udim.x >= 1 && udim.x < 2),
					(udim.x >= 2 && udim.x < 3),
					(udim.x >= 3 && udim.x < 4));
					
					da += (udim.y >= 0 && udim.y < 1) * dot(float4(_UVTileDissolveAlpha_Row0_0, _UVTileDissolveAlpha_Row0_1, _UVTileDissolveAlpha_Row0_2, _UVTileDissolveAlpha_Row0_3), xMask);
					da += (udim.y >= 1 && udim.y < 2) * dot(float4(_UVTileDissolveAlpha_Row1_0, _UVTileDissolveAlpha_Row1_1, _UVTileDissolveAlpha_Row1_2, _UVTileDissolveAlpha_Row1_3), xMask);
					da += (udim.y >= 2 && udim.y < 3) * dot(float4(_UVTileDissolveAlpha_Row2_0, _UVTileDissolveAlpha_Row2_1, _UVTileDissolveAlpha_Row2_2, _UVTileDissolveAlpha_Row2_3), xMask);
					da += (udim.y >= 3 && udim.y < 4) * dot(float4(_UVTileDissolveAlpha_Row3_0, _UVTileDissolveAlpha_Row3_1, _UVTileDissolveAlpha_Row3_2, _UVTileDissolveAlpha_Row3_3), xMask);
				}
				
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (_EnableDissolveAudioLink && poiMods.audioLinkAvailable)
				{
					da += lerp(_AudioLinkDissolveAlpha.x, _AudioLinkDissolveAlpha.y, poiMods.audioLink[_AudioLinkDissolveAlphaBand]);
					dds += lerp(_AudioLinkDissolveDetail.x, _AudioLinkDissolveDetail.y, poiMods.audioLink[_AudioLinkDissolveDetailBand]);
				}
				#endif
				
				da = saturate(da);
				dds = saturate(dds);
				
				if (_DissolveMaskInvert)
				{
					dissolveMask = 1 - dissolveMask;
				}
				#if defined(PROP_DISSOLVEDETAILNOISE) || !defined(OPTIMIZER_ENABLED)
				float dissolveDetailNoise = POI2D_SAMPLER_PAN(_DissolveDetailNoise, _MainTex, poiUV(poiMesh.uv[_DissolveDetailNoiseUV], _DissolveDetailNoise_ST), _DissolveDetailNoisePan);
				#else
				float dissolveDetailNoise = 0;
				#endif
				if (_DissolveInvertNoise)
				{
					dissolveNoiseTexture = 1 - dissolveNoiseTexture;
				}
				if (_DissolveInvertDetailNoise)
				{
					dissolveDetailNoise = 1 - dissolveDetailNoise;
				}
				if (_ContinuousDissolve != 0)
				{
					da = sin(_Time.x * _ContinuousDissolve) * .5 + .5;
				}
				da *= dissolveMask;
				dissolveAlpha = da;
				edgeAlpha = 0;
				
				[flatten]
				switch(_DissolveType)
				{
					default: // Basic (case 1)
					{
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						float noise = saturate(dissolveNoiseTexture - dissolveDetailNoise * dds);
						
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
					case 2: // Point to Point
					{
						float3 direction;
						float3 currentPos;
						float distanceTo = 0;
						direction = normalize(_DissolveEndPoint - _DissolveStartPoint);
						currentPos = lerp(_DissolveStartPoint, _DissolveEndPoint, dissolveAlpha);
						
						UNITY_BRANCH
						if (_DissolveP2PWorldLocal != 1)
						{
							float3 pos = _DissolveP2PWorldLocal == 0 ? poiMesh.localPos.rgb : poiMesh.vertexColor.rgb;
							distanceTo = dot(pos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = step(distanceTo, 0);
							edgeAlpha *= 1 - dissolveAlpha;
						}
						else
						{
							distanceTo = dot(poiMesh.worldPos - currentPos, direction) - dissolveDetailNoise * dds;
							edgeAlpha = smoothstep(_DissolveP2PEdgeLength + .00001, 0, distanceTo);
							dissolveAlpha = (distanceTo < 0) ? 1 : 0;
							edgeAlpha *= 1 - dissolveAlpha;
						}
						
						if(_DissolveP2PClamp)
						{
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 3: // Spherical
					{
						if(_SphericalDissolveInvert)
						{
							da = remap(da, 1, 0, -_DissolveEdgeWidth, 1);
						} else {
							da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						}
						
						dissolveAlpha = da;
						dds *= smoothstep(0, 0.2*dds + 0.01, dissolveAlpha) * lerp(1, smoothstep(1, 1 - 0.2*dds - 0.01, dissolveAlpha), _DissolveDetailEdgeSmoothing);
						float currentDistance = lerp(0, _SphericalDissolveRadius, dissolveAlpha);
						float fragDistance = distance(_SphericalDissolveCenter, poiMesh.localPos.xyz);
						float normalizedDistance;
						normalizedDistance = (fragDistance - currentDistance) / (_SphericalDissolveRadius + 0.0001)  - dissolveDetailNoise * dds;
						
						if(_SphericalDissolveInvert)
						{
							dissolveAlpha = (normalizedDistance > 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, -normalizedDistance);
						} else {
							dissolveAlpha = (normalizedDistance < 0) ? 1 : 0;
							edgeAlpha = smoothstep(_DissolveEdgeWidth + .00001, 0, normalizedDistance);
						}
						
						if(_SphericalDissolveClamp)
						{
							da = lerp(da, 1 - da, _SphericalDissolveInvert);
							dissolveAlpha = saturate(dissolveAlpha * smoothstep(0, 0.01, da) + smoothstep(0.99, 1, da));
							edgeAlpha *= smoothstep(0, 0.01, da);
						}
						
						break;
					}
					case 4: // CenterOut
					{
						float ramp = 0.5;
						float noise;
						
						[flatten]
						switch(_CenterOutDissolveMode)
						{
							case 1: // View Direction
							{
								ramp = saturate(lerp(poiLight.vertexNDotV, poiLight.nDotV, _CenterOutDissolveNormals));
								break;
							}
							case 2: // Custom Direction
							{
								ramp = dot(normalize(_CenterOutDissolveDirection), lerp(poiMesh.normals[0], poiMesh.normals[1], _CenterOutDissolveNormals));
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
							case 3: // Light Direction
							{
								ramp = lerp(poiLight.vertexNDotL, poiLight.nDotL, _CenterOutDissolveNormals);
								ramp = saturate(ramp * .5 + 0.5);
								break;
							}
						}
						
						if(_CenterOutDissolvePower != 1)
						{
							ramp = pow(ramp, _CenterOutDissolvePower);
						}
						
						if(!_CenterOutDissolveInvert)
						{
							ramp = 1 - ramp;
						}
						
						da = remap(da, 0, 1, -_DissolveEdgeWidth, 1);
						dissolveAlpha = da;
						//Adjust detail strength to avoid artifacts
						dds *= smoothstep(1, 0.99, da) * lerp(1, smoothstep(0, lerp(0.01, 0.1, dds), da), _DissolveDetailEdgeSmoothing);
						
						noise = saturate(ramp - dissolveDetailNoise * dds);
						noise = saturate(noise * 0.998 + 0.001);
						dissolveAlpha = dissolveAlpha >= noise;
						edgeAlpha = remapClamped(da + _DissolveEdgeWidth, da, noise) * (1 - dissolveAlpha);
						break;
					}
				}
				
				#ifndef POI_SHADOW
				UNITY_BRANCH
				if (_DissolveHueShiftEnabled)
				{
					dissolveToTexture.rgb = hueShift(dissolveToTexture.rgb, _DissolveHueShift + _Time.x * _DissolveHueShiftSpeed);
				}
				#endif
				
				poiFragData.alpha = lerp(poiFragData.alpha, dissolveToTexture.a, dissolveAlpha * .999999);
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				poiFragData.baseColor = lerp(poiFragData.baseColor, dissolveToTexture.rgb, dissolveAlpha * .999999);
				
				UNITY_BRANCH
				if (_DissolveEdgeWidth || (_DissolveType == 2 && _DissolveP2PEdgeLength != 0))
				{
					edgeColor = tex2D(_DissolveEdgeGradient, poiUV(float2(edgeAlpha, edgeAlpha), _DissolveEdgeGradient_ST)) * float4(poiThemeColor(poiMods, _DissolveEdgeColor.rgb, _DissolveEdgeColorThemeIndex), _DissolveEdgeColor.a);
					#ifndef POI_SHADOW
					UNITY_BRANCH
					if (_DissolveEdgeHueShiftEnabled)
					{
						edgeColor.rgb = hueShift(edgeColor.rgb, _DissolveEdgeHueShift + _Time.x * _DissolveEdgeHueShiftSpeed);
					}
					#endif
					poiFragData.baseColor = lerp(poiFragData.baseColor, edgeColor.rgb, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				}
				
				poiFragData.emission += lerp(0, dissolveToTexture * _DissolveToEmissionStrength, dissolveAlpha) + lerp(0, edgeColor.rgb * _DissolveEdgeEmission, smoothstep(0, 1 - _DissolveEdgeHardness * .99999999999, edgeAlpha));
				#endif
			}
			#endif
			//endex
			
			//ifex _EnableAniso==0
			#ifdef POI_ANISOTROPICS
			/*
			float D_GGX_Anisotropic(float at, float ab, float TdotH, float BdotH, float NdotH)
			{
				// Burley 2012, "Physically-Based Shading at Disney"
				
				// The values at and ab are perceptualRoughness^2, a2 is therefore perceptualRoughness^4
				// The dot product below computes perceptualRoughness^8. We cannot fit in fp16 without clamping
				// the roughness to too high values so we perform the dot product and the division in fp32
				float a2 = at * ab;
				float3 d = float3(ab * TdotH, at * BdotH, a2 * NdotH);
				float d2 = dot(d, d);
				float b2 = a2 / d2;
				return a2 * b2 * b2 * (1.0 / UNITY_PI);
			}
			
			//-------------------------------------GGX Anisotropic visibility function
			float V_SmithGGXCorrelated_Anisotropic(float at, float ab, float TdotV, float BdotV, float TdotL, float BdotL, float NdotV, float NdotL)
			{
				// Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"
				float lambdaV = NdotL * length(float3(at * TdotV, ab * BdotV, NdotV));
				float lambdaL = NdotV * length(float3(at * TdotL, ab * BdotL, NdotL));
				return 0.5 / (lambdaV + lambdaL);
			}
			*/
			
			float calculateAnisotropics(float3 binormal, float offset, float3 normal, float3 viewDir, float3 LightDirection, float exponent, float strength, float shadowMask)
			{
				float3 ShiftedTangent = normalize(binormal + offset * normal);
				float3 H = normalize(LightDirection + viewDir);
				float dotTH = dot(ShiftedTangent, H);
				float sinTH = sqrt(1.0 - dotTH * dotTH);
				float dirAtten = smoothstep(-1.0, 0.0, dotTH);
				return saturate(dirAtten * pow(sinTH, exponent) * strength) * shadowMask;
			}
			
			float aaEdgeFeather(float value, float edge, float feather)
			{
				float edgeMin = saturate(edge - feather * 0.5);
				float edgeMax = saturate(edge + feather * 0.5);
				return saturate((value - edgeMin) / saturate(edgeMax - edgeMin + fwidth(value)));
			}
			
			float3 applyAnisotropics(inout PoiFragData poiFragData, inout PoiLight poiLight, in PoiCam poiCam, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_ANISOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				float4 specMap = POI2D_SAMPLER_PAN(_AnisoColorMap, _MainTex, poiUV(poiMesh.uv[_AnisoColorMapUV], _AnisoColorMap_ST), _AnisoColorMapPan);
				#else
				float4 specMap = float4(1, 1, 1, 0);
				#endif
				
				float shadowMask = lerp(1, poiMax(poiLight.rampedLightMap), _AnisoHideInShadow);
				#ifdef POI_PASS_ADD
				shadowMask *= poiLight.attenuation * poiLight.additiveShadow;
				#endif
				
				float spec0 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso0SwitchDirection), _Aniso0Offset +_Aniso0OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.direction, _Aniso0Power * 1000, _Aniso0Strength, shadowMask);
				float spec1 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso1SwitchDirection), _Aniso1Offset +_Aniso1OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.direction, _Aniso1Power * 1000, _Aniso1Strength, shadowMask);
				
				spec0 = lerp(spec0, aaEdgeFeather(spec0, _Aniso0Edge, _Aniso0Blur), _Aniso0ToonMode);
				spec1 = lerp(spec1, aaEdgeFeather(spec1, _Aniso1Edge, _Aniso1Blur), _Aniso1ToonMode);
				
				float3 spec0Color = specMap.rgb * _Aniso0Tint;
				float3 spec1Color = specMap.rgb * _Aniso1Tint;
				
				float3 finalSpec = saturate(saturate(spec0 * spec0Color) + saturate(spec1 * spec1Color)) * lerp(1, poiFragData.baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor);
				float3 baseColor = poiFragData.baseColor;
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, spec1Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor), _AnisoReplace * spec1);
				poiFragData.baseColor = lerp(poiFragData.baseColor, spec0Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), poiLight.directColor, _AnisoUseLightColor), _AnisoReplace * spec0);
				poiLight.finalLightAdd += max(0, finalSpec * _AnisoAdd);
				
				if (_LightingVertexLightingEnabled)
				{
					#if defined(VERTEXLIGHT_ON)
					for (int index = 0; index < 4; index++)
					{
						float vSpec0 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso0SwitchDirection), _Aniso0Offset +_Aniso0OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.vDirection[index], _Aniso0Power * 1000, _Aniso0Strength, poiLight.vAttenuationDotNL[index]);
						float vSpec1 = calculateAnisotropics(lerp(poiMesh.binormal[1], poiMesh.tangent[1], _Aniso1SwitchDirection), _Aniso1Offset +_Aniso1OffsetMapStrength * specMap.a, poiMesh.normals[1], poiCam.viewDir, poiLight.vDirection[index], _Aniso1Power * 1000, _Aniso1Strength, poiLight.vAttenuationDotNL[index]);
						
						vSpec0 = lerp(vSpec0, aaEdgeFeather(vSpec0, _Aniso0Edge, _Aniso0Blur), _Aniso0ToonMode);
						vSpec1 = lerp(vSpec1, aaEdgeFeather(vSpec1, _Aniso1Edge, _Aniso1Blur), _Aniso1ToonMode);
						
						float3 vSpec0Color = specMap.rgb * _Aniso0Tint;
						float3 vSpec1Color = specMap.rgb * _Aniso1Tint;
						
						poiLight.finalLightAdd += max(0, saturate(saturate(vSpec0 * spec0Color) + saturate(vSpec1 * spec1Color)) * lerp(1, poiFragData.baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor) * _AnisoAdd);
						
						poiFragData.baseColor = lerp(poiFragData.baseColor, spec1Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor), _AnisoReplace * vSpec1);
						poiFragData.baseColor = lerp(poiFragData.baseColor, spec0Color * lerp(1, baseColor, _AnisoUseBaseColor) * lerp(dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), poiLight.vColor[index], _AnisoUseLightColor), _AnisoReplace * vSpec0);
					}
					#endif
				}
				
				//ifex _AnisoDebugToggle==0
				if(_AnisoDebugToggle)
				{
					switch(_AnisoDebugMode)
					{
						// final Spec
						case 1:
						{
							return finalSpec;
							break;
						}
						case 2:
						{
							return spec0 * spec0Color;
							break;
						}
						case 3:
						{
							return spec1 * spec1Color;
							break;
						}
					}
				}
				//endex
				
				return float3(0, 0, 0);
			}
			#endif
			//endex
			
			//ifex _EnableFlipbook==0
			#ifdef _SUNDISK_HIGH_QUALITY
			
			void applyFlipbook(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				#if defined(PROP_FLIPBOOKTEXARRAY) || !defined(OPTIMIZER_ENABLED)
				float4 flipBookPixel = float4(0, 0, 0, 0);
				#if defined(PROP_FLIPBOOKMASK) || !defined(OPTIMIZER_ENABLED)
				float flipBookMask = POI2D_SAMPLER_PAN(_FlipbookMask, _MainTex, poiUV(poiMesh.uv[_FlipbookMaskUV], _FlipbookMask_ST), _FlipbookMaskPan)[_FlipbookMaskChannel];
				#else
				float flipBookMask = 1;
				#endif
				if (_FlipbookMaskGlobalMask > 0)
				{
					flipBookMask = maskBlend(flipBookMask, poiMods.globalMask[_FlipbookMaskGlobalMask-1], _FlipbookMaskGlobalMaskBlendType);
				}
				float4 flipbookScaleOffset = _FlipbookScaleOffset;
				
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookScaleOffset.xy += lerp(_AudioLinkFlipbookScale.xy, _AudioLinkFlipbookScale.zw, poiMods.audioLink[_AudioLinkFlipbookScaleBand]);
				}
				#endif
				
				flipbookScaleOffset.xy = 1 - flipbookScaleOffset.xy;
				float2 uv = frac(poiMesh.uv[_FlipbookTexArrayUV]);
				float theta = radians(_FlipbookRotation + _Time.z * _FlipbookRotationSpeed);
				float cs = cos(theta);
				float sn = sin(theta);
				float2 spriteCenter = flipbookScaleOffset.zw + .5;
				// 2d rotation
				uv = float2((uv.x - spriteCenter.x) * cs - (uv.y - spriteCenter.y) * sn + spriteCenter.x, (uv.x - spriteCenter.x) * sn + (uv.y - spriteCenter.y) * cs + spriteCenter.y);
				float4 sideOffset = float4(-(_FlipbookSideOffset.x), _FlipbookSideOffset.y, -(_FlipbookSideOffset.z), _FlipbookSideOffset.w);
				float2 newUV = remap(uv, float2(0, 0) + flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.xz, float2(1, 1) - flipbookScaleOffset.xy / 2 + flipbookScaleOffset.zw + sideOffset.yw, float2(0, 0), float2(1, 1));
				
				UNITY_BRANCH
				if (_FlipbookTiled == 0)
				{
					if (max(newUV.x, newUV.y) > 1 || min(newUV.x, newUV.y) < 0)
					{
						return;
					}
				}
				float currentFrame = 0;
				float width;
				float height;
				float totalFrames;
				_FlipbookTexArray.GetDimensions(width, height, totalFrames);
				
				if (_FlipbookStartAndEnd)
				{
					totalFrames -= (totalFrames - min(max(_FlipbookStartFrame, _FlipbookEndFrame), totalFrames));
					totalFrames -= max(0, _FlipbookStartFrame);
				}
				if (!_FlipbookManualFrameControl)
				{
					if (_FlipbookFPS != 0)
					{
						currentFrame = ((_Time.y / (1 / _FlipbookFPS)) + _FlipbookFrameOffset) % totalFrames;
						if (_FlipbookStartAndEnd)
						{
							currentFrame += _FlipbookStartFrame;
						}
					}
				}
				else
				{
					currentFrame = fmod(_FlipbookCurrentFrame, totalFrames);
				}
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					if (_FlipbookChronotensityEnabled)
					{
						currentFrame += AudioLinkGetChronoTime(_FlipbookChronoType, _FlipbookChronotensityBand) * _FlipbookChronotensitySpeed;
					}
					currentFrame += lerp(_AudioLinkFlipbookFrame.x, _AudioLinkFlipbookFrame.y, poiMods.audioLink[_AudioLinkFlipbookFrameBand]);
					float totalFramesAL = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesAL += max(0, _FlipbookStartFrame);
					}
					currentFrame %= totalFramesAL;
				}
				#endif
				flipBookPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor(currentFrame)));
				UNITY_BRANCH
				if (_FlipbookCrossfadeEnabled)
				{
					float totalFramesCF = totalFrames;
					if (_FlipbookStartAndEnd)
					{
						totalFramesCF += max(0, _FlipbookStartFrame);
					}
					float4 flipbookNextPixel = UNITY_SAMPLE_TEX2DARRAY(_FlipbookTexArray, float3(TRANSFORM_TEX(newUV, _FlipbookTexArray) + _Time.x * _FlipbookTexArrayPan, floor((currentFrame + 1) % totalFramesCF)));
					flipBookPixel = lerp(flipBookPixel, flipbookNextPixel, smoothstep(_FlipbookCrossfadeRange.x, _FlipbookCrossfadeRange.y, frac(currentFrame)));
				}
				
				UNITY_BRANCH
				if (_FlipbookIntensityControlsAlpha)
				{
					flipBookPixel.a = poiMax(flipBookPixel.rgb);
				}
				UNITY_BRANCH
				if (_FlipbookColorReplaces)
				{
					flipBookPixel.rgb = poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				else
				{
					flipBookPixel.rgb *= poiThemeColor(poiMods, _FlipbookColor.rgb, _FlipbookColorThemeIndex);
				}
				
				UNITY_BRANCH
				if (_FlipbookHueShiftEnabled)
				{
					flipBookPixel.rgb = hueShift(flipBookPixel.rgb, _FlipbookHueShift + _Time.x * _FlipbookHueShiftSpeed);
				}
				half flipbookAlpha = 1;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookAlpha += saturate(lerp(_AudioLinkFlipbookAlpha.x, _AudioLinkFlipbookAlpha.y, poiMods.audioLink[_AudioLinkFlipbookAlphaBand]));
				}
				#endif
				
				#if !defined(POI_PASS_OUTLINE) && !defined(UNITY_PASS_SHADOWCASTER)
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * _FlipbookReplace * flipBookMask * flipbookAlpha);
				poiFragData.baseColor = poiFragData.baseColor + flipBookPixel.rgb * _FlipbookAdd * flipBookMask * flipbookAlpha;
				poiFragData.baseColor = poiFragData.baseColor * lerp(1, flipBookPixel.rgb, flipBookPixel.a * _FlipbookColor.a * flipBookMask * _FlipbookMultiply * flipbookAlpha);
				
				float flipbookEmissionStrength = _FlipbookEmissionStrength;
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable)
				{
					flipbookEmissionStrength += max(lerp(_AudioLinkFlipbookEmission.x, _AudioLinkFlipbookEmission.y, poiMods.audioLink[_AudioLinkFlipbookEmissionBand]), 0);
				}
				#endif
				
				poiFragData.emission += lerp(0, flipBookPixel.rgb * flipbookEmissionStrength, flipBookPixel.a * _FlipbookColor.a * flipBookMask * flipbookAlpha);
				
				#endif
				
				UNITY_BRANCH
				if (_FlipbookAlphaControlsFinalAlpha)
				{
					poiFragData.alpha = lerp(poiFragData.alpha, flipBookPixel.a * _FlipbookColor.a, flipBookMask);
				}
				#endif
			}
			
			#endif
			//endex
			
			//ifex _EnableEmission==0 && _EnableEmission1==0 && _EnableEmission2==0 && _EnableEmission3==0
			float calculateGlowInTheDark(in float minLight, in float maxLight, in float minEmissionMultiplier, in float maxEmissionMultiplier, in float enabled, in float worldOrMesh, in PoiLight poiLight)
			{
				float glowInTheDarkMultiplier = 1;
				//UNITY_BRANCH
				if (enabled)
				{
					float3 lightValue = worldOrMesh ? calculateluminance(poiLight.finalLighting.rgb) : calculateluminance(poiLight.directColor.rgb);
					float gitdeAlpha = saturate(inverseLerp(minLight, maxLight, lightValue));
					glowInTheDarkMultiplier = lerp(minEmissionMultiplier, maxEmissionMultiplier, gitdeAlpha);
				}
				return glowInTheDarkMultiplier;
			}
			
			float calculateScrollingEmission(in float3 direction, in float velocity, in float interval, in float scrollWidth, float offset, float3 position)
			{
				scrollWidth = max(scrollWidth, 0);
				float phase = 0;
				phase = dot(position, direction);
				phase -= (_Time.y + offset) * velocity;
				phase /= interval;
				phase -= floor(phase);
				phase = saturate(phase);
				return (pow(phase, scrollWidth) + pow(1 - phase, scrollWidth * 4)) * 0.5;
			}
			
			float calculateBlinkingEmission(in float blinkMin, in float blinkMax, in float blinkVelocity, float offset)
			{
				float amplitude = (blinkMax - blinkMin) * 0.5f;
				float base = blinkMin + amplitude;
				return sin((_Time.y + offset) * blinkVelocity) * amplitude + base;
			}
			
			void applyALEmmissionStrength(in PoiMods poiMods, inout float emissionStrength, in float2 emissionStrengthMod, in float emissionStrengthBand, in float2 _EmissionALMultipliers, in float _EmissionALMultipliersBand, in float enabled)
			{
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && enabled)
				{
					emissionStrength += lerp(emissionStrengthMod.x, emissionStrengthMod.y, poiMods.audioLink[emissionStrengthBand]);
					emissionStrength *= lerp(_EmissionALMultipliers.x, _EmissionALMultipliers.y, poiMods.audioLink[_EmissionALMultipliersBand]);
				}
				#endif
			}
			
			void applyALCenterOutEmission(in PoiMods poiMods, in float nDotV, inout float emissionStrength, in float size, in float band, in float2 emissionToAdd, in float enabled, in float duration)
			{
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && enabled)
				{
					float intensity;
					[flatten]
					if (duration >= 0)
					{
						intensity = getBandAtTime(band, saturate(remap(nDotV, 1, 0, 0, duration)), size);
					}
					else
					{
						duration *= -1;
						intensity = getBandAtTime(band, saturate(remap(pow(nDotV, 2), 0, 1 + duration, 0, duration)), size);
					}
					emissionStrength += lerp(emissionToAdd[0], emissionToAdd[1], intensity);
				}
				#endif
			}
			void applyLumaGradient(in PoiMods poiMods, inout float3 emissionColor, in float themeIndex, in float nDotV)
			{
				#ifdef POI_AUDIOLINK
				if (poiMods.audioLinkAvailable && poiMods.audioLinkViaLuma && themeIndex >= 5 && themeIndex <= 7)
				{
					emissionColor = getLumaGradient(themeIndex - 5, saturate(1 - nDotV));
				}
				#endif
			}
			//endex
			
			//ifex _EnableEmission==0
			#ifdef _EMISSION
			float3 applyEmission(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// First Emission
				float3 emission0 = 0;
				float emissionStrength0 = _EmissionStrength;
				float3 emissionColor0 = 0;
				
				float glowInTheDarkMultiplier0 = calculateGlowInTheDark(_GITDEMinLight, _GITDEMaxLight, _GITDEMinEmissionMultiplier, _GITDEMaxEmissionMultiplier, _EnableGITDEmission, _GITDEWorldOrMesh, poiLight);
				
				#if defined(PROP_EMISSIONMAP) || !defined(OPTIMIZER_ENABLED)
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled)
				{
					emissionColor0 = POI2D_SAMPLER_PAN(_EmissionMap, _MainTex, poiUV(poiMesh.uv[_EmissionMapUV], _EmissionMap_ST), _EmissionMapPan).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap).rgb * poiThemeColor(poiMods, _EmissionColor.rgb, _EmissionColorThemeIndex);
				}
				else
				{
					emissionColor0 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap_ST.xy) + _Time.x * _EmissionCenterOutSpeed).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap).rgb * poiThemeColor(poiMods, _EmissionColor.rgb, _EmissionColorThemeIndex);
				}
				#else
				emissionColor0 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap).rgb * poiThemeColor(poiMods, _EmissionColor.rgb, _EmissionColorThemeIndex);
				#endif
				
				//UNITY_BRANCH
				if (_ScrollingEmission)
				{
					float3 pos = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor)
					{
						pos = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE) || !defined(OPTIMIZER_ENABLED)
						emissionStrength0 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve, _MainTex, poiUV(poiMesh.uv[_EmissionMapUV], _EmissionScrollingCurve_ST) + (dot(pos, _EmissiveScroll_Direction.xyz) * _EmissiveScroll_Interval) + _Time.x * _EmissiveScroll_Velocity).r;
						#endif
					}
					else
					{
						emissionStrength0 *= calculateScrollingEmission(_EmissiveScroll_Direction.xyz, _EmissiveScroll_Velocity, _EmissiveScroll_Interval, _EmissiveScroll_Width, _EmissionScrollingOffset, pos);
					}
				}
				
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled)
				{
					emissionStrength0 *= calculateBlinkingEmission(_EmissiveBlink_Min, _EmissiveBlink_Max, _EmissiveBlink_Velocity, _EmissionBlinkingOffset);
				}
				
				applyLumaGradient(poiMods, emissionColor0, _EmissionColorThemeIndex, poiLight.nDotV);
				emissionColor0 = hueShift(emissionColor0, frac(_EmissionHueShift + _EmissionHueShiftSpeed * _Time.x) * _EmissionHueShiftEnabled);
				
				#if defined(PROP_EMISSIONMASK) || !defined(OPTIMIZER_ENABLED)
				float emissionMask0 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask, _MainTex, poiUV(poiMesh.uv[_EmissionMaskUV], _EmissionMask_ST) + _Time.x * _EmissionMaskPan)[_EmissionMaskChannel];
				#else
				float emissionMask0 = 1;
				#endif
				
				if (_EmissionMaskInvert)
				{
					emissionMask0 = 1 - emissionMask0;
				}
				
				if (_EmissionMask0GlobalMask > 0)
				{
					emissionMask0 = maskBlend(emissionMask0, poiMods.globalMask[_EmissionMask0GlobalMask - 1], _EmissionMask0GlobalMaskBlendType);
				}
				
				applyALEmmissionStrength(poiMods, emissionStrength0, _EmissionAL0StrengthMod, _EmissionAL0StrengthBand, _EmissionAL0Multipliers, _EmissionAL0MultipliersBand, _EmissionAL0Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength0, _AudioLinkEmission0CenterOutSize, _AudioLinkEmission0CenterOutBand, _AudioLinkEmission0CenterOut, _EmissionAL0Enabled, _AudioLinkEmission0CenterOutDuration);
				
				emissionStrength0 *= glowInTheDarkMultiplier0 * emissionMask0;
				emission0 = max(emissionStrength0 * emissionColor0, 0);
				
				#ifdef POI_DISSOLVE
				//UNITY_BRANCH
				if (_DissolveEmissionSide != 2)
				{
					emission0 *= lerp(1 - dissolveAlpha, dissolveAlpha, _DissolveEmissionSide);
				}
				#endif
				
				// poiFragData.finalColor.rgb = lerp(poiFragData.finalColor.rgb, saturate(emission0 + emission1), _EmissionReplace * poiMax(emission0 + emission1));
				
				poiFragData.emission += emission0;
				return emission0 * _EmissionReplace0;
			}
			#endif
			//endex
			//ifex _EnableEmission1==0
			#ifdef POI_EMISSION_1
			float3 applyEmission1(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// Second Emission
				float3 emission1 = 0;
				float emissionStrength1 = 0;
				float3 emissionColor1 = 0;
				
				emissionStrength1 = _EmissionStrength1;
				
				float glowInTheDarkMultiplier1 = calculateGlowInTheDark(_GITDEMinLight1, _GITDEMaxLight1, _GITDEMinEmissionMultiplier1, _GITDEMaxEmissionMultiplier1, _EnableGITDEmission1, _GITDEWorldOrMesh1, poiLight);
				#if defined(PROP_EMISSIONMAP1) || !defined(OPTIMIZER_ENABLED)
				
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled1)
				{
					emissionColor1 = POI2D_SAMPLER_PAN(_EmissionMap1, _MainTex, poiUV(poiMesh.uv[_EmissionMap1UV], _EmissionMap1_ST), _EmissionMap1Pan) * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap1).rgb * poiThemeColor(poiMods, _EmissionColor1.rgb, _EmissionColor1ThemeIndex);
				}
				else
				{
					emissionColor1 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap1, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap1_ST.xy) + _Time.x * _EmissionCenterOutSpeed1).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap1).rgb * poiThemeColor(poiMods, _EmissionColor1.rgb, _EmissionColor1ThemeIndex);
				}
				#else
				emissionColor1 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap1).rgb * poiThemeColor(poiMods, _EmissionColor1.rgb, _EmissionColor1ThemeIndex);
				#endif
				//UNITY_BRANCH
				if (_ScrollingEmission1)
				{
					float3 pos1 = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor1)
					{
						pos1 = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve1)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE1) || !defined(OPTIMIZER_ENABLED)
						emissionStrength1 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve1, _MainTex, poiUV(poiMesh.uv[_EmissionMap1UV], _EmissionScrollingCurve1_ST) + (dot(pos1, _EmissiveScroll_Direction1) * _EmissiveScroll_Interval1) + _Time.x * _EmissiveScroll_Velocity1);
						#endif
					}
					else
					{
						emissionStrength1 *= calculateScrollingEmission(_EmissiveScroll_Direction1, _EmissiveScroll_Velocity1, _EmissiveScroll_Interval1, _EmissiveScroll_Width1, _EmissionScrollingOffset1, pos1);
					}
				}
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled1)
				{
					emissionStrength1 *= calculateBlinkingEmission(_EmissiveBlink_Min1, _EmissiveBlink_Max1, _EmissiveBlink_Velocity1, _EmissionBlinkingOffset1);
				}
				
				applyLumaGradient(poiMods, emissionColor1, _EmissionColor1ThemeIndex, poiLight.nDotV);
				emissionColor1 = hueShift(emissionColor1, frac(_EmissionHueShift1 + _EmissionHueShiftSpeed1 * _Time.x) * _EmissionHueShiftEnabled1);
				#if defined(PROP_EMISSIONMASK1) || !defined(OPTIMIZER_ENABLED)
				float emissionMask1 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask1, _MainTex, poiUV(poiMesh.uv[_EmissionMask1UV], _EmissionMask1_ST) + _Time.x * _EmissionMask1Pan)[_EmissionMask1Channel];
				#else
				float emissionMask1 = 1;
				#endif
				
				if (_EmissionMaskInvert1)
				{
					emissionMask1 = 1 - emissionMask1;
				}
				
				if (_EmissionMask1GlobalMask > 0)
				{
					emissionMask1 = maskBlend(emissionMask1, poiMods.globalMask[_EmissionMask1GlobalMask - 1], _EmissionMask1GlobalMaskBlendType);
				}
				applyALEmmissionStrength(poiMods, emissionStrength1, _EmissionAL1StrengthMod, _EmissionAL1StrengthBand, _EmissionAL1Multipliers, _EmissionAL1MultipliersBand, _EmissionAL1Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength1, _AudioLinkEmission1CenterOutSize, _AudioLinkEmission1CenterOutBand, _AudioLinkEmission1CenterOut, _EmissionAL1Enabled, _AudioLinkEmission1CenterOutDuration);
				
				emissionStrength1 *= glowInTheDarkMultiplier1 * emissionMask1;
				emission1 = max(emissionStrength1 * emissionColor1, 0);
				
				poiFragData.emission += emission1;
				return emission1 * _EmissionReplace1;
			}
			#endif
			//endex
			//ifex _EnableEmission2==0
			#ifdef POI_EMISSION_2
			float3 applyEmission2(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// Second Emission
				float3 emission2 = 0;
				float emissionStrength2 = 0;
				float3 emissionColor2 = 0;
				
				emissionStrength2 = _EmissionStrength2;
				
				float glowInTheDarkMultiplier2 = calculateGlowInTheDark(_GITDEMinLight2, _GITDEMaxLight2, _GITDEMinEmissionMultiplier2, _GITDEMaxEmissionMultiplier2, _EnableGITDEmission2, _GITDEWorldOrMesh2, poiLight);
				#if defined(PROP_EMISSIONMAP2) || !defined(OPTIMIZER_ENABLED)
				
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled2)
				{
					emissionColor2 = POI2D_SAMPLER_PAN(_EmissionMap2, _MainTex, poiUV(poiMesh.uv[_EmissionMap2UV], _EmissionMap2_ST), _EmissionMap2Pan) * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap2).rgb * poiThemeColor(poiMods, _EmissionColor2.rgb, _EmissionColor2ThemeIndex);
				}
				else
				{
					emissionColor2 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap2, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap2_ST.xy) + _Time.x * _EmissionCenterOutSpeed2).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap2).rgb * poiThemeColor(poiMods, _EmissionColor2.rgb, _EmissionColor2ThemeIndex);
				}
				#else
				emissionColor2 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap2).rgb * poiThemeColor(poiMods, _EmissionColor2.rgb, _EmissionColor2ThemeIndex);
				#endif
				//UNITY_BRANCH
				if (_ScrollingEmission2)
				{
					float3 pos2 = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor2)
					{
						pos2 = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve2)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE2) || !defined(OPTIMIZER_ENABLED)
						emissionStrength2 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve2, _MainTex, poiUV(poiMesh.uv[_EmissionMap2UV], _EmissionScrollingCurve2_ST) + (dot(pos2, _EmissiveScroll_Direction2) * _EmissiveScroll_Interval2) + _Time.x * _EmissiveScroll_Velocity2);
						#endif
					}
					else
					{
						emissionStrength2 *= calculateScrollingEmission(_EmissiveScroll_Direction2, _EmissiveScroll_Velocity2, _EmissiveScroll_Interval2, _EmissiveScroll_Width2, _EmissionScrollingOffset2, pos2);
					}
				}
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled2)
				{
					emissionStrength2 *= calculateBlinkingEmission(_EmissiveBlink_Min2, _EmissiveBlink_Max2, _EmissiveBlink_Velocity2, _EmissionBlinkingOffset2);
				}
				
				applyLumaGradient(poiMods, emissionColor2, _EmissionColor2ThemeIndex, poiLight.nDotV);
				emissionColor2 = hueShift(emissionColor2, frac(_EmissionHueShift2 + _EmissionHueShiftSpeed2 * _Time.x) * _EmissionHueShiftEnabled2);
				#if defined(PROP_EMISSIONMASK2) || !defined(OPTIMIZER_ENABLED)
				float emissionMask2 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask2, _MainTex, poiUV(poiMesh.uv[_EmissionMask2UV], _EmissionMask2_ST) + _Time.x * _EmissionMask2Pan)[_EmissionMask2Channel];
				#else
				float emissionMask2 = 1;
				#endif
				if (_EmissionMaskInvert2)
				{
					emissionMask2 = 1 - emissionMask2;
				}
				
				if (_EmissionMask2GlobalMask > 0)
				{
					emissionMask2 = maskBlend(emissionMask2, poiMods.globalMask[_EmissionMask2GlobalMask - 1], _EmissionMask2GlobalMaskBlendType);
				}
				applyALEmmissionStrength(poiMods, emissionStrength2, _EmissionAL2StrengthMod, _EmissionAL2StrengthBand, _EmissionAL2Multipliers, _EmissionAL2MultipliersBand, _EmissionAL2Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength2, _AudioLinkEmission2CenterOutSize, _AudioLinkEmission2CenterOutBand, _AudioLinkEmission2CenterOut, _EmissionAL2Enabled, _AudioLinkEmission2CenterOutDuration);
				emissionStrength2 *= glowInTheDarkMultiplier2 * emissionMask2;
				emission2 = max(emissionStrength2 * emissionColor2, 0);
				
				poiFragData.emission += emission2;
				return emission2 * _EmissionReplace2;
			}
			#endif
			//endex
			//ifex _EnableEmission3==0
			#ifdef POI_EMISSION_3
			float3 applyEmission3(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiLight poiLight, in PoiCam poiCam, in PoiMods poiMods)
			{
				
				// Second Emission
				float3 emission3 = 0;
				float emissionStrength3 = 0;
				float3 emissionColor3 = 0;
				
				emissionStrength3 = _EmissionStrength3;
				
				float glowInTheDarkMultiplier3 = calculateGlowInTheDark(_GITDEMinLight3, _GITDEMaxLight3, _GITDEMinEmissionMultiplier3, _GITDEMaxEmissionMultiplier3, _EnableGITDEmission3, _GITDEWorldOrMesh3, poiLight);
				#if defined(PROP_EMISSIONMAP3) || !defined(OPTIMIZER_ENABLED)
				
				//UNITY_BRANCH
				if (!_EmissionCenterOutEnabled3)
				{
					emissionColor3 = POI2D_SAMPLER_PAN(_EmissionMap3, _MainTex, poiUV(poiMesh.uv[_EmissionMap3UV], _EmissionMap3_ST), _EmissionMap3Pan) * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap3).rgb * poiThemeColor(poiMods, _EmissionColor3.rgb, _EmissionColor3ThemeIndex);
				}
				else
				{
					emissionColor3 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap3, _MainTex, ((.5 + poiLight.nDotV * .5) * _EmissionMap3_ST.xy) + _Time.x * _EmissionCenterOutSpeed3).rgb * lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap3).rgb * poiThemeColor(poiMods, _EmissionColor3.rgb, _EmissionColor3ThemeIndex);
				}
				#else
				emissionColor3 = lerp(1, poiFragData.baseColor, _EmissionBaseColorAsMap3).rgb * poiThemeColor(poiMods, _EmissionColor3.rgb, _EmissionColor3ThemeIndex);
				#endif
				//UNITY_BRANCH
				if (_ScrollingEmission3)
				{
					float3 pos3 = poiMesh.localPos;
					//UNITY_BRANCH
					if (_EmissionScrollingVertexColor3)
					{
						pos3 = poiMesh.vertexColor.rgb;
					}
					
					//UNITY_BRANCH
					if (_EmissionScrollingUseCurve3)
					{
						#if defined(PROP_EMISSIONSCROLLINGCURVE3) || !defined(OPTIMIZER_ENABLED)
						emissionStrength3 *= UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionScrollingCurve3, _MainTex, poiUV(poiMesh.uv[_EmissionMap3UV], _EmissionScrollingCurve3_ST) + (dot(pos3, _EmissiveScroll_Direction3) * _EmissiveScroll_Interval3) + _Time.x * _EmissiveScroll_Velocity3);
						#endif
					}
					else
					{
						emissionStrength3 *= calculateScrollingEmission(_EmissiveScroll_Direction3, _EmissiveScroll_Velocity3, _EmissiveScroll_Interval3, _EmissiveScroll_Width3, _EmissionScrollingOffset3, pos3);
					}
				}
				//UNITY_BRANCH
				if (_EmissionBlinkingEnabled3)
				{
					emissionStrength3 *= calculateBlinkingEmission(_EmissiveBlink_Min3, _EmissiveBlink_Max3, _EmissiveBlink_Velocity3, _EmissionBlinkingOffset3);
				}
				
				applyLumaGradient(poiMods, emissionColor3, _EmissionColor3ThemeIndex, poiLight.nDotV);
				emissionColor3 = hueShift(emissionColor3, frac(_EmissionHueShift3 + _EmissionHueShiftSpeed3 * _Time.x) * _EmissionHueShiftEnabled3);
				#if defined(PROP_EMISSIONMASK3) || !defined(OPTIMIZER_ENABLED)
				float emissionMask3 = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMask3, _MainTex, poiUV(poiMesh.uv[_EmissionMask3UV], _EmissionMask3_ST) + _Time.x * _EmissionMask3Pan)[_EmissionMask3Channel];
				#else
				float emissionMask3 = 1;
				#endif
				
				if (_EmissionMaskInvert3)
				{
					emissionMask3 = 1 - emissionMask3;
				}
				
				if (_EmissionMask3GlobalMask > 0)
				{
					emissionMask3 = maskBlend(emissionMask3, poiMods.globalMask[_EmissionMask3GlobalMask - 1], _EmissionMask3GlobalMaskBlendType);
				}
				applyALEmmissionStrength(poiMods, emissionStrength3, _EmissionAL3StrengthMod, _EmissionAL3StrengthBand, _EmissionAL3Multipliers, _EmissionAL3MultipliersBand, _EmissionAL3Enabled);
				applyALCenterOutEmission(poiMods, poiLight.nDotV, emissionStrength3, _AudioLinkEmission3CenterOutSize, _AudioLinkEmission3CenterOutBand, _AudioLinkEmission3CenterOut, _EmissionAL3Enabled, _AudioLinkEmission3CenterOutDuration);
				emissionStrength3 *= glowInTheDarkMultiplier3 * emissionMask3;
				emission3 = max(emissionStrength3 * emissionColor3, 0);
				
				poiFragData.emission += emission3;
				return emission3 * _EmissionReplace3;
			}
			#endif
			//endex
			
			//ifex _EnableRimLighting==0 && _EnableRim2Lighting==0
			#if defined(_GLOSSYREFLECTIONS_OFF) || defined(POI_RIM2)
			#if defined(_RIMSTYLE_POIYOMI) || defined(_RIM2STYLE_POIYOMI)
			void ApplyPoiyomiRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, inout PoiMods poiMods, float Is_NormalMapToRimLight, float RimInvert, float RimPower, float RimStrength, float RimShadowWidth, float RimShadowToggle, float RimWidth, float RimBlendStrength, float RimMask, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimTex, float4 RimLightColor, float RimLightColorThemeIndex, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimSharpness, float RimShadowMaskRampType, float RimShadowMaskInvert, float RimShadowMaskStrength, float2 RimShadowAlpha, float RimApplyGlobalMaskIndex, float RimApplyGlobalMaskBlendType, float RimBaseColorMix, float RimBrightness, float RimBlendMode, half AudioLinkRimWidthBand, float2 AudioLinkRimWidthAdd, half AudioLinkRimEmissionBand, float2 AudioLinkRimEmissionAdd, half AudioLinkRimBrightnessBand, float2 AudioLinkRimBrightnessAdd, float RimClamp, float rimBias, float rimBiasIntensity)
			{
				float viewDotNormal = abs(dot(poiCam.viewDir, lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight)));
				
				UNITY_BRANCH
				if (RimInvert)
				{
					viewDotNormal = 1 - viewDotNormal;
				}
				
				viewDotNormal = pow(viewDotNormal, RimPower);
				
				if (RimShadowWidth && RimShadowToggle)
				{
					viewDotNormal += lerp(0, (1 - poiLight.nDotLNormalized) * 3, RimShadowWidth);
				}
				
				viewDotNormal *= lerp(1, rimBias, rimBiasIntensity);
				
				float rimStrength = RimStrength;
				
				float rimWidth = lerp( - .05, 1, RimWidth);
				
				float blendStrength = RimBlendStrength;
				#ifdef POI_AUDIOLINK
				UNITY_BRANCH
				if (poiMods.audioLinkAvailable)
				{
					rimWidth = clamp(rimWidth + lerp(AudioLinkRimWidthAdd.x, AudioLinkRimWidthAdd.y, poiMods.audioLink[AudioLinkRimWidthBand]), - .05, 1);
					rimStrength += lerp(AudioLinkRimEmissionAdd.x, AudioLinkRimEmissionAdd.y, poiMods.audioLink[AudioLinkRimEmissionBand]);
					blendStrength += lerp(AudioLinkRimBrightnessAdd.x, AudioLinkRimBrightnessAdd.y, poiMods.audioLink[AudioLinkRimBrightnessBand]);
				}
				#endif
				
				float rimMask = RimMask;
				
				if (RimGlobalMask > 0)
				{
					rimMask = maskBlend(rimMask, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				
				float4 rimColor = RimTex;
				rimColor *= float4(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex), RimLightColor.a);
				
				UNITY_BRANCH
				if (RimHueShiftEnabled)
				{
					rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				
				float rim = 1 - smoothstep(min(RimSharpness, rimWidth), rimWidth, viewDotNormal);
				rim *= RimLightColor.a * rimColor.a * rimMask;
				
				if (RimShadowToggle)
				{
					switch(RimShadowMaskRampType)
					{
						case 0:
						float rampedLightMap = poiLight.rampedLightMap;
						if (RimShadowMaskInvert) rampedLightMap = 1 - rampedLightMap;
						rim = lerp(rim, rim * rampedLightMap, RimShadowMaskStrength);
						break;
						case 1:
						float nDotLNormalized = poiLight.nDotLNormalized;
						if (RimShadowMaskInvert) nDotLNormalized = 1 - nDotLNormalized;
						rim = lerp(rim, rim * smoothstep(RimShadowAlpha.x, RimShadowAlpha.y, nDotLNormalized), RimShadowMaskStrength);
						break;
					}
				}
				
				if (RimApplyGlobalMaskIndex > 0)
				{
					applyToGlobalMask(poiMods, RimApplyGlobalMaskIndex-1, RimApplyGlobalMaskBlendType, rim * blendStrength);
				}
				
				float3 finalRimColor = rimColor.rgb * lerp(1, poiFragData.baseColor, RimBaseColorMix);
				finalRimColor *= RimBrightness;
				// Add 0, Replace 1, Multiply 2, Mixed 3
				switch(RimBlendMode)
				{
					case 0: poiFragData.baseColor += finalRimColor * rim * blendStrength; break;
					case 1: poiFragData.baseColor = lerp(poiFragData.baseColor, finalRimColor, rim * blendStrength); break;
					case 2: poiFragData.baseColor = lerp(poiFragData.baseColor, poiFragData.baseColor * finalRimColor, rim * blendStrength); break;
					case 3: poiFragData.baseColor = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * finalRimColor, rim * blendStrength); break;
				}
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
				poiFragData.emission += finalRimColor * rim * rimStrength;
			}
			#endif
			#if defined(_RIMSTYLE_UTS2) || defined(_RIM2STYLE_UTS2)
			void ApplyUTS2RimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float Set_RimLightMask_var, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimLightColor, float RimLightColorThemeIndex, float Is_LightColor_RimLight, float Is_NormalMapToRimLight, float RimLight_Power, float RimLight_InsideMask, float RimLight_FeatherOff, float LightDirection_MaskOn, float Tweak_LightDirection_MaskLevel, float Add_Antipodean_RimLight, float4 Ap_RimLightColor, float RimApColorThemeIndex, float Is_LightColor_Ap_RimLight, float Ap_RimLight_Power, float Ap_RimLight_FeatherOff, float Tweak_RimLightMaskLevel, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimClamp)
			{
				if (RimGlobalMask > 0)
				{
					Set_RimLightMask_var = maskBlend(Set_RimLightMask_var, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				
				float3 rimColor = float3(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex));
				float3 _Is_LightColor_RimLight_var = lerp(rimColor, (rimColor * poiLight.directColor), Is_LightColor_RimLight);
				float _RimArea_var = (1.0 - dot(lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight), poiCam.viewDir));
				float _RimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, RimLight_Power)));
				float _Rimlight_InsideMask_var = saturate(lerp((0.0 + ((_RimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _RimLightPower_var), RimLight_FeatherOff));
				float _VertHalfLambert_var = 0.5 * dot(poiMesh.normals[0], poiLight.direction) + 0.5;
				float3 _LightDirection_MaskOn_var = lerp((_Is_LightColor_RimLight_var * _Rimlight_InsideMask_var), (_Is_LightColor_RimLight_var * saturate((_Rimlight_InsideMask_var - ((1.0 - _VertHalfLambert_var) + Tweak_LightDirection_MaskLevel)))), LightDirection_MaskOn);
				float _ApRimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, Ap_RimLight_Power)));
				float3 ApRimColor = float3(poiThemeColor(poiMods, Ap_RimLightColor.rgb, RimApColorThemeIndex));
				float3 _RimLight_var = (saturate((Set_RimLightMask_var + Tweak_RimLightMaskLevel)) * lerp(_LightDirection_MaskOn_var, (_LightDirection_MaskOn_var + (lerp(ApRimColor, (ApRimColor * poiLight.directColor), Is_LightColor_Ap_RimLight) * saturate((lerp((0.0 + ((_ApRimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _ApRimLightPower_var), Ap_RimLight_FeatherOff) - (saturate(_VertHalfLambert_var) + Tweak_LightDirection_MaskLevel))))), Add_Antipodean_RimLight));
				UNITY_BRANCH
				if (RimHueShiftEnabled)
				{
					_RimLight_var = hueShift(_RimLight_var, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				poiFragData.baseColor += _RimLight_var;
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
			}
			#endif
			#if defined(_RIMSTYLE_LILTOON) || defined(_RIM2STYLE_LILTOON)
			void ApplyLiltoonRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float4 RimColor, float4 RimIndirColor, float4 RimColorTex, float RimMainStrength, float RimNormalStrength, float RimDirRange, float RimIndirRange, float RimFresnelPower, float RimBackfaceMask, float RimDirStrength, float RimBorder, float RimBlur, float RimIndirBorder, float RimIndirBlur, float RimShadowMask, float RimEnableLighting, float RimVRParallaxStrength, float RimGlobalMask, float RimGlobalMaskBlendType, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftSpeed, float RimClamp)
			{
				if (RimGlobalMask > 0)
				{
					RimColorTex.a = maskBlend(RimColorTex.a, poiMods.globalMask[RimGlobalMask-1], RimGlobalMaskBlendType);
				}
				float4 rimColor = RimColor;
				float4 rimIndirColor = RimIndirColor;
				rimColor *= RimColorTex;
				rimIndirColor *= RimColorTex;
				
				if (RimHueShiftEnabled)
				{
					rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
					rimIndirColor.rgb = hueShift(rimIndirColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed);
				}
				
				rimColor.rgb = lerp(rimColor.rgb, rimColor.rgb * poiFragData.baseColor, RimMainStrength);
				
				// View direction
				float3 centerViewDir = !IsOrthographicCamera() ? normalize(getCameraPosition() - poiMesh.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 viewDir = lerp(centerViewDir, poiCam.viewDir, RimVRParallaxStrength);
				
				// Normal
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], RimNormalStrength);
				float nvabs = abs(dot(normal, viewDir));
				
				// Factor
				float lnRaw = dot(poiLight.direction, normal) * 0.5 + 0.5;
				float lnDir = saturate((lnRaw + RimDirRange) / (1.0 + RimDirRange));
				float lnIndir = saturate((1.0-lnRaw + RimIndirRange) / (1.0 + RimIndirRange));
				float rim = pow(saturate(1.0 - nvabs), RimFresnelPower);
				rim = !poiMesh.isFrontFace && RimBackfaceMask ? 0.0 : rim;
				float rimDir = lerp(rim, rim * lnDir, RimDirStrength);
				float rimIndir = rim * lnIndir * RimDirStrength;
				
				rimDir = poiEdgeLinear(rimDir, RimBorder, RimBlur);
				rimIndir = poiEdgeLinear(rimIndir, RimIndirBorder, RimIndirBlur);
				
				rimDir = lerp(rimDir, rimDir * poiLight.rampedLightMap, RimShadowMask);
				rimIndir = lerp(rimIndir, rimIndir * poiLight.rampedLightMap, RimShadowMask);
				
				// Blend
				float3 rimSum = rimDir * rimColor.a * rimColor.rgb + rimIndir * rimIndirColor.a * rimIndirColor.rgb;
				poiFragData.baseColor += rimSum * RimEnableLighting;
				poiFragData.emission += rimSum * (1-RimEnableLighting);
				if(RimClamp)
				{
					poiFragData.baseColor = saturate(poiFragData.baseColor);
				}
			}
			#endif
			#endif
			//endex
			
			//ifex _EnableDepthRimLighting==0
			#ifdef _POI_DEPTH_RIMLIGHT
			
			float PositivePow(float base, float power)
			{
				return pow(max(abs(base), Epsilon), power);
			}
			
			float GetScaleWithHight()
			{
				return _ScreenParams.y / 1080;
			}
			
			float GetSSRimScale(float z)
			{
				float w = (1.0 / (PositivePow(z + saturate(UNITY_MATRIX_P._m00), 1.5) + 0.75)) * GetScaleWithHight();
				w *= lerp(1, UNITY_MATRIX_P._m00, 0.60 * saturate(0.25 * z * z));
				return w < 0.01 ? 0 : w;
			}
			
			void ApplyDepthRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiLight poiLight, in PoiMods poiMods)
			{
				float rim = 0;
				float perspectiveDivide = 1.0f / poiCam.clipPos.w;
				float4 direction = poiCam.worldDirection * perspectiveDivide;
				float2 screenPos = poiCam.grabPos.xy * perspectiveDivide;
				float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, screenPos);
				
				#if UNITY_REVERSED_Z
				if (z == 0) return;
				#else
				if (z == 1) return;
				#endif
				
				float depth = CorrectedLinearEyeDepth(z, direction.w);
				
				switch(_DepthRimType)
				{
					case 0:
					{
						float3 viewPos = UnityObjectToViewPos(poiMesh.localPos);
						float3 viewDir = normalize(viewPos);
						
						float3 viewNorm = mul((float3x3)UNITY_MATRIX_V, poiMesh.normals[_DepthRimNormalToUse]);
						float3 viewCrossNorm = cross(viewDir, viewNorm);
						float2 N_View = normalize(float2(-viewCrossNorm.y, viewCrossNorm.x));
						
						float3 viewLight = mul((float3x3)UNITY_MATRIX_V, poiLight.direction);
						float3 viewCrossLight = cross(viewDir, viewLight);
						float2 L_View = normalize(float2(-viewCrossLight.y, viewCrossLight.x));
						
						//float lDotN = saturate(poiLight.nDotL + _RimLightLength);
						float scale = _DepthRimWidth * GetSSRimScale(depth);
						float2 ssUV1 = clamp(screenPos + N_View * .1 * scale, 0, _ScreenParams.xy - 1);
						float depthDiff = z - SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, ssUV1) ;
						
						rim = smoothstep(0.24 * _DepthRimSharpness * z, 0.25 * z, depthDiff);
						rim *= lerp(1, (dot(L_View, N_View) > 0), _DepthRimHideInShadow);
					}
					break;
					case 1:
					{
						//float lDotN = saturate(poiLight.nDotL + _RimLightLength);
						float scale = _DepthRimWidth * GetSSRimScale(depth);
						float depthDiff = 0;
						for (int i = 0; i < 9; i++)
						{
							float2 ssUV1 = clamp(screenPos + sobelSamplePoints[i] * .1 * scale, 0, _ScreenParams.xy - 1);
							depthDiff = max(depthDiff, z - SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, ssUV1));
						}
						rim = smoothstep(0.24 * _DepthRimSharpness * z, 0.25 * z, depthDiff);
						rim *= lerp(1, lerp(poiLight.vertexNDotL > 0, poiLight.nDotL > 0, _DepthRimNormalToUse), _DepthRimHideInShadow);
					}
					break;
				}
				
				float3 rimColor = poiThemeColor(poiMods, _DepthRimColor.rgb, _DepthRimColorThemeIndex).rgb * lerp(1, poiLight.directColor, _DepthRimMixLightColor) * lerp(1, poiFragData.baseColor, _DepthRimMixBaseColor) * _DepthRimBrightness;
				
				poiLight.finalLightAdd += rim * rimColor * _DepthRimAdditiveLighting;
				poiFragData.emission += rim * rimColor * _DepthRimEmission;
				poiFragData.baseColor = lerp(poiFragData.baseColor, rimColor, rim * _DepthRimReplace);
				poiFragData.baseColor += rim * rimColor * _DepthRimAdd;
				poiFragData.baseColor *= lerp(1, rimColor, rim * _DepthRimMultiply);
			}
			#endif
			//endex
			
			//ifex _GlitterEnable==0
			#ifdef _SUNDISK_SIMPLE
			
			float3 RandomColorFromPoint(float2 rando)
			{
				fixed hue = random2(rando.x + rando.y).x;
				fixed saturation = lerp(_GlitterMinMaxSaturation.x, _GlitterMinMaxSaturation.y, rando.x);
				fixed value = lerp(_GlitterMinMaxBrightness.x, _GlitterMinMaxBrightness.y, rando.y);
				float3 hsv = float3(hue, saturation, value);
				return HSVtoRGB(hsv);
			}
			
			void applyGlitter(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods)
			{
				// Scale
				float2 st = frac(poiMesh.uv[_GlitterUV] + _GlitterUVPanning.xy * _Time.x) * _GlitterFrequency;
				
				// Tile the space
				float2 i_st = floor(st);
				float2 f_st = frac(st);
				
				float m_dist = 10.;  // minimun distance
				float2 m_point = 0;        // minimum point
				float2 randoPoint = 0;
				float2 dank;
				for (int j = -1; j <= 1; j++)
				{
					for (int i = -1; i <= 1; i++)
					{
						float2 neighbor = float2(i, j);
						float2 pos = random2(i_st + neighbor);
						float2 rando = pos;
						pos = 0.5 + 0.5 * sin(_GlitterJitter * 6.2831 * pos);
						float2 diff = neighbor + pos - f_st;
						float dist = length(diff);
						
						if (dist < m_dist)
						{
							dank = diff;
							m_dist = dist;
							m_point = pos;
							randoPoint = rando;
						}
					}
				}
				
				float randomFromPoint = random(randoPoint);
				
				float size = _GlitterSize;
				UNITY_BRANCH
				if (_GlitterRandomSize)
				{
					size = remapClamped(0, 1, randomFromPoint, _GlitterMinMaxSize.x, _GlitterMinMaxSize.y);
				}
				
				// Assign a color using the closest point position
				//color += dot(m_point, float2(.3, .6));
				
				// Add distance field to closest point center
				// color.g = m_dist;
				
				// Show isolines
				//color -= abs(sin(40.0 * m_dist)) * 0.07;
				
				// Draw cell center
				half glitterAlpha = 1;
				switch(_GlitterShape)
				{
					case 0: //circle
					glitterAlpha = saturate((size - m_dist) / clamp(fwidth(m_dist), 0.0001, 1.0));
					break;
					case 1: //sqaure
					float jaggyFix = pow(poiCam.distanceToVert, 2) * _GlitterJaggyFix;
					
					UNITY_BRANCH
					if (_GlitterRandomRotation == 1 || _GlitterTextureRotation != 0)
					{
						float2 center = float2(0, 0);
						float randomBoy = 0;
						UNITY_BRANCH
						if (_GlitterRandomRotation)
						{
							randomBoy = random(randoPoint);
						}
						float theta = radians((randomBoy + _Time.x * _GlitterTextureRotation) * 360);
						float cs = cos(theta);
						float sn = sin(theta);
						dank = float2((dank.x - center.x) * cs - (dank.y - center.y) * sn + center.x, (dank.x - center.x) * sn + (dank.y - center.y) * cs + center.y);
						glitterAlpha = (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.x))) * (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.y)));
					}
					else
					{
						glitterAlpha = (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.x))) * (1. - smoothstep(size - .1 * jaggyFix, size, abs(dank.y)));
					}
					break;
				}
				
				float3 finalGlitter = 0;
				
				half3 glitterColor = poiThemeColor(poiMods, _GlitterColor, _GlitterColorThemeIndex);
				
				float3 norm = lerp(poiMesh.normals[0], poiMesh.normals[1], _GlitterUseNormals);
				float3 randomRotation = 0;
				switch(_GlitterMode)
				{
					case 0:
					UNITY_BRANCH
					if (_GlitterSpeed > 0)
					{
						randomRotation = randomFloat3WiggleRange(randoPoint, _GlitterAngleRange, _GlitterSpeed);
					}
					else
					{
						randomRotation = randomFloat3Range(randoPoint, _GlitterAngleRange);
					}
					
					float3 glitterReflectionDirection = normalize(mul(poiRotationMatrixFromAngles(randomRotation), norm));
					finalGlitter = lerp(0, _GlitterMinBrightness * glitterAlpha, glitterAlpha) + max(pow(saturate(dot(lerp(glitterReflectionDirection, poiCam.viewDir, _GlitterBias), poiCam.viewDir)), _GlitterContrast), 0);
					finalGlitter *= glitterAlpha;
					break;
					case 1:
					float offset = random(randoPoint);
					float brightness = sin((_Time.x + offset) * _GlitterSpeed) * _glitterFrequencyLinearEmissive - (_glitterFrequencyLinearEmissive - 1);
					finalGlitter = max(_GlitterMinBrightness * glitterAlpha, brightness * glitterAlpha * smoothstep(0, 1, 1 - m_dist * _GlitterCenterSize * 10));
					break;
					case 2:
					if (_GlitterSpeed > 0)
					{
						randomRotation = randomFloat3WiggleRange(randoPoint, _GlitterAngleRange, _GlitterSpeed);
					}
					else
					{
						randomRotation = randomFloat3Range(randoPoint, _GlitterAngleRange);
					}
					
					float3 glitterLightReflectionDirection = normalize(mul(poiRotationMatrixFromAngles(randomRotation), norm));
					
					#ifdef POI_PASS_ADD
					glitterAlpha *= poiLight.nDotLSaturated * poiLight.attenuation;
					#endif
					#ifdef UNITY_PASS_FORWARDBASE
					glitterAlpha *= poiLight.nDotLSaturated;
					#endif
					
					float3 halfDir = normalize(poiLight.direction + poiCam.viewDir);
					float specAngle = max(dot(halfDir, glitterLightReflectionDirection), 0.0);
					
					finalGlitter = lerp(0, _GlitterMinBrightness * glitterAlpha, glitterAlpha) + max(pow(specAngle, _GlitterContrast), 0);
					
					glitterColor *= poiLight.directColor;
					finalGlitter *= glitterAlpha;
					
					break;
				}
				
				glitterColor *= lerp(1, poiFragData.baseColor, _GlitterUseSurfaceColor);
				#if defined(PROP_GLITTERCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				glitterColor *= POI2D_SAMPLER_PAN(_GlitterColorMap, _MainTex, poiUV(poiMesh.uv[_GlitterColorMapUV], _GlitterColorMap_ST), _GlitterColorMapPan).rgb;
				#endif
				float2 uv = remapClamped(-size, size, dank, 0, 1);
				UNITY_BRANCH
				if (_GlitterRandomRotation == 1 || _GlitterTextureRotation != 0 && !_GlitterShape)
				{
					float2 fakeUVCenter = float2(.5, .5);
					float randomBoy = 0;
					UNITY_BRANCH
					if (_GlitterRandomRotation)
					{
						randomBoy = random(randoPoint);
					}
					float theta = radians((randomBoy + _Time.x * _GlitterTextureRotation) * 360);
					float cs = cos(theta);
					float sn = sin(theta);
					uv = float2((uv.x - fakeUVCenter.x) * cs - (uv.y - fakeUVCenter.y) * sn + fakeUVCenter.x, (uv.x - fakeUVCenter.x) * sn + (uv.y - fakeUVCenter.y) * cs + fakeUVCenter.y);
				}
				
				#if defined(PROP_GLITTERTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 glitterTexture = POI2D_SAMPLER_PAN(_GlitterTexture, _MainTex, poiUV(uv, _GlitterTexture_ST), _GlitterTexturePan);
				#else
				float4 glitterTexture = 1;
				#endif
				//float4 glitterTexture = _GlitterTexture.SampleGrad(sampler_MainTex, frac(uv), ddx(uv), ddy(uv));
				glitterColor *= glitterTexture.rgb;
				#if defined(PROP_GLITTERMASK) || !defined(OPTIMIZER_ENABLED)
				float glitterMask = POI2D_SAMPLER_PAN(_GlitterMask, _MainTex, poiUV(poiMesh.uv[_GlitterMaskUV], _GlitterMask_ST), _GlitterMaskPan)[_GlitterMaskChannel];
				#else
				float glitterMask = 1;
				#endif
				
				glitterMask *= lerp(1, poiLight.rampedLightMap, _GlitterHideInShadow);
				
				if (_GlitterMaskGlobalMask > 0)
				{
					glitterMask = maskBlend(glitterMask, poiMods.globalMask[_GlitterMaskGlobalMask - 1], _GlitterMaskGlobalMaskBlendType);
				}
				
				if (_GlitterRandomColors)
				{
					glitterColor *= RandomColorFromPoint(random2(randoPoint.x + randoPoint.y));
				}
				
				UNITY_BRANCH
				if (_GlitterHueShiftEnabled)
				{
					glitterColor.rgb = hueShift(glitterColor.rgb, _GlitterHueShift + _Time.x * _GlitterHueShiftSpeed);
				}
				
				UNITY_BRANCH
				if (_GlitterBlendType == 1)
				{
					poiFragData.baseColor = lerp(poiFragData.baseColor, finalGlitter * glitterColor * _GlitterBrightness, finalGlitter * glitterTexture.a * glitterMask);
					poiFragData.emission += finalGlitter * glitterColor * max(0, (_GlitterBrightness - 1) * glitterTexture.a) * glitterMask;
				}
				else
				{
					poiFragData.emission += finalGlitter * glitterColor * _GlitterBrightness * glitterTexture.a * glitterMask;
				}
			}
			#endif
			//endex
			
			//ifex _EnablePathing==0
			#ifdef POI_PATHING
			void applyPathing(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float3 albedo = poiFragData.baseColor;
				float3 pathEmission;
				#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
				float4 path = _PathingMap.Sample(SmpRepeatPoint, poiUV(poiMesh.uv[_PathingMapUV], _PathingMap_ST) + _PathingMapPan.xy * _Time.x);
				#else
				float4 path = float4(1, 1, 1, 1);
				#endif
				float4 PathColor[4];
				half pathAudioLinkPathTimeOffsetBand[4] = {
					0, 0, 0, 0
				};
				half2 pathAudioLinkTimeOffset[4] = {
					half2(0, 0), half2(0, 0), half2(0, 0), half2(0, 0)
				};
				half pathAudioLinkPathWidthOffsetBand[4] = {
					0, 0, 0, 0
				};
				half2 pathAudioLinkWidthOffset[4] = {
					half2(0, 0), half2(0, 0), half2(0, 0), half2(0, 0)
				};
				PathColor[0] = _PathColorR;
				PathColor[1] = _PathColorG;
				PathColor[2] = _PathColorB;
				PathColor[3] = _PathColorA;
				
				// Combined data
				if (_PathGradientType == 1)
				{
					path = (path.r + path.g + path.b + path.a) * .25;
				}
				
				#if defined(PROP_PATHINGCOLORMAP) || !defined(OPTIMIZER_ENABLED)
				float4 pathColorMap = POI2D_SAMPLER_PAN(_PathingColorMap, _MainTex, poiUV(poiMesh.uv[_PathingColorMapUV], _PathingColorMap_ST), _PathingColorMapPan);
				#else
				float4 pathColorMap = float4(1, 1, 1, 1);
				#endif
				
				float4 pathAudioLinkEmission = 0;
				float4 pathTime = 0;
				float3 pathAlpha[4] = {
					float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0), float3(0.0, 0.0, 0.0)
				};
				
				#ifdef POI_AUDIOLINK
				float4 chronoType = float4(_PathChronoTypeR, _PathChronoTypeG, _PathChronoTypeB, _PathChronoTypeA);
				float4 chronoBand = float4(_PathChronoBandR, _PathChronoBandG, _PathChronoBandB, _PathChronoBandA);
				float4 chronoSpeed = float4(_PathChronoSpeedR, _PathChronoSpeedG, _PathChronoSpeedB, _PathChronoSpeedA);
				float3 autoCorrelator[4] = {
					float3(_PathALAutoCorrelatorR, _PathALAutoCorrelatorRangeR[0], _PathALAutoCorrelatorRangeR[1]), float3(_PathALAutoCorrelatorG, _PathALAutoCorrelatorRangeG[0], _PathALAutoCorrelatorRangeG[1]),
					float3(_PathALAutoCorrelatorB, _PathALAutoCorrelatorRangeB[0], _PathALAutoCorrelatorRangeB[1]), float3(_PathALAutoCorrelatorA, _PathALAutoCorrelatorRangeA[0], _PathALAutoCorrelatorRangeA[1])
				};
				float4 history[4] = {
					float4(_PathALHistoryR, _PathALHistoryBandR, _PathALHistoryRangeR[0], _PathALHistoryRangeR[1]), float4(_PathALHistoryG, _PathALHistoryBandG, _PathALHistoryRangeG[0], _PathALHistoryRangeG[1]),
					float4(_PathALHistoryB, _PathALHistoryBandB, _PathALHistoryRangeB[0], _PathALHistoryRangeB[1]), float4(_PathALHistoryA, _PathALHistoryBandA, _PathALHistoryRangeA[0], _PathALHistoryRangeA[1])
				};
				
				if (poiMods.audioLinkAvailable)
				{
					if (_PathALTimeOffset)
					{
						pathAudioLinkPathTimeOffsetBand[0] = _AudioLinkPathTimeOffsetBandR;
						pathAudioLinkPathTimeOffsetBand[1] = _AudioLinkPathTimeOffsetBandG;
						pathAudioLinkPathTimeOffsetBand[2] = _AudioLinkPathTimeOffsetBandB;
						pathAudioLinkPathTimeOffsetBand[3] = _AudioLinkPathTimeOffsetBandA;
						pathAudioLinkTimeOffset[0] = _AudioLinkPathTimeOffsetR.xy;
						pathAudioLinkTimeOffset[1] = _AudioLinkPathTimeOffsetG.xy;
						pathAudioLinkTimeOffset[2] = _AudioLinkPathTimeOffsetB.xy;
						pathAudioLinkTimeOffset[3] = _AudioLinkPathTimeOffsetA.xy;
					}
					
					if (_PathALWidthOffset)
					{
						pathAudioLinkPathWidthOffsetBand[0] = _AudioLinkPathWidthOffsetBandR;
						pathAudioLinkPathWidthOffsetBand[1] = _AudioLinkPathWidthOffsetBandG;
						pathAudioLinkPathWidthOffsetBand[2] = _AudioLinkPathWidthOffsetBandB;
						pathAudioLinkPathWidthOffsetBand[3] = _AudioLinkPathWidthOffsetBandA;
						pathAudioLinkWidthOffset[0] = _AudioLinkPathWidthOffsetR.xy;
						pathAudioLinkWidthOffset[1] = _AudioLinkPathWidthOffsetG.xy;
						pathAudioLinkWidthOffset[2] = _AudioLinkPathWidthOffsetB.xy;
						pathAudioLinkWidthOffset[3] = _AudioLinkPathWidthOffsetA.xy;
					}
					// Emission Offset
					if (_PathALEmissionOffset)
					{
						pathAudioLinkEmission.r += lerp(_AudioLinkPathEmissionAddR.x, _AudioLinkPathEmissionAddR.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandR]);
						pathAudioLinkEmission.g += lerp(_AudioLinkPathEmissionAddG.x, _AudioLinkPathEmissionAddG.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandG]);
						pathAudioLinkEmission.b += lerp(_AudioLinkPathEmissionAddB.x, _AudioLinkPathEmissionAddB.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandB]);
						pathAudioLinkEmission.a += lerp(_AudioLinkPathEmissionAddA.x, _AudioLinkPathEmissionAddA.y, poiMods.audioLink[_AudioLinkPathEmissionAddBandA]);
					}
					
					if(_PathALColorChord)
					{
						if (_PathALCCR)
						{
							PathColor[0] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[0] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCG)
						{
							PathColor[1] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[1] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCB)
						{
							PathColor[2] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[2] * AUDIOLINK_WIDTH, 0));
						}
						if (_PathALCCA)
						{
							PathColor[3] *= AudioLinkLerp(ALPASS_CCSTRIP + float2(path[3] * AUDIOLINK_WIDTH, 0));
						}
					}
				}
				#endif
				
				[unroll]
				for (int index = 0; index < 4; index++)
				{
					float timeOffset = 0;
					#ifdef POI_AUDIOLINK
					UNITY_BRANCH
					if (poiMods.audioLinkAvailable)
					{
						if (_PathALTimeOffset)
						{
							timeOffset += lerp(pathAudioLinkTimeOffset[index].x, pathAudioLinkTimeOffset[index].y, poiMods.audioLink[pathAudioLinkPathTimeOffsetBand[index]]);
						}
						
						if (_PathALChrono)
						{
							timeOffset += AudioLinkGetChronoTime(chronoType[index], chronoBand[index]) * chronoSpeed[index];
						}
					}
					#endif
					pathTime[index] = _PathTime[index] != -999.0f ? frac(_PathTime[index] + _PathOffset[index] + timeOffset) : frac(_Time.x * _PathSpeed[index] + _PathOffset[index] + timeOffset);
					
					if (_PathSegments[index])
					{
						float pathSegments = abs(_PathSegments[index]);
						pathTime = (ceil(pathTime * pathSegments) - .5) / pathSegments;
					}
					
					if (path[index])
					{
						// Cutting it in half because it goes out in both directions for now
						half pathWidth = _PathWidth[index] * .5;
						#ifdef POI_AUDIOLINK
						UNITY_BRANCH
						if (poiMods.audioLinkAvailable)
						{
							if (_PathALWidthOffset)
							{
								pathWidth += lerp(pathAudioLinkWidthOffset[index].x, pathAudioLinkWidthOffset[index].y, poiMods.audioLink[pathAudioLinkPathWidthOffsetBand[index]]);
							}
						}
						#endif
						
						//fill
						pathAlpha[index].x = pathTime[index] > path[index];
						//path
						pathAlpha[index].y = saturate((1 - abs(lerp(-pathWidth, 1 + pathWidth, pathTime[index]) - path[index])) - (1 - pathWidth)) * (1 / pathWidth);
						//loop
						pathAlpha[index].z = saturate((1 - distance(pathTime[index], path[index])) - (1 - pathWidth)) * (1 / pathWidth);
						pathAlpha[index].z += saturate(distance(pathTime[index], path[index]) - (1 - pathWidth)) * (1 / pathWidth);
						pathAlpha[index] = smoothstep(0, _PathSoftness[index] + .00001, pathAlpha[index]);
						
						#ifdef POI_AUDIOLINK
						if (poiMods.audioLinkAvailable)
						{
							if (_PathALHistory && history[index][0])
							{
								// history[index]: [0]: on/off, [1]: band, [2]/[3] min/max
								float historyUV = lerp(history[index][2], history[index][3], path[index]);
								
								if (_PathSegments[index])
								{
									float pathSegments = abs(_PathSegments[index]);
									historyUV = (ceil(historyUV * pathSegments) - .5) / pathSegments;
								}
								
								historyUV *= AUDIOLINK_WIDTH;
								
								float historyValue = AudioLinkLerp(ALPASS_AUDIOLINK + float2(historyUV, history[index][1]))[0];
								
								if(_PathALHistoryMode == 0) // Mask
								pathAlpha[index] *= historyValue;
								else // Override
								pathAlpha[index] = historyValue;
							}
							
							if (_PathALAutoCorrelator && autoCorrelator[index][0] != 0)
							{
								// autoCorrelator[index]: [0]: on/off, [1]/[2]: min/max
								// Choose from only part of the autocorrelator
								float autoCorrelatorUV = lerp(autoCorrelator[index][1], autoCorrelator[index][2], path[index]);
								if (autoCorrelator[index][0] == 2) // Mirror
								{
									autoCorrelatorUV = abs(1. - autoCorrelatorUV * 2.);
								}
								
								if (_PathSegments[index])
								{
									float pathSegments = abs(_PathSegments[index]);
									autoCorrelatorUV = (ceil(autoCorrelatorUV * pathSegments) - .5) / pathSegments;
								}
								
								// Normalize Autocorrelator Value
								float autoCorrelatorValue = AudioLinkLerp(ALPASS_AUTOCORRELATOR + float2(autoCorrelatorUV * AUDIOLINK_WIDTH, 0))[0];
								float autoCorrelatorMax = AudioLinkLerp(ALPASS_AUTOCORRELATOR);
								autoCorrelatorValue = saturate(abs(autoCorrelatorValue) * rcp(autoCorrelatorMax));
								
								// Autocorrelator is normalized, so can look weird at lower volume levels. use Filtered VU intensity to make it smoothly fall off at low volume levels.
								float4 vu = AudioLinkData(ALPASS_FILTEREDVU_INTENSITY + uint2(0, 0));
								autoCorrelatorValue *= smoothstep(0.01, 0.2, vu);
								
								if(_PathALAutoCorrelatorMode == 0) // Mask
								pathAlpha[index] *= autoCorrelatorValue;
								else // Override
								pathAlpha[index] = autoCorrelatorValue;
								
							}
						}
						#endif
					}
				}
				
				// Emission
				pathEmission = 0;
				pathEmission += pathAlpha[0][_PathTypeR] * poiThemeColor(poiMods, PathColor[0].rgb, _PathColorRThemeIndex) * (_PathEmissionStrength[0] + pathAudioLinkEmission.r);
				pathEmission += pathAlpha[1][_PathTypeG] * poiThemeColor(poiMods, PathColor[1].rgb, _PathColorGThemeIndex) * (_PathEmissionStrength[1] + pathAudioLinkEmission.g);
				pathEmission += pathAlpha[2][_PathTypeB] * poiThemeColor(poiMods, PathColor[2].rgb, _PathColorBThemeIndex) * (_PathEmissionStrength[2] + pathAudioLinkEmission.b);
				pathEmission += pathAlpha[3][_PathTypeA] * poiThemeColor(poiMods, PathColor[3].rgb, _PathColorAThemeIndex) * (_PathEmissionStrength[3] + pathAudioLinkEmission.a);
				pathEmission *= pathColorMap.rgb * pathColorMap.a;
				
				float3 colorReplace = 0;
				colorReplace = pathAlpha[0][_PathTypeR] * poiThemeColor(poiMods, PathColor[0].rgb, _PathColorRThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[0].a * pathAlpha[0][_PathTypeR]);
				colorReplace = pathAlpha[1][_PathTypeG] * poiThemeColor(poiMods, PathColor[1].rgb, _PathColorGThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[1].a * pathAlpha[1][_PathTypeG]);
				colorReplace = pathAlpha[2][_PathTypeB] * poiThemeColor(poiMods, PathColor[2].rgb, _PathColorBThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[2].a * pathAlpha[2][_PathTypeB]);
				colorReplace = pathAlpha[3][_PathTypeA] * poiThemeColor(poiMods, PathColor[3].rgb, _PathColorAThemeIndex) * pathColorMap.rgb;
				albedo.rgb = lerp(albedo.rgb, colorReplace + albedo.rgb * 0.00001, pathColorMap.a * PathColor[3].a * pathAlpha[3][_PathTypeA]);
				
				float alpha = max(max(max(pathAlpha[0][_PathTypeR], pathAlpha[1][_PathTypeG]), pathAlpha[2][_PathTypeB]), pathAlpha[3][_PathTypeA]);
				
				poiFragData.alpha *= lerp(1, alpha, _PathingOverrideAlpha);
				poiFragData.baseColor = albedo.rgb;
				poiFragData.emission += pathEmission;
			}
			#endif
			//endex
			
			//ifex _EnableMirrorOptions==0
			#ifdef POI_MIRROR
			void applyMirror(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
			{
				float inMirror = 0;
				if (_VisibilityMode == 1) // VRC
				inMirror = VRCMirrorMode() > 0;
				else // Generic (CVR, etc)
				inMirror = IsInMirror();
				
				#if (defined(POI_PASS_BASE) || defined(POI_PASS_ADD))
				#if defined(PROP_MIRRORTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 mirrorTexture = POI2D_SAMPLER_PAN(_MirrorTexture, _MainTex, poiUV(poiMesh.uv[_MirrorTextureUV], _MirrorTexture_ST), _MirrorTexturePan);
				if (inMirror)
				{
					poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, mirrorTexture.rgb, _MirrorTextureBlendType), mirrorTexture.a * _MirrorColor.a);
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#else
				if (inMirror)
				{
					poiFragData.baseColor.rgb *= lerp(1, poiThemeColor(poiMods, _MirrorColor.rgb, _MirrorColorThemeIndex), _MirrorColor.a);
				}
				#endif
				#endif
			}
			#endif
			//endex
			
			//ifex _PostProcess==0
			#ifdef POSTPROCESS
			float3 poiPosterize(float3 color, float steps)
			{
				float3 newColor = color;
				steps = floor(steps);
				newColor.r = floor(newColor.r * steps) / steps;
				newColor.g = floor(newColor.g * steps) / steps;
				newColor.b = floor(newColor.b * steps) / steps;
				return newColor;
			}
			
			float oetf_sRGB_scalar(float L)
			{
				float V = 1.055 * (pow(L, 1.0 / 2.4)) - 0.055;
				if (L <= 0.0031308)
				V = L * 12.92;
				return V;
			}
			
			float3 oetf_sRGB(float3 L)
			{
				return float3(oetf_sRGB_scalar(L.r), oetf_sRGB_scalar(L.g), oetf_sRGB_scalar(L.b));
			}
			
			float eotf_sRGB_scalar(float V)
			{
				float L = pow((V + 0.055) / 1.055, 2.4);
				if (V <= oetf_sRGB_scalar(0.0031308))
				L = V / 12.92;
				return L;
			}
			
			float3 GetHDR(float3 rgb)
			{
				return float3(eotf_sRGB_scalar(rgb.r), eotf_sRGB_scalar(rgb.g), eotf_sRGB_scalar(rgb.b));
			}
			
			float3 GetContrast(float3 col, float contrast)
			{
				return lerp(float3(0.5, 0.5, 0.5), col, contrast);
			}
			
			float3 GetSaturation(float3 col, float interpolator)
			{
				return lerp(dot(col, float3(0.3, 0.59, 0.11)), col, interpolator);
			}
			
			void applyPostProcessing(inout PoiFragData poiFragData, in PoiMesh poiMesh)
			{
				float3 col = poiFragData.finalColor;
				col = hueShift(col, _PPHue);
				col *= _PPTint;
				col *= _PPRGB;
				col = GetSaturation(col, _PPSaturation);
				col = lerp(col, GetHDR(col), _PPHDR);
				col = GetContrast(col, _PPContrast);
				col *= _PPBrightness;
				col += _PPLightness;
				
				float ppMask = 1;
				#if defined(PROP_PPMASK) || !defined(OPTIMIZER_ENABLED)
				ppMask = POI2D_SAMPLER_PAN(_PPMask, _MainTex, poiUV(poiMesh.uv[_PPMaskUV], _PPMask_ST), _PPMaskPan)[_PPMaskChannel];
				ppMask = lerp(ppMask, 1 - ppMask, _PPMaskInvert);
				col = lerp(poiFragData.finalColor, col, ppMask);
				#endif
				
				if (_PPPosterization)
				{
					col = lerp(col, poiPosterize(col, _PPPosterizationAmount), ppMask);
				}
				
				poiFragData.finalColor = col;
			}
			#endif
			//endex
			
			// normal correct code from https://github.com/yoship1639/UniToon (MIT)
			//ifex _NormalCorrect==0
			#ifdef POI_NORMALCORRECT
			void applyNormalCorrect(inout VertexOut i)
			{
				float3 normalCorrectObject = i.localPos.xyz - _NormalCorrectOrigin;
				normalCorrectObject.y = 0;
				normalCorrectObject = normalize(normalCorrectObject);
				float3 normalCorrectWorld = UnityObjectToWorldDir(normalCorrectObject);
				i.normal.xyz = normalize(lerp(i.normal.xyz, normalCorrectWorld, _NormalCorrectAmount));
				i.objNormal.xyz = normalize(lerp(i.objNormal.xyz, normalCorrectObject, _NormalCorrectAmount));
			}
			#endif
			//endex
			
			//ifex _VideoEffectsEnable==0
			float3 applyBacklight(float3 videoTexture, half backlightStrength)
			{
				return max(backlightStrength, videoTexture.rgb);
			}
			
			float3 applyViewAngleTN(float3 videoTexture, PoiCam poiCam, PoiMesh poiMesh)
			{
				float3 reflectionVector = normalize(reflect(poiCam.viewDir.rgb, poiMesh.normals[1].rgb));
				float upwardShift = dot(reflectionVector, poiMesh.binormal[0]);
				upwardShift = pow(upwardShift, 1);
				float sideShift = dot(reflectionVector, poiMesh.tangent[0]);
				sideShift *= pow(sideShift, 3);
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = LinearToGammaSpace(videoTexture);
				#endif
				videoTexture = saturate(lerp(half3(0.5, 0.5, 0.5), videoTexture, upwardShift + 1));
				#if !UNITY_COLORSPACE_GAMMA
				videoTexture = GammaToLinearSpace(videoTexture);
				#endif
				videoTexture = (lerp(videoTexture, videoTexture.gbr, sideShift));
				return videoTexture;
			}
			
			float calculateCRTPixelBrightness(float2 uv)
			{
				float totalPixels = _VideoResolution.x * _VideoResolution.y;
				float2 uvPixel = float2((floor((1 - uv.y) * _VideoResolution.y)) / _VideoResolution.y, (floor(uv.x * _VideoResolution.x)) / _VideoResolution.x);
				float currentPixelNumber = _VideoResolution.x * (_VideoResolution.y * uvPixel.x) + _VideoResolution.y * uvPixel.y;
				float currentPixelAlpha = currentPixelNumber / totalPixels;
				half electronBeamAlpha = frac(_Time.y * _VideoCRTRefreshRate);
				float electronBeamPixelNumber = totalPixels * electronBeamAlpha;
				
				float DistanceInPixelsFromCurrentElectronBeamPixel = 0;
				if (electronBeamPixelNumber >= currentPixelNumber)
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber - currentPixelNumber;
				}
				else
				{
					DistanceInPixelsFromCurrentElectronBeamPixel = electronBeamPixelNumber + (totalPixels - currentPixelNumber);
				}
				float CRTFrameTime = 1 / _VideoCRTRefreshRate;
				float timeSincecurrentPixelWasHitByElectronBeam = (DistanceInPixelsFromCurrentElectronBeamPixel / totalPixels);
				
				return saturate(_VideoCRTPixelEnergizedTime - timeSincecurrentPixelWasHitByElectronBeam);
			}
			
			void applyContrastSettings(inout float3 pixel)
			{
				#if !UNITY_COLORSPACE_GAMMA
				pixel = LinearToGammaSpace(pixel);
				#endif
				pixel = saturate(lerp(half3(0.5, 0.5, 0.5), pixel, _VideoContrast + 1));
				#if !UNITY_COLORSPACE_GAMMA
				pixel = GammaToLinearSpace(pixel);
				#endif
			}
			
			void applySaturationSettings(inout float3 pixel)
			{
				pixel = lerp(pixel.rgb, dot(pixel.rgb, float3(0.3, 0.59, 0.11)), -(_VideoSaturation));
			}
			
			void applyVideoSettings(inout float3 pixel)
			{
				applySaturationSettings(pixel);
				applyContrastSettings(pixel);
			}
			
			void calculateLCD(inout float4 videoTexture, float3 pixels)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateTN(inout float4 videoTexture, float3 pixels, PoiCam poiCam, PoiMesh poiMesh)
			{
				videoTexture.rgb = applyBacklight(videoTexture, _VideoBacklight * .01);
				videoTexture.rgb = applyViewAngleTN(videoTexture, poiCam, poiMesh);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateCRT(inout float4 videoTexture, float3 pixels, float2 uv)
			{
				float brightness = calculateCRTPixelBrightness(uv);
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * brightness * _VideoBacklight;
			}
			void calculateOLED(inout float4 videoTexture, float3 pixels)
			{
				applyVideoSettings(videoTexture.rgb);
				videoTexture.rgb = videoTexture * pixels * _VideoBacklight;
			}
			void calculateGameboy(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				// half brightness = saturate((videoTexture.r + videoTexture.g + videoTexture.b) * .3333333);
				half brightness = LinearRgbToLuminance(LinearToGammaSpace(videoTexture.rgb));
				#if defined(PROP_VIDEOGAMEBOYRAMP) || !defined(OPTIMIZER_ENABLED)
				videoTexture.rgb = tex2Dlod(_VideoGameboyRamp, float4(brightness.xx, 0, 0));
				#else
				float3 dg = float3(0.00392156863, 0.0392156863, 0.00392156863);
				float3 lg = float3(0.333333333, 0.5, 0.00392156863);
				videoTexture.rgb = lerp(dg, lg, brightness);
				#endif
			}
			void calculateProjector(inout float4 videoTexture)
			{
				applyVideoSettings(videoTexture.rgb);
				
				float3 projectorColor = videoTexture * _VideoBacklight;
				videoTexture.r = clamp(projectorColor.r, videoTexture.r, 1000);
				videoTexture.g = clamp(projectorColor.g, videoTexture.g, 1000);
				videoTexture.b = clamp(projectorColor.b, videoTexture.b, 1000);
			}
			
			void applyVideoEffectsMainTex(inout float4 mainTexture, in PoiMesh poiMesh)
			{
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					float2 originalUVs = uvs;
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
					mainTexture = _MainTex.SampleGrad(sampler_MainTex, uvs, ddx(originalUVs), ddy(originalUVs));
				}
			}
			void applyVideoEffects(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
			{
				#if defined(PROP_VIDEOPIXELTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float3 pixels = tex2D(_VideoPixelTexture, poiUV(poiMesh.uv[_VideoPixelTextureUV], _VideoPixelTexture_ST) * _VideoResolution);
				#else
				float3 pixels = 1;
				#endif
				float2 uvs = poiMesh.uv[_MainTexUV];
				if(_VideoPixelateToResolution)
				{
					uvs = sharpSample(float4(1/_VideoResolution.xy, _VideoResolution.xy), uvs);
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				else
				{
					uvs = poiUV(uvs, _MainTex_ST) + _Time.x * _MainTexPan;
				}
				float4 modifiedVideoTexture = 0;
				modifiedVideoTexture.rgb = poiFragData.baseColor;
				modifiedVideoTexture.a = poiFragData.alpha;
				
				// UNITY_BRANCH
				// if(_VideoRepeatVideoTexture == 1)
				// {
				// 	if(poiMesh.uv[_VideoUVNumber].x > 1 || poiMesh.uv[_VideoUVNumber].x < 0 || poiMesh.uv[_VideoUVNumber].y > 1 || poiMesh.uv[_VideoUVNumber].y < 0)
				// 	{
				// 		return;
				// 	}
				// }
				
				switch(_VideoType)
				{
					case 0: // LCD
					{
						calculateLCD(modifiedVideoTexture, pixels);
						break;
					}
					case 1: // TN
					{
						calculateTN(modifiedVideoTexture, pixels, poiCam, poiMesh);
						break;
					}
					case 2: // CRT
					{
						calculateCRT(modifiedVideoTexture, pixels, uvs);
						break;
					}
					case 3: // OLED
					{
						calculateOLED(modifiedVideoTexture, pixels);
						break;
					}
					case 4: // Gameboy
					{
						calculateGameboy(modifiedVideoTexture);
						break;
					}
					case 5: // Projector
					{
						calculateProjector(modifiedVideoTexture);
						break;
					}
				}
				#if defined(PROP_VIDEOMASKTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float screenMask = POI2D_SAMPLER_PAN(_VideoMaskTexture, _MainTex, poiUV(poiMesh.uv[_VideoMaskTextureUV], _VideoMaskTexture_ST), _VideoMaskTexturePan)[_VideoMaskTextureChannel];
				#else
				float screenMask = 1;
				#endif
				
				poiFragData.baseColor = lerp(poiFragData.baseColor, modifiedVideoTexture, screenMask);
				// UNITY_BRANCH
				if (_VideoEmissionEnabled)
				{
					poiFragData.emission += modifiedVideoTexture.rgb * screenMask;
				}
			}
			//endex
			
			//ifex _BacklightEnabled!=1
			#ifdef POI_BACKLIGHT
			void ApplyBacklight(inout PoiFragData poiFragData, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiCam poiCam, inout PoiMods poiMods)
			{
				
				// Color
				float3 backlightColor = _BacklightColor.rgb;
				#if defined(PROP_BACKLIGHTCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				backlightColor *= POI2D_SAMPLER_PAN(_BacklightColorTex, _MainTex, poiUV(poiMesh.uv[_BacklightColorTexUV], _BacklightColorTex_ST), _BacklightColorTexPan).rgb;
				#endif
				
				float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], _BacklightNormalStrength);
				// Factor
				float3 headDir = normalize(getCameraPosition() - poiMesh.worldPos.xyz);
				float headDotLight = dot(headDir, poiLight.direction);
				float backlightFactor = pow(saturate(-headDotLight * 0.5 + 0.5), max(0, _BacklightDirectivity));
				float backlightLN = dot(normalize(-headDir * _BacklightViewStrength + poiLight.direction), normal) * 0.5 + 0.5;
				if(_BacklightReceiveShadow) backlightLN *= saturate(poiLight.attenuation);
				backlightLN = poiEdgeLinear(backlightLN, _BacklightBorder, _BacklightBlur);
				float backlight = saturate(backlightFactor * backlightLN);
				backlight = !poiMesh.isFrontFace && _BacklightBackfaceMask ? 0.0 : backlight;
				
				// Blend
				backlightColor = lerp(backlightColor, backlightColor * poiFragData.baseColor, _BacklightMainStrength);
				poiLight.finalLightAdd += backlight * backlightColor * poiLight.directColor;
			}
			#endif
			//endex
			
			float4 frag(VertexOut i, uint facing : SV_IsFrontFace) : SV_Target
			/*
			#ifdef
			, out float depth : SV_DEPTH
			#endif
			*/
			{
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				
				PoiMesh poiMesh;
				PoiInitStruct(PoiMesh, poiMesh);
				
				PoiLight poiLight;
				PoiInitStruct(PoiLight, poiLight);
				
				PoiVertexLights poiVertexLights;
				PoiInitStruct(PoiVertexLights, poiVertexLights);
				
				PoiCam poiCam;
				PoiInitStruct(PoiCam, poiCam);
				
				PoiMods poiMods;
				PoiInitStruct(PoiMods, poiMods);
				poiMods.globalEmission = 1;
				poiMods.PBR = 1;
				
				PoiFragData poiFragData;
				poiFragData.emission = 0;
				poiFragData.baseColor = float3(0, 0, 0);
				poiFragData.finalColor = float3(0, 0, 0);
				poiFragData.alpha = 1;
				
				#ifdef POI_UDIMDISCARD
				applyUDIMDiscard(i);
				#endif
				
				//ifex _NormalCorrect==0
				#ifdef POI_NORMALCORRECT
				applyNormalCorrect(i);
				#endif
				//endex
				
				// Mesh Data
				poiMesh.objectPosition = i.objectPos;
				poiMesh.objNormal = i.objNormal;
				poiMesh.normals[0] = i.normal;
				poiMesh.tangent[0] = i.tangent;
				poiMesh.binormal[0] = i.binormal;
				poiMesh.worldPos = i.worldPos.xyz;
				poiMesh.localPos = i.localPos.xyz;
				poiMesh.vertexColor = i.vertexColor;
				poiMesh.isFrontFace = facing;
				
				#ifndef POI_PASS_OUTLINE
				if (!poiMesh.isFrontFace)
				{
					poiMesh.normals[0] *= -1;
					poiMesh.tangent[0] *= -1;
					poiMesh.binormal[0] *= -1;
				}
				#endif
				
				poiCam.viewDir = !IsOrthographicCamera() ? normalize(_WorldSpaceCameraPos - i.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
				float3 tanToWorld0 = float3(i.tangent.x, i.binormal.x, i.normal.x);
				float3 tanToWorld1 = float3(i.tangent.y, i.binormal.y, i.normal.y);
				float3 tanToWorld2 = float3(i.tangent.z, i.binormal.z, i.normal.z);
				float3 ase_tanViewDir = tanToWorld0 * poiCam.viewDir.x + tanToWorld1 * poiCam.viewDir.y + tanToWorld2 * poiCam.viewDir.z;
				poiCam.tangentViewDir = normalize(ase_tanViewDir);
				
				// 0-3 UV0-UV3
				// 4 Panosphere UV
				// 5 world pos xz
				// 6 Polar UV
				// 6 Distorted UV
				#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
				poiMesh.lightmapUV = i.lightmapUV;
				#endif
				poiMesh.parallaxUV = poiCam.tangentViewDir.xy / max(poiCam.tangentViewDir.z, 0.0001);
				poiMesh.uv[0] = i.uv[0];
				poiMesh.uv[1] = i.uv[1];
				poiMesh.uv[2] = i.uv[2];
				poiMesh.uv[3] = i.uv[3];
				poiMesh.uv[4] = poiMesh.uv[0];
				poiMesh.uv[5] = poiMesh.uv[0];
				poiMesh.uv[6] = poiMesh.uv[0];
				poiMesh.uv[7] = poiMesh.uv[0];
				poiMesh.uv[8] = poiMesh.uv[0];
				
				poiMesh.uv[4] = calculatePanosphereUV(poiMesh);
				poiMesh.uv[5] = calculateWorldUV(poiMesh);
				poiMesh.uv[6] = calculatePolarCoordinate(poiMesh);
				poiMesh.uv[8] = calculatelocalUV(poiMesh);
				//ifex _EnableDistortion==0
				#ifdef USER_LUT
				poiMesh.uv[7] = distortedUV(poiMesh);
				#endif
				//endex
				/*
				half3 worldViewUp = normalize(half3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, half3(0, 1, 0)));
				half3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
				poiMesh[8] = half2(dot(worldViewRight, poiMesh.normals[_MatcapNormal]), dot(worldViewUp, poiMesh.normals[_MatcapNormal])) * _MatcapBorder + 0.5;
				*/
				
				//ifex _PoiParallax==0
				#ifdef POI_PARALLAX
				#ifndef POI_PASS_OUTLINE
				//return frac(i.tangentViewDir.x);
				//return float4(i.binormal.xyz,1);
				applyParallax(poiMesh, poiLight, poiCam);
				#endif
				#endif
				//endex
				
				poiMods.globalMask[0]  = 1;
				poiMods.globalMask[1]  = 1;
				poiMods.globalMask[2]  = 1;
				poiMods.globalMask[3]  = 1;
				poiMods.globalMask[4]  = 1;
				poiMods.globalMask[5]  = 1;
				poiMods.globalMask[6]  = 1;
				poiMods.globalMask[7]  = 1;
				poiMods.globalMask[8]  = 1;
				poiMods.globalMask[9]  = 1;
				poiMods.globalMask[10] = 1;
				poiMods.globalMask[11] = 1;
				poiMods.globalMask[12] = 1;
				poiMods.globalMask[13] = 1;
				poiMods.globalMask[14] = 1;
				poiMods.globalMask[15] = 1;
				//ifex _GlobalMaskTexturesEnable==0
				#ifdef POI_GLOBALMASK_TEXTURES
				ApplyGlobalMaskTextures(poiMesh, poiMods);
				#endif
				//endex
				ApplyGlobalMaskModifiers(poiMesh, poiMods, poiCam);
				//ifex _GlobalMaskOptionsEnable==0
				if(_GlobalMaskOptionsEnable)
				{
					ApplyGlobalMaskOptions(poiMods);
				}
				//endex
				
				float2 mainUV = poiMesh.uv[_MainTexUV].xy;
				
				if (_MainPixelMode)
				{
					mainUV = sharpSample(_MainTex_TexelSize, mainUV);
				}
				
				float4 mainTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_MainTex, _MainTex, poiUV(mainUV, _MainTex_ST), _MainTexPan, _MainTexStochastic);
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffectsMainTex(mainTexture, poiMesh);
				}
				//endex
				
				#if defined(PROP_BUMPMAP) || !defined(OPTIMIZER_ENABLED)
				poiMesh.tangentSpaceNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_BumpMap, _MainTex, poiUV(poiMesh.uv[_BumpMapUV].xy, _BumpMap_ST), _BumpMapPan, _BumpMapStochastic), _BumpScale);
				#else
				poiMesh.tangentSpaceNormal = UnpackNormal(float4(0.5, 0.5, 1, 1));
				#endif
				
				//ifex _DetailEnabled==0
				#if defined(FINALPASS) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				ApplyDetailNormal(poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				//ifex _RgbNormalsEnabled==0
				#if defined(GEOM_TYPE_MESH) && defined(VIGNETTE) && !defined(UNITY_PASS_SHADOWCASTER) && !defined(POI_PASS_OUTLINE)
				calculateRGBNormals(poiMesh, poiMods);
				#endif
				//endex
				//endex
				
				poiMesh.normals[1] = normalize(
				poiMesh.tangentSpaceNormal.x * poiMesh.tangent[0] +
				poiMesh.tangentSpaceNormal.y * poiMesh.binormal[0] +
				poiMesh.tangentSpaceNormal.z * poiMesh.normals[0]
				);
				
				poiMesh.tangent[1] = cross(poiMesh.binormal[0], -poiMesh.normals[1]);
				poiMesh.binormal[1] = cross(-poiMesh.normals[1], poiMesh.tangent[0]);
				
				// Camera data
				poiCam.forwardDir = getCameraForward();
				poiCam.worldPos = _WorldSpaceCameraPos;
				poiCam.reflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[1]);
				poiCam.vertexReflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[0]);
				//poiCam.distanceToModel = distance(poiMesh.modelPos, poiCam.worldPos);
				poiCam.distanceToVert = distance(poiMesh.worldPos, poiCam.worldPos);
				poiCam.grabPos = i.grabPos;
				poiCam.screenUV = calcScreenUVs(i.grabPos);
				poiCam.vDotN = abs(dot(poiCam.viewDir, poiMesh.normals[1]));
				poiCam.clipPos = i.pos;
				poiCam.worldDirection = i.worldDirection;
				
				calculateGlobalThemes(poiMods);
				
				//ifex _EnableAudioLink==0
				#ifdef POI_AUDIOLINK
				SetupAudioLink(poiFragData, poiMods, poiMesh);
				#endif
				//endex
				
				//ifex _BlackLightMaskingEnabled==0
				#ifdef POI_BLACKLIGHTMASKING
				calculateBlackLightMasks(poiMesh, poiMods);
				#endif
				//endex
				
				poiFragData.baseColor = mainTexture.rgb * poiThemeColor(poiMods, _Color.rgb, _ColorThemeIndex);
				poiFragData.alpha = mainTexture.a * _Color.a;
				
				//ifex _MainColorAdjustToggle==0
				#ifdef COLOR_GRADING_HDR
				#if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
				float4 hueShiftAlpha = POI2D_SAMPLER_PAN(_MainColorAdjustTexture, _MainTex, poiUV(poiMesh.uv[_MainColorAdjustTextureUV], _MainColorAdjustTexture_ST), _MainColorAdjustTexturePan);
				#else
				float4 hueShiftAlpha = 1;
				#endif
				
				if (_MainHueGlobalMask > 0)
				{
					hueShiftAlpha.r = maskBlend(hueShiftAlpha.r, poiMods.globalMask[_MainHueGlobalMask-1], _MainHueGlobalMaskBlendType);
				}
				if (_MainSaturationGlobalMask > 0)
				{
					hueShiftAlpha.b = maskBlend(hueShiftAlpha.b, poiMods.globalMask[_MainSaturationGlobalMask-1], _MainSaturationGlobalMaskBlendType);
				}
				if (_MainBrightnessGlobalMask > 0)
				{
					hueShiftAlpha.g = maskBlend(hueShiftAlpha.g, poiMods.globalMask[_MainBrightnessGlobalMask-1], _MainBrightnessGlobalMaskBlendType);
				}
				
				if (_MainHueShiftToggle)
				{
					float shift = _MainHueShift;
					#ifdef POI_AUDIOLINK
					//UNITY_BRANCH
					if (poiMods.audioLinkAvailable && _MainHueALCTEnabled)
					{
						shift += AudioLinkGetChronoTime(_MainALHueShiftCTIndex, _MainALHueShiftBand) * _MainHueALMotionSpeed;
					}
					#endif
					if (_MainHueShiftReplace)
					{
						poiFragData.baseColor = lerp(poiFragData.baseColor, hueShift(poiFragData.baseColor, shift + _MainHueShiftSpeed * _Time.x), hueShiftAlpha.r);
					}
					else
					{
						poiFragData.baseColor = hueShift(poiFragData.baseColor, frac((shift - (1 - hueShiftAlpha.r) + _MainHueShiftSpeed * _Time.x)));
					}
				}
				poiFragData.baseColor = lerp(poiFragData.baseColor, dot(poiFragData.baseColor, float3(0.3, 0.59, 0.11)), -(_Saturation) * hueShiftAlpha.b);
				poiFragData.baseColor = saturate(poiFragData.baseColor + _MainBrightness * hueShiftAlpha.g);
				#endif
				//endex
				
				#if defined(PROP_CLIPPINGMASK) || !defined(OPTIMIZER_ENABLED)
				float alphaMask = POI2D_SAMPLER_PAN(_ClippingMask, _MainTex, poiUV(poiMesh.uv[_ClippingMaskUV], _ClippingMask_ST), _ClippingMaskPan).r;
				if (_Inverse_Clipping)
				{
					alphaMask = 1 - alphaMask;
				}
				
				poiFragData.alpha *= alphaMask;
				#endif
				
				//ifex _VideoEffectsEnable==0
				if (_VideoEffectsEnable)
				{
					applyVideoEffects(poiFragData, poiCam, poiMesh, poiLight, poiMods);
				}
				//endex
				
				applyAlphaOptions(poiFragData, poiMesh, poiCam, poiMods);
				
				//ifex _DetailEnabled==0
				#ifdef FINALPASS
				ApplyDetailColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _MainVertexColoringEnabled==0
				applyVertexColor(poiFragData, poiMesh);
				//endex
				
				//ifex _BackFaceEnabled!=1
				#ifdef POI_BACKFACE
				ApplyBackFaceColor(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _RGBMaskEnabled==0
				#ifdef VIGNETTE
				calculateRGBMask(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				#if defined(GEOM_TYPE_BRANCH) || defined(GEOM_TYPE_BRANCH_DETAIL) || defined(GEOM_TYPE_FROND) || defined(DEPTH_OF_FIELD_COC_VIEW)
				applyDecals(poiFragData, poiMesh, poiCam, poiMods, poiLight);
				#endif
				
				//ifex _EnableDissolve==0
				#ifdef DISTORT
				applyDissolve(poiFragData, poiMesh, poiMods, poiCam, poiLight);
				#endif
				//endex
				
				//ifex _EnableAniso==0
				#ifdef POI_ANISOTROPICS
				//ifex _AnisoDebugToggle==0
				if(_AnisoDebugToggle)
				{
					return float4(applyAnisotropics(poiFragData, poiLight, poiCam, poiMesh, poiMods), 1) + POI_SAFE_RGB1;
				}
				//endex
				applyAnisotropics(poiFragData, poiLight, poiCam, poiMesh, poiMods);
				
				#endif
				//endex
				
				//ifex _EnableFlipbook==0
				#ifdef _SUNDISK_HIGH_QUALITY
				applyFlipbook(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				//ifex _EnableRimLighting==0
				#ifdef _GLOSSYREFLECTIONS_OFF
				#ifdef _RIMSTYLE_POIYOMI
				#if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
				float4 rimMaskAndBias = POI2D_SAMPLER_PAN(_RimMask, _MainTex, poiUV(poiMesh.uv[_RimMaskUV], _RimMask_ST), _RimMaskPan);
				float rimMask = rimMaskAndBias[_RimMaskChannel];
				float rimBias = rimMaskAndBias.a;
				#else
				float rimMask = 1;
				float rimBias = 0;
				#endif
				
				if(_RimMaskInvert)
				{
					rimMask = 1 - rimMask;
				}
				
				#if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rimColor = POI2D_SAMPLER_PAN(_RimTex, _MainTex, poiUV(poiMesh.uv[_RimTexUV], _RimTex_ST), _RimTexPan);
				#else
				float4 rimColor = 1;
				#endif
				half AudioLinkRimWidthBand = 0;
				float2 AudioLinkRimWidthAdd = 0;
				half AudioLinkRimEmissionBand = 0;
				float2 AudioLinkRimEmissionAdd = 0;
				half AudioLinkRimBrightnessBand = 0;
				float2 AudioLinkRimBrightnessAdd = 0;
				#ifdef POI_AUDIOLINK
				AudioLinkRimWidthBand = _AudioLinkRimWidthBand;
				AudioLinkRimWidthAdd = _AudioLinkRimWidthAdd;
				AudioLinkRimEmissionBand = _AudioLinkRimEmissionBand;
				AudioLinkRimEmissionAdd = _AudioLinkRimEmissionAdd;
				AudioLinkRimBrightnessBand = _AudioLinkRimBrightnessBand;
				AudioLinkRimBrightnessAdd = _AudioLinkRimBrightnessAdd;
				#endif
				ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Is_NormalMapToRimLight, _RimLightingInvert, _RimPower, _RimStrength, _RimShadowWidth, _RimShadowToggle, _RimWidth, _RimBlendStrength, rimMask, _RimGlobalMask, _RimGlobalMaskBlendType, rimColor, _RimLightColor, _RimLightColorThemeIndex, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimSharpness, _RimShadowMaskRampType, _RimShadowMaskInvert, _RimShadowMaskStrength, _RimShadowAlpha, _RimApplyGlobalMaskIndex, _RimApplyGlobalMaskBlendType, _RimBaseColorMix, _RimBrightness, _RimBlendMode, AudioLinkRimWidthBand, AudioLinkRimWidthAdd, AudioLinkRimEmissionBand, AudioLinkRimEmissionAdd, AudioLinkRimBrightnessBand, AudioLinkRimBrightnessAdd, _RimClamp, rimBias, _RimBiasIntensity);
				#endif
				#ifdef _RIMSTYLE_UTS2
				#if defined(PROP_SET_RIMLIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float Set_RimLightMask_var = POI2D_SAMPLER_PAN(_Set_RimLightMask, _MainTex, poiUV(poiMesh.uv[_Set_RimLightMaskUV], _Set_RimLightMask_ST), _Set_RimLightMaskPan)[_Set_RimLightMaskChannel];
				#else
				float Set_RimLightMask_var = 1;
				#endif
				ApplyUTS2RimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, Set_RimLightMask_var, _RimGlobalMask, _RimGlobalMaskBlendType, _RimLightColor, _RimLightColorThemeIndex, _Is_LightColor_RimLight, _Is_NormalMapToRimLight, _RimLight_Power, _RimLight_InsideMask, _RimLight_FeatherOff, _LightDirection_MaskOn, _Tweak_LightDirection_MaskLevel, _Add_Antipodean_RimLight, _Ap_RimLightColor, _RimApColorThemeIndex, _Is_LightColor_Ap_RimLight, _Ap_RimLight_Power, _Ap_RimLight_FeatherOff, _Tweak_RimLightMaskLevel, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimClamp);
				#endif
				#ifdef _RIMSTYLE_LILTOON
				#if defined(PROP_RIMCOLORTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rimColorTex = POI2D_SAMPLER_PAN(_RimColorTex, _MainTex, poiUV(poiMesh.uv[_RimColorTexUV], _RimColorTex_ST), _RimColorTexPan);
				#else
				float4 rimColorTex = 1;
				#endif
				ApplyLiltoonRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _RimColor, _RimIndirColor, rimColorTex, _RimMainStrength, _RimNormalStrength, _RimDirRange, _RimIndirRange, _RimFresnelPower, _RimBackfaceMask, _RimDirStrength, _RimBorder, _RimBlur, _RimIndirBorder, _RimIndirBlur, _RimShadowMask, _RimEnableLighting, _RimVRParallaxStrength, _RimGlobalMask, _RimGlobalMaskBlendType, _RimHueShiftEnabled, _RimHueShift, _RimHueShiftSpeed, _RimClamp);
				#endif
				#endif
				//endex
				//ifex _EnableRim2Lighting==0
				#ifdef POI_RIM2
				#ifdef _RIM2STYLE_POIYOMI
				#if defined(PROP_RIM2MASK) || !defined(OPTIMIZER_ENABLED)
				float4 rim2MaskAndBias = POI2D_SAMPLER_PAN(_Rim2Mask, _MainTex, poiUV(poiMesh.uv[_Rim2MaskUV], _Rim2Mask_ST), _Rim2MaskPan);
				float rim2Mask = rim2MaskAndBias[_Rim2MaskChannel];
				float rim2Bias = rim2MaskAndBias.a;
				#else
				float rim2Mask = 1;
				float rim2Bias = 0;
				#endif
				
				if(_Rim2MaskInvert)
				{
					rim2Mask = 1 - rim2Mask;
				}
				
				#if defined(PROP_RIM2TEX) || !defined(OPTIMIZER_ENABLED)
				float4 rim2Color = POI2D_SAMPLER_PAN(_Rim2Tex, _MainTex, poiUV(poiMesh.uv[_Rim2TexUV], _Rim2Tex_ST), _Rim2TexPan);
				#else
				float4 rim2Color = 1;
				#endif
				half AudioLinkRim2WidthBand = 0;
				float2 AudioLinkRim2WidthAdd = 0;
				half AudioLinkRim2EmissionBand = 0;
				float2 AudioLinkRim2EmissionAdd = 0;
				half AudioLinkRim2BrightnessBand = 0;
				float2 AudioLinkRim2BrightnessAdd = 0;
				#ifdef POI_AUDIOLINK
				AudioLinkRim2WidthBand = _AudioLinkRim2WidthBand;
				AudioLinkRim2WidthAdd = _AudioLinkRim2WidthAdd;
				AudioLinkRim2EmissionBand = _AudioLinkRim2EmissionBand;
				AudioLinkRim2EmissionAdd = _AudioLinkRim2EmissionAdd;
				AudioLinkRim2BrightnessBand = _AudioLinkRim2BrightnessBand;
				AudioLinkRim2BrightnessAdd = _AudioLinkRim2BrightnessAdd;
				#endif
				ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Is_NormalMapToRim2Light, _Rim2LightingInvert, _Rim2Power, _Rim2Strength, _Rim2ShadowWidth, _Rim2ShadowToggle, _Rim2Width, _Rim2BlendStrength, rim2Mask, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, rim2Color, _Rim2LightColor, _Rim2LightColorThemeIndex, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Sharpness, _Rim2ShadowMaskRampType, _Rim2ShadowMaskInvert, _Rim2ShadowMaskStrength, _Rim2ShadowAlpha, _Rim2ApplyGlobalMaskIndex, _Rim2ApplyGlobalMaskBlendType, _Rim2BaseColorMix, _Rim2Brightness, _Rim2BlendMode, AudioLinkRim2WidthBand, AudioLinkRim2WidthAdd, AudioLinkRim2EmissionBand, AudioLinkRim2EmissionAdd, AudioLinkRim2BrightnessBand, AudioLinkRim2BrightnessAdd, _Rim2Clamp, rim2Bias, _Rim2BiasIntensity);
				#endif
				#ifdef _RIM2STYLE_UTS2
				#if defined(PROP_SET_RIM2LIGHTMASK) || !defined(OPTIMIZER_ENABLED)
				float Set_Rim2LightMask_var = POI2D_SAMPLER_PAN(_Set_Rim2LightMask, _MainTex, poiUV(poiMesh.uv[_Set_Rim2LightMaskUV], _Set_Rim2LightMask_ST), _Set_Rim2LightMaskPan)[_Set_Rim2LightMaskChannel];
				#else
				float Set_Rim2LightMask_var = 1;
				#endif
				ApplyUTS2RimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, Set_Rim2LightMask_var, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, _Rim2LightColor, _Rim2LightColorThemeIndex, _Is_LightColor_Rim2Light, _Is_NormalMapToRim2Light, _Rim2Light_Power, _Rim2Light_InsideMask, _Rim2Light_FeatherOff, _LightDirection_MaskOn2, _Tweak_LightDirection_MaskLevel2, _Add_Antipodean_Rim2Light, _Ap_Rim2LightColor, _Rim2ApColorThemeIndex, _Is_LightColor_Ap_Rim2Light, _Ap_Rim2Light_Power, _Ap_Rim2Light_FeatherOff, _Tweak_Rim2LightMaskLevel, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Clamp);
				#endif
				#ifdef _RIM2STYLE_LILTOON
				#if defined(PROP_RIM2COLORTEX) || !defined(OPTIMIZER_ENABLED)
				float4 rim2ColorTex = POI2D_SAMPLER_PAN(_Rim2ColorTex, _MainTex, poiUV(poiMesh.uv[_Rim2ColorTexUV], _Rim2ColorTex_ST), _Rim2ColorTexPan);
				#else
				float4 rim2ColorTex = 1;
				#endif
				ApplyLiltoonRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, _Rim2Color, _Rim2IndirColor, rim2ColorTex, _Rim2MainStrength, _Rim2NormalStrength, _Rim2DirRange, _Rim2IndirRange, _Rim2FresnelPower, _Rim2BackfaceMask, _Rim2DirStrength, _Rim2Border, _Rim2Blur, _Rim2IndirBorder, _Rim2IndirBlur, _Rim2ShadowMask, _Rim2EnableLighting, _Rim2VRParallaxStrength, _Rim2GlobalMask, _Rim2GlobalMaskBlendType, _Rim2HueShiftEnabled, _Rim2HueShift, _Rim2HueShiftSpeed, _Rim2Clamp);
				#endif
				#endif
				//endex
				
				//ifex _EnableDepthRimLighting==0
				#ifdef _POI_DEPTH_RIMLIGHT
				if (!IsInMirror())
				{
					ApplyDepthRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods);
				}
				#endif
				//endex
				
				//ifex _GlitterEnable==0
				#ifdef _SUNDISK_SIMPLE
				applyGlitter(poiFragData, poiMesh, poiCam, poiLight, poiMods);
				#endif
				//endex
				
				//ifex _EnablePathing==0
				#ifdef POI_PATHING
				// Only run pathing if a map exists.
				#if defined(PROP_PATHINGMAP) || !defined(OPTIMIZER_ENABLED)
				applyPathing(poiFragData, poiMesh, poiMods);
				#endif
				#endif
				//endex
				
				//ifex _EnableMirrorOptions==0
				#ifdef POI_MIRROR
				applyMirror(poiFragData, poiMesh, poiMods);
				#endif
				//endex
				
				UNITY_BRANCH
				if (_AlphaPremultiply)
				{
					poiFragData.baseColor *= saturate(poiFragData.alpha);
				}
				poiFragData.finalColor = poiFragData.baseColor;
				
				//ifex _BacklightEnabled!=1
				#ifdef POI_BACKLIGHT
				ApplyBacklight(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _EnableEmission==0 && _EnableEmission1==0 && _EnableEmission2==0 && _EnableEmission3==0
				#if defined(_EMISSION) || defined(POI_EMISSION_1) || defined(POI_EMISSION_2) || defined(POI_EMISSION_3)
				float3 emissionBaseReplace = 0;
				#endif
				//endex
				
				//ifex _EnableEmission==0
				#ifdef _EMISSION
				emissionBaseReplace += applyEmission(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				//ifex _EnableEmission1==0
				#ifdef POI_EMISSION_1
				emissionBaseReplace += applyEmission1(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				//ifex _EnableEmission2==0
				#ifdef POI_EMISSION_2
				emissionBaseReplace += applyEmission2(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				//ifex _EnableEmission3==0
				#ifdef POI_EMISSION_3
				emissionBaseReplace += applyEmission3(poiFragData, poiMesh, poiLight, poiCam, poiMods);
				#endif
				//endex
				
				//ifex _EnableEmission==0 && _EnableEmission1==0 && _EnableEmission2==0 && _EnableEmission3==0
				#if defined(_EMISSION) || defined(POI_EMISSION_1) || defined(POI_EMISSION_2) || defined(POI_EMISSION_3)
				poiFragData.finalColor.rgb = lerp(poiFragData.finalColor.rgb, saturate(emissionBaseReplace), poiMax(emissionBaseReplace));
				#endif
				//endex
				
				//UNITY_BRANCH
				if (_IgnoreFog == 0)
				{
					UNITY_APPLY_FOG(i.fogCoord, poiFragData.finalColor);
				}
				
				poiFragData.alpha = _AlphaForceOpaque ? 1 : poiFragData.alpha;
				
				//ifex _AlphaToCoverage==0 && isNotAnimated(_AlphaToCoverage)
				ApplyAlphaToCoverage(poiFragData, poiMesh);
				//endex
				
				//ifex _AlphaDithering==0 && isNotAnimated(_AlphaDithering)
				applyDithering(poiFragData, poiCam);
				//endex
				
				poiFragData.finalColor += poiLight.finalLightAdd;
				
				if (_Mode == POI_MODE_OPAQUE)
				{
					poiFragData.alpha = 1;
				}
				
				clip(poiFragData.alpha - _Cutoff);
				
				#ifdef POI_PASS_META
				UnityMetaInput meta;
				UNITY_INITIALIZE_OUTPUT(UnityMetaInput, meta);
				meta.Emission = poiFragData.emission * _GIEmissionMultiplier * poiMods.globalEmission;
				meta.Albedo = saturate(poiFragData.finalColor.rgb);
				meta.SpecularColor = poiLight.finalLightAdd;
				return UnityMetaFragment(meta);
				#endif
				
				return float4(poiFragData.finalColor + poiFragData.emission * poiMods.globalEmission, poiFragData.alpha) + POI_SAFE_RGB0;
			}
			
			ENDCG
		}
		
	}
	CustomEditor "Thry.ShaderEditor"
}
